(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('mitt'), require('websocket')) :
  typeof define === 'function' && define.amd ? define(['exports', 'tslib', 'mitt', 'websocket'], factory) :
  (factory((global.zjsSubscriptions = {}),global.tslib,global.mitt,global.websocket));
}(this, (function (exports,tslib,mitt,websocket) { 'use strict';

  mitt = mitt && mitt.hasOwnProperty('default') ? mitt['default'] : mitt;

  //  Copyright (C) 2018 Zilliqa
  (function (SocketConnect) {
      SocketConnect["READY"] = "ready";
      SocketConnect["CONNECT"] = "connect";
      SocketConnect["ERROR"] = "error";
      SocketConnect["CLOSE"] = "close";
      SocketConnect["RECONNECT"] = "reconnect";
  })(exports.SocketConnect || (exports.SocketConnect = {}));
  (function (SocketState) {
      SocketState["SOCKET_CONNECT"] = "socket_connect";
      SocketState["SOCKET_MESSAGE"] = "socket_message";
      SocketState["SOCKET_READY"] = "socket_ready";
      SocketState["SOCKET_CLOSE"] = "socket_close";
      SocketState["SOCKET_ERROR"] = "socket_error";
  })(exports.SocketState || (exports.SocketState = {}));
  (function (MessageType) {
      MessageType["NEW_BLOCK"] = "NewBlock";
      MessageType["EVENT_LOG"] = "EventLog";
      MessageType["NOTIFICATION"] = "Notification";
      MessageType["UNSUBSCRIBE"] = "Unsubscribe";
  })(exports.MessageType || (exports.MessageType = {}));
  (function (QueryParam) {
      QueryParam["NEW_BLOCK"] = "NewBlock";
      QueryParam["EVENT_LOG"] = "EventLog";
      QueryParam["UNSUBSCRIBE"] = "Unsubscribe";
  })(exports.QueryParam || (exports.QueryParam = {}));
  (function (StatusType) {
      StatusType["SUBSCRIBE_NEW_BLOCK"] = "SubscribeNewBlock";
      StatusType["SUBSCRIBE_EVENT_LOG"] = "SubscribeEventLog";
  })(exports.StatusType || (exports.StatusType = {}));

  //  Copyright (C) 2018 Zilliqa
  var WebSocketProvider = /** @class */ (function () {
      // basically, options is a collection of metadata things like protocol or headers
      function WebSocketProvider(url, options) {
          this.handlers = {};
          this.url = url;
          this.options = options;
          this.emitter = new mitt(this.handlers);
          this.websocket = WebSocketProvider.NewWebSocket(url, options);
          this.subscriptions = {};
          this.registerEventListeners();
      }
      WebSocketProvider.NewWebSocket = function (url, options) {
          if (typeof window !== 'undefined' && window.WebSocket) {
              return new WebSocket(url, options !== undefined ? options.protocol : []);
          }
          else {
              var headers = options !== undefined ? options.headers || {} : undefined;
              var urlObject = new URL(url);
              if (headers !== undefined &&
                  !headers.authorization &&
                  urlObject.username &&
                  urlObject.password) {
                  var authToken = Buffer.from(urlObject.username + ":" + urlObject.password).toString('base64');
                  headers.authorization = "Basic " + authToken;
              }
              return new websocket.w3cwebsocket(url, options !== undefined ? options.protocol : undefined, undefined, headers, undefined, options !== undefined ? options.clientConfig : undefined);
          }
      };
      WebSocketProvider.prototype.registerEventListeners = function () {
          this.websocket.onopen = this.onConnect.bind(this);
          this.websocket.onclose = this.onClose.bind(this);
          this.websocket.onmessage = this.onMessage.bind(this);
          this.websocket.onerror = this.onError.bind(this);
      };
      WebSocketProvider.prototype.removeAllSocketListeners = function () {
          this.removeEventListener(exports.SocketState.SOCKET_MESSAGE);
          this.removeEventListener(exports.SocketState.SOCKET_READY);
          this.removeEventListener(exports.SocketState.SOCKET_CLOSE);
          this.removeEventListener(exports.SocketState.SOCKET_ERROR);
          this.removeEventListener(exports.SocketState.SOCKET_CONNECT);
      };
      WebSocketProvider.prototype.removeEventListener = function (type, handler) {
          if (!type) {
              this.handlers = {};
              return;
          }
          if (!handler) {
              delete this.handlers[type];
          }
          else {
              return this.emitter.off(type, handler);
          }
      };
      WebSocketProvider.prototype.reconnect = function () {
          var _this = this;
          setTimeout(function () {
              _this.removeAllSocketListeners();
              _this.websocket = WebSocketProvider.NewWebSocket(_this.url, _this.options);
              _this.registerEventListeners();
          }, 5000);
      };
      WebSocketProvider.prototype.onClose = function (event) {
          return tslib.__awaiter(this, void 0, void 0, function () {
              return tslib.__generator(this, function (_a) {
                  // reconnect
                  if (this.subscriptions !== null && !event.wasClean) {
                      this.emitter.emit(exports.SocketConnect.RECONNECT, event);
                      this.reconnect();
                      return [2 /*return*/];
                  }
                  // normal close
                  if (this.websocket.CONNECTING) {
                      this.emitter.emit(exports.SocketConnect.CLOSE, event);
                      this.websocket.close();
                      return [2 /*return*/];
                  }
                  return [2 /*return*/];
              });
          });
      };
      WebSocketProvider.prototype.onError = function (event) {
          this.emitter.emit(exports.SocketConnect.ERROR, event);
          if (this.websocket.CONNECTING) {
              this.websocket.close();
          }
          return;
      };
      WebSocketProvider.prototype.onConnect = function () {
          return tslib.__awaiter(this, void 0, void 0, function () {
              var subscriptionKeys, subscriptionKeys_1, subscriptionKeys_1_1, key, id, parameters, e_1_1;
              var e_1, _a;
              return tslib.__generator(this, function (_b) {
                  switch (_b.label) {
                      case 0:
                          if (!this.subscriptions) {
                              this.subscriptions = {};
                          }
                          subscriptionKeys = Object.keys(this.subscriptions);
                          if (!(subscriptionKeys.length > 0)) return [3 /*break*/, 8];
                          _b.label = 1;
                      case 1:
                          _b.trys.push([1, 6, 7, 8]);
                          subscriptionKeys_1 = tslib.__values(subscriptionKeys), subscriptionKeys_1_1 = subscriptionKeys_1.next();
                          _b.label = 2;
                      case 2:
                          if (!!subscriptionKeys_1_1.done) return [3 /*break*/, 5];
                          key = subscriptionKeys_1_1.value;
                          id = key;
                          parameters = this.subscriptions[key].parameters;
                          delete this.subscriptions[id];
                          return [4 /*yield*/, this.subscribe(parameters)];
                      case 3:
                          _b.sent();
                          _b.label = 4;
                      case 4:
                          subscriptionKeys_1_1 = subscriptionKeys_1.next();
                          return [3 /*break*/, 2];
                      case 5: return [3 /*break*/, 8];
                      case 6:
                          e_1_1 = _b.sent();
                          e_1 = { error: e_1_1 };
                          return [3 /*break*/, 8];
                      case 7:
                          try {
                              if (subscriptionKeys_1_1 && !subscriptionKeys_1_1.done && (_a = subscriptionKeys_1.return)) _a.call(subscriptionKeys_1);
                          }
                          finally { if (e_1) throw e_1.error; }
                          return [7 /*endfinally*/];
                      case 8:
                          this.emitter.emit(exports.SocketState.SOCKET_CONNECT);
                          this.emitter.emit(exports.SocketConnect.CONNECT);
                          return [2 /*return*/];
                  }
              });
          });
      };
      WebSocketProvider.prototype.onMessage = function (msg) {
          var e_2, _a;
          if (msg.data) {
              var dataObj = JSON.parse(msg.data);
              if (dataObj.type === exports.MessageType.NOTIFICATION) {
                  this.emitter.emit(exports.SocketState.SOCKET_MESSAGE, dataObj);
                  try {
                      for (var _b = tslib.__values(dataObj.values), _c = _b.next(); !_c.done; _c = _b.next()) {
                          var value = _c.value;
                          if (value.query === exports.MessageType.NEW_BLOCK) {
                              this.emitter.emit(exports.MessageType.NEW_BLOCK, value);
                          }
                          else if (value.query === exports.MessageType.EVENT_LOG) {
                              this.emitter.emit(exports.MessageType.EVENT_LOG, value);
                          }
                          else if (value.query === exports.MessageType.UNSUBSCRIBE) {
                              this.emitter.emit(exports.MessageType.UNSUBSCRIBE, value);
                          }
                          else {
                              throw new Error('unsupported value type');
                          }
                      }
                  }
                  catch (e_2_1) { e_2 = { error: e_2_1 }; }
                  finally {
                      try {
                          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                      }
                      finally { if (e_2) throw e_2.error; }
                  }
              }
              else if (dataObj.query === exports.QueryParam.NEW_BLOCK) {
                  // subscribe NewBlock succeed
                  this.subscriptions[dataObj.query] = {
                      id: dataObj.query,
                      parameters: dataObj,
                  };
                  this.emitter.emit(exports.StatusType.SUBSCRIBE_NEW_BLOCK, dataObj);
                  this.emitter.emit(exports.SocketConnect.RECONNECT);
              }
              else if (dataObj.query === exports.QueryParam.EVENT_LOG) {
                  // subscribe EventLog succeed
                  this.subscriptions[dataObj.query] = {
                      id: dataObj.query,
                      parameters: dataObj,
                  };
                  this.emitter.emit(exports.StatusType.SUBSCRIBE_EVENT_LOG, dataObj);
                  this.emitter.emit(exports.SocketConnect.RECONNECT);
              }
              else if (dataObj.query === exports.QueryParam.UNSUBSCRIBE) {
                  this.emitter.emit(exports.MessageType.UNSUBSCRIBE, dataObj);
              }
              else {
                  throw new Error('unsupported message type');
              }
          }
          else {
              throw new Error('message data is empty');
          }
      };
      WebSocketProvider.prototype.addEventListener = function (type, handler) {
          this.emitter.on(type, handler);
      };
      WebSocketProvider.prototype.connecting = function () {
          return this.websocket.readyState === this.websocket.CONNECTING;
      };
      WebSocketProvider.prototype.send = function (query) {
          var _this = this;
          return new Promise(function (resolve, reject) {
              if (!_this.connecting()) {
                  try {
                      _this.websocket.send(JSON.stringify(query));
                  }
                  catch (error) {
                      throw error;
                  }
                  var queryParam = void 0;
                  if (query.query === exports.QueryParam.NEW_BLOCK) {
                      queryParam = exports.StatusType.SUBSCRIBE_NEW_BLOCK;
                  }
                  else if (query.query === exports.QueryParam.EVENT_LOG) {
                      queryParam = exports.StatusType.SUBSCRIBE_EVENT_LOG;
                  }
                  else {
                      queryParam = query.query;
                  }
                  _this.emitter.on(queryParam, function (data) {
                      resolve(data);
                  });
                  _this.emitter.on(exports.SocketConnect.ERROR, reject);
              }
              var connectHandler = function () {
                  _this.send(query).then(resolve).catch(reject);
              };
              var offConnectHandler = function () {
                  _this.emitter.off(exports.SocketConnect.CONNECT, connectHandler);
              };
              _this.emitter.on(exports.SocketConnect.CONNECT, connectHandler);
              _this.emitter.on(exports.SocketConnect.RECONNECT, offConnectHandler);
          });
      };
      WebSocketProvider.prototype.subscribe = function (payload) {
          return tslib.__awaiter(this, void 0, void 0, function () {
              var result;
              return tslib.__generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this.send(payload)];
                      case 1:
                          result = _a.sent();
                          return [2 /*return*/, result.query === payload.query];
                  }
              });
          });
      };
      WebSocketProvider.prototype.unsubscribe = function (payload) {
          return tslib.__awaiter(this, void 0, void 0, function () {
              var result, succeed;
              return tslib.__generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this.send(payload)];
                      case 1:
                          result = _a.sent();
                          succeed = result.query === payload.query;
                          if (succeed) {
                              this.subscriptions[payload.query] = null;
                          }
                          return [2 /*return*/, succeed];
                  }
              });
          });
      };
      return WebSocketProvider;
  }());

  //  Copyright (C) 2018 Zilliqa
  var Subscription = /** @class */ (function (_super) {
      tslib.__extends(Subscription, _super);
      function Subscription(subject, url, options) {
          var _this = _super.call(this, url, options) || this;
          _this.subject = subject;
          return _this;
      }
      Subscription.prototype.start = function () {
          return tslib.__awaiter(this, void 0, void 0, function () {
              return tslib.__generator(this, function (_a) {
                  return [2 /*return*/, _super.prototype.subscribe.call(this, this.subject)];
              });
          });
      };
      Subscription.prototype.stop = function () {
          return tslib.__awaiter(this, void 0, void 0, function () {
              var event;
              return tslib.__generator(this, function (_a) {
                  event = this.subject.query === exports.QueryParam.NEW_BLOCK
                      ? {
                          query: exports.QueryParam.UNSUBSCRIBE,
                          type: exports.QueryParam.NEW_BLOCK,
                      }
                      : { query: exports.QueryParam.UNSUBSCRIBE, type: exports.QueryParam.EVENT_LOG };
                  return [2 /*return*/, _super.prototype.unsubscribe.call(this, event)];
              });
          });
      };
      return Subscription;
  }(WebSocketProvider));

  //  Copyright (C) 2018 Zilliqa
  var NewTxBlockSubscription = /** @class */ (function (_super) {
      tslib.__extends(NewTxBlockSubscription, _super);
      function NewTxBlockSubscription(url, options) {
          return _super.call(this, { query: exports.QueryParam.NEW_BLOCK }, url, options) || this;
      }
      return NewTxBlockSubscription;
  }(Subscription));

  //  Copyright (C) 2018 Zilliqa
  var NewEventSubscription = /** @class */ (function (_super) {
      tslib.__extends(NewEventSubscription, _super);
      function NewEventSubscription(url, options) {
          var _this = _super.call(this, { query: exports.QueryParam.EVENT_LOG }, url, options) || this;
          _this.subject = {
              query: 'EventLog',
              addresses: options !== undefined ? options.addresses : [],
          };
          return _this;
      }
      return NewEventSubscription;
  }(Subscription));

  //  Copyright (C) 2018 Zilliqa
  var SubscriptionBuilder = /** @class */ (function () {
      function SubscriptionBuilder() {
      }
      SubscriptionBuilder.prototype.buildNewBlockSubscriptions = function (url, options) {
          return new NewTxBlockSubscription(url, options);
      };
      SubscriptionBuilder.prototype.buildEventLogSubscriptions = function (url, options) {
          return new NewEventSubscription(url, options);
      };
      return SubscriptionBuilder;
  }());

  //  Copyright (C) 2018 Zilliqa

  exports.NewTxBlockSubscription = NewTxBlockSubscription;
  exports.Subscription = Subscription;
  exports.WebSocketProvider = WebSocketProvider;
  exports.NewEventSubscription = NewEventSubscription;
  exports.SubscriptionBuilder = SubscriptionBuilder;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
