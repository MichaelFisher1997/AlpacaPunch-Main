import { __awaiter, __generator, __values, __extends } from 'tslib';
import mitt from 'mitt';
import { w3cwebsocket } from 'websocket';

//  Copyright (C) 2018 Zilliqa
//
//  This file is part of zilliqa-js
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
var SocketConnect;
(function (SocketConnect) {
    SocketConnect["READY"] = "ready";
    SocketConnect["CONNECT"] = "connect";
    SocketConnect["ERROR"] = "error";
    SocketConnect["CLOSE"] = "close";
    SocketConnect["RECONNECT"] = "reconnect";
})(SocketConnect || (SocketConnect = {}));
var SocketState;
(function (SocketState) {
    SocketState["SOCKET_CONNECT"] = "socket_connect";
    SocketState["SOCKET_MESSAGE"] = "socket_message";
    SocketState["SOCKET_READY"] = "socket_ready";
    SocketState["SOCKET_CLOSE"] = "socket_close";
    SocketState["SOCKET_ERROR"] = "socket_error";
})(SocketState || (SocketState = {}));
// message type pushed by server side
var MessageType;
(function (MessageType) {
    MessageType["NEW_BLOCK"] = "NewBlock";
    MessageType["EVENT_LOG"] = "EventLog";
    MessageType["NOTIFICATION"] = "Notification";
    MessageType["UNSUBSCRIBE"] = "Unsubscribe";
})(MessageType || (MessageType = {}));
// message type that we can query with to server
var QueryParam;
(function (QueryParam) {
    QueryParam["NEW_BLOCK"] = "NewBlock";
    QueryParam["EVENT_LOG"] = "EventLog";
    QueryParam["UNSUBSCRIBE"] = "Unsubscribe";
})(QueryParam || (QueryParam = {}));
// indicate that whether we subscribe successfully
var StatusType;
(function (StatusType) {
    StatusType["SUBSCRIBE_NEW_BLOCK"] = "SubscribeNewBlock";
    StatusType["SUBSCRIBE_EVENT_LOG"] = "SubscribeEventLog";
})(StatusType || (StatusType = {}));

//  Copyright (C) 2018 Zilliqa
var WebSocketProvider = /** @class */ (function () {
    // basically, options is a collection of metadata things like protocol or headers
    function WebSocketProvider(url, options) {
        this.handlers = {};
        this.url = url;
        this.options = options;
        this.emitter = new mitt(this.handlers);
        this.websocket = WebSocketProvider.NewWebSocket(url, options);
        this.subscriptions = {};
        this.registerEventListeners();
    }
    WebSocketProvider.NewWebSocket = function (url, options) {
        if (typeof window !== 'undefined' && window.WebSocket) {
            return new WebSocket(url, options !== undefined ? options.protocol : []);
        }
        else {
            var headers = options !== undefined ? options.headers || {} : undefined;
            var urlObject = new URL(url);
            if (headers !== undefined &&
                !headers.authorization &&
                urlObject.username &&
                urlObject.password) {
                var authToken = Buffer.from(urlObject.username + ":" + urlObject.password).toString('base64');
                headers.authorization = "Basic " + authToken;
            }
            return new w3cwebsocket(url, options !== undefined ? options.protocol : undefined, undefined, headers, undefined, options !== undefined ? options.clientConfig : undefined);
        }
    };
    WebSocketProvider.prototype.registerEventListeners = function () {
        this.websocket.onopen = this.onConnect.bind(this);
        this.websocket.onclose = this.onClose.bind(this);
        this.websocket.onmessage = this.onMessage.bind(this);
        this.websocket.onerror = this.onError.bind(this);
    };
    WebSocketProvider.prototype.removeAllSocketListeners = function () {
        this.removeEventListener(SocketState.SOCKET_MESSAGE);
        this.removeEventListener(SocketState.SOCKET_READY);
        this.removeEventListener(SocketState.SOCKET_CLOSE);
        this.removeEventListener(SocketState.SOCKET_ERROR);
        this.removeEventListener(SocketState.SOCKET_CONNECT);
    };
    WebSocketProvider.prototype.removeEventListener = function (type, handler) {
        if (!type) {
            this.handlers = {};
            return;
        }
        if (!handler) {
            delete this.handlers[type];
        }
        else {
            return this.emitter.off(type, handler);
        }
    };
    WebSocketProvider.prototype.reconnect = function () {
        var _this = this;
        setTimeout(function () {
            _this.removeAllSocketListeners();
            _this.websocket = WebSocketProvider.NewWebSocket(_this.url, _this.options);
            _this.registerEventListeners();
        }, 5000);
    };
    WebSocketProvider.prototype.onClose = function (event) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // reconnect
                if (this.subscriptions !== null && !event.wasClean) {
                    this.emitter.emit(SocketConnect.RECONNECT, event);
                    this.reconnect();
                    return [2 /*return*/];
                }
                // normal close
                if (this.websocket.CONNECTING) {
                    this.emitter.emit(SocketConnect.CLOSE, event);
                    this.websocket.close();
                    return [2 /*return*/];
                }
                return [2 /*return*/];
            });
        });
    };
    WebSocketProvider.prototype.onError = function (event) {
        this.emitter.emit(SocketConnect.ERROR, event);
        if (this.websocket.CONNECTING) {
            this.websocket.close();
        }
        return;
    };
    WebSocketProvider.prototype.onConnect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var subscriptionKeys, subscriptionKeys_1, subscriptionKeys_1_1, key, id, parameters, e_1_1;
            var e_1, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.subscriptions) {
                            this.subscriptions = {};
                        }
                        subscriptionKeys = Object.keys(this.subscriptions);
                        if (!(subscriptionKeys.length > 0)) return [3 /*break*/, 8];
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        subscriptionKeys_1 = __values(subscriptionKeys), subscriptionKeys_1_1 = subscriptionKeys_1.next();
                        _b.label = 2;
                    case 2:
                        if (!!subscriptionKeys_1_1.done) return [3 /*break*/, 5];
                        key = subscriptionKeys_1_1.value;
                        id = key;
                        parameters = this.subscriptions[key].parameters;
                        delete this.subscriptions[id];
                        return [4 /*yield*/, this.subscribe(parameters)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        subscriptionKeys_1_1 = subscriptionKeys_1.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_1_1 = _b.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (subscriptionKeys_1_1 && !subscriptionKeys_1_1.done && (_a = subscriptionKeys_1.return)) _a.call(subscriptionKeys_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 8:
                        this.emitter.emit(SocketState.SOCKET_CONNECT);
                        this.emitter.emit(SocketConnect.CONNECT);
                        return [2 /*return*/];
                }
            });
        });
    };
    WebSocketProvider.prototype.onMessage = function (msg) {
        var e_2, _a;
        if (msg.data) {
            var dataObj = JSON.parse(msg.data);
            if (dataObj.type === MessageType.NOTIFICATION) {
                this.emitter.emit(SocketState.SOCKET_MESSAGE, dataObj);
                try {
                    for (var _b = __values(dataObj.values), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var value = _c.value;
                        if (value.query === MessageType.NEW_BLOCK) {
                            this.emitter.emit(MessageType.NEW_BLOCK, value);
                        }
                        else if (value.query === MessageType.EVENT_LOG) {
                            this.emitter.emit(MessageType.EVENT_LOG, value);
                        }
                        else if (value.query === MessageType.UNSUBSCRIBE) {
                            this.emitter.emit(MessageType.UNSUBSCRIBE, value);
                        }
                        else {
                            throw new Error('unsupported value type');
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            else if (dataObj.query === QueryParam.NEW_BLOCK) {
                // subscribe NewBlock succeed
                this.subscriptions[dataObj.query] = {
                    id: dataObj.query,
                    parameters: dataObj,
                };
                this.emitter.emit(StatusType.SUBSCRIBE_NEW_BLOCK, dataObj);
                this.emitter.emit(SocketConnect.RECONNECT);
            }
            else if (dataObj.query === QueryParam.EVENT_LOG) {
                // subscribe EventLog succeed
                this.subscriptions[dataObj.query] = {
                    id: dataObj.query,
                    parameters: dataObj,
                };
                this.emitter.emit(StatusType.SUBSCRIBE_EVENT_LOG, dataObj);
                this.emitter.emit(SocketConnect.RECONNECT);
            }
            else if (dataObj.query === QueryParam.UNSUBSCRIBE) {
                this.emitter.emit(MessageType.UNSUBSCRIBE, dataObj);
            }
            else {
                throw new Error('unsupported message type');
            }
        }
        else {
            throw new Error('message data is empty');
        }
    };
    WebSocketProvider.prototype.addEventListener = function (type, handler) {
        this.emitter.on(type, handler);
    };
    WebSocketProvider.prototype.connecting = function () {
        return this.websocket.readyState === this.websocket.CONNECTING;
    };
    WebSocketProvider.prototype.send = function (query) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (!_this.connecting()) {
                try {
                    _this.websocket.send(JSON.stringify(query));
                }
                catch (error) {
                    throw error;
                }
                var queryParam = void 0;
                if (query.query === QueryParam.NEW_BLOCK) {
                    queryParam = StatusType.SUBSCRIBE_NEW_BLOCK;
                }
                else if (query.query === QueryParam.EVENT_LOG) {
                    queryParam = StatusType.SUBSCRIBE_EVENT_LOG;
                }
                else {
                    queryParam = query.query;
                }
                _this.emitter.on(queryParam, function (data) {
                    resolve(data);
                });
                _this.emitter.on(SocketConnect.ERROR, reject);
            }
            var connectHandler = function () {
                _this.send(query).then(resolve).catch(reject);
            };
            var offConnectHandler = function () {
                _this.emitter.off(SocketConnect.CONNECT, connectHandler);
            };
            _this.emitter.on(SocketConnect.CONNECT, connectHandler);
            _this.emitter.on(SocketConnect.RECONNECT, offConnectHandler);
        });
    };
    WebSocketProvider.prototype.subscribe = function (payload) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.send(payload)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.query === payload.query];
                }
            });
        });
    };
    WebSocketProvider.prototype.unsubscribe = function (payload) {
        return __awaiter(this, void 0, void 0, function () {
            var result, succeed;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.send(payload)];
                    case 1:
                        result = _a.sent();
                        succeed = result.query === payload.query;
                        if (succeed) {
                            this.subscriptions[payload.query] = null;
                        }
                        return [2 /*return*/, succeed];
                }
            });
        });
    };
    return WebSocketProvider;
}());

//  Copyright (C) 2018 Zilliqa
var Subscription = /** @class */ (function (_super) {
    __extends(Subscription, _super);
    function Subscription(subject, url, options) {
        var _this = _super.call(this, url, options) || this;
        _this.subject = subject;
        return _this;
    }
    Subscription.prototype.start = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.subscribe.call(this, this.subject)];
            });
        });
    };
    Subscription.prototype.stop = function () {
        return __awaiter(this, void 0, void 0, function () {
            var event;
            return __generator(this, function (_a) {
                event = this.subject.query === QueryParam.NEW_BLOCK
                    ? {
                        query: QueryParam.UNSUBSCRIBE,
                        type: QueryParam.NEW_BLOCK,
                    }
                    : { query: QueryParam.UNSUBSCRIBE, type: QueryParam.EVENT_LOG };
                return [2 /*return*/, _super.prototype.unsubscribe.call(this, event)];
            });
        });
    };
    return Subscription;
}(WebSocketProvider));

//  Copyright (C) 2018 Zilliqa
var NewTxBlockSubscription = /** @class */ (function (_super) {
    __extends(NewTxBlockSubscription, _super);
    function NewTxBlockSubscription(url, options) {
        return _super.call(this, { query: QueryParam.NEW_BLOCK }, url, options) || this;
    }
    return NewTxBlockSubscription;
}(Subscription));

//  Copyright (C) 2018 Zilliqa
var NewEventSubscription = /** @class */ (function (_super) {
    __extends(NewEventSubscription, _super);
    function NewEventSubscription(url, options) {
        var _this = _super.call(this, { query: QueryParam.EVENT_LOG }, url, options) || this;
        _this.subject = {
            query: 'EventLog',
            addresses: options !== undefined ? options.addresses : [],
        };
        return _this;
    }
    return NewEventSubscription;
}(Subscription));

//  Copyright (C) 2018 Zilliqa
var SubscriptionBuilder = /** @class */ (function () {
    function SubscriptionBuilder() {
    }
    SubscriptionBuilder.prototype.buildNewBlockSubscriptions = function (url, options) {
        return new NewTxBlockSubscription(url, options);
    };
    SubscriptionBuilder.prototype.buildEventLogSubscriptions = function (url, options) {
        return new NewEventSubscription(url, options);
    };
    return SubscriptionBuilder;
}());

//  Copyright (C) 2018 Zilliqa

export { NewTxBlockSubscription, Subscription, WebSocketProvider, SocketConnect, SocketState, MessageType, QueryParam, StatusType, NewEventSubscription, SubscriptionBuilder };
//# sourceMappingURL=index.esm.js.map
