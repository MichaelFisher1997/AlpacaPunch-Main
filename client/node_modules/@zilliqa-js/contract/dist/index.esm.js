import { __assign, __awaiter, __decorate, __generator, __metadata } from 'tslib';
import { Transaction, TxStatus, util } from '@zilliqa-js/account';
import { GET_TX_ATTEMPTS, RPCMethod, sign } from '@zilliqa-js/core';
import { fromBech32Address, isValidChecksumAddress, normaliseAddress, toChecksumAddress } from '@zilliqa-js/crypto';
import { BN, validation, bytes } from '@zilliqa-js/util';
import { Blockchain } from '@zilliqa-js/blockchain';
import hash from 'hash.js';

//  Copyright (C) 2018 Zilliqa
//
//  This file is part of zilliqa-js
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
var ContractStatus;
(function (ContractStatus) {
    ContractStatus[ContractStatus["Deployed"] = 0] = "Deployed";
    ContractStatus[ContractStatus["Rejected"] = 1] = "Rejected";
    ContractStatus[ContractStatus["Initialised"] = 2] = "Initialised";
})(ContractStatus || (ContractStatus = {}));

//  Copyright (C) 2018 Zilliqa
var NIL_ADDRESS = '0x0000000000000000000000000000000000000000';
var Contract = /** @class */ (function () {
    function Contract(factory, code, abi, address, init, state, checkAddr) {
        if (checkAddr === void 0) { checkAddr = false; }
        this.factory = factory;
        this.provider = factory.provider;
        this.signer = factory.signer;
        this.blockchain = new Blockchain(factory.provider, factory.signer);
        // assume that we are accessing an existing contract
        if (address) {
            this.abi = abi;
            if (checkAddr) {
                this.address = normaliseAddress(address);
            }
            else {
                if (validation.isBech32(address)) {
                    this.address = fromBech32Address(address);
                }
                else if (isValidChecksumAddress(address)) {
                    this.address = address;
                }
                else {
                    this.address = toChecksumAddress(address);
                }
            }
            this.init = init;
            this.state = state;
            this.status = ContractStatus.Deployed;
        }
        else {
            // assume we're deploying
            this.abi = abi;
            this.code = code;
            this.init = init;
            this.status = ContractStatus.Initialised;
        }
    }
    /**
     * isInitialised
     *
     * Returns true if the contract has not been deployed
     *
     * @returns {boolean}
     */
    Contract.prototype.isInitialised = function () {
        return this.status === ContractStatus.Initialised;
    };
    /**
     * isDeployed
     *
     * Returns true if the contract is deployed
     *
     * @returns {boolean}
     */
    Contract.prototype.isDeployed = function () {
        return this.status === ContractStatus.Deployed;
    };
    /**
     * isRejected
     *
     * Returns true if an attempt to deploy the contract was made, but the
     * underlying transaction was unsuccessful.
     *
     * @returns {boolean}
     */
    Contract.prototype.isRejected = function () {
        return this.status === ContractStatus.Rejected;
    };
    Contract.prototype.prepareTx = function (tx, attempts, interval, isDeploy) {
        if (attempts === void 0) { attempts = GET_TX_ATTEMPTS; }
        if (interval === void 0) { interval = 1000; }
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.provider.send(RPCMethod.CreateTransaction, __assign(__assign({}, tx.txParams), { priority: tx.toDS }))];
                    case 1:
                        response = _a.sent();
                        if (response.error) {
                            this.address = undefined;
                            this.error = response.error;
                            return [2 /*return*/, tx.setStatus(TxStatus.Rejected)];
                        }
                        if (isDeploy) {
                            this.address = response.result.ContractAddress
                                ? toChecksumAddress(response.result.ContractAddress)
                                : undefined;
                        }
                        return [2 /*return*/, tx.confirm(response.result.TranID, attempts, interval)];
                }
            });
        });
    };
    Contract.prototype.prepare = function (tx) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.provider.send(RPCMethod.CreateTransaction, __assign(__assign({}, tx.txParams), { priority: tx.toDS }))];
                    case 1:
                        response = _a.sent();
                        if (response.error || !response.result) {
                            this.address = undefined;
                            this.error = response.error;
                            tx.setStatus(TxStatus.Rejected);
                        }
                        else {
                            tx.id = response.result.TranID;
                            tx.setStatus(TxStatus.Pending);
                            return [2 /*return*/, response.result.ContractAddress];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * deploy smart contract with no confirm
     * @param params
     * @param toDs
     */
    Contract.prototype.deployWithoutConfirm = function (params, toDs) {
        if (toDs === void 0) { toDs = false; }
        return __awaiter(this, void 0, void 0, function () {
            var tx, _a, err_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.code || !this.init) {
                            throw new Error('Cannot deploy without code or initialisation parameters.');
                        }
                        tx = new Transaction(__assign(__assign({}, params), { toAddr: NIL_ADDRESS, amount: new BN(0), code: this.code, data: JSON.stringify(this.init).replace(/\\"/g, '"') }), this.provider, TxStatus.Initialised, toDs);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        _a = this;
                        return [4 /*yield*/, this.prepare(tx)];
                    case 2:
                        _a.address = _b.sent();
                        this.status =
                            this.address === undefined
                                ? ContractStatus.Rejected
                                : ContractStatus.Initialised;
                        return [2 /*return*/, [tx, this]];
                    case 3:
                        err_1 = _b.sent();
                        throw err_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * deploy
     *
     * @param {DeployParams} params
     * @returns {Promise<Contract>}
     */
    Contract.prototype.deploy = function (params, attempts, interval, toDs) {
        if (attempts === void 0) { attempts = 33; }
        if (interval === void 0) { interval = 1000; }
        if (toDs === void 0) { toDs = false; }
        return __awaiter(this, void 0, void 0, function () {
            var tx, err_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.code || !this.init) {
                            throw new Error('Cannot deploy without code or initialisation parameters.');
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.prepareTx(new Transaction(__assign(__assign({}, params), { toAddr: NIL_ADDRESS, amount: new BN(0), code: this.code, data: JSON.stringify(this.init).replace(/\\"/g, '"') }), this.provider, TxStatus.Initialised, toDs), attempts, interval, true)];
                    case 2:
                        tx = _a.sent();
                        if (tx.isRejected()) {
                            this.status = ContractStatus.Rejected;
                            this.address = undefined;
                            return [2 /*return*/, [tx, this]];
                        }
                        this.status = ContractStatus.Deployed;
                        this.address =
                            this.address && isValidChecksumAddress(this.address)
                                ? this.address
                                : Contracts.getAddressForContract(tx);
                        return [2 /*return*/, [tx, this]];
                    case 3:
                        err_2 = _a.sent();
                        throw err_2;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Contract.prototype.callWithoutConfirm = function (transition, args, params, toDs) {
        if (toDs === void 0) { toDs = false; }
        return __awaiter(this, void 0, void 0, function () {
            var data, tx, err_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        data = {
                            _tag: transition,
                            params: args,
                        };
                        if (this.error) {
                            return [2 /*return*/, Promise.reject(this.error)];
                        }
                        if (!this.address) {
                            return [2 /*return*/, Promise.reject('Contract has not been deployed!')];
                        }
                        tx = new Transaction(__assign(__assign({}, params), { toAddr: this.address, data: JSON.stringify(data) }), this.provider, TxStatus.Initialised, toDs);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.prepare(tx)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, tx];
                    case 3:
                        err_3 = _a.sent();
                        throw err_3;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * call
     *
     * @param {string} transition
     * @param {any} params
     * @returns {Promise<Transaction>}
     */
    Contract.prototype.call = function (transition, args, params, attempts, interval, toDs) {
        if (attempts === void 0) { attempts = 33; }
        if (interval === void 0) { interval = 1000; }
        if (toDs === void 0) { toDs = false; }
        return __awaiter(this, void 0, void 0, function () {
            var data, err_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        data = {
                            _tag: transition,
                            params: args,
                        };
                        if (this.error) {
                            return [2 /*return*/, Promise.reject(this.error)];
                        }
                        if (!this.address) {
                            return [2 /*return*/, Promise.reject('Contract has not been deployed!')];
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.prepareTx(new Transaction(__assign(__assign({}, params), { toAddr: this.address, data: JSON.stringify(data) }), this.provider, TxStatus.Initialised, toDs), attempts, interval, false)];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        err_4 = _a.sent();
                        throw err_4;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Contract.prototype.getState = function () {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.status !== ContractStatus.Deployed) {
                            return [2 /*return*/, Promise.resolve([])];
                        }
                        if (!this.address) {
                            throw new Error('Cannot get state of uninitialised contract');
                        }
                        return [4 /*yield*/, this.blockchain.getSmartContractState(this.address)];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, response.result];
                }
            });
        });
    };
    Contract.prototype.getSubState = function (variableName, indices) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.status !== ContractStatus.Deployed) {
                            return [2 /*return*/, Promise.resolve([])];
                        }
                        if (!this.address) {
                            throw new Error('Cannot get state of uninitialised contract');
                        }
                        if (!variableName) {
                            throw new Error('Variable name required');
                        }
                        return [4 /*yield*/, this.blockchain.getSmartContractSubState(this.address, variableName, indices)];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, response.result];
                }
            });
        });
    };
    Contract.prototype.getInit = function () {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.status !== ContractStatus.Deployed) {
                            return [2 /*return*/, Promise.resolve([])];
                        }
                        if (!this.address) {
                            throw new Error('Cannot get state of uninitialised contract');
                        }
                        return [4 /*yield*/, this.blockchain.getSmartContractInit(this.address)];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, response.result];
                }
            });
        });
    };
    __decorate([
        sign,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Transaction, Number, Number, Boolean]),
        __metadata("design:returntype", Promise)
    ], Contract.prototype, "prepareTx", null);
    __decorate([
        sign,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Transaction]),
        __metadata("design:returntype", Promise)
    ], Contract.prototype, "prepare", null);
    return Contract;
}());

//  Copyright (C) 2018 Zilliqa
/**
 * Contracts
 *
 * Unlike most zilliqa-js modules, `Contracts` is a factory class.
 * As a result, individual `Contract` instances are instead obtained by
 * calling `Contracts.at` (for an already-deployed contract) and
 * `Contracts.new` (to deploy a new contract).
 */
var Contracts = /** @class */ (function () {
    function Contracts(provider, signer) {
        this.provider = provider;
        this.provider.middleware.request.use(util.formatOutgoingTx, RPCMethod.CreateTransaction);
        this.signer = signer;
    }
    /**
     * getAddressForContract
     *
     * @static
     * @param {Transaction} tx - transaction used to create the contract
     * @returns {string} - the contract address
     */
    Contracts.getAddressForContract = function (tx) {
        // always subtract 1 from the tx nonce, as contract addresses are computed
        // based on the nonce in the global state.
        var nonce = tx.txParams.nonce ? tx.txParams.nonce - 1 : 0;
        return toChecksumAddress(hash
            .sha256()
            .update(tx.senderAddress.replace('0x', '').toLowerCase(), 'hex')
            .update(bytes.intToHexArray(nonce, 16).join(''), 'hex')
            .digest('hex')
            .slice(24));
    };
    Contracts.prototype.at = function (address, abi, code, init, state) {
        return new Contract(this, code, abi, address, init, state);
    };
    Contracts.prototype.atBech32 = function (address, abi, code, init, state) {
        return new Contract(this, code, abi, address, init, state, true);
    };
    Contracts.prototype.new = function (code, init, abi) {
        return new Contract(this, code, abi, undefined, init);
    };
    return Contracts;
}());

//  Copyright (C) 2018 Zilliqa

export { Contracts, Contract, ContractStatus };
//# sourceMappingURL=index.esm.js.map
