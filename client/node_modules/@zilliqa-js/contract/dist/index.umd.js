(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@zilliqa-js/account'), require('@zilliqa-js/core'), require('@zilliqa-js/crypto'), require('@zilliqa-js/util'), require('@zilliqa-js/blockchain'), require('hash.js')) :
  typeof define === 'function' && define.amd ? define(['exports', 'tslib', '@zilliqa-js/account', '@zilliqa-js/core', '@zilliqa-js/crypto', '@zilliqa-js/util', '@zilliqa-js/blockchain', 'hash.js'], factory) :
  (factory((global.zjsContract = {}),global.tslib,global['@zilliqa-js/account'],global['@zilliqa-js/core'],global['@zilliqa-js/crypto'],global['@zilliqa-js/util'],global['@zilliqa-js/blockchain'],global.hash.js));
}(this, (function (exports,tslib,account,core,crypto,util,blockchain,hash) { 'use strict';

  hash = hash && hash.hasOwnProperty('default') ? hash['default'] : hash;

  //  Copyright (C) 2018 Zilliqa
  (function (ContractStatus) {
      ContractStatus[ContractStatus["Deployed"] = 0] = "Deployed";
      ContractStatus[ContractStatus["Rejected"] = 1] = "Rejected";
      ContractStatus[ContractStatus["Initialised"] = 2] = "Initialised";
  })(exports.ContractStatus || (exports.ContractStatus = {}));

  //  Copyright (C) 2018 Zilliqa
  var NIL_ADDRESS = '0x0000000000000000000000000000000000000000';
  var Contract = /** @class */ (function () {
      function Contract(factory, code, abi, address, init, state, checkAddr) {
          if (checkAddr === void 0) { checkAddr = false; }
          this.factory = factory;
          this.provider = factory.provider;
          this.signer = factory.signer;
          this.blockchain = new blockchain.Blockchain(factory.provider, factory.signer);
          // assume that we are accessing an existing contract
          if (address) {
              this.abi = abi;
              if (checkAddr) {
                  this.address = crypto.normaliseAddress(address);
              }
              else {
                  if (util.validation.isBech32(address)) {
                      this.address = crypto.fromBech32Address(address);
                  }
                  else if (crypto.isValidChecksumAddress(address)) {
                      this.address = address;
                  }
                  else {
                      this.address = crypto.toChecksumAddress(address);
                  }
              }
              this.init = init;
              this.state = state;
              this.status = exports.ContractStatus.Deployed;
          }
          else {
              // assume we're deploying
              this.abi = abi;
              this.code = code;
              this.init = init;
              this.status = exports.ContractStatus.Initialised;
          }
      }
      /**
       * isInitialised
       *
       * Returns true if the contract has not been deployed
       *
       * @returns {boolean}
       */
      Contract.prototype.isInitialised = function () {
          return this.status === exports.ContractStatus.Initialised;
      };
      /**
       * isDeployed
       *
       * Returns true if the contract is deployed
       *
       * @returns {boolean}
       */
      Contract.prototype.isDeployed = function () {
          return this.status === exports.ContractStatus.Deployed;
      };
      /**
       * isRejected
       *
       * Returns true if an attempt to deploy the contract was made, but the
       * underlying transaction was unsuccessful.
       *
       * @returns {boolean}
       */
      Contract.prototype.isRejected = function () {
          return this.status === exports.ContractStatus.Rejected;
      };
      Contract.prototype.prepareTx = function (tx, attempts, interval, isDeploy) {
          if (attempts === void 0) { attempts = core.GET_TX_ATTEMPTS; }
          if (interval === void 0) { interval = 1000; }
          return tslib.__awaiter(this, void 0, void 0, function () {
              var response;
              return tslib.__generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this.provider.send(core.RPCMethod.CreateTransaction, tslib.__assign(tslib.__assign({}, tx.txParams), { priority: tx.toDS }))];
                      case 1:
                          response = _a.sent();
                          if (response.error) {
                              this.address = undefined;
                              this.error = response.error;
                              return [2 /*return*/, tx.setStatus(account.TxStatus.Rejected)];
                          }
                          if (isDeploy) {
                              this.address = response.result.ContractAddress
                                  ? crypto.toChecksumAddress(response.result.ContractAddress)
                                  : undefined;
                          }
                          return [2 /*return*/, tx.confirm(response.result.TranID, attempts, interval)];
                  }
              });
          });
      };
      Contract.prototype.prepare = function (tx) {
          return tslib.__awaiter(this, void 0, void 0, function () {
              var response;
              return tslib.__generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this.provider.send(core.RPCMethod.CreateTransaction, tslib.__assign(tslib.__assign({}, tx.txParams), { priority: tx.toDS }))];
                      case 1:
                          response = _a.sent();
                          if (response.error || !response.result) {
                              this.address = undefined;
                              this.error = response.error;
                              tx.setStatus(account.TxStatus.Rejected);
                          }
                          else {
                              tx.id = response.result.TranID;
                              tx.setStatus(account.TxStatus.Pending);
                              return [2 /*return*/, response.result.ContractAddress];
                          }
                          return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * deploy smart contract with no confirm
       * @param params
       * @param toDs
       */
      Contract.prototype.deployWithoutConfirm = function (params, toDs) {
          if (toDs === void 0) { toDs = false; }
          return tslib.__awaiter(this, void 0, void 0, function () {
              var tx, _a, err_1;
              return tslib.__generator(this, function (_b) {
                  switch (_b.label) {
                      case 0:
                          if (!this.code || !this.init) {
                              throw new Error('Cannot deploy without code or initialisation parameters.');
                          }
                          tx = new account.Transaction(tslib.__assign(tslib.__assign({}, params), { toAddr: NIL_ADDRESS, amount: new util.BN(0), code: this.code, data: JSON.stringify(this.init).replace(/\\"/g, '"') }), this.provider, account.TxStatus.Initialised, toDs);
                          _b.label = 1;
                      case 1:
                          _b.trys.push([1, 3, , 4]);
                          _a = this;
                          return [4 /*yield*/, this.prepare(tx)];
                      case 2:
                          _a.address = _b.sent();
                          this.status =
                              this.address === undefined
                                  ? exports.ContractStatus.Rejected
                                  : exports.ContractStatus.Initialised;
                          return [2 /*return*/, [tx, this]];
                      case 3:
                          err_1 = _b.sent();
                          throw err_1;
                      case 4: return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * deploy
       *
       * @param {DeployParams} params
       * @returns {Promise<Contract>}
       */
      Contract.prototype.deploy = function (params, attempts, interval, toDs) {
          if (attempts === void 0) { attempts = 33; }
          if (interval === void 0) { interval = 1000; }
          if (toDs === void 0) { toDs = false; }
          return tslib.__awaiter(this, void 0, void 0, function () {
              var tx, err_2;
              return tslib.__generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (!this.code || !this.init) {
                              throw new Error('Cannot deploy without code or initialisation parameters.');
                          }
                          _a.label = 1;
                      case 1:
                          _a.trys.push([1, 3, , 4]);
                          return [4 /*yield*/, this.prepareTx(new account.Transaction(tslib.__assign(tslib.__assign({}, params), { toAddr: NIL_ADDRESS, amount: new util.BN(0), code: this.code, data: JSON.stringify(this.init).replace(/\\"/g, '"') }), this.provider, account.TxStatus.Initialised, toDs), attempts, interval, true)];
                      case 2:
                          tx = _a.sent();
                          if (tx.isRejected()) {
                              this.status = exports.ContractStatus.Rejected;
                              this.address = undefined;
                              return [2 /*return*/, [tx, this]];
                          }
                          this.status = exports.ContractStatus.Deployed;
                          this.address =
                              this.address && crypto.isValidChecksumAddress(this.address)
                                  ? this.address
                                  : Contracts.getAddressForContract(tx);
                          return [2 /*return*/, [tx, this]];
                      case 3:
                          err_2 = _a.sent();
                          throw err_2;
                      case 4: return [2 /*return*/];
                  }
              });
          });
      };
      Contract.prototype.callWithoutConfirm = function (transition, args, params, toDs) {
          if (toDs === void 0) { toDs = false; }
          return tslib.__awaiter(this, void 0, void 0, function () {
              var data, tx, err_3;
              return tslib.__generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          data = {
                              _tag: transition,
                              params: args,
                          };
                          if (this.error) {
                              return [2 /*return*/, Promise.reject(this.error)];
                          }
                          if (!this.address) {
                              return [2 /*return*/, Promise.reject('Contract has not been deployed!')];
                          }
                          tx = new account.Transaction(tslib.__assign(tslib.__assign({}, params), { toAddr: this.address, data: JSON.stringify(data) }), this.provider, account.TxStatus.Initialised, toDs);
                          _a.label = 1;
                      case 1:
                          _a.trys.push([1, 3, , 4]);
                          return [4 /*yield*/, this.prepare(tx)];
                      case 2:
                          _a.sent();
                          return [2 /*return*/, tx];
                      case 3:
                          err_3 = _a.sent();
                          throw err_3;
                      case 4: return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * call
       *
       * @param {string} transition
       * @param {any} params
       * @returns {Promise<Transaction>}
       */
      Contract.prototype.call = function (transition, args, params, attempts, interval, toDs) {
          if (attempts === void 0) { attempts = 33; }
          if (interval === void 0) { interval = 1000; }
          if (toDs === void 0) { toDs = false; }
          return tslib.__awaiter(this, void 0, void 0, function () {
              var data, err_4;
              return tslib.__generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          data = {
                              _tag: transition,
                              params: args,
                          };
                          if (this.error) {
                              return [2 /*return*/, Promise.reject(this.error)];
                          }
                          if (!this.address) {
                              return [2 /*return*/, Promise.reject('Contract has not been deployed!')];
                          }
                          _a.label = 1;
                      case 1:
                          _a.trys.push([1, 3, , 4]);
                          return [4 /*yield*/, this.prepareTx(new account.Transaction(tslib.__assign(tslib.__assign({}, params), { toAddr: this.address, data: JSON.stringify(data) }), this.provider, account.TxStatus.Initialised, toDs), attempts, interval, false)];
                      case 2: return [2 /*return*/, _a.sent()];
                      case 3:
                          err_4 = _a.sent();
                          throw err_4;
                      case 4: return [2 /*return*/];
                  }
              });
          });
      };
      Contract.prototype.getState = function () {
          return tslib.__awaiter(this, void 0, void 0, function () {
              var response;
              return tslib.__generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (this.status !== exports.ContractStatus.Deployed) {
                              return [2 /*return*/, Promise.resolve([])];
                          }
                          if (!this.address) {
                              throw new Error('Cannot get state of uninitialised contract');
                          }
                          return [4 /*yield*/, this.blockchain.getSmartContractState(this.address)];
                      case 1:
                          response = _a.sent();
                          return [2 /*return*/, response.result];
                  }
              });
          });
      };
      Contract.prototype.getSubState = function (variableName, indices) {
          return tslib.__awaiter(this, void 0, void 0, function () {
              var response;
              return tslib.__generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (this.status !== exports.ContractStatus.Deployed) {
                              return [2 /*return*/, Promise.resolve([])];
                          }
                          if (!this.address) {
                              throw new Error('Cannot get state of uninitialised contract');
                          }
                          if (!variableName) {
                              throw new Error('Variable name required');
                          }
                          return [4 /*yield*/, this.blockchain.getSmartContractSubState(this.address, variableName, indices)];
                      case 1:
                          response = _a.sent();
                          return [2 /*return*/, response.result];
                  }
              });
          });
      };
      Contract.prototype.getInit = function () {
          return tslib.__awaiter(this, void 0, void 0, function () {
              var response;
              return tslib.__generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (this.status !== exports.ContractStatus.Deployed) {
                              return [2 /*return*/, Promise.resolve([])];
                          }
                          if (!this.address) {
                              throw new Error('Cannot get state of uninitialised contract');
                          }
                          return [4 /*yield*/, this.blockchain.getSmartContractInit(this.address)];
                      case 1:
                          response = _a.sent();
                          return [2 /*return*/, response.result];
                  }
              });
          });
      };
      tslib.__decorate([
          core.sign,
          tslib.__metadata("design:type", Function),
          tslib.__metadata("design:paramtypes", [account.Transaction, Number, Number, Boolean]),
          tslib.__metadata("design:returntype", Promise)
      ], Contract.prototype, "prepareTx", null);
      tslib.__decorate([
          core.sign,
          tslib.__metadata("design:type", Function),
          tslib.__metadata("design:paramtypes", [account.Transaction]),
          tslib.__metadata("design:returntype", Promise)
      ], Contract.prototype, "prepare", null);
      return Contract;
  }());

  //  Copyright (C) 2018 Zilliqa
  /**
   * Contracts
   *
   * Unlike most zilliqa-js modules, `Contracts` is a factory class.
   * As a result, individual `Contract` instances are instead obtained by
   * calling `Contracts.at` (for an already-deployed contract) and
   * `Contracts.new` (to deploy a new contract).
   */
  var Contracts = /** @class */ (function () {
      function Contracts(provider, signer) {
          this.provider = provider;
          this.provider.middleware.request.use(account.util.formatOutgoingTx, core.RPCMethod.CreateTransaction);
          this.signer = signer;
      }
      /**
       * getAddressForContract
       *
       * @static
       * @param {Transaction} tx - transaction used to create the contract
       * @returns {string} - the contract address
       */
      Contracts.getAddressForContract = function (tx) {
          // always subtract 1 from the tx nonce, as contract addresses are computed
          // based on the nonce in the global state.
          var nonce = tx.txParams.nonce ? tx.txParams.nonce - 1 : 0;
          return crypto.toChecksumAddress(hash
              .sha256()
              .update(tx.senderAddress.replace('0x', '').toLowerCase(), 'hex')
              .update(util.bytes.intToHexArray(nonce, 16).join(''), 'hex')
              .digest('hex')
              .slice(24));
      };
      Contracts.prototype.at = function (address, abi, code, init, state) {
          return new Contract(this, code, abi, address, init, state);
      };
      Contracts.prototype.atBech32 = function (address, abi, code, init, state) {
          return new Contract(this, code, abi, address, init, state, true);
      };
      Contracts.prototype.new = function (code, init, abi) {
          return new Contract(this, code, abi, undefined, init);
      };
      return Contracts;
  }());

  //  Copyright (C) 2018 Zilliqa

  exports.Contracts = Contracts;
  exports.Contract = Contract;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
