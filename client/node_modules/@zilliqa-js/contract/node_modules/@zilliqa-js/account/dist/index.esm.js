import { __assign, __awaiter, __generator, __read, __spreadArray, __values, __extends, __rest } from 'tslib';
import { RPCMethod, Signer, EventEmitter, GET_TX_ATTEMPTS } from '@zilliqa-js/core';
import { bytes, validation, BN } from '@zilliqa-js/util';
import { ZilliqaMessage } from '@zilliqa-js/proto';
import { getPubKeyFromPrivateKey, getAddressFromPublicKey, toBech32Address, decryptPrivateKey, encryptPrivateKey, sign, normalizePrivateKey, schnorr, normaliseAddress, toChecksumAddress } from '@zilliqa-js/crypto';
import bip39 from 'bip39';
import hdkey from 'hdkey';

//  Copyright (C) 2018 Zilliqa
var encodeTransactionProto = function (tx) {
    var msg = {
        version: tx.version,
        nonce: tx.nonce || 0,
        // core protocol Schnorr expects lowercase, non-prefixed address.
        toaddr: bytes.hexToByteArray(tx.toAddr.replace('0x', '').toLowerCase()),
        senderpubkey: ZilliqaMessage.ByteArray.create({
            data: bytes.hexToByteArray(tx.pubKey || '00'),
        }),
        amount: ZilliqaMessage.ByteArray.create({
            data: Uint8Array.from(tx.amount.toArrayLike(Buffer, undefined, 16)),
        }),
        gasprice: ZilliqaMessage.ByteArray.create({
            data: Uint8Array.from(tx.gasPrice.toArrayLike(Buffer, undefined, 16)),
        }),
        gaslimit: tx.gasLimit,
        code: tx.code && tx.code.length
            ? Uint8Array.from(__spreadArray([], __read(tx.code), false).map(function (c) { return c.charCodeAt(0); }))
            : null,
        data: tx.data && tx.data.length
            ? Uint8Array.from(__spreadArray([], __read(tx.data), false).map(function (c) { return c.charCodeAt(0); }))
            : null,
    };
    var serialised = ZilliqaMessage.ProtoTransactionCoreInfo.create(msg);
    return Buffer.from(ZilliqaMessage.ProtoTransactionCoreInfo.encode(serialised).finish());
};
var isTxReceipt = function (x) {
    return validation.isPlainObject(x) && validation.matchesObject(x, {});
};
var isTxParams = function (obj) {
    var validator = {
        version: [validation.required(validation.isNumber)],
        toAddr: [validation.required(validation.isAddress)],
        amount: [validation.required(validation.isBN)],
        gasPrice: [validation.required(validation.isBN)],
        gasLimit: [validation.required(validation.isLong)],
        code: [validation.isString],
        data: [validation.isString],
        receipt: [isTxReceipt],
        nonce: [validation.required(validation.isNumber)],
        signature: [validation.required(validation.isSignature)],
    };
    return validation.matchesObject(obj, validator);
};
var formatOutgoingTx = function (req) {
    var e_1, _a;
    // if batch create transaction, payload is array
    if (Array.isArray(req.payload) &&
        req.payload[0].method === RPCMethod.CreateTransaction &&
        isTxParams(req.payload[0].params[0])) {
        // loop thru batch payloads and format the params
        var payloads = [];
        try {
            for (var _b = __values(req.payload), _c = _b.next(); !_c.done; _c = _b.next()) {
                var txPayload = _c.value;
                var txConfig = txPayload.params[0];
                payloads.push(__assign(__assign({}, txPayload), { params: [
                        __assign(__assign({}, txConfig), { amount: txConfig.amount.toString(), gasLimit: txConfig.gasLimit.toString(), gasPrice: txConfig.gasPrice.toString() }),
                    ] }));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var ret = __assign(__assign({}, req), { payload: payloads });
        return ret;
    }
    // non-batch create transactions
    if (!Array.isArray(req.payload) &&
        req.payload.method === RPCMethod.CreateTransaction &&
        isTxParams(req.payload.params[0])) {
        var txConfig = req.payload.params[0];
        var ret = __assign(__assign({}, req), { payload: __assign(__assign({}, req.payload), { params: [
                    __assign(__assign({}, txConfig), { amount: txConfig.amount.toString(), gasLimit: txConfig.gasLimit.toString(), gasPrice: txConfig.gasPrice.toString() }),
                ] }) });
        return ret;
    }
    return req;
};
function sleep(ms) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve) {
                    setTimeout(function () { return resolve(undefined); }, ms);
                })];
        });
    });
}

var util = /*#__PURE__*/Object.freeze({
  encodeTransactionProto: encodeTransactionProto,
  isTxReceipt: isTxReceipt,
  isTxParams: isTxParams,
  formatOutgoingTx: formatOutgoingTx,
  sleep: sleep
});

//  Copyright (C) 2018 Zilliqa
var Account = /** @class */ (function () {
    function Account(privateKey) {
        this.privateKey = this.normalizePrivateKey(privateKey);
        this.publicKey = getPubKeyFromPrivateKey(this.privateKey);
        this.address = getAddressFromPublicKey(this.publicKey);
        this.bech32Address = toBech32Address(this.address);
    }
    /**
     * fromFile
     *
     * Takes a JSON-encoded keystore and passphrase, returning a fully
     * instantiated Account instance.
     *
     * @param {string} file
     * @param {string} passphrase
     * @returns {Promise<Account>}
     */
    Account.fromFile = function (file, passphrase) {
        return __awaiter(this, void 0, void 0, function () {
            var keystore, privateKey, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        keystore = JSON.parse(file);
                        return [4 /*yield*/, decryptPrivateKey(passphrase, keystore)];
                    case 1:
                        privateKey = _a.sent();
                        return [2 /*return*/, new Account(privateKey)];
                    case 2:
                        err_1 = _a.sent();
                        throw new Error("Could not decrypt keystore file.");
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * toFile
     *
     * @param {string} passphrase
     * @param {kdf} 'pbkdf2' | 'scrypt'
     * @returns {Promise<string>}
     */
    Account.prototype.toFile = function (passphrase, kdf) {
        if (kdf === void 0) { kdf = 'scrypt'; }
        return __awaiter(this, void 0, void 0, function () {
            var keystore;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!passphrase || !passphrase.length) {
                            throw new Error('Passphrase cannot have a length of 0');
                        }
                        return [4 /*yield*/, encryptPrivateKey(kdf, this.privateKey, passphrase)];
                    case 1:
                        keystore = _a.sent();
                        return [2 /*return*/, keystore];
                }
            });
        });
    };
    /**
     * signTransaction
     *
     * @param {Buffer} bytes - the data to be signed
     *
     * @returns {string} - the hex encoded signature. it is a concatenation of
     * the r and s values in hex, each padded to a length of 64.
     */
    Account.prototype.signTransaction = function (bytes$$1) {
        return sign(bytes$$1, this.privateKey, this.publicKey);
    };
    Account.prototype.normalizePrivateKey = function (privateKey) {
        return normalizePrivateKey(privateKey);
    };
    return Account;
}());

//  Copyright (C) 2018 Zilliqa
var Wallet = /** @class */ (function (_super) {
    __extends(Wallet, _super);
    /**
     * constructor
     *
     * Takes an array of Account objects and instantiates a Wallet instance.
     *
     * @param {Account[]} accounts
     */
    function Wallet(provider, accounts) {
        if (accounts === void 0) { accounts = []; }
        var _this = _super.call(this) || this;
        _this.accounts = {};
        if (accounts.length) {
            _this.accounts = accounts.reduce(function (acc, account) {
                var _a;
                return __assign(__assign({}, acc), (_a = {}, _a[account.address] = account, _a));
            }, {});
        }
        _this.provider = provider;
        _this.defaultAccount = accounts[0];
        return _this;
    }
    /**
     * create
     *
     * Creates a new keypair with a randomly-generated private key. The new
     * account is accessible by address.
     *
     * @returns {string} - address of the new account
     */
    Wallet.prototype.create = function () {
        var _a;
        var privateKey = schnorr.generatePrivateKey();
        var newAccount = new Account(privateKey);
        this.accounts = __assign(__assign({}, this.accounts), (_a = {}, _a[newAccount.address] = newAccount, _a));
        if (!this.defaultAccount) {
            this.defaultAccount = newAccount;
        }
        return newAccount.address;
    };
    /**
     * addByPrivateKey
     *
     * Adds an account to the wallet by private key.
     *
     * @param {string} privateKey - hex-encoded private key
     * @returns {string} - the corresponing address, computer from the private
     * key.
     */
    Wallet.prototype.addByPrivateKey = function (privateKey) {
        var _a;
        var newAccount = new Account(privateKey);
        this.accounts = __assign(__assign({}, this.accounts), (_a = {}, _a[newAccount.address] = newAccount, _a));
        if (!this.defaultAccount) {
            this.defaultAccount = newAccount;
        }
        return newAccount.address;
    };
    /**
     * addByKeystore
     *
     * Adds an account by keystore. This method is asynchronous and returns
     * a Promise<string>, in order not to block on the underlying decryption
     * operation.
     *
     * @param {string} keystore
     * @param {string} passphrase
     * @returns {Promise<string>}
     */
    Wallet.prototype.addByKeystore = function (keystore, passphrase) {
        return __awaiter(this, void 0, void 0, function () {
            var newAccount;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, Account.fromFile(keystore, passphrase)];
                    case 1:
                        newAccount = _b.sent();
                        this.accounts = __assign(__assign({}, this.accounts), (_a = {}, _a[newAccount.address] = newAccount, _a));
                        if (!this.defaultAccount) {
                            this.defaultAccount = newAccount;
                        }
                        return [2 /*return*/, newAccount.address];
                }
            });
        });
    };
    /**
     * addByMnemonic
     *
     * Adds an `Account` by use of a mnemonic as specified in BIP-32 and BIP-39
     *
     * @param {string} phrase - 12-word mnemonic phrase
     * @param {number} index=0 - the number of the child key to add
     * @returns {string} - the corresponding address
     */
    Wallet.prototype.addByMnemonic = function (phrase, index) {
        if (index === void 0) { index = 0; }
        if (!this.isValidMnemonic(phrase)) {
            throw new Error("Invalid mnemonic phrase: " + phrase);
        }
        var seed = bip39.mnemonicToSeed(phrase);
        var hdKey = hdkey.fromMasterSeed(seed);
        var childKey = hdKey.derive("m/44'/313'/0'/0/" + index);
        var privateKey = childKey.privateKey.toString('hex');
        return this.addByPrivateKey(privateKey);
    };
    /**
     * addByMnemonicLedger
     *
     * Adds an `Account` by use of a mnemonic as specified in BIP-32 and BIP-39
     * The key derivation path used in Ledger is different from that of
     * addByMnemonic.
     *
     * @param {string} phrase - 12-word mnemonic phrase
     * @param {number} index=0 - the number of the child key to add
     * @returns {string} - the corresponding address
     */
    Wallet.prototype.addByMnemonicLedger = function (phrase, index) {
        if (index === void 0) { index = 0; }
        if (!this.isValidMnemonic(phrase)) {
            throw new Error("Invalid mnemonic phrase: " + phrase);
        }
        var seed = bip39.mnemonicToSeed(phrase);
        var hdKey = hdkey.fromMasterSeed(seed);
        var childKey = hdKey.derive("m/44'/313'/" + index + "'/0'/0'");
        var privateKey = childKey.privateKey.toString('hex');
        return this.addByPrivateKey(privateKey);
    };
    /**
     * export
     *
     * Exports the specified account as a keystore file.
     *
     * @param {string} address
     * @param {string} passphrase
     * @param {KDF} kdf='scrypt'
     * @returns {Promise<string>}
     */
    Wallet.prototype.export = function (address, passphrase, kdf) {
        if (kdf === void 0) { kdf = 'scrypt'; }
        if (!this.accounts[address]) {
            throw new Error("No account with address " + address + " exists");
        }
        return this.accounts[address].toFile(passphrase, kdf);
    };
    /**
     * remove
     *
     * Removes an account from the wallet and returns boolean to indicate
     * failure or success.
     *
     * @param {string} address
     * @returns {boolean}
     */
    Wallet.prototype.remove = function (address) {
        if (this.accounts[address]) {
            var _a = this.accounts, _b = address, toRemove = _a[_b], rest = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
            this.accounts = rest;
            return true;
        }
        return false;
    };
    /**
     * setDefault
     *
     * Sets the default account of the wallet.
     *
     * @param {string} address
     */
    Wallet.prototype.setDefault = function (address) {
        this.defaultAccount = this.accounts[address];
    };
    /**
     * sign
     *
     * signs an unsigned transaction with the default account.
     *
     * @param {Transaction} tx
     * @param {boolean} offlineSign
     * @returns {Transaction}
     */
    Wallet.prototype.sign = function (tx, offlineSign) {
        if (tx.txParams && tx.txParams.pubKey) {
            // attempt to find the address
            var senderAddress = getAddressFromPublicKey(tx.txParams.pubKey);
            if (!this.accounts[senderAddress]) {
                throw new Error("Could not sign the transaction with " + senderAddress + " as it does not exist");
            }
            return this.signWith(tx, senderAddress, offlineSign);
        }
        if (!this.defaultAccount) {
            throw new Error('This wallet has no default account.');
        }
        return this.signWith(tx, this.defaultAccount.address, offlineSign);
    };
    Wallet.prototype.signBatch = function (txList) {
        return __awaiter(this, void 0, void 0, function () {
            var batchResults, signer_1, balance, nextNonce, _loop_1, this_1, index, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        batchResults = [];
                        if (!this.defaultAccount) {
                            throw new Error('This wallet has no default account.');
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 7, , 8]);
                        signer_1 = this.accounts[this.defaultAccount.address];
                        return [4 /*yield*/, this.provider.send(RPCMethod.GetBalance, signer_1.address.replace('0x', '').toLowerCase())];
                    case 2:
                        balance = _a.sent();
                        if (balance.result === undefined) {
                            throw new Error('Could not get balance');
                        }
                        if (typeof balance.result.nonce !== 'number') {
                            throw new Error('Could not get nonce');
                        }
                        nextNonce = balance.result.nonce + 1;
                        _loop_1 = function (index) {
                            var currentNonce, withNonceTx, signedTx;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        currentNonce = index + nextNonce;
                                        withNonceTx = txList[index].map(function (txObj) {
                                            return __assign(__assign({}, txObj), { nonce: currentNonce, pubKey: signer_1.publicKey });
                                        });
                                        return [4 /*yield*/, this_1.sign(withNonceTx)];
                                    case 1:
                                        signedTx = _b.sent();
                                        batchResults.push(signedTx);
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        index = 0;
                        _a.label = 3;
                    case 3:
                        if (!(index < txList.length)) return [3 /*break*/, 6];
                        return [5 /*yield**/, _loop_1(index)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        index++;
                        return [3 /*break*/, 3];
                    case 6: return [3 /*break*/, 8];
                    case 7:
                        err_1 = _a.sent();
                        throw err_1;
                    case 8: return [2 /*return*/, batchResults];
                }
            });
        });
    };
    /**
     * signWith
     *
     * @param {Transaction} tx
     * @param {string} account
     * @param {boolean} offlineSign
     * @returns {Transaction}
     */
    Wallet.prototype.signWith = function (tx, account, offlineSign) {
        return __awaiter(this, void 0, void 0, function () {
            var signer, gasPrice, gasLimit, debt, currNonce, balance, bal, withNonce_1, withPublicKey, err_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.accounts[account]) {
                            throw new Error('The selected account does not exist on this Wallet instance.');
                        }
                        signer = this.accounts[account];
                        gasPrice = tx.txParams.gasPrice;
                        gasLimit = new BN(tx.txParams.gasLimit.toString());
                        debt = gasPrice.mul(gasLimit).add(tx.txParams.amount);
                        currNonce = 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 5, , 6]);
                        if (!!tx.txParams.nonce) return [3 /*break*/, 4];
                        if (offlineSign) {
                            throw new Error('No nonce detected in tx params when signing in offline mode');
                        }
                        if (!(typeof offlineSign === 'undefined' || !offlineSign)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.provider.send(RPCMethod.GetBalance, signer.address.replace('0x', '').toLowerCase())];
                    case 2:
                        balance = _a.sent();
                        if (balance.result === undefined) {
                            throw new Error('Could not get balance');
                        }
                        bal = new BN(balance.result.balance);
                        if (debt.gt(bal)) {
                            throw new Error('You do not have enough funds, need ' +
                                debt.toString() +
                                ' but only have ' +
                                bal.toString());
                        }
                        if (typeof balance.result.nonce !== 'number') {
                            throw new Error('Could not get nonce');
                        }
                        currNonce = balance.result.nonce;
                        _a.label = 3;
                    case 3:
                        withNonce_1 = tx.map(function (txObj) {
                            return __assign(__assign({}, txObj), { nonce: txObj.nonce || currNonce + 1, pubKey: signer.publicKey });
                        });
                        return [2 /*return*/, withNonce_1.map(function (txObj) {
                                // @ts-ignore
                                return __assign(__assign({}, txObj), { signature: signer.signTransaction(withNonce_1.bytes) });
                            })];
                    case 4:
                        withPublicKey = tx.map(function (txObj) {
                            return __assign(__assign({}, txObj), { pubKey: signer.publicKey });
                        });
                        return [2 /*return*/, withPublicKey.map(function (txObj) {
                                return __assign(__assign({}, txObj), { signature: signer.signTransaction(tx.bytes) });
                            })];
                    case 5:
                        err_2 = _a.sent();
                        throw err_2;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    Wallet.prototype.isValidMnemonic = function (phrase) {
        if (phrase.trim().split(/\s+/g).length < 12) {
            return false;
        }
        return bip39.validateMnemonic(phrase);
    };
    return Wallet;
}(Signer));

//  Copyright (C) 2018 Zilliqa
//
//  This file is part of zilliqa-js
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
var TxStatus;
(function (TxStatus) {
    TxStatus[TxStatus["Initialised"] = 0] = "Initialised";
    TxStatus[TxStatus["Pending"] = 1] = "Pending";
    TxStatus[TxStatus["Confirmed"] = 2] = "Confirmed";
    TxStatus[TxStatus["Rejected"] = 3] = "Rejected";
})(TxStatus || (TxStatus = {}));
var TxEventName;
(function (TxEventName) {
    TxEventName["Error"] = "error";
    TxEventName["Receipt"] = "receipt";
    TxEventName["Track"] = "track";
})(TxEventName || (TxEventName = {}));

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var minimalisticAssert = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

var inherits_browser = createCommonjsModule(function (module) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
});

var inherits_1 = inherits_browser;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
var toArray_1 = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
var toHex_1 = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
var htonl_1 = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
var toHex32_1 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
var zero2_1 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
var zero8_1 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  minimalisticAssert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
var join32_1 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
var split32_1 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
var rotr32_1 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
var rotl32_1 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
var sum32_1 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
var sum32_3_1 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
var sum32_4_1 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
var sum32_5_1 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
var sum64_1 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
var sum64_hi_1 = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
var sum64_lo_1 = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
var sum64_4_hi_1 = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
var sum64_4_lo_1 = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
var sum64_5_hi_1 = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
var sum64_5_lo_1 = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
var rotr64_hi_1 = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
var rotr64_lo_1 = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
var shr64_hi_1 = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
var shr64_lo_1 = shr64_lo;

var utils = {
	inherits: inherits_1,
	toArray: toArray_1,
	toHex: toHex_1,
	htonl: htonl_1,
	toHex32: toHex32_1,
	zero2: zero2_1,
	zero8: zero8_1,
	join32: join32_1,
	split32: split32_1,
	rotr32: rotr32_1,
	rotl32: rotl32_1,
	sum32: sum32_1,
	sum32_3: sum32_3_1,
	sum32_4: sum32_4_1,
	sum32_5: sum32_5_1,
	sum64: sum64_1,
	sum64_hi: sum64_hi_1,
	sum64_lo: sum64_lo_1,
	sum64_4_hi: sum64_4_hi_1,
	sum64_4_lo: sum64_4_lo_1,
	sum64_5_hi: sum64_5_hi_1,
	sum64_5_lo: sum64_5_lo_1,
	rotr64_hi: rotr64_hi_1,
	rotr64_lo: rotr64_lo_1,
	shr64_hi: shr64_hi_1,
	shr64_lo: shr64_lo_1
};

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
var BlockHash_1 = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  minimalisticAssert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes$$1 = this._delta8;
  var k = bytes$$1 - ((len + this.padLength) % bytes$$1);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

var common = {
	BlockHash: BlockHash_1
};

var rotr32$1 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
var ft_1_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
var ch32_1 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
var maj32_1 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
var p32_1 = p32;

function s0_256(x) {
  return rotr32$1(x, 2) ^ rotr32$1(x, 13) ^ rotr32$1(x, 22);
}
var s0_256_1 = s0_256;

function s1_256(x) {
  return rotr32$1(x, 6) ^ rotr32$1(x, 11) ^ rotr32$1(x, 25);
}
var s1_256_1 = s1_256;

function g0_256(x) {
  return rotr32$1(x, 7) ^ rotr32$1(x, 18) ^ (x >>> 3);
}
var g0_256_1 = g0_256;

function g1_256(x) {
  return rotr32$1(x, 17) ^ rotr32$1(x, 19) ^ (x >>> 10);
}
var g1_256_1 = g1_256;

var common$1 = {
	ft_1: ft_1_1,
	ch32: ch32_1,
	maj32: maj32_1,
	p32: p32_1,
	s0_256: s0_256_1,
	s1_256: s1_256_1,
	g0_256: g0_256_1,
	g1_256: g1_256_1
};

var rotl32$1 = utils.rotl32;
var sum32$1 = utils.sum32;
var sum32_5$1 = utils.sum32_5;
var ft_1$1 = common$1.ft_1;
var BlockHash$1 = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash$1.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash$1);
var _1 = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5$1(rotl32$1(a, 5), ft_1$1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32$1(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32$1(this.h[0], a);
  this.h[1] = sum32$1(this.h[1], b);
  this.h[2] = sum32$1(this.h[2], c);
  this.h[3] = sum32$1(this.h[3], d);
  this.h[4] = sum32$1(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

var sum32$2 = utils.sum32;
var sum32_4$1 = utils.sum32_4;
var sum32_5$2 = utils.sum32_5;
var ch32$1 = common$1.ch32;
var maj32$1 = common$1.maj32;
var s0_256$1 = common$1.s0_256;
var s1_256$1 = common$1.s1_256;
var g0_256$1 = common$1.g0_256;
var g1_256$1 = common$1.g1_256;

var BlockHash$2 = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash$2.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash$2);
var _256 = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4$1(g1_256$1(W[i - 2]), W[i - 7], g0_256$1(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  minimalisticAssert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5$2(h, s1_256$1(e), ch32$1(e, f, g), this.k[i], W[i]);
    var T2 = sum32$2(s0_256$1(a), maj32$1(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32$2(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32$2(T1, T2);
  }

  this.h[0] = sum32$2(this.h[0], a);
  this.h[1] = sum32$2(this.h[1], b);
  this.h[2] = sum32$2(this.h[2], c);
  this.h[3] = sum32$2(this.h[3], d);
  this.h[4] = sum32$2(this.h[4], e);
  this.h[5] = sum32$2(this.h[5], f);
  this.h[6] = sum32$2(this.h[6], g);
  this.h[7] = sum32$2(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  _256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, _256);
var _224 = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};

var rotr64_hi$1 = utils.rotr64_hi;
var rotr64_lo$1 = utils.rotr64_lo;
var shr64_hi$1 = utils.shr64_hi;
var shr64_lo$1 = utils.shr64_lo;
var sum64$1 = utils.sum64;
var sum64_hi$1 = utils.sum64_hi;
var sum64_lo$1 = utils.sum64_lo;
var sum64_4_hi$1 = utils.sum64_4_hi;
var sum64_4_lo$1 = utils.sum64_4_lo;
var sum64_5_hi$1 = utils.sum64_5_hi;
var sum64_5_lo$1 = utils.sum64_5_lo;

var BlockHash$3 = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash$3.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash$3);
var _512 = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi$1(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo$1(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  minimalisticAssert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi$1(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo$1(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi$1(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo$1(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi$1(dh, dl, T1_hi, T1_lo);
    el = sum64_lo$1(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi$1(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo$1(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64$1(this.h, 0, ah, al);
  sum64$1(this.h, 2, bh, bl);
  sum64$1(this.h, 4, ch, cl);
  sum64$1(this.h, 6, dh, dl);
  sum64$1(this.h, 8, eh, el);
  sum64$1(this.h, 10, fh, fl);
  sum64$1(this.h, 12, gh, gl);
  sum64$1(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi$1(xh, xl, 28);
  var c1_hi = rotr64_hi$1(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi$1(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo$1(xh, xl, 28);
  var c1_lo = rotr64_lo$1(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo$1(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi$1(xh, xl, 14);
  var c1_hi = rotr64_hi$1(xh, xl, 18);
  var c2_hi = rotr64_hi$1(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo$1(xh, xl, 14);
  var c1_lo = rotr64_lo$1(xh, xl, 18);
  var c2_lo = rotr64_lo$1(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi$1(xh, xl, 1);
  var c1_hi = rotr64_hi$1(xh, xl, 8);
  var c2_hi = shr64_hi$1(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo$1(xh, xl, 1);
  var c1_lo = rotr64_lo$1(xh, xl, 8);
  var c2_lo = shr64_lo$1(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi$1(xh, xl, 19);
  var c1_hi = rotr64_hi$1(xl, xh, 29);  // 61
  var c2_hi = shr64_hi$1(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo$1(xh, xl, 19);
  var c1_lo = rotr64_lo$1(xl, xh, 29);  // 61
  var c2_lo = shr64_lo$1(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  _512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, _512);
var _384 = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

var sha1 = _1;
var sha224 = _224;
var sha256 = _256;
var sha384 = _384;
var sha512 = _512;

var sha = {
	sha1: sha1,
	sha224: sha224,
	sha256: sha256,
	sha384: sha384,
	sha512: sha512
};

var rotl32$2 = utils.rotl32;
var sum32$3 = utils.sum32;
var sum32_3$1 = utils.sum32_3;
var sum32_4$2 = utils.sum32_4;
var BlockHash$4 = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash$4.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash$4);
var ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32$3(
      rotl32$2(
        sum32_4$2(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32$2(C, 10);
    C = B;
    B = T;
    T = sum32$3(
      rotl32$2(
        sum32_4$2(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32$2(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3$1(this.h[1], C, Dh);
  this.h[1] = sum32_3$1(this.h[2], D, Eh);
  this.h[2] = sum32_3$1(this.h[3], E, Ah);
  this.h[3] = sum32_3$1(this.h[4], A, Bh);
  this.h[4] = sum32_3$1(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

var ripemd = {
	ripemd160: ripemd160
};

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
var hmac = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  minimalisticAssert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

var hash_1 = createCommonjsModule(function (module, exports) {
var hash = exports;

hash.utils = utils;
hash.common = common;
hash.sha = sha;
hash.ripemd = ripemd;
hash.hmac = hmac;

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;
});

//  Copyright (C) 2018 Zilliqa
/**
 * Transaction
 *
 * Transaction is a functor. Its purpose is to encode the possible states a
 * Transaction can be in:  Confirmed, Rejected, Pending, or Initialised (i.e., not broadcasted).
 */
var Transaction = /** @class */ (function () {
    function Transaction(params, provider, status, toDS, enableSecureToAddress) {
        if (status === void 0) { status = TxStatus.Initialised; }
        if (toDS === void 0) { toDS = false; }
        if (enableSecureToAddress === void 0) { enableSecureToAddress = true; }
        this.code = '';
        this.data = '';
        // private members
        this.version = params.version;
        this.toAddr = enableSecureToAddress
            ? normaliseAddress(params.toAddr)
            : toChecksumAddress(params.toAddr);
        this.nonce = params.nonce;
        this.pubKey = params.pubKey;
        this.amount = params.amount;
        this.code = params.code || '';
        this.data = params.data || '';
        this.signature = params.signature;
        this.gasPrice = params.gasPrice;
        this.gasLimit = params.gasLimit;
        this.receipt = params.receipt;
        // public members
        this.provider = provider;
        this.status = status;
        this.toDS = toDS;
        this.blockConfirmation = 0;
        this.eventEmitter = new EventEmitter();
    }
    /**
     * confirm
     *
     * constructs an already-confirmed transaction.
     *
     * @static
     * @param {BaseTx} params
     */
    Transaction.confirm = function (params, provider) {
        return new Transaction(params, provider, TxStatus.Confirmed);
    };
    /**
     * reject
     *
     * constructs an already-rejected transaction.
     *
     * @static
     * @param {BaseTx} params
     */
    Transaction.reject = function (params, provider) {
        return new Transaction(params, provider, TxStatus.Rejected);
    };
    Object.defineProperty(Transaction.prototype, "hash", {
        /**
         * to get hash or transaction id of this transaction
         * this can be identical returned by zilliqa network while calling CreateTransaction
         */
        get: function () {
            var payload = this.bytes.toString('hex');
            return hash_1.sha256().update(payload, 'hex').digest('hex');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "bytes", {
        get: function () {
            return encodeTransactionProto(this.txParams);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "senderAddress", {
        get: function () {
            if (!this.pubKey) {
                return '0'.repeat(40);
            }
            return getAddressFromPublicKey(this.pubKey);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "txParams", {
        get: function () {
            return {
                version: this.version,
                toAddr: normaliseAddress(this.toAddr),
                nonce: this.nonce,
                pubKey: this.pubKey,
                amount: this.amount,
                gasPrice: this.gasPrice,
                gasLimit: this.gasLimit,
                code: this.code,
                data: this.data,
                signature: this.signature,
                receipt: this.receipt,
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "payload", {
        get: function () {
            return {
                version: this.version,
                toAddr: this.toAddr,
                nonce: this.nonce,
                pubKey: this.pubKey,
                amount: this.amount.toString(),
                gasPrice: this.gasPrice.toString(),
                gasLimit: this.gasLimit.toString(),
                code: this.code,
                data: this.data,
                signature: this.signature,
                receipt: this.receipt,
            };
        },
        enumerable: false,
        configurable: true
    });
    /**
     * isPending
     *
     * @returns {boolean}
     */
    Transaction.prototype.isPending = function () {
        return this.status === TxStatus.Pending;
    };
    /**
     * isInitialised
     *
     * @returns {boolean}
     */
    Transaction.prototype.isInitialised = function () {
        return this.status === TxStatus.Initialised;
    };
    Transaction.prototype.getReceipt = function () {
        return this.receipt;
    };
    /**
     * isConfirmed
     *
     * @returns {boolean}
     */
    Transaction.prototype.isConfirmed = function () {
        return this.status === TxStatus.Confirmed;
    };
    /**
     * isRejected
     *
     * @returns {boolean}
     */
    Transaction.prototype.isRejected = function () {
        return this.status === TxStatus.Rejected;
    };
    /**
     * setProvider
     *
     * Sets the provider on this instance.
     *
     * @param {Provider} provider
     */
    Transaction.prototype.setProvider = function (provider) {
        this.provider = provider;
    };
    /**
     * setStatus
     *
     * Escape hatch to imperatively set the state of the transaction.
     *
     * @param {TxStatus} status
     * @returns {undefined}
     */
    Transaction.prototype.setStatus = function (status) {
        this.status = status;
        return this;
    };
    Transaction.prototype.observed = function () {
        return this.eventEmitter;
    };
    /**
     * blockConfirm
     *
     * Use `RPCMethod.GetLatestBlock` to get latest blockNumber
     * Use interval to get the latestBlockNumber
     * After BlockNumber change, then we use `RPCMethod.GetTransaction` to get the receipt
     *
     * @param {string} txHash
     * @param {number} maxblockCount
     * @param {number} interval interval in milliseconds
     * @returns {Promise<Transaction>}
     */
    Transaction.prototype.blockConfirm = function (txHash, maxblockCount, interval) {
        if (maxblockCount === void 0) { maxblockCount = 4; }
        if (interval === void 0) { interval = 1000; }
        return __awaiter(this, void 0, void 0, function () {
            var blockStart, blockChecked, attempt, blockLatest, blockNext, err_1, blockFailed, errorMessage;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.status = TxStatus.Pending;
                        return [4 /*yield*/, this.getBlockNumber()];
                    case 1:
                        blockStart = _a.sent();
                        blockChecked = blockStart;
                        attempt = 0;
                        _a.label = 2;
                    case 2:
                        if (!(attempt < maxblockCount)) return [3 /*break*/, 12];
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 8, , 9]);
                        return [4 /*yield*/, this.getBlockNumber()];
                    case 4:
                        blockLatest = _a.sent();
                        blockNext = blockChecked.add(new BN(attempt === 0 ? attempt : 1));
                        if (!blockLatest.gte(blockNext)) return [3 /*break*/, 6];
                        blockChecked = blockLatest;
                        this.emit(TxEventName.Track, {
                            txHash: txHash,
                            attempt: attempt,
                            currentBlock: blockChecked.toString(),
                        });
                        return [4 /*yield*/, this.trackTx(txHash)];
                    case 5:
                        if (_a.sent()) {
                            this.blockConfirmation = blockLatest.sub(blockStart).toNumber();
                            return [2 /*return*/, this];
                        }
                        return [3 /*break*/, 7];
                    case 6:
                        attempt = attempt - 1 >= 0 ? attempt - 1 : 0;
                        _a.label = 7;
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        err_1 = _a.sent();
                        this.status = TxStatus.Rejected;
                        throw err_1;
                    case 9:
                        if (!(attempt + 1 < maxblockCount)) return [3 /*break*/, 11];
                        return [4 /*yield*/, sleep(interval)];
                    case 10:
                        _a.sent();
                        _a.label = 11;
                    case 11:
                        attempt += 1;
                        return [3 /*break*/, 2];
                    case 12: return [4 /*yield*/, this.getBlockNumber()];
                    case 13:
                        blockFailed = _a.sent();
                        this.blockConfirmation = blockFailed.sub(blockStart).toNumber();
                        this.status = TxStatus.Rejected;
                        errorMessage = "The transaction is still not confirmed after " + maxblockCount + " blocks.";
                        throw new Error(errorMessage);
                }
            });
        });
    };
    /**
     * confirmReceipt
     *
     * Similar to the Promise API. This sets the Transaction instance to a state
     * of pending. Calling this function kicks off a passive loop that polls the
     * lookup node for confirmation on the txHash.
     *
     * The polls are performed with a linear backoff:
     *
     * `const delay = interval * attempt`
     *
     * This is a low-level method that you should generally not have to use
     * directly.
     *
     * @param {string} txHash
     * @param {number} maxAttempts
     * @param {number} initial interval in milliseconds
     * @returns {Promise<Transaction>}
     */
    Transaction.prototype.confirm = function (txHash, maxAttempts, interval) {
        if (maxAttempts === void 0) { maxAttempts = GET_TX_ATTEMPTS; }
        if (interval === void 0) { interval = 1000; }
        return __awaiter(this, void 0, void 0, function () {
            var attempt, err_2, errorMessage;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.status = TxStatus.Pending;
                        attempt = 0;
                        _a.label = 1;
                    case 1:
                        if (!(attempt < maxAttempts)) return [3 /*break*/, 8];
                        this.emit(TxEventName.Track, {
                            txHash: txHash,
                            attempt: attempt,
                        });
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, this.trackTx(txHash)];
                    case 3:
                        if (_a.sent()) {
                            return [2 /*return*/, this];
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        err_2 = _a.sent();
                        this.status = TxStatus.Rejected;
                        throw err_2;
                    case 5:
                        if (!(attempt + 1 < maxAttempts)) return [3 /*break*/, 7];
                        return [4 /*yield*/, sleep(interval * attempt)];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7:
                        attempt++;
                        return [3 /*break*/, 1];
                    case 8:
                        this.status = TxStatus.Rejected;
                        errorMessage = "The transaction is still not confirmed after " + maxAttempts + " attempts.";
                        throw new Error(errorMessage);
                }
            });
        });
    };
    /**
     * map
     *
     * maps over the transaction, allowing for manipulation.
     *
     * @param {(prev: TxParams) => TxParams} fn - mapper
     * @returns {Transaction}
     */
    Transaction.prototype.map = function (fn) {
        var newParams = fn(this.txParams);
        this.setParams(newParams);
        return this;
    };
    Transaction.prototype.setParams = function (params) {
        this.version = params.version;
        this.toAddr = normaliseAddress(params.toAddr);
        this.nonce = params.nonce;
        this.pubKey = params.pubKey;
        this.amount = params.amount;
        this.code = params.code || '';
        this.data = params.data || '';
        this.signature = params.signature;
        this.gasPrice = params.gasPrice;
        this.gasLimit = params.gasLimit;
        this.receipt = params.receipt;
    };
    Transaction.prototype.trackTx = function (txHash) {
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.provider.send(RPCMethod.GetTransaction, txHash)];
                    case 1:
                        res = _a.sent();
                        if (res.error) {
                            this.emit(TxEventName.Error, res.error);
                            return [2 /*return*/, false];
                        }
                        this.id = res.result.ID;
                        this.receipt = __assign(__assign({}, res.result.receipt), { cumulative_gas: parseInt(res.result.receipt.cumulative_gas, 10) });
                        this.emit(TxEventName.Receipt, this.receipt);
                        this.status =
                            this.receipt && this.receipt.success
                                ? TxStatus.Confirmed
                                : TxStatus.Rejected;
                        return [2 /*return*/, true];
                }
            });
        });
    };
    Transaction.prototype.getBlockNumber = function () {
        return __awaiter(this, void 0, void 0, function () {
            var res, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.provider.send(RPCMethod.GetLatestTxBlock)];
                    case 1:
                        res = _a.sent();
                        if (res.error === undefined && res.result.header.BlockNum) {
                            // if blockNumber is too high, we use BN to be safer
                            return [2 /*return*/, new BN(res.result.header.BlockNum)];
                        }
                        else {
                            throw new Error('Can not get latest BlockNumber');
                        }
                        return [3 /*break*/, 3];
                    case 2:
                        error_1 = _a.sent();
                        throw error_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    Transaction.prototype.emit = function (event, txEvent) {
        this.eventEmitter.emit(event, __assign(__assign({}, txEvent), { event: event }));
    };
    return Transaction;
}());

//  Copyright (C) 2018 Zilliqa
var TransactionFactory = /** @class */ (function () {
    function TransactionFactory(provider, signer) {
        this.provider = provider;
        this.provider.middleware.request.use(formatOutgoingTx, RPCMethod.CreateTransaction);
        this.signer = signer;
    }
    TransactionFactory.prototype.new = function (txParams, toDs, enableSecureAddress) {
        if (toDs === void 0) { toDs = false; }
        if (enableSecureAddress === void 0) { enableSecureAddress = true; }
        return new Transaction(txParams, this.provider, TxStatus.Initialised, toDs, enableSecureAddress);
    };
    /**
     * This constructor could help you to check if there is a default account to be used, and further more, if it has
     * sufficient fund to do the transfer.
     * @param txParams
     */
    TransactionFactory.prototype.payment = function (txParams) {
        return __awaiter(this, void 0, void 0, function () {
            var defaultAccount, addr, response, fund;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        defaultAccount = this.signer.defaultAccount;
                        if (!(defaultAccount !== undefined)) return [3 /*break*/, 2];
                        addr = defaultAccount.address;
                        return [4 /*yield*/, this.provider.send(RPCMethod.GetBalance, addr.replace('0x', '').toLowerCase())];
                    case 1:
                        response = _a.sent();
                        if (response.error) {
                            throw response.error;
                        }
                        fund = new BN(response.result.balance);
                        if (txParams.amount.cmp(fund) === 1) {
                            throw new Error('No sufficient fund');
                        }
                        return [3 /*break*/, 3];
                    case 2: throw new Error('No default wallet');
                    case 3: return [2 /*return*/, this.new(txParams, true)];
                }
            });
        });
    };
    return TransactionFactory;
}());

//  Copyright (C) 2018 Zilliqa

export { util, Account, Wallet, Transaction, TransactionFactory, TxStatus, TxEventName };
//# sourceMappingURL=index.esm.js.map
