{"ast":null,"code":"'use strict';\n\nconst {\n  kMaxLength\n} = require('buffer');\n\nconst {\n  createInflate,\n  constants: {\n    DEFLATE,\n    INFLATE,\n    Z_DEFAULT_CHUNK,\n    Z_DEFAULT_COMPRESSION,\n    Z_DEFAULT_MEMLEVEL,\n    Z_DEFAULT_STRATEGY,\n    Z_DEFAULT_WINDOWBITS,\n    Z_PARTIAL_FLUSH\n  }\n} = require('zlib');\n\nconst ZlibHandle = createInflate()._handle.constructor;\n\nfunction processCallback() {\n  throw new Error('Should not get here');\n}\n\nfunction zlibOnError(message, errno, code) {\n  const self = this._owner; // There is no way to cleanly recover.\n  // Continuing only obscures problems.\n\n  const error = new Error(message);\n  error.errno = errno;\n  error.code = code;\n  self._err = error;\n}\n\nfunction _close(engine) {\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle) return;\n\n  engine._handle.close();\n\n  engine._handle = null;\n}\n\nclass Zlib {\n  constructor(mode) {\n    const windowBits = Z_DEFAULT_WINDOWBITS;\n    const level = Z_DEFAULT_COMPRESSION;\n    const memLevel = Z_DEFAULT_MEMLEVEL;\n    const strategy = Z_DEFAULT_STRATEGY;\n    const dictionary = undefined;\n    this._err = undefined;\n    this._writeState = new Uint32Array(2);\n    this._chunkSize = Z_DEFAULT_CHUNK;\n    this._maxOutputLength = kMaxLength;\n    this._outBuffer = Buffer.allocUnsafe(this._chunkSize);\n    this._outOffset = 0;\n    this._handle = new ZlibHandle(mode);\n    this._handle._owner = this;\n    this._handle.onerror = zlibOnError;\n\n    this._handle.init(windowBits, level, memLevel, strategy, this._writeState, processCallback, dictionary);\n  }\n\n  writeSync(chunk, retChunks) {\n    const handle = this._handle;\n    if (!handle) throw new Error('Invalid Zlib instance');\n    let availInBefore = chunk.length;\n    let availOutBefore = this._chunkSize - this._outOffset;\n    let inOff = 0;\n    let availOutAfter;\n    let availInAfter;\n    let buffers;\n    let nread = 0;\n    const state = this._writeState;\n    let buffer = this._outBuffer;\n    let offset = this._outOffset;\n    const chunkSize = this._chunkSize;\n\n    while (true) {\n      handle.writeSync(Z_PARTIAL_FLUSH, chunk, // in\n      inOff, // in_off\n      availInBefore, // in_len\n      buffer, // out\n      offset, // out_off\n      availOutBefore); // out_len\n\n      if (this._err) throw this._err;\n      availOutAfter = state[0];\n      availInAfter = state[1];\n      const inDelta = availInBefore - availInAfter;\n      const have = availOutBefore - availOutAfter;\n\n      if (have > 0) {\n        const out = offset === 0 && have === buffer.length ? buffer : buffer.slice(offset, offset + have);\n        offset += have;\n        if (!buffers) buffers = out;else if (buffers.push === undefined) buffers = [buffers, out];else buffers.push(out);\n        nread += out.byteLength;\n\n        if (nread > this._maxOutputLength) {\n          _close(this);\n\n          throw new Error(`Output length exceeded maximum of ${this._maxOutputLength}`);\n        }\n      } else if (have !== 0) {\n        throw new Error('have should not go down');\n      } // Exhausted the output buffer, or used all the input create a new one.\n\n\n      if (availOutAfter === 0 || offset >= chunkSize) {\n        availOutBefore = chunkSize;\n        offset = 0;\n        buffer = Buffer.allocUnsafe(chunkSize);\n      }\n\n      if (availOutAfter === 0) {\n        // Not actually done. Need to reprocess.\n        // Also, update the availInBefore to the availInAfter value,\n        // so that if we have to hit it a third (fourth, etc.) time,\n        // it'll have the correct byte counts.\n        inOff += inDelta;\n        availInBefore = availInAfter;\n      } else {\n        break;\n      }\n    }\n\n    this._outBuffer = buffer;\n    this._outOffset = offset;\n    if (nread === 0) buffers = Buffer.alloc(0);\n\n    if (retChunks) {\n      buffers.totalLen = nread;\n      return buffers;\n    }\n\n    if (buffers.push === undefined) return buffers;\n    const output = Buffer.allocUnsafe(nread);\n\n    for (let i = 0, p = 0; i < buffers.length; ++i) {\n      const buf = buffers[i];\n      output.set(buf, p);\n      p += buf.length;\n    }\n\n    return output;\n  }\n\n}\n\nclass ZlibPacketWriter {\n  constructor(protocol) {\n    this.allocStart = 0;\n    this.allocStartKEX = 0;\n    this._protocol = protocol;\n    this._zlib = new Zlib(DEFLATE);\n  }\n\n  cleanup() {\n    if (this._zlib) _close(this._zlib);\n  }\n\n  alloc(payloadSize, force) {\n    return Buffer.allocUnsafe(payloadSize);\n  }\n\n  finalize(payload, force) {\n    if (this._protocol._kexinit === undefined || force) {\n      const output = this._zlib.writeSync(payload, true);\n\n      const packet = this._protocol._cipher.allocPacket(output.totalLen);\n\n      if (output.push === undefined) {\n        packet.set(output, 5);\n      } else {\n        for (let i = 0, p = 5; i < output.length; ++i) {\n          const chunk = output[i];\n          packet.set(chunk, p);\n          p += chunk.length;\n        }\n      }\n\n      return packet;\n    }\n\n    return payload;\n  }\n\n}\n\nclass PacketWriter {\n  constructor(protocol) {\n    this.allocStart = 5;\n    this.allocStartKEX = 5;\n    this._protocol = protocol;\n  }\n\n  cleanup() {}\n\n  alloc(payloadSize, force) {\n    if (this._protocol._kexinit === undefined || force) return this._protocol._cipher.allocPacket(payloadSize);\n    return Buffer.allocUnsafe(payloadSize);\n  }\n\n  finalize(packet, force) {\n    return packet;\n  }\n\n}\n\nclass ZlibPacketReader {\n  constructor() {\n    this._zlib = new Zlib(INFLATE);\n  }\n\n  cleanup() {\n    if (this._zlib) _close(this._zlib);\n  }\n\n  read(data) {\n    return this._zlib.writeSync(data, false);\n  }\n\n}\n\nclass PacketReader {\n  cleanup() {}\n\n  read(data) {\n    return data;\n  }\n\n}\n\nmodule.exports = {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter\n};","map":{"version":3,"names":["kMaxLength","require","createInflate","constants","DEFLATE","INFLATE","Z_DEFAULT_CHUNK","Z_DEFAULT_COMPRESSION","Z_DEFAULT_MEMLEVEL","Z_DEFAULT_STRATEGY","Z_DEFAULT_WINDOWBITS","Z_PARTIAL_FLUSH","ZlibHandle","_handle","constructor","processCallback","Error","zlibOnError","message","errno","code","self","_owner","error","_err","_close","engine","close","Zlib","mode","windowBits","level","memLevel","strategy","dictionary","undefined","_writeState","Uint32Array","_chunkSize","_maxOutputLength","_outBuffer","Buffer","allocUnsafe","_outOffset","onerror","init","writeSync","chunk","retChunks","handle","availInBefore","length","availOutBefore","inOff","availOutAfter","availInAfter","buffers","nread","state","buffer","offset","chunkSize","inDelta","have","out","slice","push","byteLength","alloc","totalLen","output","i","p","buf","set","ZlibPacketWriter","protocol","allocStart","allocStartKEX","_protocol","_zlib","cleanup","payloadSize","force","finalize","payload","_kexinit","packet","_cipher","allocPacket","PacketWriter","ZlibPacketReader","read","data","PacketReader","module","exports"],"sources":["/home/micqdf/AlpacaPunchTests/maintest/test1/client/node_modules/ssh2/lib/protocol/zlib.js"],"sourcesContent":["'use strict';\n\nconst { kMaxLength } = require('buffer');\nconst {\n  createInflate,\n  constants: {\n    DEFLATE,\n    INFLATE,\n    Z_DEFAULT_CHUNK,\n    Z_DEFAULT_COMPRESSION,\n    Z_DEFAULT_MEMLEVEL,\n    Z_DEFAULT_STRATEGY,\n    Z_DEFAULT_WINDOWBITS,\n    Z_PARTIAL_FLUSH,\n  }\n} = require('zlib');\nconst ZlibHandle = createInflate()._handle.constructor;\n\nfunction processCallback() {\n  throw new Error('Should not get here');\n}\n\nfunction zlibOnError(message, errno, code) {\n  const self = this._owner;\n  // There is no way to cleanly recover.\n  // Continuing only obscures problems.\n\n  const error = new Error(message);\n  error.errno = errno;\n  error.code = code;\n  self._err = error;\n}\n\nfunction _close(engine) {\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle)\n    return;\n\n  engine._handle.close();\n  engine._handle = null;\n}\n\nclass Zlib {\n  constructor(mode) {\n    const windowBits = Z_DEFAULT_WINDOWBITS;\n    const level = Z_DEFAULT_COMPRESSION;\n    const memLevel = Z_DEFAULT_MEMLEVEL;\n    const strategy = Z_DEFAULT_STRATEGY;\n    const dictionary = undefined;\n\n    this._err = undefined;\n    this._writeState = new Uint32Array(2);\n    this._chunkSize = Z_DEFAULT_CHUNK;\n    this._maxOutputLength = kMaxLength;\n    this._outBuffer = Buffer.allocUnsafe(this._chunkSize);\n    this._outOffset = 0;\n\n    this._handle = new ZlibHandle(mode);\n    this._handle._owner = this;\n    this._handle.onerror = zlibOnError;\n    this._handle.init(windowBits,\n                      level,\n                      memLevel,\n                      strategy,\n                      this._writeState,\n                      processCallback,\n                      dictionary);\n  }\n\n  writeSync(chunk, retChunks) {\n    const handle = this._handle;\n    if (!handle)\n      throw new Error('Invalid Zlib instance');\n\n    let availInBefore = chunk.length;\n    let availOutBefore = this._chunkSize - this._outOffset;\n    let inOff = 0;\n    let availOutAfter;\n    let availInAfter;\n\n    let buffers;\n    let nread = 0;\n    const state = this._writeState;\n    let buffer = this._outBuffer;\n    let offset = this._outOffset;\n    const chunkSize = this._chunkSize;\n\n    while (true) {\n      handle.writeSync(Z_PARTIAL_FLUSH,\n                       chunk, // in\n                       inOff, // in_off\n                       availInBefore, // in_len\n                       buffer, // out\n                       offset, // out_off\n                       availOutBefore); // out_len\n      if (this._err)\n        throw this._err;\n\n      availOutAfter = state[0];\n      availInAfter = state[1];\n\n      const inDelta = availInBefore - availInAfter;\n      const have = availOutBefore - availOutAfter;\n\n      if (have > 0) {\n        const out = (offset === 0 && have === buffer.length\n                     ? buffer\n                     : buffer.slice(offset, offset + have));\n        offset += have;\n        if (!buffers)\n          buffers = out;\n        else if (buffers.push === undefined)\n          buffers = [buffers, out];\n        else\n          buffers.push(out);\n        nread += out.byteLength;\n\n        if (nread > this._maxOutputLength) {\n          _close(this);\n          throw new Error(\n            `Output length exceeded maximum of ${this._maxOutputLength}`\n          );\n        }\n      } else if (have !== 0) {\n        throw new Error('have should not go down');\n      }\n\n      // Exhausted the output buffer, or used all the input create a new one.\n      if (availOutAfter === 0 || offset >= chunkSize) {\n        availOutBefore = chunkSize;\n        offset = 0;\n        buffer = Buffer.allocUnsafe(chunkSize);\n      }\n\n      if (availOutAfter === 0) {\n        // Not actually done. Need to reprocess.\n        // Also, update the availInBefore to the availInAfter value,\n        // so that if we have to hit it a third (fourth, etc.) time,\n        // it'll have the correct byte counts.\n        inOff += inDelta;\n        availInBefore = availInAfter;\n      } else {\n        break;\n      }\n    }\n\n    this._outBuffer = buffer;\n    this._outOffset = offset;\n\n    if (nread === 0)\n      buffers = Buffer.alloc(0);\n\n    if (retChunks) {\n      buffers.totalLen = nread;\n      return buffers;\n    }\n\n    if (buffers.push === undefined)\n      return buffers;\n\n    const output = Buffer.allocUnsafe(nread);\n    for (let i = 0, p = 0; i < buffers.length; ++i) {\n      const buf = buffers[i];\n      output.set(buf, p);\n      p += buf.length;\n    }\n    return output;\n  }\n}\n\nclass ZlibPacketWriter {\n  constructor(protocol) {\n    this.allocStart = 0;\n    this.allocStartKEX = 0;\n    this._protocol = protocol;\n    this._zlib = new Zlib(DEFLATE);\n  }\n\n  cleanup() {\n    if (this._zlib)\n      _close(this._zlib);\n  }\n\n  alloc(payloadSize, force) {\n    return Buffer.allocUnsafe(payloadSize);\n  }\n\n  finalize(payload, force) {\n    if (this._protocol._kexinit === undefined || force) {\n      const output = this._zlib.writeSync(payload, true);\n      const packet = this._protocol._cipher.allocPacket(output.totalLen);\n      if (output.push === undefined) {\n        packet.set(output, 5);\n      } else {\n        for (let i = 0, p = 5; i < output.length; ++i) {\n          const chunk = output[i];\n          packet.set(chunk, p);\n          p += chunk.length;\n        }\n      }\n      return packet;\n    }\n    return payload;\n  }\n}\n\nclass PacketWriter {\n  constructor(protocol) {\n    this.allocStart = 5;\n    this.allocStartKEX = 5;\n    this._protocol = protocol;\n  }\n\n  cleanup() {}\n\n  alloc(payloadSize, force) {\n    if (this._protocol._kexinit === undefined || force)\n      return this._protocol._cipher.allocPacket(payloadSize);\n    return Buffer.allocUnsafe(payloadSize);\n  }\n\n  finalize(packet, force) {\n    return packet;\n  }\n}\n\nclass ZlibPacketReader {\n  constructor() {\n    this._zlib = new Zlib(INFLATE);\n  }\n\n  cleanup() {\n    if (this._zlib)\n      _close(this._zlib);\n  }\n\n  read(data) {\n    return this._zlib.writeSync(data, false);\n  }\n}\n\nclass PacketReader {\n  cleanup() {}\n\n  read(data) {\n    return data;\n  }\n}\n\nmodule.exports = {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}