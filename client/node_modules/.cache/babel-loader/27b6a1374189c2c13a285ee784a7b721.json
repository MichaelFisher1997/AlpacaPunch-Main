{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('mitt'), require('websocket')) : typeof define === 'function' && define.amd ? define(['exports', 'tslib', 'mitt', 'websocket'], factory) : factory(global.zjsSubscriptions = {}, global.tslib, global.mitt, global.websocket);\n})(this, function (exports, tslib, mitt, websocket) {\n  'use strict';\n\n  mitt = mitt && mitt.hasOwnProperty('default') ? mitt['default'] : mitt; //  Copyright (C) 2018 Zilliqa\n\n  (function (SocketConnect) {\n    SocketConnect[\"READY\"] = \"ready\";\n    SocketConnect[\"CONNECT\"] = \"connect\";\n    SocketConnect[\"ERROR\"] = \"error\";\n    SocketConnect[\"CLOSE\"] = \"close\";\n    SocketConnect[\"RECONNECT\"] = \"reconnect\";\n  })(exports.SocketConnect || (exports.SocketConnect = {}));\n\n  (function (SocketState) {\n    SocketState[\"SOCKET_CONNECT\"] = \"socket_connect\";\n    SocketState[\"SOCKET_MESSAGE\"] = \"socket_message\";\n    SocketState[\"SOCKET_READY\"] = \"socket_ready\";\n    SocketState[\"SOCKET_CLOSE\"] = \"socket_close\";\n    SocketState[\"SOCKET_ERROR\"] = \"socket_error\";\n  })(exports.SocketState || (exports.SocketState = {}));\n\n  (function (MessageType) {\n    MessageType[\"NEW_BLOCK\"] = \"NewBlock\";\n    MessageType[\"EVENT_LOG\"] = \"EventLog\";\n    MessageType[\"NOTIFICATION\"] = \"Notification\";\n    MessageType[\"UNSUBSCRIBE\"] = \"Unsubscribe\";\n  })(exports.MessageType || (exports.MessageType = {}));\n\n  (function (QueryParam) {\n    QueryParam[\"NEW_BLOCK\"] = \"NewBlock\";\n    QueryParam[\"EVENT_LOG\"] = \"EventLog\";\n    QueryParam[\"UNSUBSCRIBE\"] = \"Unsubscribe\";\n  })(exports.QueryParam || (exports.QueryParam = {}));\n\n  (function (StatusType) {\n    StatusType[\"SUBSCRIBE_NEW_BLOCK\"] = \"SubscribeNewBlock\";\n    StatusType[\"SUBSCRIBE_EVENT_LOG\"] = \"SubscribeEventLog\";\n  })(exports.StatusType || (exports.StatusType = {})); //  Copyright (C) 2018 Zilliqa\n\n\n  var WebSocketProvider =\n  /** @class */\n  function () {\n    // basically, options is a collection of metadata things like protocol or headers\n    function WebSocketProvider(url, options) {\n      this.handlers = {};\n      this.url = url;\n      this.options = options;\n      this.emitter = new mitt(this.handlers);\n      this.websocket = WebSocketProvider.NewWebSocket(url, options);\n      this.subscriptions = {};\n      this.registerEventListeners();\n    }\n\n    WebSocketProvider.NewWebSocket = function (url, options) {\n      if (typeof window !== 'undefined' && window.WebSocket) {\n        return new WebSocket(url, options !== undefined ? options.protocol : []);\n      } else {\n        var headers = options !== undefined ? options.headers || {} : undefined;\n        var urlObject = new URL(url);\n\n        if (headers !== undefined && !headers.authorization && urlObject.username && urlObject.password) {\n          var authToken = Buffer.from(urlObject.username + \":\" + urlObject.password).toString('base64');\n          headers.authorization = \"Basic \" + authToken;\n        }\n\n        return new websocket.w3cwebsocket(url, options !== undefined ? options.protocol : undefined, undefined, headers, undefined, options !== undefined ? options.clientConfig : undefined);\n      }\n    };\n\n    WebSocketProvider.prototype.registerEventListeners = function () {\n      this.websocket.onopen = this.onConnect.bind(this);\n      this.websocket.onclose = this.onClose.bind(this);\n      this.websocket.onmessage = this.onMessage.bind(this);\n      this.websocket.onerror = this.onError.bind(this);\n    };\n\n    WebSocketProvider.prototype.removeAllSocketListeners = function () {\n      this.removeEventListener(exports.SocketState.SOCKET_MESSAGE);\n      this.removeEventListener(exports.SocketState.SOCKET_READY);\n      this.removeEventListener(exports.SocketState.SOCKET_CLOSE);\n      this.removeEventListener(exports.SocketState.SOCKET_ERROR);\n      this.removeEventListener(exports.SocketState.SOCKET_CONNECT);\n    };\n\n    WebSocketProvider.prototype.removeEventListener = function (type, handler) {\n      if (!type) {\n        this.handlers = {};\n        return;\n      }\n\n      if (!handler) {\n        delete this.handlers[type];\n      } else {\n        return this.emitter.off(type, handler);\n      }\n    };\n\n    WebSocketProvider.prototype.reconnect = function () {\n      var _this = this;\n\n      setTimeout(function () {\n        _this.removeAllSocketListeners();\n\n        _this.websocket = WebSocketProvider.NewWebSocket(_this.url, _this.options);\n\n        _this.registerEventListeners();\n      }, 5000);\n    };\n\n    WebSocketProvider.prototype.onClose = function (event) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        return tslib.__generator(this, function (_a) {\n          // reconnect\n          if (this.subscriptions !== null && !event.wasClean) {\n            this.emitter.emit(exports.SocketConnect.RECONNECT, event);\n            this.reconnect();\n            return [2\n            /*return*/\n            ];\n          } // normal close\n\n\n          if (this.websocket.CONNECTING) {\n            this.emitter.emit(exports.SocketConnect.CLOSE, event);\n            this.websocket.close();\n            return [2\n            /*return*/\n            ];\n          }\n\n          return [2\n          /*return*/\n          ];\n        });\n      });\n    };\n\n    WebSocketProvider.prototype.onError = function (event) {\n      this.emitter.emit(exports.SocketConnect.ERROR, event);\n\n      if (this.websocket.CONNECTING) {\n        this.websocket.close();\n      }\n\n      return;\n    };\n\n    WebSocketProvider.prototype.onConnect = function () {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var subscriptionKeys, subscriptionKeys_1, subscriptionKeys_1_1, key, id, parameters, e_1_1;\n\n        var e_1, _a;\n\n        return tslib.__generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              if (!this.subscriptions) {\n                this.subscriptions = {};\n              }\n\n              subscriptionKeys = Object.keys(this.subscriptions);\n              if (!(subscriptionKeys.length > 0)) return [3\n              /*break*/\n              , 8];\n              _b.label = 1;\n\n            case 1:\n              _b.trys.push([1, 6, 7, 8]);\n\n              subscriptionKeys_1 = tslib.__values(subscriptionKeys), subscriptionKeys_1_1 = subscriptionKeys_1.next();\n              _b.label = 2;\n\n            case 2:\n              if (!!subscriptionKeys_1_1.done) return [3\n              /*break*/\n              , 5];\n              key = subscriptionKeys_1_1.value;\n              id = key;\n              parameters = this.subscriptions[key].parameters;\n              delete this.subscriptions[id];\n              return [4\n              /*yield*/\n              , this.subscribe(parameters)];\n\n            case 3:\n              _b.sent();\n\n              _b.label = 4;\n\n            case 4:\n              subscriptionKeys_1_1 = subscriptionKeys_1.next();\n              return [3\n              /*break*/\n              , 2];\n\n            case 5:\n              return [3\n              /*break*/\n              , 8];\n\n            case 6:\n              e_1_1 = _b.sent();\n              e_1 = {\n                error: e_1_1\n              };\n              return [3\n              /*break*/\n              , 8];\n\n            case 7:\n              try {\n                if (subscriptionKeys_1_1 && !subscriptionKeys_1_1.done && (_a = subscriptionKeys_1.return)) _a.call(subscriptionKeys_1);\n              } finally {\n                if (e_1) throw e_1.error;\n              }\n\n              return [7\n              /*endfinally*/\n              ];\n\n            case 8:\n              this.emitter.emit(exports.SocketState.SOCKET_CONNECT);\n              this.emitter.emit(exports.SocketConnect.CONNECT);\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    WebSocketProvider.prototype.onMessage = function (msg) {\n      var e_2, _a;\n\n      if (msg.data) {\n        var dataObj = JSON.parse(msg.data);\n\n        if (dataObj.type === exports.MessageType.NOTIFICATION) {\n          this.emitter.emit(exports.SocketState.SOCKET_MESSAGE, dataObj);\n\n          try {\n            for (var _b = tslib.__values(dataObj.values), _c = _b.next(); !_c.done; _c = _b.next()) {\n              var value = _c.value;\n\n              if (value.query === exports.MessageType.NEW_BLOCK) {\n                this.emitter.emit(exports.MessageType.NEW_BLOCK, value);\n              } else if (value.query === exports.MessageType.EVENT_LOG) {\n                this.emitter.emit(exports.MessageType.EVENT_LOG, value);\n              } else if (value.query === exports.MessageType.UNSUBSCRIBE) {\n                this.emitter.emit(exports.MessageType.UNSUBSCRIBE, value);\n              } else {\n                throw new Error('unsupported value type');\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        } else if (dataObj.query === exports.QueryParam.NEW_BLOCK) {\n          // subscribe NewBlock succeed\n          this.subscriptions[dataObj.query] = {\n            id: dataObj.query,\n            parameters: dataObj\n          };\n          this.emitter.emit(exports.StatusType.SUBSCRIBE_NEW_BLOCK, dataObj);\n          this.emitter.emit(exports.SocketConnect.RECONNECT);\n        } else if (dataObj.query === exports.QueryParam.EVENT_LOG) {\n          // subscribe EventLog succeed\n          this.subscriptions[dataObj.query] = {\n            id: dataObj.query,\n            parameters: dataObj\n          };\n          this.emitter.emit(exports.StatusType.SUBSCRIBE_EVENT_LOG, dataObj);\n          this.emitter.emit(exports.SocketConnect.RECONNECT);\n        } else if (dataObj.query === exports.QueryParam.UNSUBSCRIBE) {\n          this.emitter.emit(exports.MessageType.UNSUBSCRIBE, dataObj);\n        } else {\n          throw new Error('unsupported message type');\n        }\n      } else {\n        throw new Error('message data is empty');\n      }\n    };\n\n    WebSocketProvider.prototype.addEventListener = function (type, handler) {\n      this.emitter.on(type, handler);\n    };\n\n    WebSocketProvider.prototype.connecting = function () {\n      return this.websocket.readyState === this.websocket.CONNECTING;\n    };\n\n    WebSocketProvider.prototype.send = function (query) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        if (!_this.connecting()) {\n          try {\n            _this.websocket.send(JSON.stringify(query));\n          } catch (error) {\n            throw error;\n          }\n\n          var queryParam = void 0;\n\n          if (query.query === exports.QueryParam.NEW_BLOCK) {\n            queryParam = exports.StatusType.SUBSCRIBE_NEW_BLOCK;\n          } else if (query.query === exports.QueryParam.EVENT_LOG) {\n            queryParam = exports.StatusType.SUBSCRIBE_EVENT_LOG;\n          } else {\n            queryParam = query.query;\n          }\n\n          _this.emitter.on(queryParam, function (data) {\n            resolve(data);\n          });\n\n          _this.emitter.on(exports.SocketConnect.ERROR, reject);\n        }\n\n        var connectHandler = function () {\n          _this.send(query).then(resolve).catch(reject);\n        };\n\n        var offConnectHandler = function () {\n          _this.emitter.off(exports.SocketConnect.CONNECT, connectHandler);\n        };\n\n        _this.emitter.on(exports.SocketConnect.CONNECT, connectHandler);\n\n        _this.emitter.on(exports.SocketConnect.RECONNECT, offConnectHandler);\n      });\n    };\n\n    WebSocketProvider.prototype.subscribe = function (payload) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var result;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.send(payload)];\n\n            case 1:\n              result = _a.sent();\n              return [2\n              /*return*/\n              , result.query === payload.query];\n          }\n        });\n      });\n    };\n\n    WebSocketProvider.prototype.unsubscribe = function (payload) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var result, succeed;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.send(payload)];\n\n            case 1:\n              result = _a.sent();\n              succeed = result.query === payload.query;\n\n              if (succeed) {\n                this.subscriptions[payload.query] = null;\n              }\n\n              return [2\n              /*return*/\n              , succeed];\n          }\n        });\n      });\n    };\n\n    return WebSocketProvider;\n  }(); //  Copyright (C) 2018 Zilliqa\n\n\n  var Subscription =\n  /** @class */\n  function (_super) {\n    tslib.__extends(Subscription, _super);\n\n    function Subscription(subject, url, options) {\n      var _this = _super.call(this, url, options) || this;\n\n      _this.subject = subject;\n      return _this;\n    }\n\n    Subscription.prototype.start = function () {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        return tslib.__generator(this, function (_a) {\n          return [2\n          /*return*/\n          , _super.prototype.subscribe.call(this, this.subject)];\n        });\n      });\n    };\n\n    Subscription.prototype.stop = function () {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var event;\n        return tslib.__generator(this, function (_a) {\n          event = this.subject.query === exports.QueryParam.NEW_BLOCK ? {\n            query: exports.QueryParam.UNSUBSCRIBE,\n            type: exports.QueryParam.NEW_BLOCK\n          } : {\n            query: exports.QueryParam.UNSUBSCRIBE,\n            type: exports.QueryParam.EVENT_LOG\n          };\n          return [2\n          /*return*/\n          , _super.prototype.unsubscribe.call(this, event)];\n        });\n      });\n    };\n\n    return Subscription;\n  }(WebSocketProvider); //  Copyright (C) 2018 Zilliqa\n\n\n  var NewTxBlockSubscription =\n  /** @class */\n  function (_super) {\n    tslib.__extends(NewTxBlockSubscription, _super);\n\n    function NewTxBlockSubscription(url, options) {\n      return _super.call(this, {\n        query: exports.QueryParam.NEW_BLOCK\n      }, url, options) || this;\n    }\n\n    return NewTxBlockSubscription;\n  }(Subscription); //  Copyright (C) 2018 Zilliqa\n\n\n  var NewEventSubscription =\n  /** @class */\n  function (_super) {\n    tslib.__extends(NewEventSubscription, _super);\n\n    function NewEventSubscription(url, options) {\n      var _this = _super.call(this, {\n        query: exports.QueryParam.EVENT_LOG\n      }, url, options) || this;\n\n      _this.subject = {\n        query: 'EventLog',\n        addresses: options !== undefined ? options.addresses : []\n      };\n      return _this;\n    }\n\n    return NewEventSubscription;\n  }(Subscription); //  Copyright (C) 2018 Zilliqa\n\n\n  var SubscriptionBuilder =\n  /** @class */\n  function () {\n    function SubscriptionBuilder() {}\n\n    SubscriptionBuilder.prototype.buildNewBlockSubscriptions = function (url, options) {\n      return new NewTxBlockSubscription(url, options);\n    };\n\n    SubscriptionBuilder.prototype.buildEventLogSubscriptions = function (url, options) {\n      return new NewEventSubscription(url, options);\n    };\n\n    return SubscriptionBuilder;\n  }(); //  Copyright (C) 2018 Zilliqa\n\n\n  exports.NewTxBlockSubscription = NewTxBlockSubscription;\n  exports.Subscription = Subscription;\n  exports.WebSocketProvider = WebSocketProvider;\n  exports.NewEventSubscription = NewEventSubscription;\n  exports.SubscriptionBuilder = SubscriptionBuilder;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n}); //# sourceMappingURL=index.umd.js.map","map":null,"metadata":{},"sourceType":"script"}