{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('mitt')) : typeof define === 'function' && define.amd ? define(['exports', 'tslib', 'mitt'], factory) : factory(global.zjsCore = {}, global.tslib, global.mitt);\n})(this, function (exports, tslib, mitt) {\n  'use strict';\n\n  mitt = mitt && mitt.hasOwnProperty('default') ? mitt['default'] : mitt; //  Copyright (C) 2018 Zilliqa\n  //\n  //  This file is part of zilliqa-js\n  //\n  //  This program is free software: you can redistribute it and/or modify\n  //  it under the terms of the GNU General Public License as published by\n  //  the Free Software Foundation, either version 3 of the License, or\n  //  (at your option) any later version.\n  //\n  //  This program is distributed in the hope that it will be useful,\n  //  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  //  GNU General Public License for more details.\n  //\n  //  You should have received a copy of the GNU General Public License\n  //  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n  var Signer =\n  /** @class */\n  function () {\n    function Signer() {}\n\n    return Signer;\n  }();\n\n  (function (TransactionError) {\n    TransactionError[TransactionError[\"CHECKER_FAILED\"] = 0] = \"CHECKER_FAILED\";\n    TransactionError[TransactionError[\"RUNNER_FAILED\"] = 1] = \"RUNNER_FAILED\";\n    TransactionError[TransactionError[\"BALANCE_TRANSFER_FAILED\"] = 2] = \"BALANCE_TRANSFER_FAILED\";\n    TransactionError[TransactionError[\"EXECUTE_CMD_FAILED\"] = 3] = \"EXECUTE_CMD_FAILED\";\n    TransactionError[TransactionError[\"EXECUTE_CMD_TIMEOUT\"] = 4] = \"EXECUTE_CMD_TIMEOUT\";\n    TransactionError[TransactionError[\"NO_GAS_REMAINING_FOUND\"] = 5] = \"NO_GAS_REMAINING_FOUND\";\n    TransactionError[TransactionError[\"NO_ACCEPTED_FOUND\"] = 6] = \"NO_ACCEPTED_FOUND\";\n    TransactionError[TransactionError[\"CALL_CONTRACT_FAILED\"] = 7] = \"CALL_CONTRACT_FAILED\";\n    TransactionError[TransactionError[\"CREATE_CONTRACT_FAILED\"] = 8] = \"CREATE_CONTRACT_FAILED\";\n    TransactionError[TransactionError[\"JSON_OUTPUT_CORRUPTED\"] = 9] = \"JSON_OUTPUT_CORRUPTED\";\n    TransactionError[TransactionError[\"CONTRACT_NOT_EXIST\"] = 10] = \"CONTRACT_NOT_EXIST\";\n    TransactionError[TransactionError[\"STATE_CORRUPTED\"] = 11] = \"STATE_CORRUPTED\";\n    TransactionError[TransactionError[\"LOG_ENTRY_INSTALL_FAILED\"] = 12] = \"LOG_ENTRY_INSTALL_FAILED\";\n    TransactionError[TransactionError[\"MESSAGE_CORRUPTED\"] = 13] = \"MESSAGE_CORRUPTED\";\n    TransactionError[TransactionError[\"RECEIPT_IS_NULL\"] = 14] = \"RECEIPT_IS_NULL\";\n    TransactionError[TransactionError[\"MAX_DEPTH_REACHED\"] = 15] = \"MAX_DEPTH_REACHED\";\n    TransactionError[TransactionError[\"CHAIN_CALL_DIFF_SHARD\"] = 16] = \"CHAIN_CALL_DIFF_SHARD\";\n    TransactionError[TransactionError[\"PREPARATION_FAILED\"] = 17] = \"PREPARATION_FAILED\";\n    TransactionError[TransactionError[\"NO_OUTPUT\"] = 18] = \"NO_OUTPUT\";\n    TransactionError[TransactionError[\"OUTPUT_ILLEGAL\"] = 19] = \"OUTPUT_ILLEGAL\";\n  })(exports.TransactionError || (exports.TransactionError = {})); //  Copyright (C) 2018 Zilliqa\n\n  /**\r\n   * sign\r\n   *\r\n   * This decorates a method by attempting to sign the first argument of the\r\n   * intercepted method.\r\n   *\r\n   * @param {T} target\r\n   * @param {K} key\r\n   * @param {PropertyDescriptor} descriptor\r\n   * @returns {PropertyDescriptor | undefined}\r\n   */\n\n\n  var sign = function (target, key, descriptor) {\n    var original = descriptor.value;\n\n    function interceptor(arg) {\n      var args = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var signed;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!(original && arg.bytes)) return [3\n              /*break*/\n              , 2];\n              return [4\n              /*yield*/\n              , this.signer.sign(arg)];\n\n            case 1:\n              signed = _a.sent();\n              return [2\n              /*return*/\n              , original.call.apply(original, tslib.__spreadArray([this, signed], tslib.__read(args), false))];\n\n            case 2:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }\n\n    descriptor.value = interceptor;\n    return descriptor;\n  }; //  Copyright (C) 2018 Zilliqa\n\n\n  (function (self) {\n    if (self.fetch) {\n      return;\n    }\n\n    var support = {\n      searchParams: 'URLSearchParams' in self,\n      iterable: 'Symbol' in self && 'iterator' in Symbol,\n      blob: 'FileReader' in self && 'Blob' in self && function () {\n        try {\n          new Blob();\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }(),\n      formData: 'FormData' in self,\n      arrayBuffer: 'ArrayBuffer' in self\n    };\n\n    if (support.arrayBuffer) {\n      var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];\n\n      var isDataView = function (obj) {\n        return obj && DataView.prototype.isPrototypeOf(obj);\n      };\n\n      var isArrayBufferView = ArrayBuffer.isView || function (obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n      };\n    }\n\n    function normalizeName(name) {\n      if (typeof name !== 'string') {\n        name = String(name);\n      }\n\n      if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n        throw new TypeError('Invalid character in header field name');\n      }\n\n      return name.toLowerCase();\n    }\n\n    function normalizeValue(value) {\n      if (typeof value !== 'string') {\n        value = String(value);\n      }\n\n      return value;\n    } // Build a destructive iterator for the value list\n\n\n    function iteratorFor(items) {\n      var iterator = {\n        next: function () {\n          var value = items.shift();\n          return {\n            done: value === undefined,\n            value: value\n          };\n        }\n      };\n\n      if (support.iterable) {\n        iterator[Symbol.iterator] = function () {\n          return iterator;\n        };\n      }\n\n      return iterator;\n    }\n\n    function Headers(headers) {\n      this.map = {};\n\n      if (headers instanceof Headers) {\n        headers.forEach(function (value, name) {\n          this.append(name, value);\n        }, this);\n      } else if (Array.isArray(headers)) {\n        headers.forEach(function (header) {\n          this.append(header[0], header[1]);\n        }, this);\n      } else if (headers) {\n        Object.getOwnPropertyNames(headers).forEach(function (name) {\n          this.append(name, headers[name]);\n        }, this);\n      }\n    }\n\n    Headers.prototype.append = function (name, value) {\n      name = normalizeName(name);\n      value = normalizeValue(value);\n      var oldValue = this.map[name];\n      this.map[name] = oldValue ? oldValue + ',' + value : value;\n    };\n\n    Headers.prototype['delete'] = function (name) {\n      delete this.map[normalizeName(name)];\n    };\n\n    Headers.prototype.get = function (name) {\n      name = normalizeName(name);\n      return this.has(name) ? this.map[name] : null;\n    };\n\n    Headers.prototype.has = function (name) {\n      return this.map.hasOwnProperty(normalizeName(name));\n    };\n\n    Headers.prototype.set = function (name, value) {\n      this.map[normalizeName(name)] = normalizeValue(value);\n    };\n\n    Headers.prototype.forEach = function (callback, thisArg) {\n      for (var name in this.map) {\n        if (this.map.hasOwnProperty(name)) {\n          callback.call(thisArg, this.map[name], name, this);\n        }\n      }\n    };\n\n    Headers.prototype.keys = function () {\n      var items = [];\n      this.forEach(function (value, name) {\n        items.push(name);\n      });\n      return iteratorFor(items);\n    };\n\n    Headers.prototype.values = function () {\n      var items = [];\n      this.forEach(function (value) {\n        items.push(value);\n      });\n      return iteratorFor(items);\n    };\n\n    Headers.prototype.entries = function () {\n      var items = [];\n      this.forEach(function (value, name) {\n        items.push([name, value]);\n      });\n      return iteratorFor(items);\n    };\n\n    if (support.iterable) {\n      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n    }\n\n    function consumed(body) {\n      if (body.bodyUsed) {\n        return Promise.reject(new TypeError('Already read'));\n      }\n\n      body.bodyUsed = true;\n    }\n\n    function fileReaderReady(reader) {\n      return new Promise(function (resolve, reject) {\n        reader.onload = function () {\n          resolve(reader.result);\n        };\n\n        reader.onerror = function () {\n          reject(reader.error);\n        };\n      });\n    }\n\n    function readBlobAsArrayBuffer(blob) {\n      var reader = new FileReader();\n      var promise = fileReaderReady(reader);\n      reader.readAsArrayBuffer(blob);\n      return promise;\n    }\n\n    function readBlobAsText(blob) {\n      var reader = new FileReader();\n      var promise = fileReaderReady(reader);\n      reader.readAsText(blob);\n      return promise;\n    }\n\n    function readArrayBufferAsText(buf) {\n      var view = new Uint8Array(buf);\n      var chars = new Array(view.length);\n\n      for (var i = 0; i < view.length; i++) {\n        chars[i] = String.fromCharCode(view[i]);\n      }\n\n      return chars.join('');\n    }\n\n    function bufferClone(buf) {\n      if (buf.slice) {\n        return buf.slice(0);\n      } else {\n        var view = new Uint8Array(buf.byteLength);\n        view.set(new Uint8Array(buf));\n        return view.buffer;\n      }\n    }\n\n    function Body() {\n      this.bodyUsed = false;\n\n      this._initBody = function (body) {\n        this._bodyInit = body;\n\n        if (!body) {\n          this._bodyText = '';\n        } else if (typeof body === 'string') {\n          this._bodyText = body;\n        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n          this._bodyBlob = body;\n        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n          this._bodyFormData = body;\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this._bodyText = body.toString();\n        } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n          this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.\n\n          this._bodyInit = new Blob([this._bodyArrayBuffer]);\n        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n          this._bodyArrayBuffer = bufferClone(body);\n        } else {\n          throw new Error('unsupported BodyInit type');\n        }\n\n        if (!this.headers.get('content-type')) {\n          if (typeof body === 'string') {\n            this.headers.set('content-type', 'text/plain;charset=UTF-8');\n          } else if (this._bodyBlob && this._bodyBlob.type) {\n            this.headers.set('content-type', this._bodyBlob.type);\n          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n            this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n          }\n        }\n      };\n\n      if (support.blob) {\n        this.blob = function () {\n          var rejected = consumed(this);\n\n          if (rejected) {\n            return rejected;\n          }\n\n          if (this._bodyBlob) {\n            return Promise.resolve(this._bodyBlob);\n          } else if (this._bodyArrayBuffer) {\n            return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n          } else if (this._bodyFormData) {\n            throw new Error('could not read FormData body as blob');\n          } else {\n            return Promise.resolve(new Blob([this._bodyText]));\n          }\n        };\n\n        this.arrayBuffer = function () {\n          if (this._bodyArrayBuffer) {\n            return consumed(this) || Promise.resolve(this._bodyArrayBuffer);\n          } else {\n            return this.blob().then(readBlobAsArrayBuffer);\n          }\n        };\n      }\n\n      this.text = function () {\n        var rejected = consumed(this);\n\n        if (rejected) {\n          return rejected;\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob);\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text');\n        } else {\n          return Promise.resolve(this._bodyText);\n        }\n      };\n\n      if (support.formData) {\n        this.formData = function () {\n          return this.text().then(decode);\n        };\n      }\n\n      this.json = function () {\n        return this.text().then(JSON.parse);\n      };\n\n      return this;\n    } // HTTP methods whose capitalization should be normalized\n\n\n    var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n    function normalizeMethod(method) {\n      var upcased = method.toUpperCase();\n      return methods.indexOf(upcased) > -1 ? upcased : method;\n    }\n\n    function Request(input, options) {\n      options = options || {};\n      var body = options.body;\n\n      if (input instanceof Request) {\n        if (input.bodyUsed) {\n          throw new TypeError('Already read');\n        }\n\n        this.url = input.url;\n        this.credentials = input.credentials;\n\n        if (!options.headers) {\n          this.headers = new Headers(input.headers);\n        }\n\n        this.method = input.method;\n        this.mode = input.mode;\n\n        if (!body && input._bodyInit != null) {\n          body = input._bodyInit;\n          input.bodyUsed = true;\n        }\n      } else {\n        this.url = String(input);\n      }\n\n      this.credentials = options.credentials || this.credentials || 'omit';\n\n      if (options.headers || !this.headers) {\n        this.headers = new Headers(options.headers);\n      }\n\n      this.method = normalizeMethod(options.method || this.method || 'GET');\n      this.mode = options.mode || this.mode || null;\n      this.referrer = null;\n\n      if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n        throw new TypeError('Body not allowed for GET or HEAD requests');\n      }\n\n      this._initBody(body);\n    }\n\n    Request.prototype.clone = function () {\n      return new Request(this, {\n        body: this._bodyInit\n      });\n    };\n\n    function decode(body) {\n      var form = new FormData();\n      body.trim().split('&').forEach(function (bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n      return form;\n    }\n\n    function parseHeaders(rawHeaders) {\n      var headers = new Headers(); // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n      // https://tools.ietf.org/html/rfc7230#section-3.2\n\n      var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n      preProcessedHeaders.split(/\\r?\\n/).forEach(function (line) {\n        var parts = line.split(':');\n        var key = parts.shift().trim();\n\n        if (key) {\n          var value = parts.join(':').trim();\n          headers.append(key, value);\n        }\n      });\n      return headers;\n    }\n\n    Body.call(Request.prototype);\n\n    function Response(bodyInit, options) {\n      if (!options) {\n        options = {};\n      }\n\n      this.type = 'default';\n      this.status = options.status === undefined ? 200 : options.status;\n      this.ok = this.status >= 200 && this.status < 300;\n      this.statusText = 'statusText' in options ? options.statusText : 'OK';\n      this.headers = new Headers(options.headers);\n      this.url = options.url || '';\n\n      this._initBody(bodyInit);\n    }\n\n    Body.call(Response.prototype);\n\n    Response.prototype.clone = function () {\n      return new Response(this._bodyInit, {\n        status: this.status,\n        statusText: this.statusText,\n        headers: new Headers(this.headers),\n        url: this.url\n      });\n    };\n\n    Response.error = function () {\n      var response = new Response(null, {\n        status: 0,\n        statusText: ''\n      });\n      response.type = 'error';\n      return response;\n    };\n\n    var redirectStatuses = [301, 302, 303, 307, 308];\n\n    Response.redirect = function (url, status) {\n      if (redirectStatuses.indexOf(status) === -1) {\n        throw new RangeError('Invalid status code');\n      }\n\n      return new Response(null, {\n        status: status,\n        headers: {\n          location: url\n        }\n      });\n    };\n\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n\n    self.fetch = function (input, init) {\n      return new Promise(function (resolve, reject) {\n        var request = new Request(input, init);\n        var xhr = new XMLHttpRequest();\n\n        xhr.onload = function () {\n          var options = {\n            status: xhr.status,\n            statusText: xhr.statusText,\n            headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n          };\n          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n          var body = 'response' in xhr ? xhr.response : xhr.responseText;\n          resolve(new Response(body, options));\n        };\n\n        xhr.onerror = function () {\n          reject(new TypeError('Network request failed'));\n        };\n\n        xhr.ontimeout = function () {\n          reject(new TypeError('Network request failed'));\n        };\n\n        xhr.open(request.method, request.url, true);\n\n        if (request.credentials === 'include') {\n          xhr.withCredentials = true;\n        } else if (request.credentials === 'omit') {\n          xhr.withCredentials = false;\n        }\n\n        if ('responseType' in xhr && support.blob) {\n          xhr.responseType = 'blob';\n        }\n\n        request.headers.forEach(function (value, name) {\n          xhr.setRequestHeader(name, value);\n        });\n        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n      });\n    };\n\n    self.fetch.polyfill = true;\n  })(typeof self !== 'undefined' ? self : undefined);\n\n  (function (RPCMethod) {\n    // Network-related methods\n    RPCMethod[\"GetNetworkId\"] = \"GetNetworkId\"; // Blockchain-related methods\n\n    RPCMethod[\"GetBlockchainInfo\"] = \"GetBlockchainInfo\";\n    RPCMethod[\"GetShardingStructure\"] = \"GetShardingStructure\";\n    RPCMethod[\"GetDSBlock\"] = \"GetDsBlock\";\n    RPCMethod[\"GetLatestDSBlock\"] = \"GetLatestDsBlock\";\n    RPCMethod[\"GetNumDSBlocks\"] = \"GetNumDSBlocks\";\n    RPCMethod[\"GetDSBlockRate\"] = \"GetDSBlockRate\";\n    RPCMethod[\"DSBlockListing\"] = \"DSBlockListing\";\n    RPCMethod[\"GetTxBlock\"] = \"GetTxBlock\";\n    RPCMethod[\"GetLatestTxBlock\"] = \"GetLatestTxBlock\";\n    RPCMethod[\"GetNumTxBlocks\"] = \"GetNumTxBlocks\";\n    RPCMethod[\"GetTxBlockRate\"] = \"GetTxBlockRate\";\n    RPCMethod[\"TxBlockListing\"] = \"TxBlockListing\";\n    RPCMethod[\"GetNumTransactions\"] = \"GetNumTransactions\";\n    RPCMethod[\"GetTransactionRate\"] = \"GetTransactionRate\";\n    RPCMethod[\"GetCurrentMiniEpoch\"] = \"GetCurrentMiniEpoch\";\n    RPCMethod[\"GetCurrentDSEpoch\"] = \"GetCurrentDSEpoch\";\n    RPCMethod[\"GetPrevDifficulty\"] = \"GetPrevDifficulty\";\n    RPCMethod[\"GetPrevDSDifficulty\"] = \"GetPrevDSDifficulty\";\n    RPCMethod[\"GetTotalCoinSupply\"] = \"GetTotalCoinSupply\";\n    RPCMethod[\"GetMinerInfo\"] = \"GetMinerInfo\"; // Transaction-related methods\n\n    RPCMethod[\"CreateTransaction\"] = \"CreateTransaction\";\n    RPCMethod[\"GetTransaction\"] = \"GetTransaction\";\n    RPCMethod[\"GetTransactionStatus\"] = \"GetTransactionStatus\";\n    RPCMethod[\"GetRecentTransactions\"] = \"GetRecentTransactions\";\n    RPCMethod[\"GetTransactionsForTxBlock\"] = \"GetTransactionsForTxBlock\";\n    RPCMethod[\"GetTransactionsForTxBlockEx\"] = \"GetTransactionsForTxBlockEx\";\n    RPCMethod[\"GetTxnBodiesForTxBlock\"] = \"GetTxnBodiesForTxBlock\";\n    RPCMethod[\"GetTxnBodiesForTxBlockEx\"] = \"GetTxnBodiesForTxBlockEx\";\n    RPCMethod[\"GetNumTxnsTxEpoch\"] = \"GetNumTxnsTxEpoch\";\n    RPCMethod[\"GetNumTxnsDSEpoch\"] = \"GetNumTxnsDSEpoch\";\n    RPCMethod[\"GetMinimumGasPrice\"] = \"GetMinimumGasPrice\"; // Contract-related methods\n\n    RPCMethod[\"GetContractAddressFromTransactionID\"] = \"GetContractAddressFromTransactionID\";\n    RPCMethod[\"GetSmartContracts\"] = \"GetSmartContracts\";\n    RPCMethod[\"GetSmartContractCode\"] = \"GetSmartContractCode\";\n    RPCMethod[\"GetSmartContractInit\"] = \"GetSmartContractInit\";\n    RPCMethod[\"GetSmartContractState\"] = \"GetSmartContractState\";\n    RPCMethod[\"GetSmartContractSubState\"] = \"GetSmartContractSubState\";\n    RPCMethod[\"GetStateProof\"] = \"GetStateProof\"; // Account-related methods\n\n    RPCMethod[\"GetBalance\"] = \"GetBalance\";\n  })(exports.RPCMethod || (exports.RPCMethod = {}));\n\n  (function (RPCErrorCode) {\n    // Standard JSON-RPC 2.0 errors\n    // RPC_INVALID_REQUEST is internally mapped to HTTP_BAD_REQUEST (400).\n    // It should not be used for application-layer errors.\n    RPCErrorCode[RPCErrorCode[\"RPC_INVALID_REQUEST\"] = -32600] = \"RPC_INVALID_REQUEST\"; // RPC_METHOD_NOT_FOUND is internally mapped to HTTP_NOT_FOUND (404).\n    // It should not be used for application-layer errors.\n\n    RPCErrorCode[RPCErrorCode[\"RPC_METHOD_NOT_FOUND\"] = -32601] = \"RPC_METHOD_NOT_FOUND\";\n    RPCErrorCode[RPCErrorCode[\"RPC_INVALID_PARAMS\"] = -32602] = \"RPC_INVALID_PARAMS\"; // RPC_INTERNAL_ERROR should only be used for genuine errors in bitcoind\n    // (for example datadir corruption).\n\n    RPCErrorCode[RPCErrorCode[\"RPC_INTERNAL_ERROR\"] = -32603] = \"RPC_INTERNAL_ERROR\";\n    RPCErrorCode[RPCErrorCode[\"RPC_PARSE_ERROR\"] = -32700] = \"RPC_PARSE_ERROR\"; // General application defined errors\n\n    RPCErrorCode[RPCErrorCode[\"RPC_MISC_ERROR\"] = -1] = \"RPC_MISC_ERROR\";\n    RPCErrorCode[RPCErrorCode[\"RPC_TYPE_ERROR\"] = -3] = \"RPC_TYPE_ERROR\";\n    RPCErrorCode[RPCErrorCode[\"RPC_INVALID_ADDRESS_OR_KEY\"] = -5] = \"RPC_INVALID_ADDRESS_OR_KEY\";\n    RPCErrorCode[RPCErrorCode[\"RPC_INVALID_PARAMETER\"] = -8] = \"RPC_INVALID_PARAMETER\";\n    RPCErrorCode[RPCErrorCode[\"RPC_DATABASE_ERROR\"] = -20] = \"RPC_DATABASE_ERROR\";\n    RPCErrorCode[RPCErrorCode[\"RPC_DESERIALIZATION_ERROR\"] = -22] = \"RPC_DESERIALIZATION_ERROR\";\n    RPCErrorCode[RPCErrorCode[\"RPC_VERIFY_ERROR\"] = -25] = \"RPC_VERIFY_ERROR\";\n    RPCErrorCode[RPCErrorCode[\"RPC_VERIFY_REJECTED\"] = -26] = \"RPC_VERIFY_REJECTED\";\n    RPCErrorCode[RPCErrorCode[\"RPC_IN_WARMUP\"] = -28] = \"RPC_IN_WARMUP\";\n    RPCErrorCode[RPCErrorCode[\"RPC_METHOD_DEPRECATED\"] = -32] = \"RPC_METHOD_DEPRECATED\";\n  })(exports.RPCErrorCode || (exports.RPCErrorCode = {}));\n\n  var DEFAULT_HEADERS = {\n    'Content-Type': 'application/json'\n  };\n\n  var performRPC = function (request, handler) {\n    return tslib.__awaiter(void 0, void 0, void 0, function () {\n      var response, err_1;\n      return tslib.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , fetch(request.url, {\n              method: 'POST',\n              cache: 'no-cache',\n              mode: 'cors',\n              redirect: 'follow',\n              referrer: 'no-referrer',\n              body: JSON.stringify(request.payload),\n              headers: tslib.__assign(tslib.__assign({}, DEFAULT_HEADERS), request.options && request.options.headers || {})\n            })];\n\n          case 1:\n            response = _a.sent();\n            return [2\n            /*return*/\n            , response.json().then(function (body) {\n              return tslib.__assign(tslib.__assign({}, body), {\n                req: request\n              });\n            }).then(handler)];\n\n          case 2:\n            err_1 = _a.sent();\n            throw err_1;\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // identical to performRPC; difference is the response\n\n\n  var performBatchRPC = function (request, handler) {\n    return tslib.__awaiter(void 0, void 0, void 0, function () {\n      var response, err_2;\n      return tslib.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , fetch(request.url, {\n              method: 'POST',\n              cache: 'no-cache',\n              mode: 'cors',\n              redirect: 'follow',\n              referrer: 'no-referrer',\n              body: JSON.stringify(request.payload),\n              headers: tslib.__assign(tslib.__assign({}, DEFAULT_HEADERS), request.options && request.options.headers || {})\n            })];\n\n          case 1:\n            response = _a.sent();\n            return [2\n            /*return*/\n            , response.json().then(function (batch_result) {\n              return {\n                batch_result: batch_result,\n                req: request\n              };\n            }) // no handler as compared to performRPC to preserve the body array\n            // e.g. response\n\n            /*\r\n            { body:\r\n            [ { id: 1, jsonrpc: '2.0', result: [Object] },\r\n              { id: 1, jsonrpc: '2.0', result: [Object] } ],\r\n            req:\r\n            { url: 'https://dev-api.zilliqa.com',\r\n              payload: [ [Object], [Object] ] } }\r\n            */\n            .then()];\n\n          case 2:\n            err_2 = _a.sent();\n            throw err_2;\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; //  Copyright (C) 2018 Zilliqa\n  //\n  //  This file is part of zilliqa-js\n  //\n  //  This program is free software: you can redistribute it and/or modify\n  //  it under the terms of the GNU General Public License as published by\n  //  the Free Software Foundation, either version 3 of the License, or\n  //  (at your option) any later version.\n  //\n  //  This program is distributed in the hope that it will be useful,\n  //  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  //  GNU General Public License for more details.\n  //\n  //  You should have received a copy of the GNU General Public License\n  //  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\n  function isValidResponse(response) {\n    if (response.jsonrpc === '2.0' && (response.id === '1' || response.id === 1) && (response.error || response.result)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function composeMiddleware() {\n    var fns = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      fns[_i] = arguments[_i];\n    }\n\n    if (fns.length === 0) {\n      return function (arg) {\n        return arg;\n      };\n    }\n\n    if (fns.length === 1) {\n      return fns[0];\n    }\n\n    return fns.reduce(function (a, b) {\n      return function (arg) {\n        return a(b(arg));\n      };\n    });\n  } //  Copyright (C) 2018 Zilliqa\n\n\n  var MiddlewareType;\n\n  (function (MiddlewareType) {\n    MiddlewareType[MiddlewareType[\"REQ\"] = 0] = \"REQ\";\n    MiddlewareType[MiddlewareType[\"RES\"] = 1] = \"RES\";\n  })(MiddlewareType || (MiddlewareType = {}));\n\n  var BaseProvider =\n  /** @class */\n  function () {\n    function BaseProvider(nodeURL, reqMiddleware, resMiddleware) {\n      var _this = this;\n\n      if (reqMiddleware === void 0) {\n        reqMiddleware = new Map();\n      }\n\n      if (resMiddleware === void 0) {\n        resMiddleware = new Map();\n      }\n\n      this.middleware = {\n        request: {\n          use: function (fn, match) {\n            if (match === void 0) {\n              match = '*';\n            }\n\n            _this.pushMiddleware(fn, 0\n            /* REQ */\n            , match);\n          }\n        },\n        response: {\n          use: function (fn, match) {\n            if (match === void 0) {\n              match = '*';\n            }\n\n            _this.pushMiddleware(fn, 1\n            /* RES */\n            , match);\n          }\n        }\n      };\n      this.nodeURL = nodeURL;\n      this.reqMiddleware = reqMiddleware;\n      this.resMiddleware = resMiddleware;\n    }\n    /**\r\n     * pushMiddleware\r\n     *\r\n     * Adds the middleware to the appropriate middleware map.\r\n     *\r\n     * @param {ResMiddlewareFn}\r\n     * @param {T} type\r\n     * @param {Matcher} match\r\n     * @returns {void}\r\n     */\n\n\n    BaseProvider.prototype.pushMiddleware = function (fn, type, match) {\n      if (type !== 0\n      /* REQ */\n      && type !== 1\n      /* RES */\n      ) {\n        throw new Error('Please specify the type of middleware being added');\n      }\n\n      if (type === 0\n      /* REQ */\n      ) {\n        var current = this.reqMiddleware.get(match) || [];\n        this.reqMiddleware.set(match, tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(current), false), [fn], false));\n      } else {\n        var current = this.resMiddleware.get(match) || [];\n        this.resMiddleware.set(match, tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(current), false), [fn], false));\n      }\n    };\n    /**\r\n     * getMiddleware\r\n     *\r\n     * Returns the middleware that matches the matcher provided. Note that\r\n     * middleware are called in order of specificity: string -> regexp ->\r\n     * wildcard.\r\n     *\r\n     * @param {Matcher} match\r\n     * @returns {[ReqMiddlewareFn[], ResMiddlewareFn[]]}\r\n     */\n\n\n    BaseProvider.prototype.getMiddleware = function (method) {\n      var e_1, _a, e_2, _b;\n\n      var reqFns = [];\n      var resFns = [];\n\n      try {\n        for (var _c = tslib.__values(this.reqMiddleware.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var _e = tslib.__read(_d.value, 2),\n              key = _e[0],\n              transformers = _e[1];\n\n          if (typeof key === 'string' && key !== '*' && key === method) {\n            reqFns.push.apply(reqFns, tslib.__spreadArray([], tslib.__read(transformers), false));\n          }\n\n          if (key instanceof RegExp && key.test(method)) {\n            reqFns.push.apply(reqFns, tslib.__spreadArray([], tslib.__read(transformers), false));\n          }\n\n          if (key === '*') {\n            reqFns.push.apply(reqFns, tslib.__spreadArray([], tslib.__read(transformers), false));\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      try {\n        for (var _f = tslib.__values(this.resMiddleware.entries()), _g = _f.next(); !_g.done; _g = _f.next()) {\n          var _h = tslib.__read(_g.value, 2),\n              key = _h[0],\n              transformers = _h[1];\n\n          if (typeof key === 'string' && key !== '*' && key === method) {\n            resFns.push.apply(resFns, tslib.__spreadArray([], tslib.__read(transformers), false));\n          }\n\n          if (key instanceof RegExp && key.test(method)) {\n            resFns.push.apply(resFns, tslib.__spreadArray([], tslib.__read(transformers), false));\n          }\n\n          if (key === '*') {\n            resFns.push.apply(resFns, tslib.__spreadArray([], tslib.__read(transformers), false));\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      return [reqFns, resFns];\n    };\n\n    return BaseProvider;\n  }(); //  Copyright (C) 2018 Zilliqa\n\n\n  var HTTPProvider =\n  /** @class */\n  function (_super) {\n    tslib.__extends(HTTPProvider, _super);\n\n    function HTTPProvider() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    HTTPProvider.prototype.buildPayload = function (method, params) {\n      return {\n        url: this.nodeURL,\n        payload: {\n          id: 1,\n          jsonrpc: '2.0',\n          method: method,\n          params: params\n        }\n      };\n    };\n\n    HTTPProvider.prototype.buildBatchPayload = function (method, paramsList) {\n      var payloads = [];\n\n      for (var i = 0; i < paramsList.length; i++) {\n        // most of the payloads should be a single param, e.g. GetTransaction\n        // however, there are special cases e.g. GetSmartContractSubState & GetTransactionsForTxBlockEx\n        // where the param field is a list\n        var payloadParams = paramsList[i];\n        var params = void 0;\n\n        if (Array.isArray(payloadParams)) {\n          // for those param field that is already a list\n          params = payloadParams;\n        } else {\n          params = [payloadParams];\n        } // id start from index 1\n\n\n        payloads.push({\n          id: i + 1,\n          jsonrpc: '2.0',\n          method: method,\n          params: params\n        });\n      }\n\n      return {\n        url: this.nodeURL,\n        payload: payloads\n      };\n    };\n\n    HTTPProvider.prototype.send = function (method) {\n      var params = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        params[_i - 1] = arguments[_i];\n      }\n\n      var _a = tslib.__read(this.getMiddleware(method), 2),\n          tReq = _a[0],\n          tRes = _a[1];\n\n      var reqMiddleware = composeMiddleware.apply(void 0, tslib.__spreadArray([], tslib.__read(tReq), false));\n      var resMiddleware = composeMiddleware.apply(void 0, tslib.__spreadArray([], tslib.__read(tRes), false));\n      var req = reqMiddleware(this.buildPayload(method, params));\n      return performRPC(req, resMiddleware);\n    };\n\n    HTTPProvider.prototype.sendBatch = function (method, params) {\n      var _a = tslib.__read(this.getMiddleware(method), 2),\n          tReq = _a[0],\n          tRes = _a[1];\n\n      var reqMiddleware = composeMiddleware.apply(void 0, tslib.__spreadArray([], tslib.__read(tReq), false));\n      var resMiddleware = composeMiddleware.apply(void 0, tslib.__spreadArray([], tslib.__read(tRes), false));\n      var batchPayload = this.buildBatchPayload(method, params);\n      var req = reqMiddleware(batchPayload);\n      return performBatchRPC(req, resMiddleware);\n    };\n\n    HTTPProvider.prototype.subscribe = function (event, subscriber) {\n      throw new Error('HTTPProvider does not support subscriptions.');\n    };\n\n    HTTPProvider.prototype.unsubscribe = function (token) {\n      throw new Error('HTTPProvider does not support subscriptions.');\n    };\n\n    return HTTPProvider;\n  }(BaseProvider); //  Copyright (C) 2018 Zilliqa\n  //\n  //  This file is part of zilliqa-js\n  //\n  //  This program is free software: you can redistribute it and/or modify\n  //  it under the terms of the GNU General Public License as published by\n  //  the Free Software Foundation, either version 3 of the License, or\n  //  (at your option) any later version.\n  //\n  //  This program is distributed in the hope that it will be useful,\n  //  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  //  GNU General Public License for more details.\n  //\n  //  You should have received a copy of the GNU General Public License\n  //  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n  // this constant is used to indicate the number of times to poll the\n  // blockchain for a transaction confirmation. this number has been selected by\n  // using a heuristic to calculate the approximate maximum amount of time it\n  // should take for a transaction to be confirmed, even during a PoW submission\n  // round.\n\n\n  var GET_TX_ATTEMPTS = 33; //  Copyright (C) 2018 Zilliqa\n\n  var EventEmitter =\n  /** @class */\n  function () {\n    function EventEmitter() {\n      var _this = this;\n\n      this.handlers = {};\n      this.emitter = new mitt(this.handlers);\n      this.off = this.emitter.off.bind(this);\n      this.emit = this.emitter.emit.bind(this);\n      this.promise = new Promise(function (resolve, reject) {\n        _this.resolve = resolve;\n        _this.reject = reject;\n      });\n      this.then = this.promise.then.bind(this.promise);\n    }\n\n    EventEmitter.prototype.resetHandlers = function () {\n      for (var i in this.handlers) {\n        delete this.handlers[i];\n      }\n    };\n\n    EventEmitter.prototype.on = function (type, handler) {\n      this.emitter.on(type, handler);\n      return this;\n    };\n\n    EventEmitter.prototype.once = function (type, handler) {\n      var _this = this;\n\n      this.emitter.on(type, function (e) {\n        handler(e);\n\n        _this.removeEventListener(type);\n      });\n    };\n\n    EventEmitter.prototype.addEventListener = function (type, handler) {\n      this.emitter.on(type, handler);\n    };\n\n    EventEmitter.prototype.removeEventListener = function (type, handler) {\n      if (!type) {\n        this.handlers = {};\n        return;\n      }\n\n      if (!handler) {\n        delete this.handlers[type];\n      } else {\n        return this.emitter.off(type, handler);\n      }\n    };\n\n    EventEmitter.prototype.onError = function (error) {\n      this.emitter.on('error', error);\n      this.removeEventListener('*');\n    };\n\n    EventEmitter.prototype.onData = function (data) {\n      this.emitter.on('data', data);\n      this.removeEventListener('*');\n    };\n\n    EventEmitter.prototype.listenerCount = function (listenKey) {\n      var count = 0;\n      Object.keys(this.handlers).forEach(function (val) {\n        if (listenKey === val) {\n          count += 1;\n        }\n      });\n      return count;\n    };\n\n    return EventEmitter;\n  }(); //  Copyright (C) 2018 Zilliqa\n\n\n  exports.Signer = Signer;\n  exports.sign = sign;\n  exports.performRPC = performRPC;\n  exports.performBatchRPC = performBatchRPC;\n  exports.isValidResponse = isValidResponse;\n  exports.composeMiddleware = composeMiddleware;\n  exports.HTTPProvider = HTTPProvider;\n  exports.GET_TX_ATTEMPTS = GET_TX_ATTEMPTS;\n  exports.EventEmitter = EventEmitter;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n}); //# sourceMappingURL=index.umd.js.map","map":null,"metadata":{},"sourceType":"script"}