{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@zilliqa-js/core'), require('@zilliqa-js/crypto'), require('@zilliqa-js/util'), require('@zilliqa-js/account')) : typeof define === 'function' && define.amd ? define(['exports', 'tslib', '@zilliqa-js/core', '@zilliqa-js/crypto', '@zilliqa-js/util', '@zilliqa-js/account'], factory) : factory(global.zjsBlockchain = {}, global.tslib, global['@zilliqa-js/core'], global['@zilliqa-js/crypto'], global['@zilliqa-js/util'], global['@zilliqa-js/account']);\n})(this, function (exports, tslib, core, crypto, util, account) {\n  'use strict'; //  Copyright (C) 2018 Zilliqa\n\n  function toTxParams(response) {\n    var _a = response.result,\n        toAddr = _a.toAddr,\n        senderPubKey = _a.senderPubKey,\n        gasPrice = _a.gasPrice,\n        gasLimit = _a.gasLimit,\n        nonce = _a.nonce,\n        amount = _a.amount,\n        receipt = _a.receipt,\n        version = _a.version,\n        code = _a.code,\n        data = _a.data,\n        rest = tslib.__rest(_a, [\"toAddr\", \"senderPubKey\", \"gasPrice\", \"gasLimit\", \"nonce\", \"amount\", \"receipt\", \"version\", \"code\", \"data\"]);\n\n    var msg = receipt.errors ? Object.keys(receipt.errors).reduce(function (acc, depth) {\n      var _a;\n\n      var errorMsgList = receipt.errors[depth].map(function (num) {\n        return core.TransactionError[num];\n      });\n      return tslib.__assign(tslib.__assign({}, acc), (_a = {}, _a[depth] = errorMsgList, _a));\n    }, {}) : {};\n    return tslib.__assign(tslib.__assign({}, rest), {\n      version: parseInt(version, 10),\n      toAddr: crypto.toChecksumAddress(toAddr),\n      pubKey: senderPubKey.replace('0x', ''),\n      gasPrice: new util.BN(gasPrice),\n      gasLimit: util.Long.fromString(gasLimit, 10),\n      amount: new util.BN(amount),\n      nonce: parseInt(nonce, 10),\n      code: code,\n      data: data,\n      receipt: tslib.__assign(tslib.__assign({}, receipt), {\n        accepted: receipt.accepted,\n        errors: msg,\n        cumulative_gas: parseInt(receipt.cumulative_gas, 10)\n      })\n    });\n  } //  Copyright (C) 2018 Zilliqa\n\n\n  var isBlockNumber = function (blockNum) {\n    return Number.isFinite(blockNum) && Number.isInteger(blockNum) && blockNum >= 0;\n  };\n\n  var Blockchain =\n  /** @class */\n  function () {\n    function Blockchain(provider, signer) {\n      this.pendingErrorMap = {\n        0: 'Transaction not found',\n        1: 'Pending - Dispatched',\n        2: 'Pending - Soft-confirmed (awaiting Tx block generation)',\n        4: 'Pending - Nonce is higher than expected',\n        5: 'Pending - Microblock gas limit exceeded',\n        6: 'Pending - Consensus failure in network',\n        3: 'Confirmed',\n        10: 'Rejected - Transaction caused math error',\n        11: 'Rejected - Scilla invocation error',\n        12: 'Rejected - Contract account initialization error',\n        13: 'Rejected - Invalid source account',\n        14: 'Rejected - Gas limit higher than shard gas limit',\n        15: 'Rejected - Unknown transaction type',\n        16: 'Rejected - Transaction sent to wrong shard',\n        17: 'Rejected - Contract & source account cross-shard issue',\n        18: 'Rejected - Code size exceeded limit',\n        19: 'Rejected - Transaction verification failed',\n        20: 'Rejected - Gas limit too low',\n        21: 'Rejected - Insufficient balance',\n        22: 'Rejected - Insufficient gas to invoke Scilla checker',\n        23: 'Rejected - Duplicate transaction exists',\n        24: 'Rejected - Transaction with same nonce but same/higher gas price exists',\n        25: 'Rejected - Invalid destination address',\n        26: 'Rejected - Failed to add contract account to state',\n        27: 'Rejected - Nonce is lower than expected',\n        255: 'Rejected - Internal error'\n      };\n      this.transactionStatusMap = {\n        0: {\n          0: 'Transaction not found',\n          1: ' Pending - Dispatched'\n        },\n        1: {\n          2: 'Pending - Soft-confirmed (awaiting Tx block generation)',\n          4: 'Pending - Nonce is higher than expected',\n          5: 'Pending - Microblock gas limit exceeded',\n          6: 'Pending - Consensus failure in network'\n        },\n        2: {\n          3: 'Confirmed',\n          10: 'Rejected - Transaction caused math error',\n          11: 'Rejected - Scilla invocation error',\n          12: 'Rejected - Contract account initialization error',\n          13: 'Rejected - Invalid source account',\n          14: 'Rejected - Gas limit higher than shard gas limit',\n          15: 'Rejected - Unknown transaction type',\n          16: 'Rejected - Transaction sent to wrong shard',\n          17: 'Rejected - Contract & source account cross-shard issue',\n          18: 'Rejected - Code size exceeded limit',\n          19: 'Rejected - Transaction verification failed',\n          20: 'Rejected - Gas limit too low',\n          21: 'Rejected - Insufficient balance',\n          22: 'Rejected - Insufficient gas to invoke Scilla checker',\n          23: 'Rejected - Duplicate transaction exists',\n          24: 'Rejected - Transaction with higher gas price exists',\n          25: 'Rejected - Invalid destination address',\n          26: 'Rejected - Failed to add contract account to state',\n          27: 'Rejected - Nonce is lower than expected',\n          255: 'Rejected - Internal error'\n        }\n      };\n      this.provider = provider;\n      this.provider.middleware.request.use(account.util.formatOutgoingTx, core.RPCMethod.CreateTransaction);\n      this.signer = signer;\n    }\n\n    Blockchain.prototype.getBlockChainInfo = function () {\n      return this.provider.send(core.RPCMethod.GetBlockchainInfo);\n    };\n\n    Blockchain.prototype.getShardingStructure = function () {\n      return this.provider.send(core.RPCMethod.GetShardingStructure);\n    }; // Gets details of a Directory Service block by block number.\n\n\n    Blockchain.prototype.getDSBlock = function (blockNum) {\n      return this.provider.send(core.RPCMethod.GetDSBlock, blockNum.toString());\n    }; // Gets details of the most recent Directory Service block.\n\n\n    Blockchain.prototype.getLatestDSBlock = function () {\n      return this.provider.send(core.RPCMethod.GetLatestDSBlock);\n    }; // Gets the number of DS blocks that the network has processed.\n\n\n    Blockchain.prototype.getNumDSBlocks = function () {\n      return this.provider.send(core.RPCMethod.GetNumDSBlocks);\n    }; // Gets the average rate of DS blocks processed per second\n\n\n    Blockchain.prototype.getDSBlockRate = function () {\n      return this.provider.send(core.RPCMethod.GetDSBlockRate);\n    }; // Gets a paginated list of up to 10 Directory Service (DS) blocks\n    // and their block hashes for a specified page.\n\n\n    Blockchain.prototype.getDSBlockListing = function (max) {\n      return this.provider.send(core.RPCMethod.DSBlockListing, max);\n    }; // Gets details of a Transaction block by block number.\n\n\n    Blockchain.prototype.getTxBlock = function (blockNum) {\n      return this.provider.send(core.RPCMethod.GetTxBlock, blockNum.toString());\n    }; // Gets details of the most recent Transaction block.\n\n\n    Blockchain.prototype.getLatestTxBlock = function () {\n      return this.provider.send(core.RPCMethod.GetLatestTxBlock);\n    }; // Gets the total number of TxBlocks.\n\n\n    Blockchain.prototype.getNumTxBlocks = function () {\n      return this.provider.send(core.RPCMethod.GetNumTxBlocks);\n    }; // Gets the average number of Tx blocks per second.\n\n\n    Blockchain.prototype.getTxBlockRate = function () {\n      return this.provider.send(core.RPCMethod.GetTxBlockRate);\n    }; // Get a paginated list of Transaction blocks.\n\n\n    Blockchain.prototype.getTxBlockListing = function (max) {\n      return this.provider.send(core.RPCMethod.TxBlockListing, max);\n    }; // Gets the number of transactions processed by the network so far.\n\n\n    Blockchain.prototype.getNumTransactions = function () {\n      return this.provider.send(core.RPCMethod.GetNumTransactions);\n    }; // Gets the number of transactions processed per second\n\n\n    Blockchain.prototype.getTransactionRate = function () {\n      return this.provider.send(core.RPCMethod.GetTransactionRate);\n    }; // Gets the current Tx Epoch.\n\n\n    Blockchain.prototype.getCurrentMiniEpoch = function () {\n      return this.provider.send(core.RPCMethod.GetCurrentMiniEpoch);\n    }; // Gets the current DS Epoch.\n\n\n    Blockchain.prototype.getCurrentDSEpoch = function () {\n      return this.provider.send(core.RPCMethod.GetCurrentDSEpoch);\n    }; // Gets shard difficulty for previous PoW round\n\n\n    Blockchain.prototype.getPrevDifficulty = function () {\n      return this.provider.send(core.RPCMethod.GetPrevDifficulty);\n    }; // Gets DS difficulty for previous PoW round\n\n\n    Blockchain.prototype.getPrevDSDifficulty = function () {\n      return this.provider.send(core.RPCMethod.GetPrevDSDifficulty);\n    }; // Returns the total supply (ZIL) of coins in the network.\n\n\n    Blockchain.prototype.getTotalCoinSupply = function () {\n      return this.provider.send(core.RPCMethod.GetTotalCoinSupply);\n    }; // Returns the mining nodes (i.e., the members of the DS committee and shards)\n    // at the specified DS block.\n\n\n    Blockchain.prototype.getMinerInfo = function (dsBlockNumber) {\n      return this.provider.send(core.RPCMethod.GetMinerInfo, dsBlockNumber);\n    }; // Creates a transaction and polls the lookup node for a transaction receipt.\n\n\n    Blockchain.prototype.createTransaction = function (tx, maxAttempts, interval, blockConfirm) {\n      if (maxAttempts === void 0) {\n        maxAttempts = core.GET_TX_ATTEMPTS;\n      }\n\n      if (interval === void 0) {\n        interval = 1000;\n      }\n\n      if (blockConfirm === void 0) {\n        blockConfirm = false;\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response, err_1;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.CreateTransaction, tslib.__assign(tslib.__assign({}, tx.txParams), {\n                priority: tx.toDS\n              }))];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error) {\n                throw response.error;\n              }\n\n              if (blockConfirm) {\n                return [2\n                /*return*/\n                , tx.blockConfirm(response.result.TranID, maxAttempts, interval)];\n              }\n\n              return [2\n              /*return*/\n              , tx.confirm(response.result.TranID, maxAttempts, interval)];\n\n            case 2:\n              err_1 = _a.sent();\n              throw err_1;\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }; // used together with signed batch\n    // this method waits for each txn to confirm\n    // see @createBatchTransactionWithoutConfirm for transactions without confirmation\n\n\n    Blockchain.prototype.createBatchTransaction = function (signedTxList, maxAttempts, interval, blockConfirm) {\n      if (maxAttempts === void 0) {\n        maxAttempts = core.GET_TX_ATTEMPTS;\n      }\n\n      if (interval === void 0) {\n        interval = 1000;\n      }\n\n      if (blockConfirm === void 0) {\n        blockConfirm = false;\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var txParamsList, signedTxList_1, signedTxList_1_1, signedTx, response, batchResults, i, tx, txRes, _a, _b, _c, _d, err_2;\n\n        var e_1, _e;\n\n        return tslib.__generator(this, function (_f) {\n          switch (_f.label) {\n            case 0:\n              _f.trys.push([0, 8,, 9]);\n\n              txParamsList = [];\n\n              try {\n                for (signedTxList_1 = tslib.__values(signedTxList), signedTxList_1_1 = signedTxList_1.next(); !signedTxList_1_1.done; signedTxList_1_1 = signedTxList_1.next()) {\n                  signedTx = signedTxList_1_1.value;\n\n                  if (signedTx.txParams.signature === undefined) {\n                    throw new Error('The transaction is not signed.');\n                  }\n\n                  txParamsList.push(tslib.__assign(tslib.__assign({}, signedTx.txParams), {\n                    priority: signedTx.toDS\n                  }));\n                }\n              } catch (e_1_1) {\n                e_1 = {\n                  error: e_1_1\n                };\n              } finally {\n                try {\n                  if (signedTxList_1_1 && !signedTxList_1_1.done && (_e = signedTxList_1.return)) _e.call(signedTxList_1);\n                } finally {\n                  if (e_1) throw e_1.error;\n                }\n              }\n\n              return [4\n              /*yield*/\n              , this.provider.sendBatch(core.RPCMethod.CreateTransaction, txParamsList)];\n\n            case 1:\n              response = _f.sent();\n\n              if (response.error) {\n                throw response.error;\n              }\n\n              batchResults = [];\n              i = 0;\n              _f.label = 2;\n\n            case 2:\n              if (!(i < signedTxList.length)) return [3\n              /*break*/\n              , 7];\n              tx = signedTxList[i];\n              txRes = response.batch_result[i];\n              if (!blockConfirm) return [3\n              /*break*/\n              , 4];\n              _b = (_a = batchResults).push;\n              return [4\n              /*yield*/\n              , tx.blockConfirm(txRes.result.TranID, maxAttempts, interval)];\n\n            case 3:\n              _b.apply(_a, [_f.sent()]);\n\n              return [3\n              /*break*/\n              , 6];\n\n            case 4:\n              _d = (_c = batchResults).push;\n              return [4\n              /*yield*/\n              , tx.confirm(txRes.result.TranID, maxAttempts, interval)];\n\n            case 5:\n              _d.apply(_c, [_f.sent()]);\n\n              _f.label = 6;\n\n            case 6:\n              i++;\n              return [3\n              /*break*/\n              , 2];\n\n            case 7:\n              return [2\n              /*return*/\n              , batchResults];\n\n            case 8:\n              err_2 = _f.sent();\n              throw err_2;\n\n            case 9:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }; // Create a transaction by using a exist signed transaction payload\n    // This payload may come form some offline signing software like ledger\n    // Currently we haven't supported convert a singed transaction back to transaction param, so we won't perform\n    // confirm logic here.\n\n\n    Blockchain.prototype.createTransactionRaw = function (payload) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var tx, response, err_3;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              tx = JSON.parse(payload);\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.CreateTransaction, tx)];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error) {\n                throw response.error;\n              }\n\n              return [2\n              /*return*/\n              , response.result.TranID];\n\n            case 2:\n              err_3 = _a.sent();\n              throw err_3;\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    Blockchain.prototype.createTransactionWithoutConfirm = function (tx) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response, err_4;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.CreateTransaction, tslib.__assign(tslib.__assign({}, tx.txParams), {\n                priority: tx.toDS\n              }))];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error) {\n                throw response.error;\n              }\n\n              tx.id = response.result.TranID;\n              return [2\n              /*return*/\n              , tx];\n\n            case 2:\n              err_4 = _a.sent();\n              throw err_4;\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }; // used together with signed batch\n\n\n    Blockchain.prototype.createBatchTransactionWithoutConfirm = function (signedTxList) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var txParamsList, signedTxList_2, signedTxList_2_1, signedTx, response, batchResults, i, tx, txRes, err_5;\n\n        var e_2, _a;\n\n        return tslib.__generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              _b.trys.push([0, 2,, 3]);\n\n              txParamsList = [];\n\n              try {\n                for (signedTxList_2 = tslib.__values(signedTxList), signedTxList_2_1 = signedTxList_2.next(); !signedTxList_2_1.done; signedTxList_2_1 = signedTxList_2.next()) {\n                  signedTx = signedTxList_2_1.value;\n\n                  if (signedTx.txParams.signature === undefined) {\n                    throw new Error('The transaction is not signed.');\n                  }\n\n                  txParamsList.push(tslib.__assign(tslib.__assign({}, signedTx.txParams), {\n                    priority: signedTx.toDS\n                  }));\n                }\n              } catch (e_2_1) {\n                e_2 = {\n                  error: e_2_1\n                };\n              } finally {\n                try {\n                  if (signedTxList_2_1 && !signedTxList_2_1.done && (_a = signedTxList_2.return)) _a.call(signedTxList_2);\n                } finally {\n                  if (e_2) throw e_2.error;\n                }\n              }\n\n              return [4\n              /*yield*/\n              , this.provider.sendBatch(core.RPCMethod.CreateTransaction, txParamsList)];\n\n            case 1:\n              response = _b.sent();\n\n              if (response.error) {\n                throw response.error;\n              }\n\n              batchResults = [];\n\n              for (i = 0; i < signedTxList.length; i++) {\n                tx = signedTxList[i];\n                txRes = response.batch_result[i];\n                tx.id = txRes.result.TranID;\n                batchResults.push(tx);\n              }\n\n              return [2\n              /*return*/\n              , batchResults];\n\n            case 2:\n              err_5 = _b.sent();\n              throw err_5;\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }; // Returns the details of a specified Transaction.\n\n\n    Blockchain.prototype.getTransaction = function (txHash) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response, err_6;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.GetTransaction, txHash.replace('0x', ''))];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error) {\n                return [2\n                /*return*/\n                , Promise.reject(response.error)];\n              }\n\n              return [2\n              /*return*/\n              , response.result.receipt.success ? account.Transaction.confirm(toTxParams(response), this.provider) : account.Transaction.reject(toTxParams(response), this.provider)];\n\n            case 2:\n              err_6 = _a.sent();\n              throw err_6;\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }; // Returns the status of a specified transaction.\n\n\n    Blockchain.prototype.getTransactionStatus = function (txHash) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response, modificationState, status_1, err_7;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.GetTransactionStatus, txHash.replace('0x', ''))];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error) {\n                return [2\n                /*return*/\n                , Promise.reject(response.error)];\n              }\n\n              modificationState = response.result.modificationState;\n              status_1 = response.result.status;\n              response.result.statusMessage = this.transactionStatusMap[modificationState][status_1];\n              return [2\n              /*return*/\n              , response.result];\n\n            case 2:\n              err_7 = _a.sent();\n              throw err_7;\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }; // Gets a list of recent transactions\n\n\n    Blockchain.prototype.getRecentTransactions = function () {\n      return this.provider.send(core.RPCMethod.GetRecentTransactions);\n    }; // Returns the validated transactions included\n    // within a specified final transaction block as an array of\n    // length i, where i is the number of shards plus the DS committee.\n\n\n    Blockchain.prototype.getTransactionsForTxBlock = function (txBlock) {\n      return this.provider.send(core.RPCMethod.GetTransactionsForTxBlock, txBlock.toString());\n    }; // returns the transactions in batches (or pages) of 2,500.\n    // This API behaves similar to GetTransactionsForTxBlock\n\n\n    Blockchain.prototype.getTransactionsForTxBlockEx = function (txBlock) {\n      if (!isBlockNumber(txBlock)) {\n        throw new Error('invalid txBlock');\n      }\n\n      return this.provider.send(core.RPCMethod.GetTransactionsForTxBlockEx, txBlock.toString());\n    }; // Returns the validated transactions (in verbose form)\n    // included within a specified final transaction block.\n\n\n    Blockchain.prototype.getTxnBodiesForTxBlock = function (txBlock) {\n      return this.provider.send(core.RPCMethod.GetTxnBodiesForTxBlock, txBlock.toString());\n    }; // Returns the transactions in batches (or pages) of 2,500\n    // This API behaves similar to GetTxBodiesForTxBlock\n\n\n    Blockchain.prototype.getTxnBodiesForTxBlockEx = function (txBlock) {\n      if (!isBlockNumber(txBlock)) {\n        throw new Error('invalid txBlock');\n      }\n\n      return this.provider.send(core.RPCMethod.GetTxnBodiesForTxBlockEx, txBlock.toString());\n    }; // Gets the number of transactions procesed for a given Tx Epoch.\n\n\n    Blockchain.prototype.getNumTxnsTxEpoch = function (epoch) {\n      return this.provider.send(core.RPCMethod.GetNumTxnsTxEpoch, epoch);\n    }; // Gets the number of transactions procesed for a given DS Epoch.\n\n\n    Blockchain.prototype.getNumTxnsDSEpoch = function (epoch) {\n      return this.provider.send(core.RPCMethod.GetNumTxnsDSEpoch, epoch);\n    }; // Gets the numeric minimum gas price.\n\n\n    Blockchain.prototype.getMinimumGasPrice = function () {\n      return this.provider.send(core.RPCMethod.GetMinimumGasPrice);\n    }; // Gets the balance of an account by address.\n\n\n    Blockchain.prototype.getBalance = function (addr) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n      return this.provider.send(core.RPCMethod.GetBalance, address.replace('0x', '').toLowerCase());\n    }; // Returns the Scilla code associated with a smart contract address\n\n\n    Blockchain.prototype.getSmartContractCode = function (addr) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n      return this.provider.send(core.RPCMethod.GetSmartContractCode, address.replace('0x', '').toLowerCase());\n    }; // Returns the initialization (immutable) parameters of\n    // a given smart contract, represented in a JSON format.\n\n\n    Blockchain.prototype.getSmartContractInit = function (addr) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n      return this.provider.send(core.RPCMethod.GetSmartContractInit, address.replace('0x', '').toLowerCase());\n    }; // Retrieves the entire state of a smart contract.\n\n\n    Blockchain.prototype.getSmartContractState = function (addr) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n      return this.provider.send(core.RPCMethod.GetSmartContractState, address.replace('0x', '').toLowerCase());\n    }; // Queries the contract state, filtered by the variable names.\n\n\n    Blockchain.prototype.getSmartContractSubState = function (addr, variableName, indices) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n\n      if (!variableName) {\n        throw new Error('Variable name required');\n      }\n\n      return this.provider.send(core.RPCMethod.GetSmartContractSubState, address.replace('0x', '').toLowerCase(), variableName, indices === undefined ? [] : indices);\n    }; // Queries the contract state using batch rpc.\n\n\n    Blockchain.prototype.getSmartContractSubStateBatch = function (reqs) {\n      return this.provider.sendBatch(core.RPCMethod.GetSmartContractSubState, reqs);\n    };\n\n    Blockchain.prototype.getSmartContracts = function (addr) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n      return this.provider.send(core.RPCMethod.GetSmartContracts, address.replace('0x', '').toLowerCase());\n    };\n\n    Blockchain.prototype.getContractAddressFromTransactionID = function (txHash) {\n      return this.provider.send(core.RPCMethod.GetContractAddressFromTransactionID, txHash);\n    }; // Returns the state proof for the corresponding TxBlock for a smart contract.\n\n\n    Blockchain.prototype.getStateProof = function (contractAddress, sha256Hash, txBlock) {\n      var address = util.validation.isBech32(contractAddress) ? crypto.fromBech32Address(contractAddress) : contractAddress;\n      var isLatestStr = txBlock === 'latest';\n      var isValid = isLatestStr || isBlockNumber(Number(txBlock));\n\n      if (!isValid) {\n        throw new Error('invalid txBlock');\n      }\n\n      return this.provider.send(core.RPCMethod.GetStateProof, address.replace('0x', '').toLowerCase(), sha256Hash, txBlock.toString());\n    };\n\n    tslib.__decorate([core.sign, tslib.__metadata(\"design:type\", Function), tslib.__metadata(\"design:paramtypes\", [account.Transaction, Number, Number, Boolean]), tslib.__metadata(\"design:returntype\", Promise)], Blockchain.prototype, \"createTransaction\", null);\n\n    tslib.__decorate([core.sign, tslib.__metadata(\"design:type\", Function), tslib.__metadata(\"design:paramtypes\", [account.Transaction]), tslib.__metadata(\"design:returntype\", Promise)], Blockchain.prototype, \"createTransactionWithoutConfirm\", null);\n\n    return Blockchain;\n  }(); //  Copyright (C) 2018 Zilliqa\n  //\n  //  This file is part of zilliqa-js\n  //\n  //  This program is free software: you can redistribute it and/or modify\n  //  it under the terms of the GNU General Public License as published by\n  //  the Free Software Foundation, either version 3 of the License, or\n  //  (at your option) any later version.\n  //\n  //  This program is distributed in the hope that it will be useful,\n  //  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  //  GNU General Public License for more details.\n  //\n  //  You should have received a copy of the GNU General Public License\n  //  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\n  var NetworkMethods;\n\n  (function (NetworkMethods) {\n    NetworkMethods[\"GetClientVersion\"] = \"GetClientVersion\";\n    NetworkMethods[\"GetNetworkId\"] = \"GetNetworkId\";\n    NetworkMethods[\"GetProtocolVersion\"] = \"GetProtocolVersion\";\n  })(NetworkMethods || (NetworkMethods = {}));\n\n  var Network =\n  /** @class */\n  function () {\n    function Network(provider, signer) {\n      this.provider = provider;\n      this.signer = signer;\n    }\n\n    Network.prototype.getClientVersion = function () {\n      return this.provider.send(\"GetClientVersion\"\n      /* GetClientVersion */\n      );\n    };\n\n    Network.prototype.GetNetworkId = function () {\n      return this.provider.send(\"GetNetworkId\"\n      /* GetNetworkId */\n      );\n    };\n\n    Network.prototype.GetProtocolVersion = function (blockNum) {\n      return this.provider.send(\"GetProtocolVersion\"\n      /* GetProtocolVersion */\n      );\n    };\n\n    return Network;\n  }(); //  Copyright (C) 2018 Zilliqa\n\n\n  exports.Blockchain = Blockchain;\n  exports.Network = Network;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n}); //# sourceMappingURL=index.umd.js.map","map":null,"metadata":{},"sourceType":"script"}