{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@zilliqa-js/account'), require('@zilliqa-js/core'), require('@zilliqa-js/crypto'), require('@zilliqa-js/util'), require('@zilliqa-js/blockchain'), require('hash.js')) : typeof define === 'function' && define.amd ? define(['exports', 'tslib', '@zilliqa-js/account', '@zilliqa-js/core', '@zilliqa-js/crypto', '@zilliqa-js/util', '@zilliqa-js/blockchain', 'hash.js'], factory) : factory(global.zjsContract = {}, global.tslib, global['@zilliqa-js/account'], global['@zilliqa-js/core'], global['@zilliqa-js/crypto'], global['@zilliqa-js/util'], global['@zilliqa-js/blockchain'], global.hash.js);\n})(this, function (exports, tslib, account, core, crypto, util, blockchain, hash) {\n  'use strict';\n\n  hash = hash && hash.hasOwnProperty('default') ? hash['default'] : hash; //  Copyright (C) 2018 Zilliqa\n\n  (function (ContractStatus) {\n    ContractStatus[ContractStatus[\"Deployed\"] = 0] = \"Deployed\";\n    ContractStatus[ContractStatus[\"Rejected\"] = 1] = \"Rejected\";\n    ContractStatus[ContractStatus[\"Initialised\"] = 2] = \"Initialised\";\n  })(exports.ContractStatus || (exports.ContractStatus = {})); //  Copyright (C) 2018 Zilliqa\n\n\n  var NIL_ADDRESS = '0x0000000000000000000000000000000000000000';\n\n  var Contract =\n  /** @class */\n  function () {\n    function Contract(factory, code, abi, address, init, state, checkAddr) {\n      if (checkAddr === void 0) {\n        checkAddr = false;\n      }\n\n      this.factory = factory;\n      this.provider = factory.provider;\n      this.signer = factory.signer;\n      this.blockchain = new blockchain.Blockchain(factory.provider, factory.signer); // assume that we are accessing an existing contract\n\n      if (address) {\n        this.abi = abi;\n\n        if (checkAddr) {\n          this.address = crypto.normaliseAddress(address);\n        } else {\n          if (util.validation.isBech32(address)) {\n            this.address = crypto.fromBech32Address(address);\n          } else if (crypto.isValidChecksumAddress(address)) {\n            this.address = address;\n          } else {\n            this.address = crypto.toChecksumAddress(address);\n          }\n        }\n\n        this.init = init;\n        this.state = state;\n        this.status = exports.ContractStatus.Deployed;\n      } else {\n        // assume we're deploying\n        this.abi = abi;\n        this.code = code;\n        this.init = init;\n        this.status = exports.ContractStatus.Initialised;\n      }\n    }\n    /**\r\n     * isInitialised\r\n     *\r\n     * Returns true if the contract has not been deployed\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n\n    Contract.prototype.isInitialised = function () {\n      return this.status === exports.ContractStatus.Initialised;\n    };\n    /**\r\n     * isDeployed\r\n     *\r\n     * Returns true if the contract is deployed\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n\n    Contract.prototype.isDeployed = function () {\n      return this.status === exports.ContractStatus.Deployed;\n    };\n    /**\r\n     * isRejected\r\n     *\r\n     * Returns true if an attempt to deploy the contract was made, but the\r\n     * underlying transaction was unsuccessful.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n\n    Contract.prototype.isRejected = function () {\n      return this.status === exports.ContractStatus.Rejected;\n    };\n\n    Contract.prototype.prepareTx = function (tx, attempts, interval, isDeploy) {\n      if (attempts === void 0) {\n        attempts = core.GET_TX_ATTEMPTS;\n      }\n\n      if (interval === void 0) {\n        interval = 1000;\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.CreateTransaction, tslib.__assign(tslib.__assign({}, tx.txParams), {\n                priority: tx.toDS\n              }))];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error) {\n                this.address = undefined;\n                this.error = response.error;\n                return [2\n                /*return*/\n                , tx.setStatus(account.TxStatus.Rejected)];\n              }\n\n              if (isDeploy) {\n                this.address = response.result.ContractAddress ? crypto.toChecksumAddress(response.result.ContractAddress) : undefined;\n              }\n\n              return [2\n              /*return*/\n              , tx.confirm(response.result.TranID, attempts, interval)];\n          }\n        });\n      });\n    };\n\n    Contract.prototype.prepare = function (tx) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.CreateTransaction, tslib.__assign(tslib.__assign({}, tx.txParams), {\n                priority: tx.toDS\n              }))];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error || !response.result) {\n                this.address = undefined;\n                this.error = response.error;\n                tx.setStatus(account.TxStatus.Rejected);\n              } else {\n                tx.id = response.result.TranID;\n                tx.setStatus(account.TxStatus.Pending);\n                return [2\n                /*return*/\n                , response.result.ContractAddress];\n              }\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\r\n     * deploy smart contract with no confirm\r\n     * @param params\r\n     * @param toDs\r\n     */\n\n\n    Contract.prototype.deployWithoutConfirm = function (params, toDs) {\n      if (toDs === void 0) {\n        toDs = false;\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var tx, _a, err_1;\n\n        return tslib.__generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              if (!this.code || !this.init) {\n                throw new Error('Cannot deploy without code or initialisation parameters.');\n              }\n\n              tx = new account.Transaction(tslib.__assign(tslib.__assign({}, params), {\n                toAddr: NIL_ADDRESS,\n                amount: new util.BN(0),\n                code: this.code,\n                data: JSON.stringify(this.init).replace(/\\\\\"/g, '\"')\n              }), this.provider, account.TxStatus.Initialised, toDs);\n              _b.label = 1;\n\n            case 1:\n              _b.trys.push([1, 3,, 4]);\n\n              _a = this;\n              return [4\n              /*yield*/\n              , this.prepare(tx)];\n\n            case 2:\n              _a.address = _b.sent();\n              this.status = this.address === undefined ? exports.ContractStatus.Rejected : exports.ContractStatus.Initialised;\n              return [2\n              /*return*/\n              , [tx, this]];\n\n            case 3:\n              err_1 = _b.sent();\n              throw err_1;\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\r\n     * deploy\r\n     *\r\n     * @param {DeployParams} params\r\n     * @returns {Promise<Contract>}\r\n     */\n\n\n    Contract.prototype.deploy = function (params, attempts, interval, toDs) {\n      if (attempts === void 0) {\n        attempts = 33;\n      }\n\n      if (interval === void 0) {\n        interval = 1000;\n      }\n\n      if (toDs === void 0) {\n        toDs = false;\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var tx, err_2;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!this.code || !this.init) {\n                throw new Error('Cannot deploy without code or initialisation parameters.');\n              }\n\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 3,, 4]);\n\n              return [4\n              /*yield*/\n              , this.prepareTx(new account.Transaction(tslib.__assign(tslib.__assign({}, params), {\n                toAddr: NIL_ADDRESS,\n                amount: new util.BN(0),\n                code: this.code,\n                data: JSON.stringify(this.init).replace(/\\\\\"/g, '\"')\n              }), this.provider, account.TxStatus.Initialised, toDs), attempts, interval, true)];\n\n            case 2:\n              tx = _a.sent();\n\n              if (tx.isRejected()) {\n                this.status = exports.ContractStatus.Rejected;\n                this.address = undefined;\n                return [2\n                /*return*/\n                , [tx, this]];\n              }\n\n              this.status = exports.ContractStatus.Deployed;\n              this.address = this.address && crypto.isValidChecksumAddress(this.address) ? this.address : Contracts.getAddressForContract(tx);\n              return [2\n              /*return*/\n              , [tx, this]];\n\n            case 3:\n              err_2 = _a.sent();\n              throw err_2;\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    Contract.prototype.callWithoutConfirm = function (transition, args, params, toDs) {\n      if (toDs === void 0) {\n        toDs = false;\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var data, tx, err_3;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              data = {\n                _tag: transition,\n                params: args\n              };\n\n              if (this.error) {\n                return [2\n                /*return*/\n                , Promise.reject(this.error)];\n              }\n\n              if (!this.address) {\n                return [2\n                /*return*/\n                , Promise.reject('Contract has not been deployed!')];\n              }\n\n              tx = new account.Transaction(tslib.__assign(tslib.__assign({}, params), {\n                toAddr: this.address,\n                data: JSON.stringify(data)\n              }), this.provider, account.TxStatus.Initialised, toDs);\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 3,, 4]);\n\n              return [4\n              /*yield*/\n              , this.prepare(tx)];\n\n            case 2:\n              _a.sent();\n\n              return [2\n              /*return*/\n              , tx];\n\n            case 3:\n              err_3 = _a.sent();\n              throw err_3;\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\r\n     * call\r\n     *\r\n     * @param {string} transition\r\n     * @param {any} params\r\n     * @returns {Promise<Transaction>}\r\n     */\n\n\n    Contract.prototype.call = function (transition, args, params, attempts, interval, toDs) {\n      if (attempts === void 0) {\n        attempts = 33;\n      }\n\n      if (interval === void 0) {\n        interval = 1000;\n      }\n\n      if (toDs === void 0) {\n        toDs = false;\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var data, err_4;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              data = {\n                _tag: transition,\n                params: args\n              };\n\n              if (this.error) {\n                return [2\n                /*return*/\n                , Promise.reject(this.error)];\n              }\n\n              if (!this.address) {\n                return [2\n                /*return*/\n                , Promise.reject('Contract has not been deployed!')];\n              }\n\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 3,, 4]);\n\n              return [4\n              /*yield*/\n              , this.prepareTx(new account.Transaction(tslib.__assign(tslib.__assign({}, params), {\n                toAddr: this.address,\n                data: JSON.stringify(data)\n              }), this.provider, account.TxStatus.Initialised, toDs), attempts, interval, false)];\n\n            case 2:\n              return [2\n              /*return*/\n              , _a.sent()];\n\n            case 3:\n              err_4 = _a.sent();\n              throw err_4;\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    Contract.prototype.getState = function () {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (this.status !== exports.ContractStatus.Deployed) {\n                return [2\n                /*return*/\n                , Promise.resolve([])];\n              }\n\n              if (!this.address) {\n                throw new Error('Cannot get state of uninitialised contract');\n              }\n\n              return [4\n              /*yield*/\n              , this.blockchain.getSmartContractState(this.address)];\n\n            case 1:\n              response = _a.sent();\n              return [2\n              /*return*/\n              , response.result];\n          }\n        });\n      });\n    };\n\n    Contract.prototype.getSubState = function (variableName, indices) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (this.status !== exports.ContractStatus.Deployed) {\n                return [2\n                /*return*/\n                , Promise.resolve([])];\n              }\n\n              if (!this.address) {\n                throw new Error('Cannot get state of uninitialised contract');\n              }\n\n              if (!variableName) {\n                throw new Error('Variable name required');\n              }\n\n              return [4\n              /*yield*/\n              , this.blockchain.getSmartContractSubState(this.address, variableName, indices)];\n\n            case 1:\n              response = _a.sent();\n              return [2\n              /*return*/\n              , response.result];\n          }\n        });\n      });\n    };\n\n    Contract.prototype.getInit = function () {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (this.status !== exports.ContractStatus.Deployed) {\n                return [2\n                /*return*/\n                , Promise.resolve([])];\n              }\n\n              if (!this.address) {\n                throw new Error('Cannot get state of uninitialised contract');\n              }\n\n              return [4\n              /*yield*/\n              , this.blockchain.getSmartContractInit(this.address)];\n\n            case 1:\n              response = _a.sent();\n              return [2\n              /*return*/\n              , response.result];\n          }\n        });\n      });\n    };\n\n    tslib.__decorate([core.sign, tslib.__metadata(\"design:type\", Function), tslib.__metadata(\"design:paramtypes\", [account.Transaction, Number, Number, Boolean]), tslib.__metadata(\"design:returntype\", Promise)], Contract.prototype, \"prepareTx\", null);\n\n    tslib.__decorate([core.sign, tslib.__metadata(\"design:type\", Function), tslib.__metadata(\"design:paramtypes\", [account.Transaction]), tslib.__metadata(\"design:returntype\", Promise)], Contract.prototype, \"prepare\", null);\n\n    return Contract;\n  }(); //  Copyright (C) 2018 Zilliqa\n\n  /**\r\n   * Contracts\r\n   *\r\n   * Unlike most zilliqa-js modules, `Contracts` is a factory class.\r\n   * As a result, individual `Contract` instances are instead obtained by\r\n   * calling `Contracts.at` (for an already-deployed contract) and\r\n   * `Contracts.new` (to deploy a new contract).\r\n   */\n\n\n  var Contracts =\n  /** @class */\n  function () {\n    function Contracts(provider, signer) {\n      this.provider = provider;\n      this.provider.middleware.request.use(account.util.formatOutgoingTx, core.RPCMethod.CreateTransaction);\n      this.signer = signer;\n    }\n    /**\r\n     * getAddressForContract\r\n     *\r\n     * @static\r\n     * @param {Transaction} tx - transaction used to create the contract\r\n     * @returns {string} - the contract address\r\n     */\n\n\n    Contracts.getAddressForContract = function (tx) {\n      // always subtract 1 from the tx nonce, as contract addresses are computed\n      // based on the nonce in the global state.\n      var nonce = tx.txParams.nonce ? tx.txParams.nonce - 1 : 0;\n      return crypto.toChecksumAddress(hash.sha256().update(tx.senderAddress.replace('0x', '').toLowerCase(), 'hex').update(util.bytes.intToHexArray(nonce, 16).join(''), 'hex').digest('hex').slice(24));\n    };\n\n    Contracts.prototype.at = function (address, abi, code, init, state) {\n      return new Contract(this, code, abi, address, init, state);\n    };\n\n    Contracts.prototype.atBech32 = function (address, abi, code, init, state) {\n      return new Contract(this, code, abi, address, init, state, true);\n    };\n\n    Contracts.prototype.new = function (code, init, abi) {\n      return new Contract(this, code, abi, undefined, init);\n    };\n\n    return Contracts;\n  }(); //  Copyright (C) 2018 Zilliqa\n\n\n  exports.Contracts = Contracts;\n  exports.Contract = Contract;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n}); //# sourceMappingURL=index.umd.js.map","map":null,"metadata":{},"sourceType":"script"}