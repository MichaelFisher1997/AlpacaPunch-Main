{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('sodium-randbytes'), require('elliptic'), require('hash.js'), require('hmac-drbg'), require('@zilliqa-js/util'), require('tslib'), require('aes-js'), require('pbkdf2'), require('scrypt-js'), require('uuid')) : typeof define === 'function' && define.amd ? define(['exports', 'sodium-randbytes', 'elliptic', 'hash.js', 'hmac-drbg', '@zilliqa-js/util', 'tslib', 'aes-js', 'pbkdf2', 'scrypt-js', 'uuid'], factory) : factory(global.zjsCrypto = {}, global['sodium-randbytes'], global.elliptic, global.hash.js, global['hmac-drbg'], global['@zilliqa-js/util'], global.tslib, global['aes-js'], global.pbkdf2, global['scrypt-js'], global.uuid);\n})(this, function (exports, randbytes, elliptic, hashjs, DRBG, util, tslib, aes, pbkdf2, scrypt, uuid) {\n  'use strict';\n\n  randbytes = randbytes && randbytes.hasOwnProperty('default') ? randbytes['default'] : randbytes;\n  var elliptic__default = 'default' in elliptic ? elliptic['default'] : elliptic;\n  hashjs = hashjs && hashjs.hasOwnProperty('default') ? hashjs['default'] : hashjs;\n  DRBG = DRBG && DRBG.hasOwnProperty('default') ? DRBG['default'] : DRBG;\n  aes = aes && aes.hasOwnProperty('default') ? aes['default'] : aes;\n  scrypt = scrypt && scrypt.hasOwnProperty('default') ? scrypt['default'] : scrypt; //  Copyright (C) 2018 Zilliqa\n\n  var randomBytes = function (bytes) {\n    // For node enviroment, use sodium-native because we prefer kernel CSPRNG.\n    // References:\n    // - https://paragonie.com/blog/2016/05/how-generate-secure-random-numbers-in-various-programming-languages#nodejs-csprng\n    // - https://github.com/nodejs/node/issues/5798\n    var b = randbytes(bytes);\n    return b.toString('hex');\n  }; //  Copyright (C) 2018 Zilliqa\n\n\n  var secp256k1 = new elliptic.ec('secp256k1');\n  var curve = secp256k1.curve;\n  var PRIVKEY_SIZE_BYTES = 32; // Public key is a point (x, y) on the curve.\n  // Each coordinate requires 32 bytes.\n  // In its compressed form it suffices to store the x co-ordinate\n  // and the sign for y.\n  // Hence a total of 33 bytes.\n\n  var PUBKEY_COMPRESSED_SIZE_BYTES = 33; // Personalization string used for HMAC-DRBG instantiation.\n\n  var ALG = Buffer.from('Schnorr+SHA256  ', 'ascii'); // The length in bytes of the string above.\n\n  var ALG_LEN = 16; // The length in bytes of entropy inputs to HMAC-DRBG\n\n  var ENT_LEN = 32;\n  var HEX_ENC = 'hex';\n  /**\r\n   * generatePrivateKey\r\n   *\r\n   * @returns {string} - the hex-encoded private key\r\n   */\n\n  var generatePrivateKey$$1 = function () {\n    return secp256k1.genKeyPair({\n      entropy: randomBytes(secp256k1.curve.n.byteLength()),\n      entropyEnc: HEX_ENC,\n      pers: 'zilliqajs+secp256k1+SHA256'\n    }).getPrivate().toString(16, PRIVKEY_SIZE_BYTES * 2);\n  };\n  /**\r\n   * Hash (r | M).\r\n   * @param {Buffer} msg\r\n   * @param {BN} r\r\n   *\r\n   * @returns {Buffer}\r\n   */\n\n\n  var hash$$1 = function (q, pubkey, msg) {\n    var sha256 = hashjs.sha256();\n    var totalLength = PUBKEY_COMPRESSED_SIZE_BYTES * 2 + msg.byteLength; // 33 q + 33 pubkey + variable msgLen\n\n    var Q = q.toArrayLike(Buffer, 'be', 33);\n    var B = Buffer.allocUnsafe(totalLength);\n    Q.copy(B, 0);\n    pubkey.copy(B, 33);\n    msg.copy(B, 66);\n    return new util.BN(sha256.update(B).digest('hex'), 16);\n  };\n  /**\r\n   * sign\r\n   *\r\n   * @param {Buffer} msg\r\n   * @param {Buffer} key\r\n   * @param {Buffer} pubkey\r\n   *\r\n   * @returns {Signature}\r\n   */\n\n\n  var sign$$1 = function (msg, privKey, pubKey) {\n    var prv = new util.BN(privKey);\n    var drbg = getDRBG(msg);\n    var len = curve.n.byteLength();\n    var sig;\n\n    while (!sig) {\n      var k = new util.BN(drbg.generate(len));\n      sig = trySign$$1(msg, k, prv, pubKey);\n    }\n\n    return sig;\n  };\n  /**\r\n   * trySign\r\n   *\r\n   * @param {Buffer} msg - the message to sign over\r\n   * @param {BN} k - output of the HMAC-DRBG\r\n   * @param {BN} privateKey - the private key\r\n   * @param {Buffer} pubKey - the public key\r\n   *\r\n   * @returns {Signature | null =>}\r\n   */\n\n\n  var trySign$$1 = function (msg, k, privKey, pubKey) {\n    if (privKey.isZero()) {\n      throw new Error('Bad private key.');\n    }\n\n    if (privKey.gte(curve.n)) {\n      throw new Error('Bad private key.');\n    } // 1a. check that k is not 0\n\n\n    if (k.isZero()) {\n      return null;\n    } // 1b. check that k is < the order of the group\n\n\n    if (k.gte(curve.n)) {\n      return null;\n    } // 2. Compute commitment Q = kG, where g is the base point\n\n\n    var Q = curve.g.mul(k); // convert the commitment to octets first\n\n    var compressedQ = new util.BN(Q.encodeCompressed()); // 3. Compute the challenge r = H(Q || pubKey || msg)\n    // mod reduce the r value by the order of secp256k1, n\n\n    var r = hash$$1(compressedQ, pubKey, msg).umod(curve.n);\n    var h = r.clone();\n\n    if (h.isZero()) {\n      return null;\n    } // 4. Compute s = k - r * prv\n    // 4a. Compute r * prv\n\n\n    var s = h.imul(privKey).umod(curve.n); // 4b. Compute s = k - r * prv mod n\n\n    s = k.isub(s).umod(curve.n);\n\n    if (s.isZero()) {\n      return null;\n    }\n\n    return new Signature({\n      r: r,\n      s: s\n    });\n  };\n  /**\r\n   * Verify signature.\r\n   *\r\n   * @param {Buffer} msg\r\n   * @param {Buffer} signature\r\n   * @param {Buffer} key\r\n   *\r\n   * @returns {boolean}\r\n   *\r\n   * 1. Check if r,s is in [1, ..., order-1]\r\n   * 2. Compute Q = sG + r*kpub\r\n   * 3. If Q = O (the neutral point), return 0;\r\n   * 4. r' = H(Q, kpub, m)\r\n   * 5. return r' == r\r\n   */\n\n\n  var verify$$1 = function (msg, signature, key) {\n    var sig = new Signature(signature);\n\n    if (sig.s.isZero() || sig.r.isZero()) {\n      throw new Error('Invalid signature');\n    }\n\n    if (sig.s.isNeg() || sig.r.isNeg()) {\n      throw new Error('Invalid signature');\n    }\n\n    if (sig.s.gte(curve.n) || sig.r.gte(curve.n)) {\n      throw new Error('Invalid signature');\n    }\n\n    var kpub = curve.decodePoint(key);\n\n    if (!curve.validate(kpub)) {\n      throw new Error('Invalid public key');\n    }\n\n    var l = kpub.mul(sig.r);\n    var r = curve.g.mul(sig.s);\n    var Q = l.add(r);\n\n    if (Q.isInfinity()) {\n      throw new Error('Invalid intermediate point.');\n    }\n\n    var compressedQ = new util.BN(Q.encodeCompressed());\n    var r1 = hash$$1(compressedQ, key, msg).umod(curve.n);\n\n    if (r1.isZero()) {\n      throw new Error('Invalid hash.');\n    }\n\n    return r1.eq(sig.r);\n  };\n\n  var toSignature$$1 = function (serialised) {\n    var r = serialised.slice(0, 64);\n    var s = serialised.slice(64);\n    return new Signature({\n      r: r,\n      s: s\n    });\n  };\n  /**\r\n   * Instantiate an HMAC-DRBG.\r\n   *\r\n   * @param {Buffer} msg - used as nonce\r\n   *\r\n   * @returns {DRBG}\r\n   */\n\n\n  var getDRBG = function (msg) {\n    var entropy = randomBytes(ENT_LEN);\n    var pers = Buffer.allocUnsafe(ALG_LEN + ENT_LEN);\n    Buffer.from(randomBytes(ENT_LEN)).copy(pers, 0);\n    ALG.copy(pers, ENT_LEN);\n    return new DRBG({\n      hash: hashjs.sha256,\n      entropy: entropy,\n      nonce: msg,\n      pers: pers\n    });\n  };\n\n  var schnorr = /*#__PURE__*/Object.freeze({\n    generatePrivateKey: generatePrivateKey$$1,\n    hash: hash$$1,\n    sign: sign$$1,\n    trySign: trySign$$1,\n    verify: verify$$1,\n    toSignature: toSignature$$1\n  }); //  Copyright (C) 2018 Zilliqa\n  // This replaces `elliptic/lib/elliptic/ec/signature`.\n  // Q. Why do we replace `elliptic/lib/elliptic/ec/signature` with this?\n  // A. At the moment, Signature() in 'elliptic' is not exposed.\n\n  var Signature =\n  /** @class */\n  function () {\n    function Signature(options) {\n      var isValid = options.r && options.s;\n\n      if (!isValid) {\n        throw new Error('Signature without r or s');\n      }\n\n      this.r = new util.BN(options.r, 16);\n      this.s = new util.BN(options.s, 16);\n    }\n\n    return Signature;\n  }(); //  Copyright (C) 2018 Zilliqa\n  // This code is taken from https://github.com/sipa/bech32/tree/bdc264f84014c234e908d72026b7b780122be11f/ref/javascript\n  // Copyright (c) 2017 Pieter Wuille\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a copy\n  // of this software and associated documentation files (the \"Software\"), to deal\n  // in the Software without restriction, including without limitation the rights\n  // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  // copies of the Software, and to permit persons to whom the Software is\n  // furnished to do so, subject to the following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included in\n  // all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  // THE SOFTWARE.\n\n\n  var CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\n  var GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n\n  var polymod = function (values) {\n    var chk = 1;\n\n    for (var p = 0; p < values.length; ++p) {\n      var top_1 = chk >> 25;\n      chk = (chk & 0x1ffffff) << 5 ^ values[p];\n\n      for (var i = 0; i < 5; ++i) {\n        if (top_1 >> i & 1) {\n          chk ^= GENERATOR[i];\n        }\n      }\n    }\n\n    return chk;\n  };\n\n  var hrpExpand = function (hrp) {\n    var ret = [];\n    var p;\n\n    for (p = 0; p < hrp.length; ++p) {\n      ret.push(hrp.charCodeAt(p) >> 5);\n    }\n\n    ret.push(0);\n\n    for (p = 0; p < hrp.length; ++p) {\n      ret.push(hrp.charCodeAt(p) & 31);\n    }\n\n    return Buffer.from(ret);\n  };\n\n  function verifyChecksum(hrp, data) {\n    return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;\n  }\n\n  function createChecksum(hrp, data) {\n    var values = Buffer.concat([Buffer.from(hrpExpand(hrp)), data, Buffer.from([0, 0, 0, 0, 0, 0])]); // var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n\n    var mod = polymod(values) ^ 1;\n    var ret = [];\n\n    for (var p = 0; p < 6; ++p) {\n      ret.push(mod >> 5 * (5 - p) & 31);\n    }\n\n    return Buffer.from(ret);\n  }\n\n  var encode = function (hrp, data) {\n    var combined = Buffer.concat([data, createChecksum(hrp, data)]);\n    var ret = hrp + '1';\n\n    for (var p = 0; p < combined.length; ++p) {\n      ret += CHARSET.charAt(combined[p]);\n    }\n\n    return ret;\n  };\n\n  var decode = function (bechString) {\n    var p;\n    var hasLower = false;\n    var hasUpper = false;\n\n    for (p = 0; p < bechString.length; ++p) {\n      if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {\n        return null;\n      }\n\n      if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {\n        hasLower = true;\n      }\n\n      if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {\n        hasUpper = true;\n      }\n    }\n\n    if (hasLower && hasUpper) {\n      return null;\n    }\n\n    bechString = bechString.toLowerCase();\n    var pos = bechString.lastIndexOf('1');\n\n    if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {\n      return null;\n    }\n\n    var hrp = bechString.substring(0, pos);\n    var data = [];\n\n    for (p = pos + 1; p < bechString.length; ++p) {\n      var d = CHARSET.indexOf(bechString.charAt(p));\n\n      if (d === -1) {\n        return null;\n      }\n\n      data.push(d);\n    }\n\n    if (!verifyChecksum(hrp, Buffer.from(data))) {\n      return null;\n    }\n\n    return {\n      hrp: hrp,\n      data: Buffer.from(data.slice(0, data.length - 6))\n    };\n  }; // HRP is the human-readable part of zilliqa bech32 addresses\n\n\n  var HRP = 'zil';\n  /**\r\n   * convertBits\r\n   *\r\n   * groups buffers of a certain width to buffers of the desired width.\r\n   *\r\n   * For example, converts byte buffers to buffers of maximum 5 bit numbers,\r\n   * padding those numbers as necessary. Necessary for encoding Ethereum-style\r\n   * addresses as bech32 ones.\r\n   *\r\n   * @param {Buffer} data\r\n   * @param {number} fromWidth\r\n   * @param {number} toWidth\r\n   * @param {boolean} pad\r\n   * @returns {Buffer|null}\r\n   */\n\n  var convertBits = function (data, fromWidth, toWidth, pad) {\n    if (pad === void 0) {\n      pad = true;\n    }\n\n    var acc = 0;\n    var bits = 0;\n    var ret = [];\n    var maxv = (1 << toWidth) - 1;\n\n    for (var p = 0; p < data.length; ++p) {\n      var value = data[p];\n\n      if (value < 0 || value >> fromWidth !== 0) {\n        return null;\n      }\n\n      acc = acc << fromWidth | value;\n      bits += fromWidth;\n\n      while (bits >= toWidth) {\n        bits -= toWidth;\n        ret.push(acc >> bits & maxv);\n      }\n    }\n\n    if (pad) {\n      if (bits > 0) {\n        ret.push(acc << toWidth - bits & maxv);\n      }\n    } else if (bits >= fromWidth || acc << toWidth - bits & maxv) {\n      return null;\n    }\n\n    return Buffer.from(ret);\n  };\n  /**\r\n   * toBech32Address\r\n   *\r\n   * Encodes a canonical 20-byte Ethereum-style address as a bech32 zilliqa\r\n   * address.\r\n   *\r\n   * The expected format is zil1<address><checksum> where address and checksum\r\n   * are the result of bech32 encoding a Buffer containing the address bytes.\r\n   *\r\n   * @param {string} 20 byte canonical address\r\n   * @returns {string} 38 char bech32 encoded zilliqa address\r\n   */\n\n\n  var toBech32Address = function (address) {\n    if (!util.validation.isAddress(address)) {\n      throw new Error('Invalid address format.');\n    }\n\n    var addrBz = convertBits(Buffer.from(address.replace('0x', ''), 'hex'), 8, 5);\n\n    if (addrBz === null) {\n      throw new Error('Could not convert byte Buffer to 5-bit Buffer');\n    }\n\n    return encode(HRP, addrBz);\n  };\n  /**\r\n   * fromBech32Address\r\n   *\r\n   * @param {string} address - a valid Zilliqa bech32 address\r\n   * @returns {string} a canonical 20-byte Ethereum-style address\r\n   */\n\n\n  var fromBech32Address = function (address) {\n    var res = decode(address);\n\n    if (res === null) {\n      throw new Error('Invalid bech32 address');\n    }\n\n    var hrp = res.hrp,\n        data = res.data;\n    var shouldBe = HRP;\n\n    if (hrp !== shouldBe) {\n      throw new Error(\"Expected hrp to be \" + shouldBe + \" but got \" + hrp);\n    }\n\n    var buf = convertBits(data, 5, 8, false);\n\n    if (buf === null) {\n      throw new Error('Could not convert buffer to bytes');\n    }\n\n    return toChecksumAddress(buf.toString('hex'));\n  }; //  Copyright (C) 2018 Zilliqa\n\n\n  var secp256k1$1 = new elliptic__default.ec('secp256k1');\n  /**\r\n   * getAddressFromPrivateKey\r\n   *\r\n   * takes a hex-encoded string (private key) and returns its corresponding\r\n   * 20-byte hex-encoded address.\r\n   *\r\n   * @param {string} privateKey\r\n   * @returns {string}\r\n   */\n\n  var getAddressFromPrivateKey = function (privateKey) {\n    var normalizedPrviateKey = normalizePrivateKey(privateKey);\n    var keyPair = secp256k1$1.keyFromPrivate(normalizedPrviateKey, 'hex');\n    var pub = keyPair.getPublic(true, 'hex');\n    return toChecksumAddress(hashjs.sha256().update(pub, 'hex').digest('hex').slice(24));\n  };\n  /**\r\n   * getPubKeyFromPrivateKey\r\n   *\r\n   * takes a hex-encoded string (private key) and returns its corresponding\r\n   * hex-encoded 33-byte public key.\r\n   *\r\n   * @param {string} privateKey\r\n   * @returns {string}\r\n   */\n\n\n  var getPubKeyFromPrivateKey = function (privateKey) {\n    var normalizedPrviateKey = normalizePrivateKey(privateKey);\n    var keyPair = secp256k1$1.keyFromPrivate(normalizedPrviateKey, 'hex');\n    return keyPair.getPublic(true, 'hex');\n  };\n  /**\r\n   * getAccountFrom0xPrivateKey\r\n   *\r\n   * Utility method for recovering account from 0x private key.\r\n   * See https://github.com/Zilliqa/zilliqa-js/pull/159\r\n   * @param privateKeyWith0x : private key with 0x prefix\r\n   */\n\n\n  var getAccountFrom0xPrivateKey = function (privateKeyWith0x) {\n    var privateKeyWithout0x = normalizePrivateKey(privateKeyWith0x);\n    var keyPair = secp256k1$1.keyFromPrivate(privateKeyWith0x, 'hex');\n    var publicKeyWith0x = keyPair.getPublic(true, 'hex');\n    var addressWith0x = getAddressFromPublicKey(publicKeyWith0x);\n    var bech32With0x = toBech32Address(addressWith0x);\n    var with0x = {\n      prv: privateKeyWith0x,\n      pub: publicKeyWith0x,\n      addr: addressWith0x,\n      bech32: bech32With0x\n    };\n    var keyPair2 = secp256k1$1.keyFromPrivate(privateKeyWithout0x, 'hex');\n    var publicKeyWithout0x = keyPair2.getPublic(true, 'hex');\n    var addressWithout0x = getAddressFromPublicKey(publicKeyWithout0x);\n    var bech32Without0x = toBech32Address(addressWithout0x);\n    var without0x = {\n      prv: privateKeyWithout0x,\n      pub: publicKeyWithout0x,\n      addr: addressWithout0x,\n      bech32: bech32Without0x\n    };\n    var privateKeyAfterChange = keyPair.getPrivate('hex');\n    var publicKeyAfterChange = keyPair.getPublic(true, 'hex');\n    var addressAfterChange = getAddressFromPublicKey(publicKeyAfterChange);\n    var bech32AfterChange = toBech32Address(addressAfterChange);\n    var changed = {\n      prv: privateKeyAfterChange,\n      pub: publicKeyAfterChange,\n      addr: addressAfterChange,\n      bech32: bech32AfterChange\n    };\n    return {\n      with0x: with0x,\n      without0x: without0x,\n      changed: changed\n    };\n  };\n  /**\r\n   * compressPublicKey\r\n   *\r\n   * @param {string} publicKey - 65-byte public key, a point (x, y)\r\n   *\r\n   * @returns {string}\r\n   */\n\n\n  var compressPublicKey = function (publicKey) {\n    return secp256k1$1.keyFromPublic(publicKey, 'hex').getPublic(true, 'hex');\n  };\n  /**\r\n   * getAddressFromPublicKey\r\n   *\r\n   * takes hex-encoded string and returns the corresponding address\r\n   *\r\n   * @param {string} pubKey\r\n   * @returns {string}\r\n   */\n\n\n  var getAddressFromPublicKey = function (publicKey) {\n    var normalized = publicKey.toLowerCase().replace('0x', '');\n    return toChecksumAddress(hashjs.sha256().update(normalized, 'hex').digest('hex').slice(24));\n  };\n  /**\r\n   * toChecksumAddress\r\n   *\r\n   * takes hex-encoded string and returns the corresponding address\r\n   *\r\n   * @param {string} address\r\n   * @returns {string}\r\n   */\n\n\n  var toChecksumAddress = function (address) {\n    if (!util.validation.isAddress(address)) {\n      throw new Error(address + \" is not a valid base 16 address\");\n    }\n\n    address = address.toLowerCase().replace('0x', '');\n    var hash = hashjs.sha256().update(address, 'hex').digest('hex');\n    var v = new util.BN(hash, 'hex', 'be');\n    var ret = '0x';\n\n    for (var i = 0; i < address.length; i++) {\n      if ('0123456789'.indexOf(address[i]) !== -1) {\n        ret += address[i];\n      } else {\n        ret += v.and(new util.BN(2).pow(new util.BN(255 - 6 * i))).gte(new util.BN(1)) ? address[i].toUpperCase() : address[i].toLowerCase();\n      }\n    }\n\n    return ret;\n  };\n  /**\r\n   * isValidChecksumAddress\r\n   *\r\n   * takes hex-encoded string and returns boolean if address is checksumed\r\n   *\r\n   * @param {string} address\r\n   * @returns {boolean}\r\n   */\n\n\n  var isValidChecksumAddress = function (address) {\n    return util.validation.isAddress(address.replace('0x', '')) && toChecksumAddress(address) === address;\n  };\n  /**\r\n   * normaliseAddress\r\n   *\r\n   * takes in a base16 address or a zilliqa bech32 encoded address\r\n   * and returns a checksum base16 address. If the address is neither a base16\r\n   * nor bech32 address, the code will return an error\r\n   * @param {string)} address\r\n   * @returns {string}\r\n   */\n\n\n  var normaliseAddress = function (address) {\n    if (util.validation.isBech32(address)) {\n      return fromBech32Address(address);\n    }\n\n    if (!isValidChecksumAddress(address)) {\n      throw Error('Wrong address format, should be either bech32 or checksummed address');\n    }\n\n    return address;\n  };\n  /**\r\n   * encodeBase58 - may be required for DID public key\r\n   * undeprecating this function after version 2.0.0\r\n   *\r\n   * @param {string} hex - base 16 encoded string\r\n   * @returns {string} - big endian base 58 encoded string\r\n   */\n\n\n  var encodeBase58 = function (hex) {\n    var clean = hex.toLowerCase().replace('0x', '');\n    var tbl = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n    var base = new util.BN(58);\n    var zero = new util.BN(0);\n    var x = new util.BN(clean, 16);\n    var res = '';\n\n    while (x.gt(zero)) {\n      var rem = x.mod(base).toNumber(); // safe, always < 58\n      // big endian\n\n      res = tbl[rem] + res; // quotient, remainders thrown away in integer division\n\n      x = x.div(base);\n    } // convert to big endian in case the input hex is little endian\n\n\n    var hexBE = x.toString('hex', clean.length);\n\n    for (var i = 0; i < hexBE.length; i += 2) {\n      if (hex[i] === '0' && hex[i + 1] === '0') {\n        res = tbl[0] + res;\n      } else {\n        break;\n      }\n    }\n\n    return res;\n  };\n  /**\r\n   * decodeBase58 - may be required for DID public key\r\n   * undeprecating this function after version 2.0.0\r\n   *\r\n   * @param {string} raw - base 58 string\r\n   * @returns {string} - big endian base 16 string\r\n   */\n\n\n  var decodeBase58 = function (raw) {\n    var tbl = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n    var base = new util.BN(58);\n    var zero = new util.BN(0);\n    var isBreak = false;\n    var n = new util.BN(0);\n    var leader = '';\n\n    for (var i = 0; i < raw.length; i++) {\n      var char = raw.charAt(i);\n      var weight = new util.BN(tbl.indexOf(char));\n      n = n.mul(base).add(weight); // check if padding required\n\n      if (!isBreak) {\n        if (i - 1 > 0 && raw[i - 1] !== '1') {\n          isBreak = true;\n          continue;\n        }\n\n        if (char === '1') {\n          leader += '00';\n        }\n      }\n    }\n\n    if (n.eq(zero)) {\n      return leader;\n    }\n\n    var res = leader + n.toString('hex');\n\n    if (res.length % 2 !== 0) {\n      res = '0' + res;\n    }\n\n    return res;\n  };\n  /**\r\n   * verifyPrivateKey\r\n   *\r\n   * @param {string|Buffer} privateKey\r\n   * @returns {boolean}\r\n   */\n\n\n  var verifyPrivateKey = function (privateKey) {\n    var keyPair = secp256k1$1.keyFromPrivate(privateKey, 'hex');\n    var result = keyPair.validate().result;\n    return result;\n  };\n  /**\r\n   * normalizePrivateKey : normalise private key from 0x or without 0x prefix\r\n   *\r\n   * @param {string} privateKey\r\n   * @returns {string}\r\n   */\n\n\n  var normalizePrivateKey = function (privateKey) {\n    try {\n      if (!util.validation.isPrivateKey(privateKey)) {\n        throw new Error('Private key is not correct');\n      }\n\n      var normalized = privateKey.toLowerCase().replace('0x', '');\n\n      if (!verifyPrivateKey(normalized)) {\n        throw new Error('Private key is not correct');\n      }\n\n      return normalized;\n    } catch (error) {\n      throw error;\n    }\n  }; //  Copyright (C) 2018 Zilliqa\n\n\n  var ALGO_IDENTIFIER = 'aes-128-ctr';\n  /**\r\n   * getDerivedKey\r\n   *\r\n   * NOTE: only scrypt and pbkdf2 are supported.\r\n   *\r\n   * @param {Buffer} key - the passphrase\r\n   * @param {KDF} kdf - the key derivation function to be used\r\n   * @param {KDFParams} params - params for the kdf\r\n   *\r\n   * @returns {Promise<Buffer>}\r\n   */\n\n  function getDerivedKey(key, kdf, params) {\n    return tslib.__awaiter(this, void 0, void 0, function () {\n      var salt, _a, c, dklen, _b, n, r, p, dklen, derivedKeyInt8Array;\n\n      return tslib.__generator(this, function (_c) {\n        salt = Buffer.from(params.salt, 'hex');\n\n        if (kdf === 'pbkdf2') {\n          _a = params, c = _a.c, dklen = _a.dklen;\n          return [2\n          /*return*/\n          , pbkdf2.pbkdf2Sync(key, salt, c, dklen, 'sha256')];\n        }\n\n        if (kdf === 'scrypt') {\n          _b = params, n = _b.n, r = _b.r, p = _b.p, dklen = _b.dklen;\n          derivedKeyInt8Array = scrypt.syncScrypt(key, salt, n, r, p, dklen);\n          return [2\n          /*return*/\n          , Buffer.from(derivedKeyInt8Array)];\n        }\n\n        throw new Error('Only pbkdf2 and scrypt are supported');\n      });\n    });\n  }\n  /**\r\n   * encryptPrivateKey\r\n   *\r\n   * Encodes and encrypts an account in the format specified by\r\n   * https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition.\r\n   * However, note that, in keeping with the hash function used by Zilliqa's\r\n   * core protocol, the MAC is generated using sha256 instead of keccak.\r\n   *\r\n   * NOTE: only scrypt and pbkdf2 are supported.\r\n   *\r\n   * @param {KDF} kdf - the key derivation function to be used\r\n   * @param {string} privateKey - hex-encoded private key\r\n   * @param {string} passphrase - a passphrase used for encryption\r\n   *\r\n   * @returns {Promise<string>}\r\n   */\n\n\n  var encryptPrivateKey = function (kdf, privateKey, passphrase) {\n    return tslib.__awaiter(void 0, void 0, void 0, function () {\n      var address, salt, iv, kdfparams, derivedKey, cipher, ciphertext;\n      return tslib.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            address = getAddressFromPrivateKey(privateKey);\n            salt = randomBytes(32);\n            iv = Buffer.from(randomBytes(16), 'hex');\n            kdfparams = {\n              salt: salt,\n              n: 8192,\n              c: 262144,\n              r: 8,\n              p: 1,\n              dklen: 32\n            };\n            return [4\n            /*yield*/\n            , getDerivedKey(Buffer.from(passphrase), kdf, kdfparams)];\n\n          case 1:\n            derivedKey = _a.sent();\n            cipher = new aes.ModeOfOperation.ctr(derivedKey.slice(0, 16), new aes.Counter(iv));\n            ciphertext = Buffer.from(cipher.encrypt(Buffer.from(privateKey, 'hex')));\n            return [2\n            /*return*/\n            , JSON.stringify({\n              address: address,\n              crypto: {\n                cipher: ALGO_IDENTIFIER,\n                cipherparams: {\n                  iv: iv.toString('hex')\n                },\n                ciphertext: ciphertext.toString('hex'),\n                kdf: kdf,\n                kdfparams: kdfparams,\n                mac: hashjs // @ts-ignore\n                .hmac(hashjs.sha256, derivedKey, 'hex').update(Buffer.concat([derivedKey.slice(16, 32), ciphertext, iv, Buffer.from(ALGO_IDENTIFIER)]), 'hex').digest('hex')\n              },\n              id: uuid.v4({\n                random: util.bytes.hexToIntArray(randomBytes(16))\n              }),\n              version: 3\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   * decryptPrivateKey\r\n   *\r\n   * Recovers the private key from a keystore file using the given passphrase.\r\n   *\r\n   * @param {string} passphrase\r\n   * @param {KeystoreV3} keystore\r\n   * @returns {Promise<string>}\r\n   */\n\n\n  var decryptPrivateKey = function (passphrase, keystore) {\n    return tslib.__awaiter(void 0, void 0, void 0, function () {\n      var ciphertext, iv, kdfparams, derivedKey, mac, cipher;\n      return tslib.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ciphertext = Buffer.from(keystore.crypto.ciphertext, 'hex');\n            iv = Buffer.from(keystore.crypto.cipherparams.iv, 'hex');\n            kdfparams = keystore.crypto.kdfparams;\n            return [4\n            /*yield*/\n            , getDerivedKey(Buffer.from(passphrase), keystore.crypto.kdf, kdfparams)];\n\n          case 1:\n            derivedKey = _a.sent();\n            mac = hashjs // @ts-ignore\n            .hmac(hashjs.sha256, derivedKey, 'hex').update(Buffer.concat([derivedKey.slice(16, 32), ciphertext, iv, Buffer.from(ALGO_IDENTIFIER)]), 'hex').digest('hex'); // we need to do a byte-by-byte comparison to avoid non-constant time side\n            // channel attacks.\n\n            if (!util.bytes.isEqual(mac.toUpperCase(), keystore.crypto.mac.toUpperCase())) {\n              return [2\n              /*return*/\n              , Promise.reject('Failed to decrypt.')];\n            }\n\n            cipher = new aes.ModeOfOperation.ctr(derivedKey.slice(0, 16), new aes.Counter(iv));\n            return [2\n            /*return*/\n            , Buffer.from(cipher.decrypt(ciphertext)).toString('hex')];\n        }\n      });\n    });\n  }; //  Copyright (C) 2018 Zilliqa\n  //  Copyright (C) 2018 Zilliqa\n\n  /**\r\n   * sign\r\n   *\r\n   * @param {string} hash - hex-encoded hash of the data to be signed\r\n   *\r\n   * @returns {string} the signature\r\n   */\n\n\n  var sign$1 = function (msg, privateKey, pubKey) {\n    var sig = sign$$1(msg, Buffer.from(privateKey, 'hex'), Buffer.from(pubKey, 'hex'));\n    var r = sig.r.toString('hex');\n    var s = sig.s.toString('hex');\n\n    while (r.length < 64) {\n      r = '0' + r;\n    }\n\n    while (s.length < 64) {\n      s = '0' + s;\n    }\n\n    return r + s;\n  };\n\n  exports.sign = sign$1;\n  exports.schnorr = schnorr;\n  exports.Signature = Signature;\n  exports.getAddressFromPrivateKey = getAddressFromPrivateKey;\n  exports.getPubKeyFromPrivateKey = getPubKeyFromPrivateKey;\n  exports.getAccountFrom0xPrivateKey = getAccountFrom0xPrivateKey;\n  exports.compressPublicKey = compressPublicKey;\n  exports.getAddressFromPublicKey = getAddressFromPublicKey;\n  exports.toChecksumAddress = toChecksumAddress;\n  exports.isValidChecksumAddress = isValidChecksumAddress;\n  exports.normaliseAddress = normaliseAddress;\n  exports.encodeBase58 = encodeBase58;\n  exports.decodeBase58 = decodeBase58;\n  exports.verifyPrivateKey = verifyPrivateKey;\n  exports.normalizePrivateKey = normalizePrivateKey;\n  exports.encryptPrivateKey = encryptPrivateKey;\n  exports.decryptPrivateKey = decryptPrivateKey;\n  exports.randomBytes = randomBytes;\n  exports.encode = encode;\n  exports.decode = decode;\n  exports.HRP = HRP;\n  exports.convertBits = convertBits;\n  exports.toBech32Address = toBech32Address;\n  exports.fromBech32Address = fromBech32Address;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n}); //# sourceMappingURL=index.umd.js.map","map":null,"metadata":{},"sourceType":"script"}