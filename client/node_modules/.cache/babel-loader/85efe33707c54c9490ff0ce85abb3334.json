{"ast":null,"code":"// TODO:\n//   * convert listenerCount() usage to emit() return value checking?\n//   * emit error when connection severed early (e.g. before handshake)\n//   * add '.connected' or similar property to connection objects to allow\n//     immediate connection status checking\n'use strict';\n\nconst {\n  Server: netServer\n} = require('net');\n\nconst EventEmitter = require('events');\n\nconst {\n  listenerCount\n} = EventEmitter;\n\nconst {\n  CHANNEL_OPEN_FAILURE,\n  DEFAULT_CIPHER,\n  DEFAULT_COMPRESSION,\n  DEFAULT_KEX,\n  DEFAULT_MAC,\n  DEFAULT_SERVER_HOST_KEY,\n  DISCONNECT_REASON,\n  DISCONNECT_REASON_BY_VALUE,\n  SUPPORTED_CIPHER,\n  SUPPORTED_COMPRESSION,\n  SUPPORTED_KEX,\n  SUPPORTED_MAC,\n  SUPPORTED_SERVER_HOST_KEY\n} = require('./protocol/constants.js');\n\nconst {\n  init: cryptoInit\n} = require('./protocol/crypto.js');\n\nconst {\n  KexInit\n} = require('./protocol/kex.js');\n\nconst {\n  parseKey\n} = require('./protocol/keyParser.js');\n\nconst Protocol = require('./protocol/Protocol.js');\n\nconst {\n  SFTP\n} = require('./protocol/SFTP.js');\n\nconst {\n  writeUInt32BE\n} = require('./protocol/utils.js');\n\nconst {\n  Channel,\n  MAX_WINDOW,\n  PACKET_SIZE,\n  windowAdjust,\n  WINDOW_THRESHOLD\n} = require('./Channel.js');\n\nconst {\n  ChannelManager,\n  generateAlgorithmList,\n  isWritable,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE\n} = require('./utils.js');\n\nconst MAX_PENDING_AUTHS = 10;\n\nclass AuthContext extends EventEmitter {\n  constructor(protocol, username, service, method, cb) {\n    super();\n    this.username = this.user = username;\n    this.service = service;\n    this.method = method;\n    this._initialResponse = false;\n    this._finalResponse = false;\n    this._multistep = false;\n\n    this._cbfinal = (allowed, methodsLeft, isPartial) => {\n      if (!this._finalResponse) {\n        this._finalResponse = true;\n        cb(this, allowed, methodsLeft, isPartial);\n      }\n    };\n\n    this._protocol = protocol;\n  }\n\n  accept() {\n    this._cleanup && this._cleanup();\n    this._initialResponse = true;\n\n    this._cbfinal(true);\n  }\n\n  reject(methodsLeft, isPartial) {\n    this._cleanup && this._cleanup();\n    this._initialResponse = true;\n\n    this._cbfinal(false, methodsLeft, isPartial);\n  }\n\n}\n\nclass KeyboardAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, submethods, cb) {\n    super(protocol, username, service, method, cb);\n    this._multistep = true;\n    this._cb = undefined;\n\n    this._onInfoResponse = responses => {\n      const callback = this._cb;\n\n      if (callback) {\n        this._cb = undefined;\n        callback(responses);\n      }\n    };\n\n    this.submethods = submethods;\n    this.on('abort', () => {\n      this._cb && this._cb(new Error('Authentication request aborted'));\n    });\n  }\n\n  prompt(prompts, title, instructions, cb) {\n    if (!Array.isArray(prompts)) prompts = [prompts];\n\n    if (typeof title === 'function') {\n      cb = title;\n      title = instructions = undefined;\n    } else if (typeof instructions === 'function') {\n      cb = instructions;\n      instructions = undefined;\n    } else if (typeof cb !== 'function') {\n      cb = undefined;\n    }\n\n    for (let i = 0; i < prompts.length; ++i) {\n      if (typeof prompts[i] === 'string') {\n        prompts[i] = {\n          prompt: prompts[i],\n          echo: true\n        };\n      }\n    }\n\n    this._cb = cb;\n    this._initialResponse = true;\n\n    this._protocol.authInfoReq(title, instructions, prompts);\n  }\n\n}\n\nclass PKAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, pkInfo, cb) {\n    super(protocol, username, service, method, cb);\n    this.key = {\n      algo: pkInfo.keyAlgo,\n      data: pkInfo.key\n    };\n    this.signature = pkInfo.signature;\n    this.blob = pkInfo.blob;\n  }\n\n  accept() {\n    if (!this.signature) {\n      this._initialResponse = true;\n\n      this._protocol.authPKOK(this.key.algo, this.key.data);\n    } else {\n      AuthContext.prototype.accept.call(this);\n    }\n  }\n\n}\n\nclass HostbasedAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, pkInfo, cb) {\n    super(protocol, username, service, method, cb);\n    this.key = {\n      algo: pkInfo.keyAlgo,\n      data: pkInfo.key\n    };\n    this.signature = pkInfo.signature;\n    this.blob = pkInfo.blob;\n    this.localHostname = pkInfo.localHostname;\n    this.localUsername = pkInfo.localUsername;\n  }\n\n}\n\nclass PwdAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, password, cb) {\n    super(protocol, username, service, method, cb);\n    this.password = password;\n    this._changeCb = undefined;\n  }\n\n  requestChange(prompt, cb) {\n    if (this._changeCb) throw new Error('Change request already in progress');\n    if (typeof prompt !== 'string') throw new Error('prompt argument must be a string');\n    if (typeof cb !== 'function') throw new Error('Callback argument must be a function');\n    this._changeCb = cb;\n\n    this._protocol.authPasswdChg(prompt);\n  }\n\n}\n\nclass Session extends EventEmitter {\n  constructor(client, info, localChan) {\n    super();\n    this.type = 'session';\n    this.subtype = undefined;\n    this.server = true;\n    this._ending = false;\n    this._channel = undefined;\n    this._chanInfo = {\n      type: 'session',\n      incoming: {\n        id: localChan,\n        window: MAX_WINDOW,\n        packetSize: PACKET_SIZE,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n  }\n\n}\n\nclass Server extends EventEmitter {\n  constructor(cfg, listener) {\n    super();\n    if (typeof cfg !== 'object' || cfg === null) throw new Error('Missing configuration object');\n    const hostKeys = Object.create(null);\n    const hostKeyAlgoOrder = [];\n    const hostKeys_ = cfg.hostKeys;\n    if (!Array.isArray(hostKeys_)) throw new Error('hostKeys must be an array');\n    const cfgAlgos = typeof cfg.algorithms === 'object' && cfg.algorithms !== null ? cfg.algorithms : {};\n    const hostKeyAlgos = generateAlgorithmList(cfgAlgos.serverHostKey, DEFAULT_SERVER_HOST_KEY, SUPPORTED_SERVER_HOST_KEY);\n\n    for (let i = 0; i < hostKeys_.length; ++i) {\n      let privateKey;\n      if (Buffer.isBuffer(hostKeys_[i]) || typeof hostKeys_[i] === 'string') privateKey = parseKey(hostKeys_[i]);else privateKey = parseKey(hostKeys_[i].key, hostKeys_[i].passphrase);\n      if (privateKey instanceof Error) throw new Error(`Cannot parse privateKey: ${privateKey.message}`);\n\n      if (Array.isArray(privateKey)) {\n        // OpenSSH's newer format only stores 1 key for now\n        privateKey = privateKey[0];\n      }\n\n      if (privateKey.getPrivatePEM() === null) throw new Error('privateKey value contains an invalid private key'); // Discard key if we already found a key of the same type\n\n      if (hostKeyAlgoOrder.includes(privateKey.type)) continue;\n\n      if (privateKey.type === 'ssh-rsa') {\n        // SSH supports multiple signature hashing algorithms for RSA, so we add\n        // the algorithms in the desired order\n        let sha1Pos = hostKeyAlgos.indexOf('ssh-rsa');\n        const sha256Pos = hostKeyAlgos.indexOf('rsa-sha2-256');\n        const sha512Pos = hostKeyAlgos.indexOf('rsa-sha2-512');\n\n        if (sha1Pos === -1) {\n          // Fall back to giving SHA1 the lowest priority\n          sha1Pos = Infinity;\n        }\n\n        [sha1Pos, sha256Pos, sha512Pos].sort(compareNumbers).forEach(pos => {\n          if (pos === -1) return;\n          let type;\n\n          switch (pos) {\n            case sha1Pos:\n              type = 'ssh-rsa';\n              break;\n\n            case sha256Pos:\n              type = 'rsa-sha2-256';\n              break;\n\n            case sha512Pos:\n              type = 'rsa-sha2-512';\n              break;\n\n            default:\n              return;\n          } // Store same RSA key under each hash algorithm name for convenience\n\n\n          hostKeys[type] = privateKey;\n          hostKeyAlgoOrder.push(type);\n        });\n      } else {\n        hostKeys[privateKey.type] = privateKey;\n        hostKeyAlgoOrder.push(privateKey.type);\n      }\n    }\n\n    const algorithms = {\n      kex: generateAlgorithmList(cfgAlgos.kex, DEFAULT_KEX, SUPPORTED_KEX),\n      serverHostKey: hostKeyAlgoOrder,\n      cs: {\n        cipher: generateAlgorithmList(cfgAlgos.cipher, DEFAULT_CIPHER, SUPPORTED_CIPHER),\n        mac: generateAlgorithmList(cfgAlgos.hmac, DEFAULT_MAC, SUPPORTED_MAC),\n        compress: generateAlgorithmList(cfgAlgos.compress, DEFAULT_COMPRESSION, SUPPORTED_COMPRESSION),\n        lang: []\n      },\n      sc: undefined\n    };\n    algorithms.sc = algorithms.cs;\n    if (typeof listener === 'function') this.on('connection', listener);\n    const origDebug = typeof cfg.debug === 'function' ? cfg.debug : undefined;\n    const ident = cfg.ident ? Buffer.from(cfg.ident) : undefined;\n    const offer = new KexInit(algorithms);\n    this._srv = new netServer(socket => {\n      if (this._connections >= this.maxConnections) {\n        socket.destroy();\n        return;\n      }\n\n      ++this._connections;\n      socket.once('close', () => {\n        --this._connections;\n      });\n      let debug;\n\n      if (origDebug) {\n        // Prepend debug output with a unique identifier in case there are\n        // multiple clients connected at the same time\n        const debugPrefix = `[${process.hrtime().join('.')}] `;\n\n        debug = msg => {\n          origDebug(`${debugPrefix}${msg}`);\n        };\n      } // eslint-disable-next-line no-use-before-define\n\n\n      new Client(socket, hostKeys, ident, offer, debug, this, cfg);\n    }).on('error', err => {\n      this.emit('error', err);\n    }).on('listening', () => {\n      this.emit('listening');\n    }).on('close', () => {\n      this.emit('close');\n    });\n    this._connections = 0;\n    this.maxConnections = Infinity;\n  }\n\n  injectSocket(socket) {\n    this._srv.emit('connection', socket);\n  }\n\n  listen() {\n    this._srv.listen(...arguments);\n\n    return this;\n  }\n\n  address() {\n    return this._srv.address();\n  }\n\n  getConnections(cb) {\n    this._srv.getConnections(cb);\n\n    return this;\n  }\n\n  close(cb) {\n    this._srv.close(cb);\n\n    return this;\n  }\n\n  ref() {\n    this._srv.ref();\n\n    return this;\n  }\n\n  unref() {\n    this._srv.unref();\n\n    return this;\n  }\n\n}\n\nServer.KEEPALIVE_CLIENT_INTERVAL = 15000;\nServer.KEEPALIVE_CLIENT_COUNT_MAX = 3;\n\nclass Client extends EventEmitter {\n  constructor(socket, hostKeys, ident, offer, debug, server, srvCfg) {\n    super();\n    let exchanges = 0;\n    let acceptedAuthSvc = false;\n    let pendingAuths = [];\n    let authCtx;\n    let kaTimer;\n    let onPacket;\n    const unsentGlobalRequestsReplies = [];\n    this._sock = socket;\n    this._chanMgr = new ChannelManager(this);\n    this._debug = debug;\n    this.noMoreSessions = false;\n    this.authenticated = false; // Silence pre-header errors\n\n    function onClientPreHeaderError(err) {}\n\n    this.on('error', onClientPreHeaderError);\n    const DEBUG_HANDLER = !debug ? undefined : (p, display, msg) => {\n      debug(`Debug output from client: ${JSON.stringify(msg)}`);\n    };\n    const kaIntvl = typeof srvCfg.keepaliveInterval === 'number' && isFinite(srvCfg.keepaliveInterval) && srvCfg.keepaliveInterval > 0 ? srvCfg.keepaliveInterval : typeof Server.KEEPALIVE_CLIENT_INTERVAL === 'number' && isFinite(Server.KEEPALIVE_CLIENT_INTERVAL) && Server.KEEPALIVE_CLIENT_INTERVAL > 0 ? Server.KEEPALIVE_CLIENT_INTERVAL : -1;\n    const kaCountMax = typeof srvCfg.keepaliveCountMax === 'number' && isFinite(srvCfg.keepaliveCountMax) && srvCfg.keepaliveCountMax >= 0 ? srvCfg.keepaliveCountMax : typeof Server.KEEPALIVE_CLIENT_COUNT_MAX === 'number' && isFinite(Server.KEEPALIVE_CLIENT_COUNT_MAX) && Server.KEEPALIVE_CLIENT_COUNT_MAX >= 0 ? Server.KEEPALIVE_CLIENT_COUNT_MAX : -1;\n    let kaCurCount = 0;\n\n    if (kaIntvl !== -1 && kaCountMax !== -1) {\n      this.once('ready', () => {\n        const onClose = () => {\n          clearInterval(kaTimer);\n        };\n\n        this.on('close', onClose).on('end', onClose);\n        kaTimer = setInterval(() => {\n          if (++kaCurCount > kaCountMax) {\n            clearInterval(kaTimer);\n            const err = new Error('Keepalive timeout');\n            err.level = 'client-timeout';\n            this.emit('error', err);\n            this.end();\n          } else {\n            // XXX: if the server ever starts sending real global requests to\n            //      the client, we will need to add a dummy callback here to\n            //      keep the correct reply order\n            proto.ping();\n          }\n        }, kaIntvl);\n      }); // TODO: re-verify keepalive behavior with OpenSSH\n\n      onPacket = () => {\n        kaTimer && kaTimer.refresh();\n        kaCurCount = 0;\n      };\n    }\n\n    const proto = this._protocol = new Protocol({\n      server: true,\n      hostKeys,\n      ident,\n      offer,\n      onPacket,\n      greeting: srvCfg.greeting,\n      banner: srvCfg.banner,\n      onWrite: data => {\n        if (isWritable(socket)) socket.write(data);\n      },\n      onError: err => {\n        if (!proto._destruct) socket.removeAllListeners('data');\n        this.emit('error', err);\n\n        try {\n          socket.end();\n        } catch {}\n      },\n      onHeader: header => {\n        this.removeListener('error', onClientPreHeaderError);\n        const info = {\n          ip: socket.remoteAddress,\n          family: socket.remoteFamily,\n          port: socket.remotePort,\n          header\n        };\n\n        if (!server.emit('connection', this, info)) {\n          // auto reject\n          proto.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n          socket.end();\n          return;\n        }\n\n        if (header.greeting) this.emit('greeting', header.greeting);\n      },\n      onHandshakeComplete: negotiated => {\n        if (++exchanges > 1) this.emit('rekey');\n        this.emit('handshake', negotiated);\n      },\n      debug,\n      messageHandlers: {\n        DEBUG: DEBUG_HANDLER,\n        DISCONNECT: (p, reason, desc) => {\n          if (reason !== DISCONNECT_REASON.BY_APPLICATION) {\n            if (!desc) {\n              desc = DISCONNECT_REASON_BY_VALUE[reason];\n              if (desc === undefined) desc = `Unexpected disconnection reason: ${reason}`;\n            }\n\n            const err = new Error(desc);\n            err.code = reason;\n            this.emit('error', err);\n          }\n\n          socket.end();\n        },\n        CHANNEL_OPEN: (p, info) => {\n          // Handle incoming requests from client\n          // Do early reject in some cases to prevent wasteful channel\n          // allocation\n          if (info.type === 'session' && this.noMoreSessions || !this.authenticated) {\n            const reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n            return proto.channelOpenFail(info.sender, reasonCode);\n          }\n\n          let localChan = -1;\n          let reason;\n          let replied = false;\n          let accept;\n\n          const reject = () => {\n            if (replied) return;\n            replied = true;\n\n            if (reason === undefined) {\n              if (localChan === -1) reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;else reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;\n            }\n\n            if (localChan !== -1) this._chanMgr.remove(localChan);\n            proto.channelOpenFail(info.sender, reason, '');\n          };\n\n          const reserveChannel = () => {\n            localChan = this._chanMgr.add();\n\n            if (localChan === -1) {\n              reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n\n              if (debug) {\n                debug('Automatic rejection of incoming channel open: ' + 'no channels available');\n              }\n            }\n\n            return localChan !== -1;\n          };\n\n          const data = info.data;\n\n          switch (info.type) {\n            case 'session':\n              if (listenerCount(this, 'session') && reserveChannel()) {\n                accept = () => {\n                  if (replied) return;\n                  replied = true;\n                  const instance = new Session(this, info, localChan);\n\n                  this._chanMgr.update(localChan, instance);\n\n                  proto.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);\n                  return instance;\n                };\n\n                this.emit('session', accept, reject);\n                return;\n              }\n\n              break;\n\n            case 'direct-tcpip':\n              if (listenerCount(this, 'tcpip') && reserveChannel()) {\n                accept = () => {\n                  if (replied) return;\n                  replied = true;\n                  const chanInfo = {\n                    type: undefined,\n                    incoming: {\n                      id: localChan,\n                      window: MAX_WINDOW,\n                      packetSize: PACKET_SIZE,\n                      state: 'open'\n                    },\n                    outgoing: {\n                      id: info.sender,\n                      window: info.window,\n                      packetSize: info.packetSize,\n                      state: 'open'\n                    }\n                  };\n                  const stream = new Channel(this, chanInfo, {\n                    server: true\n                  });\n\n                  this._chanMgr.update(localChan, stream);\n\n                  proto.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);\n                  return stream;\n                };\n\n                this.emit('tcpip', accept, reject, data);\n                return;\n              }\n\n              break;\n\n            case 'direct-streamlocal@openssh.com':\n              if (listenerCount(this, 'openssh.streamlocal') && reserveChannel()) {\n                accept = () => {\n                  if (replied) return;\n                  replied = true;\n                  const chanInfo = {\n                    type: undefined,\n                    incoming: {\n                      id: localChan,\n                      window: MAX_WINDOW,\n                      packetSize: PACKET_SIZE,\n                      state: 'open'\n                    },\n                    outgoing: {\n                      id: info.sender,\n                      window: info.window,\n                      packetSize: info.packetSize,\n                      state: 'open'\n                    }\n                  };\n                  const stream = new Channel(this, chanInfo, {\n                    server: true\n                  });\n\n                  this._chanMgr.update(localChan, stream);\n\n                  proto.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);\n                  return stream;\n                };\n\n                this.emit('openssh.streamlocal', accept, reject, data);\n                return;\n              }\n\n              break;\n\n            default:\n              // Automatically reject any unsupported channel open requests\n              reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;\n\n              if (debug) {\n                debug('Automatic rejection of unsupported incoming channel open' + ` type: ${info.type}`);\n              }\n\n          }\n\n          if (reason === undefined) {\n            reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n\n            if (debug) {\n              debug('Automatic rejection of unexpected incoming channel open' + ` for: ${info.type}`);\n            }\n          }\n\n          reject();\n        },\n        CHANNEL_OPEN_CONFIRMATION: (p, info) => {\n          const channel = this._chanMgr.get(info.recipient);\n\n          if (typeof channel !== 'function') return;\n          const chanInfo = {\n            type: channel.type,\n            incoming: {\n              id: info.recipient,\n              window: MAX_WINDOW,\n              packetSize: PACKET_SIZE,\n              state: 'open'\n            },\n            outgoing: {\n              id: info.sender,\n              window: info.window,\n              packetSize: info.packetSize,\n              state: 'open'\n            }\n          };\n          const instance = new Channel(this, chanInfo, {\n            server: true\n          });\n\n          this._chanMgr.update(info.recipient, instance);\n\n          channel(undefined, instance);\n        },\n        CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {\n          const channel = this._chanMgr.get(recipient);\n\n          if (typeof channel !== 'function') return;\n          const info = {\n            reason,\n            description\n          };\n          onChannelOpenFailure(this, recipient, info, channel);\n        },\n        CHANNEL_DATA: (p, recipient, data) => {\n          let channel = this._chanMgr.get(recipient);\n\n          if (typeof channel !== 'object' || channel === null) return;\n\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel) return;\n          } // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n\n\n          if (channel.incoming.window === 0) return;\n          channel.incoming.window -= data.length;\n\n          if (channel.push(data) === false) {\n            channel._waitChanDrain = true;\n            return;\n          }\n\n          if (channel.incoming.window <= WINDOW_THRESHOLD) windowAdjust(channel);\n        },\n        CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {// NOOP -- should not be sent by client\n        },\n        CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {\n          let channel = this._chanMgr.get(recipient);\n\n          if (typeof channel !== 'object' || channel === null) return;\n\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel) return;\n          } // The other side is allowing us to send `amount` more bytes of data\n\n\n          channel.outgoing.window += amount;\n\n          if (channel._waitWindow) {\n            channel._waitWindow = false;\n\n            if (channel._chunk) {\n              channel._write(channel._chunk, null, channel._chunkcb);\n            } else if (channel._chunkcb) {\n              channel._chunkcb();\n            } else if (channel._chunkErr) {\n              channel.stderr._write(channel._chunkErr, null, channel._chunkcbErr);\n            } else if (channel._chunkcbErr) {\n              channel._chunkcbErr();\n            }\n          }\n        },\n        CHANNEL_SUCCESS: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n\n          if (typeof channel !== 'object' || channel === null) return;\n\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel) return;\n          }\n\n          if (channel._callbacks.length) channel._callbacks.shift()(false);\n        },\n        CHANNEL_FAILURE: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n\n          if (typeof channel !== 'object' || channel === null) return;\n\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel) return;\n          }\n\n          if (channel._callbacks.length) channel._callbacks.shift()(true);\n        },\n        CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {\n          const session = this._chanMgr.get(recipient);\n\n          if (typeof session !== 'object' || session === null) return;\n          let replied = false;\n          let accept;\n          let reject;\n\n          if (session.constructor !== Session) {\n            // normal Channel instance\n            if (wantReply) proto.channelFailure(session.outgoing.id);\n            return;\n          }\n\n          if (wantReply) {\n            // \"real session\" requests will have custom accept behaviors\n            if (type !== 'shell' && type !== 'exec' && type !== 'subsystem') {\n              accept = () => {\n                if (replied || session._ending || session._channel) return;\n                replied = true;\n                proto.channelSuccess(session._chanInfo.outgoing.id);\n              };\n            }\n\n            reject = () => {\n              if (replied || session._ending || session._channel) return;\n              replied = true;\n              proto.channelFailure(session._chanInfo.outgoing.id);\n            };\n          }\n\n          if (session._ending) {\n            reject && reject();\n            return;\n          }\n\n          switch (type) {\n            // \"pre-real session start\" requests\n            case 'env':\n              if (listenerCount(session, 'env')) {\n                session.emit('env', accept, reject, {\n                  key: data.name,\n                  val: data.value\n                });\n                return;\n              }\n\n              break;\n\n            case 'pty-req':\n              if (listenerCount(session, 'pty')) {\n                session.emit('pty', accept, reject, data);\n                return;\n              }\n\n              break;\n\n            case 'window-change':\n              if (listenerCount(session, 'window-change')) session.emit('window-change', accept, reject, data);else reject && reject();\n              break;\n\n            case 'x11-req':\n              if (listenerCount(session, 'x11')) {\n                session.emit('x11', accept, reject, data);\n                return;\n              }\n\n              break;\n            // \"post-real session start\" requests\n\n            case 'signal':\n              if (listenerCount(session, 'signal')) {\n                session.emit('signal', accept, reject, {\n                  name: data\n                });\n                return;\n              }\n\n              break;\n            // XXX: is `auth-agent-req@openssh.com` really \"post-real session\n            // start\"?\n\n            case 'auth-agent-req@openssh.com':\n              if (listenerCount(session, 'auth-agent')) {\n                session.emit('auth-agent', accept, reject);\n                return;\n              }\n\n              break;\n            // \"real session start\" requests\n\n            case 'shell':\n              if (listenerCount(session, 'shell')) {\n                accept = () => {\n                  if (replied || session._ending || session._channel) return;\n                  replied = true;\n                  if (wantReply) proto.channelSuccess(session._chanInfo.outgoing.id);\n                  const channel = new Channel(this, session._chanInfo, {\n                    server: true\n                  });\n                  channel.subtype = session.subtype = type;\n                  session._channel = channel;\n                  return channel;\n                };\n\n                session.emit('shell', accept, reject);\n                return;\n              }\n\n              break;\n\n            case 'exec':\n              if (listenerCount(session, 'exec')) {\n                accept = () => {\n                  if (replied || session._ending || session._channel) return;\n                  replied = true;\n                  if (wantReply) proto.channelSuccess(session._chanInfo.outgoing.id);\n                  const channel = new Channel(this, session._chanInfo, {\n                    server: true\n                  });\n                  channel.subtype = session.subtype = type;\n                  session._channel = channel;\n                  return channel;\n                };\n\n                session.emit('exec', accept, reject, {\n                  command: data\n                });\n                return;\n              }\n\n              break;\n\n            case 'subsystem':\n              {\n                let useSFTP = data === 'sftp';\n\n                accept = () => {\n                  if (replied || session._ending || session._channel) return;\n                  replied = true;\n                  if (wantReply) proto.channelSuccess(session._chanInfo.outgoing.id);\n                  let instance;\n\n                  if (useSFTP) {\n                    instance = new SFTP(this, session._chanInfo, {\n                      server: true,\n                      debug\n                    });\n                  } else {\n                    instance = new Channel(this, session._chanInfo, {\n                      server: true\n                    });\n                    instance.subtype = session.subtype = `${type}:${data}`;\n                  }\n\n                  session._channel = instance;\n                  return instance;\n                };\n\n                if (data === 'sftp') {\n                  if (listenerCount(session, 'sftp')) {\n                    session.emit('sftp', accept, reject);\n                    return;\n                  }\n\n                  useSFTP = false;\n                }\n\n                if (listenerCount(session, 'subsystem')) {\n                  session.emit('subsystem', accept, reject, {\n                    name: data\n                  });\n                  return;\n                }\n\n                break;\n              }\n          }\n\n          debug && debug(`Automatic rejection of incoming channel request: ${type}`);\n          reject && reject();\n        },\n        CHANNEL_EOF: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n\n          if (typeof channel !== 'object' || channel === null) return;\n\n          if (channel.constructor === Session) {\n            if (!channel._ending) {\n              channel._ending = true;\n              channel.emit('eof');\n              channel.emit('end');\n            }\n\n            channel = channel._channel;\n            if (!channel) return;\n          }\n\n          if (channel.incoming.state !== 'open') return;\n          channel.incoming.state = 'eof';\n          if (channel.readable) channel.push(null);\n        },\n        CHANNEL_CLOSE: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n\n          if (typeof channel !== 'object' || channel === null) return;\n\n          if (channel.constructor === Session) {\n            channel._ending = true;\n            channel.emit('close');\n            channel = channel._channel;\n            if (!channel) return;\n          }\n\n          onCHANNEL_CLOSE(this, recipient, channel);\n        },\n        // Begin service/auth-related ==========================================\n        SERVICE_REQUEST: (p, service) => {\n          if (exchanges === 0 || acceptedAuthSvc || this.authenticated || service !== 'ssh-userauth') {\n            proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);\n            socket.end();\n            return;\n          }\n\n          acceptedAuthSvc = true;\n          proto.serviceAccept(service);\n        },\n        USERAUTH_REQUEST: (p, username, service, method, methodData) => {\n          if (exchanges === 0 || this.authenticated || authCtx && (authCtx.username !== username || authCtx.service !== service) // TODO: support hostbased auth\n          || method !== 'password' && method !== 'publickey' && method !== 'hostbased' && method !== 'keyboard-interactive' && method !== 'none' || pendingAuths.length === MAX_PENDING_AUTHS) {\n            proto.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n            socket.end();\n            return;\n          } else if (service !== 'ssh-connection') {\n            proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);\n            socket.end();\n            return;\n          }\n\n          let ctx;\n\n          switch (method) {\n            case 'keyboard-interactive':\n              ctx = new KeyboardAuthContext(proto, username, service, method, methodData, onAuthDecide);\n              break;\n\n            case 'publickey':\n              ctx = new PKAuthContext(proto, username, service, method, methodData, onAuthDecide);\n              break;\n\n            case 'hostbased':\n              ctx = new HostbasedAuthContext(proto, username, service, method, methodData, onAuthDecide);\n              break;\n\n            case 'password':\n              if (authCtx && authCtx instanceof PwdAuthContext && authCtx._changeCb) {\n                const cb = authCtx._changeCb;\n                authCtx._changeCb = undefined;\n                cb(methodData.newPassword);\n                return;\n              }\n\n              ctx = new PwdAuthContext(proto, username, service, method, methodData, onAuthDecide);\n              break;\n\n            case 'none':\n              ctx = new AuthContext(proto, username, service, method, onAuthDecide);\n              break;\n          }\n\n          if (authCtx) {\n            if (!authCtx._initialResponse) {\n              return pendingAuths.push(ctx);\n            } else if (authCtx._multistep && !authCtx._finalResponse) {\n              // RFC 4252 says to silently abort the current auth request if a\n              // new auth request comes in before the final response from an\n              // auth method that requires additional request/response exchanges\n              // -- this means keyboard-interactive for now ...\n              authCtx._cleanup && authCtx._cleanup();\n              authCtx.emit('abort');\n            }\n          }\n\n          authCtx = ctx;\n          if (listenerCount(this, 'authentication')) this.emit('authentication', authCtx);else authCtx.reject();\n        },\n        USERAUTH_INFO_RESPONSE: (p, responses) => {\n          if (authCtx && authCtx instanceof KeyboardAuthContext) authCtx._onInfoResponse(responses);\n        },\n        // End service/auth-related ============================================\n        GLOBAL_REQUEST: (p, name, wantReply, data) => {\n          const reply = {\n            type: null,\n            buf: null\n          };\n\n          function setReply(type, buf) {\n            reply.type = type;\n            reply.buf = buf;\n            sendReplies();\n          }\n\n          if (wantReply) unsentGlobalRequestsReplies.push(reply);\n\n          if ((name === 'tcpip-forward' || name === 'cancel-tcpip-forward' || name === 'no-more-sessions@openssh.com' || name === 'streamlocal-forward@openssh.com' || name === 'cancel-streamlocal-forward@openssh.com') && listenerCount(this, 'request') && this.authenticated) {\n            let accept;\n            let reject;\n\n            if (wantReply) {\n              let replied = false;\n\n              accept = chosenPort => {\n                if (replied) return;\n                replied = true;\n                let bufPort;\n\n                if (name === 'tcpip-forward' && data.bindPort === 0 && typeof chosenPort === 'number') {\n                  bufPort = Buffer.allocUnsafe(4);\n                  writeUInt32BE(bufPort, chosenPort, 0);\n                }\n\n                setReply('SUCCESS', bufPort);\n              };\n\n              reject = () => {\n                if (replied) return;\n                replied = true;\n                setReply('FAILURE');\n              };\n            }\n\n            if (name === 'no-more-sessions@openssh.com') {\n              this.noMoreSessions = true;\n              accept && accept();\n              return;\n            }\n\n            this.emit('request', accept, reject, name, data);\n          } else if (wantReply) {\n            setReply('FAILURE');\n          }\n        }\n      }\n    });\n    socket.pause();\n    cryptoInit.then(() => {\n      proto.start();\n      socket.on('data', data => {\n        try {\n          proto.parse(data, 0, data.length);\n        } catch (ex) {\n          this.emit('error', ex);\n\n          try {\n            if (isWritable(socket)) socket.end();\n          } catch {}\n        }\n      });\n      socket.resume();\n    }).catch(err => {\n      this.emit('error', err);\n\n      try {\n        if (isWritable(socket)) socket.end();\n      } catch {}\n    });\n    socket.on('error', err => {\n      err.level = 'socket';\n      this.emit('error', err);\n    }).once('end', () => {\n      debug && debug('Socket ended');\n      proto.cleanup();\n      this.emit('end');\n    }).once('close', () => {\n      debug && debug('Socket closed');\n      proto.cleanup();\n      this.emit('close');\n      const err = new Error('No response from server'); // Simulate error for pending channels and close any open channels\n\n      this._chanMgr.cleanup(err);\n    });\n\n    const onAuthDecide = (ctx, allowed, methodsLeft, isPartial) => {\n      if (authCtx === ctx && !this.authenticated) {\n        if (allowed) {\n          authCtx = undefined;\n          this.authenticated = true;\n          proto.authSuccess();\n          pendingAuths = [];\n          this.emit('ready');\n        } else {\n          proto.authFailure(methodsLeft, isPartial);\n\n          if (pendingAuths.length) {\n            authCtx = pendingAuths.pop();\n            if (listenerCount(this, 'authentication')) this.emit('authentication', authCtx);else authCtx.reject();\n          }\n        }\n      }\n    };\n\n    function sendReplies() {\n      while (unsentGlobalRequestsReplies.length > 0 && unsentGlobalRequestsReplies[0].type) {\n        const reply = unsentGlobalRequestsReplies.shift();\n        if (reply.type === 'SUCCESS') proto.requestSuccess(reply.buf);\n        if (reply.type === 'FAILURE') proto.requestFailure();\n      }\n    }\n  }\n\n  end() {\n    if (this._sock && isWritable(this._sock)) {\n      this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n\n      this._sock.end();\n    }\n\n    return this;\n  }\n\n  x11(originAddr, originPort, cb) {\n    const opts = {\n      originAddr,\n      originPort\n    };\n    openChannel(this, 'x11', opts, cb);\n    return this;\n  }\n\n  forwardOut(boundAddr, boundPort, remoteAddr, remotePort, cb) {\n    const opts = {\n      boundAddr,\n      boundPort,\n      remoteAddr,\n      remotePort\n    };\n    openChannel(this, 'forwarded-tcpip', opts, cb);\n    return this;\n  }\n\n  openssh_forwardOutStreamLocal(socketPath, cb) {\n    const opts = {\n      socketPath\n    };\n    openChannel(this, 'forwarded-streamlocal@openssh.com', opts, cb);\n    return this;\n  }\n\n  rekey(cb) {\n    let error;\n\n    try {\n      this._protocol.rekey();\n    } catch (ex) {\n      error = ex;\n    } // TODO: re-throw error if no callback?\n\n\n    if (typeof cb === 'function') {\n      if (error) process.nextTick(cb, error);else this.once('rekey', cb);\n    }\n  }\n\n}\n\nfunction openChannel(self, type, opts, cb) {\n  // Ask the client to open a channel for some purpose (e.g. a forwarded TCP\n  // connection)\n  const initWindow = MAX_WINDOW;\n  const maxPacket = PACKET_SIZE;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  const wrapper = (err, stream) => {\n    cb(err, stream);\n  };\n\n  wrapper.type = type;\n\n  const localChan = self._chanMgr.add(wrapper);\n\n  if (localChan === -1) {\n    cb(new Error('No free channels available'));\n    return;\n  }\n\n  switch (type) {\n    case 'forwarded-tcpip':\n      self._protocol.forwardedTcpip(localChan, initWindow, maxPacket, opts);\n\n      break;\n\n    case 'x11':\n      self._protocol.x11(localChan, initWindow, maxPacket, opts);\n\n      break;\n\n    case 'forwarded-streamlocal@openssh.com':\n      self._protocol.openssh_forwardedStreamLocal(localChan, initWindow, maxPacket, opts);\n\n      break;\n\n    default:\n      throw new Error(`Unsupported channel type: ${type}`);\n  }\n}\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\nmodule.exports = Server;\nmodule.exports.IncomingClient = Client;","map":{"version":3,"names":["Server","netServer","require","EventEmitter","listenerCount","CHANNEL_OPEN_FAILURE","DEFAULT_CIPHER","DEFAULT_COMPRESSION","DEFAULT_KEX","DEFAULT_MAC","DEFAULT_SERVER_HOST_KEY","DISCONNECT_REASON","DISCONNECT_REASON_BY_VALUE","SUPPORTED_CIPHER","SUPPORTED_COMPRESSION","SUPPORTED_KEX","SUPPORTED_MAC","SUPPORTED_SERVER_HOST_KEY","init","cryptoInit","KexInit","parseKey","Protocol","SFTP","writeUInt32BE","Channel","MAX_WINDOW","PACKET_SIZE","windowAdjust","WINDOW_THRESHOLD","ChannelManager","generateAlgorithmList","isWritable","onChannelOpenFailure","onCHANNEL_CLOSE","MAX_PENDING_AUTHS","AuthContext","constructor","protocol","username","service","method","cb","user","_initialResponse","_finalResponse","_multistep","_cbfinal","allowed","methodsLeft","isPartial","_protocol","accept","_cleanup","reject","KeyboardAuthContext","submethods","_cb","undefined","_onInfoResponse","responses","callback","on","Error","prompt","prompts","title","instructions","Array","isArray","i","length","echo","authInfoReq","PKAuthContext","pkInfo","key","algo","keyAlgo","data","signature","blob","authPKOK","prototype","call","HostbasedAuthContext","localHostname","localUsername","PwdAuthContext","password","_changeCb","requestChange","authPasswdChg","Session","client","info","localChan","type","subtype","server","_ending","_channel","_chanInfo","incoming","id","window","packetSize","state","outgoing","sender","cfg","listener","hostKeys","Object","create","hostKeyAlgoOrder","hostKeys_","cfgAlgos","algorithms","hostKeyAlgos","serverHostKey","privateKey","Buffer","isBuffer","passphrase","message","getPrivatePEM","includes","sha1Pos","indexOf","sha256Pos","sha512Pos","Infinity","sort","compareNumbers","forEach","pos","push","kex","cs","cipher","mac","hmac","compress","lang","sc","origDebug","debug","ident","from","offer","_srv","socket","_connections","maxConnections","destroy","once","debugPrefix","process","hrtime","join","msg","Client","err","emit","injectSocket","listen","address","getConnections","close","ref","unref","KEEPALIVE_CLIENT_INTERVAL","KEEPALIVE_CLIENT_COUNT_MAX","srvCfg","exchanges","acceptedAuthSvc","pendingAuths","authCtx","kaTimer","onPacket","unsentGlobalRequestsReplies","_sock","_chanMgr","_debug","noMoreSessions","authenticated","onClientPreHeaderError","DEBUG_HANDLER","p","display","JSON","stringify","kaIntvl","keepaliveInterval","isFinite","kaCountMax","keepaliveCountMax","kaCurCount","onClose","clearInterval","setInterval","level","end","proto","ping","refresh","greeting","banner","onWrite","write","onError","_destruct","removeAllListeners","onHeader","header","removeListener","ip","remoteAddress","family","remoteFamily","port","remotePort","disconnect","BY_APPLICATION","onHandshakeComplete","negotiated","messageHandlers","DEBUG","DISCONNECT","reason","desc","code","CHANNEL_OPEN","reasonCode","ADMINISTRATIVELY_PROHIBITED","channelOpenFail","replied","RESOURCE_SHORTAGE","CONNECT_FAILED","remove","reserveChannel","add","instance","update","channelOpenConfirm","chanInfo","stream","UNKNOWN_CHANNEL_TYPE","CHANNEL_OPEN_CONFIRMATION","channel","get","recipient","description","CHANNEL_DATA","_waitChanDrain","CHANNEL_EXTENDED_DATA","CHANNEL_WINDOW_ADJUST","amount","_waitWindow","_chunk","_write","_chunkcb","_chunkErr","stderr","_chunkcbErr","CHANNEL_SUCCESS","_callbacks","shift","CHANNEL_FAILURE","CHANNEL_REQUEST","wantReply","session","channelFailure","channelSuccess","name","val","value","command","useSFTP","CHANNEL_EOF","readable","CHANNEL_CLOSE","SERVICE_REQUEST","SERVICE_NOT_AVAILABLE","serviceAccept","USERAUTH_REQUEST","methodData","PROTOCOL_ERROR","ctx","onAuthDecide","newPassword","USERAUTH_INFO_RESPONSE","GLOBAL_REQUEST","reply","buf","setReply","sendReplies","chosenPort","bufPort","bindPort","allocUnsafe","pause","then","start","parse","ex","resume","catch","cleanup","authSuccess","authFailure","pop","requestSuccess","requestFailure","x11","originAddr","originPort","opts","openChannel","forwardOut","boundAddr","boundPort","remoteAddr","openssh_forwardOutStreamLocal","socketPath","rekey","error","nextTick","self","initWindow","maxPacket","wrapper","forwardedTcpip","openssh_forwardedStreamLocal","a","b","module","exports","IncomingClient"],"sources":["/home/micqdf/AlpacaPunchTests/maintest/test1/client/node_modules/ssh2/lib/server.js"],"sourcesContent":["// TODO:\n//   * convert listenerCount() usage to emit() return value checking?\n//   * emit error when connection severed early (e.g. before handshake)\n//   * add '.connected' or similar property to connection objects to allow\n//     immediate connection status checking\n'use strict';\n\nconst { Server: netServer } = require('net');\nconst EventEmitter = require('events');\nconst { listenerCount } = EventEmitter;\n\nconst {\n  CHANNEL_OPEN_FAILURE,\n  DEFAULT_CIPHER,\n  DEFAULT_COMPRESSION,\n  DEFAULT_KEX,\n  DEFAULT_MAC,\n  DEFAULT_SERVER_HOST_KEY,\n  DISCONNECT_REASON,\n  DISCONNECT_REASON_BY_VALUE,\n  SUPPORTED_CIPHER,\n  SUPPORTED_COMPRESSION,\n  SUPPORTED_KEX,\n  SUPPORTED_MAC,\n  SUPPORTED_SERVER_HOST_KEY,\n} = require('./protocol/constants.js');\nconst { init: cryptoInit } = require('./protocol/crypto.js');\nconst { KexInit } = require('./protocol/kex.js');\nconst { parseKey } = require('./protocol/keyParser.js');\nconst Protocol = require('./protocol/Protocol.js');\nconst { SFTP } = require('./protocol/SFTP.js');\nconst { writeUInt32BE } = require('./protocol/utils.js');\n\nconst {\n  Channel,\n  MAX_WINDOW,\n  PACKET_SIZE,\n  windowAdjust,\n  WINDOW_THRESHOLD,\n} = require('./Channel.js');\n\nconst {\n  ChannelManager,\n  generateAlgorithmList,\n  isWritable,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE,\n} = require('./utils.js');\n\nconst MAX_PENDING_AUTHS = 10;\n\nclass AuthContext extends EventEmitter {\n  constructor(protocol, username, service, method, cb) {\n    super();\n\n    this.username = this.user = username;\n    this.service = service;\n    this.method = method;\n    this._initialResponse = false;\n    this._finalResponse = false;\n    this._multistep = false;\n    this._cbfinal = (allowed, methodsLeft, isPartial) => {\n      if (!this._finalResponse) {\n        this._finalResponse = true;\n        cb(this, allowed, methodsLeft, isPartial);\n      }\n    };\n    this._protocol = protocol;\n  }\n\n  accept() {\n    this._cleanup && this._cleanup();\n    this._initialResponse = true;\n    this._cbfinal(true);\n  }\n  reject(methodsLeft, isPartial) {\n    this._cleanup && this._cleanup();\n    this._initialResponse = true;\n    this._cbfinal(false, methodsLeft, isPartial);\n  }\n}\n\n\nclass KeyboardAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, submethods, cb) {\n    super(protocol, username, service, method, cb);\n\n    this._multistep = true;\n\n    this._cb = undefined;\n    this._onInfoResponse = (responses) => {\n      const callback = this._cb;\n      if (callback) {\n        this._cb = undefined;\n        callback(responses);\n      }\n    };\n    this.submethods = submethods;\n    this.on('abort', () => {\n      this._cb && this._cb(new Error('Authentication request aborted'));\n    });\n  }\n\n  prompt(prompts, title, instructions, cb) {\n    if (!Array.isArray(prompts))\n      prompts = [ prompts ];\n\n    if (typeof title === 'function') {\n      cb = title;\n      title = instructions = undefined;\n    } else if (typeof instructions === 'function') {\n      cb = instructions;\n      instructions = undefined;\n    } else if (typeof cb !== 'function') {\n      cb = undefined;\n    }\n\n    for (let i = 0; i < prompts.length; ++i) {\n      if (typeof prompts[i] === 'string') {\n        prompts[i] = {\n          prompt: prompts[i],\n          echo: true\n        };\n      }\n    }\n\n    this._cb = cb;\n    this._initialResponse = true;\n\n    this._protocol.authInfoReq(title, instructions, prompts);\n  }\n}\n\nclass PKAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, pkInfo, cb) {\n    super(protocol, username, service, method, cb);\n\n    this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };\n    this.signature = pkInfo.signature;\n    this.blob = pkInfo.blob;\n  }\n\n  accept() {\n    if (!this.signature) {\n      this._initialResponse = true;\n      this._protocol.authPKOK(this.key.algo, this.key.data);\n    } else {\n      AuthContext.prototype.accept.call(this);\n    }\n  }\n}\n\nclass HostbasedAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, pkInfo, cb) {\n    super(protocol, username, service, method, cb);\n\n    this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };\n    this.signature = pkInfo.signature;\n    this.blob = pkInfo.blob;\n    this.localHostname = pkInfo.localHostname;\n    this.localUsername = pkInfo.localUsername;\n  }\n}\n\nclass PwdAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, password, cb) {\n    super(protocol, username, service, method, cb);\n\n    this.password = password;\n    this._changeCb = undefined;\n  }\n\n  requestChange(prompt, cb) {\n    if (this._changeCb)\n      throw new Error('Change request already in progress');\n    if (typeof prompt !== 'string')\n      throw new Error('prompt argument must be a string');\n    if (typeof cb !== 'function')\n      throw new Error('Callback argument must be a function');\n    this._changeCb = cb;\n    this._protocol.authPasswdChg(prompt);\n  }\n}\n\n\nclass Session extends EventEmitter {\n  constructor(client, info, localChan) {\n    super();\n\n    this.type = 'session';\n    this.subtype = undefined;\n    this.server = true;\n    this._ending = false;\n    this._channel = undefined;\n    this._chanInfo = {\n      type: 'session',\n      incoming: {\n        id: localChan,\n        window: MAX_WINDOW,\n        packetSize: PACKET_SIZE,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n  }\n}\n\n\nclass Server extends EventEmitter {\n  constructor(cfg, listener) {\n    super();\n\n    if (typeof cfg !== 'object' || cfg === null)\n      throw new Error('Missing configuration object');\n\n    const hostKeys = Object.create(null);\n    const hostKeyAlgoOrder = [];\n\n    const hostKeys_ = cfg.hostKeys;\n    if (!Array.isArray(hostKeys_))\n      throw new Error('hostKeys must be an array');\n\n    const cfgAlgos = (\n      typeof cfg.algorithms === 'object' && cfg.algorithms !== null\n      ? cfg.algorithms\n      : {}\n    );\n\n    const hostKeyAlgos = generateAlgorithmList(\n      cfgAlgos.serverHostKey,\n      DEFAULT_SERVER_HOST_KEY,\n      SUPPORTED_SERVER_HOST_KEY\n    );\n    for (let i = 0; i < hostKeys_.length; ++i) {\n      let privateKey;\n      if (Buffer.isBuffer(hostKeys_[i]) || typeof hostKeys_[i] === 'string')\n        privateKey = parseKey(hostKeys_[i]);\n      else\n        privateKey = parseKey(hostKeys_[i].key, hostKeys_[i].passphrase);\n\n      if (privateKey instanceof Error)\n        throw new Error(`Cannot parse privateKey: ${privateKey.message}`);\n\n      if (Array.isArray(privateKey)) {\n        // OpenSSH's newer format only stores 1 key for now\n        privateKey = privateKey[0];\n      }\n\n      if (privateKey.getPrivatePEM() === null)\n        throw new Error('privateKey value contains an invalid private key');\n\n      // Discard key if we already found a key of the same type\n      if (hostKeyAlgoOrder.includes(privateKey.type))\n        continue;\n\n      if (privateKey.type === 'ssh-rsa') {\n        // SSH supports multiple signature hashing algorithms for RSA, so we add\n        // the algorithms in the desired order\n        let sha1Pos = hostKeyAlgos.indexOf('ssh-rsa');\n        const sha256Pos = hostKeyAlgos.indexOf('rsa-sha2-256');\n        const sha512Pos = hostKeyAlgos.indexOf('rsa-sha2-512');\n        if (sha1Pos === -1) {\n          // Fall back to giving SHA1 the lowest priority\n          sha1Pos = Infinity;\n        }\n        [sha1Pos, sha256Pos, sha512Pos].sort(compareNumbers).forEach((pos) => {\n          if (pos === -1)\n            return;\n\n          let type;\n          switch (pos) {\n            case sha1Pos: type = 'ssh-rsa'; break;\n            case sha256Pos: type = 'rsa-sha2-256'; break;\n            case sha512Pos: type = 'rsa-sha2-512'; break;\n            default: return;\n          }\n\n          // Store same RSA key under each hash algorithm name for convenience\n          hostKeys[type] = privateKey;\n\n          hostKeyAlgoOrder.push(type);\n        });\n      } else {\n        hostKeys[privateKey.type] = privateKey;\n        hostKeyAlgoOrder.push(privateKey.type);\n      }\n    }\n\n    const algorithms = {\n      kex: generateAlgorithmList(cfgAlgos.kex, DEFAULT_KEX, SUPPORTED_KEX),\n      serverHostKey: hostKeyAlgoOrder,\n      cs: {\n        cipher: generateAlgorithmList(\n                  cfgAlgos.cipher,\n                  DEFAULT_CIPHER,\n                  SUPPORTED_CIPHER\n                ),\n        mac: generateAlgorithmList(cfgAlgos.hmac, DEFAULT_MAC, SUPPORTED_MAC),\n        compress: generateAlgorithmList(\n                    cfgAlgos.compress,\n                    DEFAULT_COMPRESSION,\n                    SUPPORTED_COMPRESSION\n                  ),\n        lang: [],\n      },\n      sc: undefined,\n    };\n    algorithms.sc = algorithms.cs;\n\n    if (typeof listener === 'function')\n      this.on('connection', listener);\n\n    const origDebug = (typeof cfg.debug === 'function' ? cfg.debug : undefined);\n    const ident = (cfg.ident ? Buffer.from(cfg.ident) : undefined);\n    const offer = new KexInit(algorithms);\n\n    this._srv = new netServer((socket) => {\n      if (this._connections >= this.maxConnections) {\n        socket.destroy();\n        return;\n      }\n      ++this._connections;\n      socket.once('close', () => {\n        --this._connections;\n      });\n\n      let debug;\n      if (origDebug) {\n        // Prepend debug output with a unique identifier in case there are\n        // multiple clients connected at the same time\n        const debugPrefix = `[${process.hrtime().join('.')}] `;\n        debug = (msg) => {\n          origDebug(`${debugPrefix}${msg}`);\n        };\n      }\n\n      // eslint-disable-next-line no-use-before-define\n      new Client(socket, hostKeys, ident, offer, debug, this, cfg);\n    }).on('error', (err) => {\n      this.emit('error', err);\n    }).on('listening', () => {\n      this.emit('listening');\n    }).on('close', () => {\n      this.emit('close');\n    });\n    this._connections = 0;\n    this.maxConnections = Infinity;\n  }\n\n  injectSocket(socket) {\n    this._srv.emit('connection', socket);\n  }\n\n  listen(...args) {\n    this._srv.listen(...args);\n    return this;\n  }\n\n  address() {\n    return this._srv.address();\n  }\n\n  getConnections(cb) {\n    this._srv.getConnections(cb);\n    return this;\n  }\n\n  close(cb) {\n    this._srv.close(cb);\n    return this;\n  }\n\n  ref() {\n    this._srv.ref();\n    return this;\n  }\n\n  unref() {\n    this._srv.unref();\n    return this;\n  }\n}\nServer.KEEPALIVE_CLIENT_INTERVAL = 15000;\nServer.KEEPALIVE_CLIENT_COUNT_MAX = 3;\n\n\nclass Client extends EventEmitter {\n  constructor(socket, hostKeys, ident, offer, debug, server, srvCfg) {\n    super();\n\n    let exchanges = 0;\n    let acceptedAuthSvc = false;\n    let pendingAuths = [];\n    let authCtx;\n    let kaTimer;\n    let onPacket;\n    const unsentGlobalRequestsReplies = [];\n    this._sock = socket;\n    this._chanMgr = new ChannelManager(this);\n    this._debug = debug;\n    this.noMoreSessions = false;\n    this.authenticated = false;\n\n    // Silence pre-header errors\n    function onClientPreHeaderError(err) {}\n    this.on('error', onClientPreHeaderError);\n\n    const DEBUG_HANDLER = (!debug ? undefined : (p, display, msg) => {\n      debug(`Debug output from client: ${JSON.stringify(msg)}`);\n    });\n\n    const kaIntvl = (\n      typeof srvCfg.keepaliveInterval === 'number'\n        && isFinite(srvCfg.keepaliveInterval)\n        && srvCfg.keepaliveInterval > 0\n      ? srvCfg.keepaliveInterval\n      : (\n        typeof Server.KEEPALIVE_CLIENT_INTERVAL === 'number'\n          && isFinite(Server.KEEPALIVE_CLIENT_INTERVAL)\n          && Server.KEEPALIVE_CLIENT_INTERVAL > 0\n        ? Server.KEEPALIVE_CLIENT_INTERVAL\n        : -1\n      )\n    );\n    const kaCountMax = (\n      typeof srvCfg.keepaliveCountMax === 'number'\n        && isFinite(srvCfg.keepaliveCountMax)\n        && srvCfg.keepaliveCountMax >= 0\n      ? srvCfg.keepaliveCountMax\n      : (\n        typeof Server.KEEPALIVE_CLIENT_COUNT_MAX === 'number'\n          && isFinite(Server.KEEPALIVE_CLIENT_COUNT_MAX)\n          && Server.KEEPALIVE_CLIENT_COUNT_MAX >= 0\n        ? Server.KEEPALIVE_CLIENT_COUNT_MAX\n        : -1\n      )\n    );\n    let kaCurCount = 0;\n    if (kaIntvl !== -1 && kaCountMax !== -1) {\n      this.once('ready', () => {\n        const onClose = () => {\n          clearInterval(kaTimer);\n        };\n        this.on('close', onClose).on('end', onClose);\n        kaTimer = setInterval(() => {\n          if (++kaCurCount > kaCountMax) {\n            clearInterval(kaTimer);\n            const err = new Error('Keepalive timeout');\n            err.level = 'client-timeout';\n            this.emit('error', err);\n            this.end();\n          } else {\n            // XXX: if the server ever starts sending real global requests to\n            //      the client, we will need to add a dummy callback here to\n            //      keep the correct reply order\n            proto.ping();\n          }\n        }, kaIntvl);\n      });\n      // TODO: re-verify keepalive behavior with OpenSSH\n      onPacket = () => {\n        kaTimer && kaTimer.refresh();\n        kaCurCount = 0;\n      };\n    }\n\n    const proto = this._protocol = new Protocol({\n      server: true,\n      hostKeys,\n      ident,\n      offer,\n      onPacket,\n      greeting: srvCfg.greeting,\n      banner: srvCfg.banner,\n      onWrite: (data) => {\n        if (isWritable(socket))\n          socket.write(data);\n      },\n      onError: (err) => {\n        if (!proto._destruct)\n          socket.removeAllListeners('data');\n        this.emit('error', err);\n        try {\n          socket.end();\n        } catch {}\n      },\n      onHeader: (header) => {\n        this.removeListener('error', onClientPreHeaderError);\n\n        const info = {\n          ip: socket.remoteAddress,\n          family: socket.remoteFamily,\n          port: socket.remotePort,\n          header,\n        };\n        if (!server.emit('connection', this, info)) {\n          // auto reject\n          proto.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n          socket.end();\n          return;\n        }\n\n        if (header.greeting)\n          this.emit('greeting', header.greeting);\n      },\n      onHandshakeComplete: (negotiated) => {\n        if (++exchanges > 1)\n          this.emit('rekey');\n        this.emit('handshake', negotiated);\n      },\n      debug,\n      messageHandlers: {\n        DEBUG: DEBUG_HANDLER,\n        DISCONNECT: (p, reason, desc) => {\n          if (reason !== DISCONNECT_REASON.BY_APPLICATION) {\n            if (!desc) {\n              desc = DISCONNECT_REASON_BY_VALUE[reason];\n              if (desc === undefined)\n                desc = `Unexpected disconnection reason: ${reason}`;\n            }\n            const err = new Error(desc);\n            err.code = reason;\n            this.emit('error', err);\n          }\n          socket.end();\n        },\n        CHANNEL_OPEN: (p, info) => {\n          // Handle incoming requests from client\n\n          // Do early reject in some cases to prevent wasteful channel\n          // allocation\n          if ((info.type === 'session' && this.noMoreSessions)\n              || !this.authenticated) {\n            const reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n            return proto.channelOpenFail(info.sender, reasonCode);\n          }\n\n          let localChan = -1;\n          let reason;\n          let replied = false;\n\n          let accept;\n          const reject = () => {\n            if (replied)\n              return;\n            replied = true;\n\n            if (reason === undefined) {\n              if (localChan === -1)\n                reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n              else\n                reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;\n            }\n\n            if (localChan !== -1)\n              this._chanMgr.remove(localChan);\n            proto.channelOpenFail(info.sender, reason, '');\n          };\n          const reserveChannel = () => {\n            localChan = this._chanMgr.add();\n\n            if (localChan === -1) {\n              reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n              if (debug) {\n                debug('Automatic rejection of incoming channel open: '\n                        + 'no channels available');\n              }\n            }\n\n            return (localChan !== -1);\n          };\n\n          const data = info.data;\n          switch (info.type) {\n            case 'session':\n              if (listenerCount(this, 'session') && reserveChannel()) {\n                accept = () => {\n                  if (replied)\n                    return;\n                  replied = true;\n\n                  const instance = new Session(this, info, localChan);\n                  this._chanMgr.update(localChan, instance);\n\n                  proto.channelOpenConfirm(info.sender,\n                                           localChan,\n                                           MAX_WINDOW,\n                                           PACKET_SIZE);\n\n                  return instance;\n                };\n\n                this.emit('session', accept, reject);\n                return;\n              }\n              break;\n            case 'direct-tcpip':\n              if (listenerCount(this, 'tcpip') && reserveChannel()) {\n                accept = () => {\n                  if (replied)\n                    return;\n                  replied = true;\n\n                  const chanInfo = {\n                    type: undefined,\n                    incoming: {\n                      id: localChan,\n                      window: MAX_WINDOW,\n                      packetSize: PACKET_SIZE,\n                      state: 'open'\n                    },\n                    outgoing: {\n                      id: info.sender,\n                      window: info.window,\n                      packetSize: info.packetSize,\n                      state: 'open'\n                    }\n                  };\n\n                  const stream = new Channel(this, chanInfo, { server: true });\n                  this._chanMgr.update(localChan, stream);\n\n                  proto.channelOpenConfirm(info.sender,\n                                           localChan,\n                                           MAX_WINDOW,\n                                           PACKET_SIZE);\n\n                  return stream;\n                };\n\n                this.emit('tcpip', accept, reject, data);\n                return;\n              }\n              break;\n            case 'direct-streamlocal@openssh.com':\n              if (listenerCount(this, 'openssh.streamlocal')\n                  && reserveChannel()) {\n                accept = () => {\n                  if (replied)\n                    return;\n                  replied = true;\n\n                  const chanInfo = {\n                    type: undefined,\n                    incoming: {\n                      id: localChan,\n                      window: MAX_WINDOW,\n                      packetSize: PACKET_SIZE,\n                      state: 'open'\n                    },\n                    outgoing: {\n                      id: info.sender,\n                      window: info.window,\n                      packetSize: info.packetSize,\n                      state: 'open'\n                    }\n                  };\n\n                  const stream = new Channel(this, chanInfo, { server: true });\n                  this._chanMgr.update(localChan, stream);\n\n                  proto.channelOpenConfirm(info.sender,\n                                           localChan,\n                                           MAX_WINDOW,\n                                           PACKET_SIZE);\n\n                  return stream;\n                };\n\n                this.emit('openssh.streamlocal', accept, reject, data);\n                return;\n              }\n              break;\n            default:\n              // Automatically reject any unsupported channel open requests\n              reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;\n              if (debug) {\n                debug('Automatic rejection of unsupported incoming channel open'\n                        + ` type: ${info.type}`);\n              }\n          }\n\n          if (reason === undefined) {\n            reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n            if (debug) {\n              debug('Automatic rejection of unexpected incoming channel open'\n                      + ` for: ${info.type}`);\n            }\n          }\n\n          reject();\n        },\n        CHANNEL_OPEN_CONFIRMATION: (p, info) => {\n          const channel = this._chanMgr.get(info.recipient);\n          if (typeof channel !== 'function')\n            return;\n\n          const chanInfo = {\n            type: channel.type,\n            incoming: {\n              id: info.recipient,\n              window: MAX_WINDOW,\n              packetSize: PACKET_SIZE,\n              state: 'open'\n            },\n            outgoing: {\n              id: info.sender,\n              window: info.window,\n              packetSize: info.packetSize,\n              state: 'open'\n            }\n          };\n\n          const instance = new Channel(this, chanInfo, { server: true });\n          this._chanMgr.update(info.recipient, instance);\n          channel(undefined, instance);\n        },\n        CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'function')\n            return;\n\n          const info = { reason, description };\n          onChannelOpenFailure(this, recipient, info, channel);\n        },\n        CHANNEL_DATA: (p, recipient, data) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel)\n              return;\n          }\n\n          // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n          if (channel.incoming.window === 0)\n            return;\n\n          channel.incoming.window -= data.length;\n\n          if (channel.push(data) === false) {\n            channel._waitChanDrain = true;\n            return;\n          }\n\n          if (channel.incoming.window <= WINDOW_THRESHOLD)\n            windowAdjust(channel);\n        },\n        CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {\n          // NOOP -- should not be sent by client\n        },\n        CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel)\n              return;\n          }\n\n          // The other side is allowing us to send `amount` more bytes of data\n          channel.outgoing.window += amount;\n\n          if (channel._waitWindow) {\n            channel._waitWindow = false;\n\n            if (channel._chunk) {\n              channel._write(channel._chunk, null, channel._chunkcb);\n            } else if (channel._chunkcb) {\n              channel._chunkcb();\n            } else if (channel._chunkErr) {\n              channel.stderr._write(channel._chunkErr,\n                                    null,\n                                    channel._chunkcbErr);\n            } else if (channel._chunkcbErr) {\n              channel._chunkcbErr();\n            }\n          }\n        },\n        CHANNEL_SUCCESS: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel)\n              return;\n          }\n\n          if (channel._callbacks.length)\n            channel._callbacks.shift()(false);\n        },\n        CHANNEL_FAILURE: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel)\n              return;\n          }\n\n          if (channel._callbacks.length)\n            channel._callbacks.shift()(true);\n        },\n        CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {\n          const session = this._chanMgr.get(recipient);\n          if (typeof session !== 'object' || session === null)\n            return;\n\n          let replied = false;\n          let accept;\n          let reject;\n\n          if (session.constructor !== Session) {\n            // normal Channel instance\n            if (wantReply)\n              proto.channelFailure(session.outgoing.id);\n            return;\n          }\n\n          if (wantReply) {\n            // \"real session\" requests will have custom accept behaviors\n            if (type !== 'shell'\n                && type !== 'exec'\n                && type !== 'subsystem') {\n              accept = () => {\n                if (replied || session._ending || session._channel)\n                  return;\n                replied = true;\n\n                proto.channelSuccess(session._chanInfo.outgoing.id);\n              };\n            }\n\n            reject = () => {\n              if (replied || session._ending || session._channel)\n                return;\n              replied = true;\n\n              proto.channelFailure(session._chanInfo.outgoing.id);\n            };\n          }\n\n          if (session._ending) {\n            reject && reject();\n            return;\n          }\n\n          switch (type) {\n            // \"pre-real session start\" requests\n            case 'env':\n              if (listenerCount(session, 'env')) {\n                session.emit('env', accept, reject, {\n                  key: data.name,\n                  val: data.value\n                });\n                return;\n              }\n              break;\n            case 'pty-req':\n              if (listenerCount(session, 'pty')) {\n                session.emit('pty', accept, reject, data);\n                return;\n              }\n              break;\n            case 'window-change':\n              if (listenerCount(session, 'window-change'))\n                session.emit('window-change', accept, reject, data);\n              else\n                reject && reject();\n              break;\n            case 'x11-req':\n              if (listenerCount(session, 'x11')) {\n                session.emit('x11', accept, reject, data);\n                return;\n              }\n              break;\n            // \"post-real session start\" requests\n            case 'signal':\n              if (listenerCount(session, 'signal')) {\n                session.emit('signal', accept, reject, {\n                  name: data\n                });\n                return;\n              }\n              break;\n            // XXX: is `auth-agent-req@openssh.com` really \"post-real session\n            // start\"?\n            case 'auth-agent-req@openssh.com':\n              if (listenerCount(session, 'auth-agent')) {\n                session.emit('auth-agent', accept, reject);\n                return;\n              }\n              break;\n            // \"real session start\" requests\n            case 'shell':\n              if (listenerCount(session, 'shell')) {\n                accept = () => {\n                  if (replied || session._ending || session._channel)\n                    return;\n                  replied = true;\n\n                  if (wantReply)\n                    proto.channelSuccess(session._chanInfo.outgoing.id);\n\n                  const channel = new Channel(\n                    this, session._chanInfo, { server: true }\n                  );\n\n                  channel.subtype = session.subtype = type;\n                  session._channel = channel;\n\n                  return channel;\n                };\n\n                session.emit('shell', accept, reject);\n                return;\n              }\n              break;\n            case 'exec':\n              if (listenerCount(session, 'exec')) {\n                accept = () => {\n                  if (replied || session._ending || session._channel)\n                    return;\n                  replied = true;\n\n                  if (wantReply)\n                    proto.channelSuccess(session._chanInfo.outgoing.id);\n\n                  const channel = new Channel(\n                    this, session._chanInfo, { server: true }\n                  );\n\n                  channel.subtype = session.subtype = type;\n                  session._channel = channel;\n\n                  return channel;\n                };\n\n                session.emit('exec', accept, reject, {\n                  command: data\n                });\n                return;\n              }\n              break;\n            case 'subsystem': {\n              let useSFTP = (data === 'sftp');\n              accept = () => {\n                if (replied || session._ending || session._channel)\n                  return;\n                replied = true;\n\n                if (wantReply)\n                  proto.channelSuccess(session._chanInfo.outgoing.id);\n\n                let instance;\n                if (useSFTP) {\n                  instance = new SFTP(this, session._chanInfo, {\n                    server: true,\n                    debug,\n                  });\n                } else {\n                  instance = new Channel(\n                    this, session._chanInfo, { server: true }\n                  );\n                  instance.subtype =\n                    session.subtype = `${type}:${data}`;\n                }\n                session._channel = instance;\n\n                return instance;\n              };\n\n              if (data === 'sftp') {\n                if (listenerCount(session, 'sftp')) {\n                  session.emit('sftp', accept, reject);\n                  return;\n                }\n                useSFTP = false;\n              }\n              if (listenerCount(session, 'subsystem')) {\n                session.emit('subsystem', accept, reject, {\n                  name: data\n                });\n                return;\n              }\n              break;\n            }\n          }\n          debug && debug(\n            `Automatic rejection of incoming channel request: ${type}`\n          );\n          reject && reject();\n        },\n        CHANNEL_EOF: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          if (channel.constructor === Session) {\n            if (!channel._ending) {\n              channel._ending = true;\n              channel.emit('eof');\n              channel.emit('end');\n            }\n            channel = channel._channel;\n            if (!channel)\n              return;\n          }\n\n          if (channel.incoming.state !== 'open')\n            return;\n          channel.incoming.state = 'eof';\n\n          if (channel.readable)\n            channel.push(null);\n        },\n        CHANNEL_CLOSE: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          if (channel.constructor === Session) {\n            channel._ending = true;\n            channel.emit('close');\n            channel = channel._channel;\n            if (!channel)\n              return;\n          }\n\n          onCHANNEL_CLOSE(this, recipient, channel);\n        },\n        // Begin service/auth-related ==========================================\n        SERVICE_REQUEST: (p, service) => {\n          if (exchanges === 0\n              || acceptedAuthSvc\n              || this.authenticated\n              || service !== 'ssh-userauth') {\n            proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);\n            socket.end();\n            return;\n          }\n\n          acceptedAuthSvc = true;\n          proto.serviceAccept(service);\n        },\n        USERAUTH_REQUEST: (p, username, service, method, methodData) => {\n          if (exchanges === 0\n              || this.authenticated\n              || (authCtx\n                  && (authCtx.username !== username\n                      || authCtx.service !== service))\n                // TODO: support hostbased auth\n              || (method !== 'password'\n                  && method !== 'publickey'\n                  && method !== 'hostbased'\n                  && method !== 'keyboard-interactive'\n                  && method !== 'none')\n              || pendingAuths.length === MAX_PENDING_AUTHS) {\n            proto.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n            socket.end();\n            return;\n          } else if (service !== 'ssh-connection') {\n            proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);\n            socket.end();\n            return;\n          }\n\n          let ctx;\n          switch (method) {\n            case 'keyboard-interactive':\n              ctx = new KeyboardAuthContext(proto, username, service, method,\n                                            methodData, onAuthDecide);\n              break;\n            case 'publickey':\n              ctx = new PKAuthContext(proto, username, service, method,\n                                      methodData, onAuthDecide);\n              break;\n            case 'hostbased':\n              ctx = new HostbasedAuthContext(proto, username, service, method,\n                                             methodData, onAuthDecide);\n              break;\n            case 'password':\n              if (authCtx\n                  && authCtx instanceof PwdAuthContext\n                  && authCtx._changeCb) {\n                const cb = authCtx._changeCb;\n                authCtx._changeCb = undefined;\n                cb(methodData.newPassword);\n                return;\n              }\n              ctx = new PwdAuthContext(proto, username, service, method,\n                                       methodData, onAuthDecide);\n              break;\n            case 'none':\n              ctx = new AuthContext(proto, username, service, method,\n                                    onAuthDecide);\n              break;\n          }\n\n          if (authCtx) {\n            if (!authCtx._initialResponse) {\n              return pendingAuths.push(ctx);\n            } else if (authCtx._multistep && !authCtx._finalResponse) {\n              // RFC 4252 says to silently abort the current auth request if a\n              // new auth request comes in before the final response from an\n              // auth method that requires additional request/response exchanges\n              // -- this means keyboard-interactive for now ...\n              authCtx._cleanup && authCtx._cleanup();\n              authCtx.emit('abort');\n            }\n          }\n\n          authCtx = ctx;\n\n          if (listenerCount(this, 'authentication'))\n            this.emit('authentication', authCtx);\n          else\n            authCtx.reject();\n        },\n        USERAUTH_INFO_RESPONSE: (p, responses) => {\n          if (authCtx && authCtx instanceof KeyboardAuthContext)\n            authCtx._onInfoResponse(responses);\n        },\n        // End service/auth-related ============================================\n        GLOBAL_REQUEST: (p, name, wantReply, data) => {\n          const reply = {\n            type: null,\n            buf: null\n          };\n\n          function setReply(type, buf) {\n            reply.type = type;\n            reply.buf = buf;\n            sendReplies();\n          }\n\n          if (wantReply)\n            unsentGlobalRequestsReplies.push(reply);\n\n          if ((name === 'tcpip-forward'\n               || name === 'cancel-tcpip-forward'\n               || name === 'no-more-sessions@openssh.com'\n               || name === 'streamlocal-forward@openssh.com'\n               || name === 'cancel-streamlocal-forward@openssh.com')\n              && listenerCount(this, 'request')\n              && this.authenticated) {\n            let accept;\n            let reject;\n\n            if (wantReply) {\n              let replied = false;\n              accept = (chosenPort) => {\n                if (replied)\n                  return;\n                replied = true;\n                let bufPort;\n                if (name === 'tcpip-forward'\n                    && data.bindPort === 0\n                    && typeof chosenPort === 'number') {\n                  bufPort = Buffer.allocUnsafe(4);\n                  writeUInt32BE(bufPort, chosenPort, 0);\n                }\n                setReply('SUCCESS', bufPort);\n              };\n              reject = () => {\n                if (replied)\n                  return;\n                replied = true;\n                setReply('FAILURE');\n              };\n            }\n\n            if (name === 'no-more-sessions@openssh.com') {\n              this.noMoreSessions = true;\n              accept && accept();\n              return;\n            }\n\n            this.emit('request', accept, reject, name, data);\n          } else if (wantReply) {\n            setReply('FAILURE');\n          }\n        },\n      },\n    });\n\n    socket.pause();\n    cryptoInit.then(() => {\n      proto.start();\n      socket.on('data', (data) => {\n        try {\n          proto.parse(data, 0, data.length);\n        } catch (ex) {\n          this.emit('error', ex);\n          try {\n            if (isWritable(socket))\n              socket.end();\n          } catch {}\n        }\n      });\n      socket.resume();\n    }).catch((err) => {\n      this.emit('error', err);\n      try {\n        if (isWritable(socket))\n          socket.end();\n      } catch {}\n    });\n    socket.on('error', (err) => {\n      err.level = 'socket';\n      this.emit('error', err);\n    }).once('end', () => {\n      debug && debug('Socket ended');\n      proto.cleanup();\n      this.emit('end');\n    }).once('close', () => {\n      debug && debug('Socket closed');\n      proto.cleanup();\n      this.emit('close');\n\n      const err = new Error('No response from server');\n\n      // Simulate error for pending channels and close any open channels\n      this._chanMgr.cleanup(err);\n    });\n\n    const onAuthDecide = (ctx, allowed, methodsLeft, isPartial) => {\n      if (authCtx === ctx && !this.authenticated) {\n        if (allowed) {\n          authCtx = undefined;\n          this.authenticated = true;\n          proto.authSuccess();\n          pendingAuths = [];\n          this.emit('ready');\n        } else {\n          proto.authFailure(methodsLeft, isPartial);\n          if (pendingAuths.length) {\n            authCtx = pendingAuths.pop();\n            if (listenerCount(this, 'authentication'))\n              this.emit('authentication', authCtx);\n            else\n              authCtx.reject();\n          }\n        }\n      }\n    };\n\n    function sendReplies() {\n      while (unsentGlobalRequestsReplies.length > 0\n             && unsentGlobalRequestsReplies[0].type) {\n        const reply = unsentGlobalRequestsReplies.shift();\n        if (reply.type === 'SUCCESS')\n          proto.requestSuccess(reply.buf);\n        if (reply.type === 'FAILURE')\n          proto.requestFailure();\n      }\n    }\n  }\n\n  end() {\n    if (this._sock && isWritable(this._sock)) {\n      this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n      this._sock.end();\n    }\n    return this;\n  }\n\n  x11(originAddr, originPort, cb) {\n    const opts = { originAddr, originPort };\n    openChannel(this, 'x11', opts, cb);\n    return this;\n  }\n\n  forwardOut(boundAddr, boundPort, remoteAddr, remotePort, cb) {\n    const opts = { boundAddr, boundPort, remoteAddr, remotePort };\n    openChannel(this, 'forwarded-tcpip', opts, cb);\n    return this;\n  }\n\n  openssh_forwardOutStreamLocal(socketPath, cb) {\n    const opts = { socketPath };\n    openChannel(this, 'forwarded-streamlocal@openssh.com', opts, cb);\n    return this;\n  }\n\n  rekey(cb) {\n    let error;\n\n    try {\n      this._protocol.rekey();\n    } catch (ex) {\n      error = ex;\n    }\n\n    // TODO: re-throw error if no callback?\n\n    if (typeof cb === 'function') {\n      if (error)\n        process.nextTick(cb, error);\n      else\n        this.once('rekey', cb);\n    }\n  }\n}\n\n\nfunction openChannel(self, type, opts, cb) {\n  // Ask the client to open a channel for some purpose (e.g. a forwarded TCP\n  // connection)\n  const initWindow = MAX_WINDOW;\n  const maxPacket = PACKET_SIZE;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  const wrapper = (err, stream) => {\n    cb(err, stream);\n  };\n  wrapper.type = type;\n\n  const localChan = self._chanMgr.add(wrapper);\n\n  if (localChan === -1) {\n    cb(new Error('No free channels available'));\n    return;\n  }\n\n  switch (type) {\n    case 'forwarded-tcpip':\n      self._protocol.forwardedTcpip(localChan, initWindow, maxPacket, opts);\n      break;\n    case 'x11':\n      self._protocol.x11(localChan, initWindow, maxPacket, opts);\n      break;\n    case 'forwarded-streamlocal@openssh.com':\n      self._protocol.openssh_forwardedStreamLocal(\n        localChan, initWindow, maxPacket, opts\n      );\n      break;\n    default:\n      throw new Error(`Unsupported channel type: ${type}`);\n  }\n}\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\nmodule.exports = Server;\nmodule.exports.IncomingClient = Client;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}