{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst fs = require('fs');\n\nconst {\n  constants\n} = fs;\n\nconst {\n  Readable: ReadableStream,\n  Writable: WritableStream\n} = require('stream');\n\nconst {\n  inherits,\n  isDate\n} = require('util');\n\nconst FastBuffer = Buffer[Symbol.species];\n\nconst {\n  bufferCopy,\n  bufferSlice,\n  makeBufferParser,\n  writeUInt32BE\n} = require('./utils.js');\n\nconst ATTR = {\n  SIZE: 0x00000001,\n  UIDGID: 0x00000002,\n  PERMISSIONS: 0x00000004,\n  ACMODTIME: 0x00000008,\n  EXTENDED: 0x80000000\n}; // Large enough to store all possible attributes\n\nconst ATTRS_BUF = Buffer.alloc(28);\nconst STATUS_CODE = {\n  OK: 0,\n  EOF: 1,\n  NO_SUCH_FILE: 2,\n  PERMISSION_DENIED: 3,\n  FAILURE: 4,\n  BAD_MESSAGE: 5,\n  NO_CONNECTION: 6,\n  CONNECTION_LOST: 7,\n  OP_UNSUPPORTED: 8\n};\nconst VALID_STATUS_CODES = new Map(Object.values(STATUS_CODE).map(n => [n, 1]));\nconst STATUS_CODE_STR = {\n  [STATUS_CODE.OK]: 'No error',\n  [STATUS_CODE.EOF]: 'End of file',\n  [STATUS_CODE.NO_SUCH_FILE]: 'No such file or directory',\n  [STATUS_CODE.PERMISSION_DENIED]: 'Permission denied',\n  [STATUS_CODE.FAILURE]: 'Failure',\n  [STATUS_CODE.BAD_MESSAGE]: 'Bad message',\n  [STATUS_CODE.NO_CONNECTION]: 'No connection',\n  [STATUS_CODE.CONNECTION_LOST]: 'Connection lost',\n  [STATUS_CODE.OP_UNSUPPORTED]: 'Operation unsupported'\n};\nconst REQUEST = {\n  INIT: 1,\n  OPEN: 3,\n  CLOSE: 4,\n  READ: 5,\n  WRITE: 6,\n  LSTAT: 7,\n  FSTAT: 8,\n  SETSTAT: 9,\n  FSETSTAT: 10,\n  OPENDIR: 11,\n  READDIR: 12,\n  REMOVE: 13,\n  MKDIR: 14,\n  RMDIR: 15,\n  REALPATH: 16,\n  STAT: 17,\n  RENAME: 18,\n  READLINK: 19,\n  SYMLINK: 20,\n  EXTENDED: 200\n};\nconst RESPONSE = {\n  VERSION: 2,\n  STATUS: 101,\n  HANDLE: 102,\n  DATA: 103,\n  NAME: 104,\n  ATTRS: 105,\n  EXTENDED: 201\n};\nconst OPEN_MODE = {\n  READ: 0x00000001,\n  WRITE: 0x00000002,\n  APPEND: 0x00000004,\n  CREAT: 0x00000008,\n  TRUNC: 0x00000010,\n  EXCL: 0x00000020\n};\nconst PKT_RW_OVERHEAD = 2 * 1024;\nconst MAX_REQID = 2 ** 32 - 1;\nconst CLIENT_VERSION_BUFFER = Buffer.from([0, 0, 0, 5\n/* length */\n, REQUEST.INIT, 0, 0, 0, 3\n/* version */\n]);\nconst SERVER_VERSION_BUFFER = Buffer.from([0, 0, 0, 5\n/* length */\n, RESPONSE.VERSION, 0, 0, 0, 3\n/* version */\n]);\nconst RE_OPENSSH = /^SSH-2.0-(?:OpenSSH|dropbear)/;\nconst OPENSSH_MAX_PKT_LEN = 256 * 1024;\nconst bufferParser = makeBufferParser();\nconst fakeStderr = {\n  readable: false,\n  writable: false,\n  push: data => {},\n  once: () => {},\n  on: () => {},\n  emit: () => {},\n  end: () => {}\n};\n\nfunction noop() {} // Emulates enough of `Channel` to be able to be used as a drop-in replacement\n// in order to process incoming data with as little overhead as possible\n\n\nclass SFTP extends EventEmitter {\n  constructor(client, chanInfo, cfg) {\n    super();\n    if (typeof cfg !== 'object' || !cfg) cfg = {};\n    const remoteIdentRaw = client._protocol._remoteIdentRaw;\n    this.server = !!cfg.server;\n    this._debug = typeof cfg.debug === 'function' ? cfg.debug : undefined;\n    this._isOpenSSH = remoteIdentRaw && RE_OPENSSH.test(remoteIdentRaw);\n    this._version = -1;\n    this._extensions = {};\n    this._biOpt = cfg.biOpt;\n    this._pktLenBytes = 0;\n    this._pktLen = 0;\n    this._pktPos = 0;\n    this._pktType = 0;\n    this._pktData = undefined;\n    this._writeReqid = -1;\n    this._requests = {};\n    this._maxInPktLen = OPENSSH_MAX_PKT_LEN;\n    this._maxOutPktLen = 34000;\n    this._maxReadLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34000) - PKT_RW_OVERHEAD;\n    this._maxWriteLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34000) - PKT_RW_OVERHEAD;\n    this.maxOpenHandles = undefined; // Channel compatibility\n\n    this._client = client;\n    this._protocol = client._protocol;\n    this._callbacks = [];\n    this._hasX11 = false;\n    this._exit = {\n      code: undefined,\n      signal: undefined,\n      dump: undefined,\n      desc: undefined\n    };\n    this._waitWindow = false; // SSH-level backpressure\n\n    this._chunkcb = undefined;\n    this._buffer = [];\n    this.type = chanInfo.type;\n    this.subtype = undefined;\n    this.incoming = chanInfo.incoming;\n    this.outgoing = chanInfo.outgoing;\n    this.stderr = fakeStderr;\n    this.readable = true;\n  } // This handles incoming data to parse\n\n\n  push(data) {\n    if (data === null) {\n      cleanupRequests(this);\n      if (!this.readable) return; // No more incoming data from the remote side\n\n      this.readable = false;\n      this.emit('end');\n      return;\n    }\n    /*\n        uint32             length\n        byte               type\n        byte[length - 1]   data payload\n    */\n\n\n    let p = 0;\n\n    while (p < data.length) {\n      if (this._pktLenBytes < 4) {\n        let nb = Math.min(4 - this._pktLenBytes, data.length - p);\n        this._pktLenBytes += nb;\n\n        while (nb--) this._pktLen = (this._pktLen << 8) + data[p++];\n\n        if (this._pktLenBytes < 4) return;\n        if (this._pktLen === 0) return doFatalSFTPError(this, 'Invalid packet length');\n\n        if (this._pktLen > this._maxInPktLen) {\n          const max = this._maxInPktLen;\n          return doFatalSFTPError(this, `Packet length ${this._pktLen} exceeds max length of ${max}`);\n        }\n\n        if (p >= data.length) return;\n      }\n\n      if (this._pktPos < this._pktLen) {\n        const nb = Math.min(this._pktLen - this._pktPos, data.length - p);\n\n        if (p !== 0 || nb !== data.length) {\n          if (nb === this._pktLen) {\n            this._pkt = new FastBuffer(data.buffer, data.byteOffset + p, nb);\n          } else {\n            if (!this._pkt) this._pkt = Buffer.allocUnsafe(this._pktLen);\n\n            this._pkt.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._pktPos);\n          }\n        } else if (nb === this._pktLen) {\n          this._pkt = data;\n        } else {\n          if (!this._pkt) this._pkt = Buffer.allocUnsafe(this._pktLen);\n\n          this._pkt.set(data, this._pktPos);\n        }\n\n        p += nb;\n        this._pktPos += nb;\n        if (this._pktPos < this._pktLen) return;\n      }\n\n      const type = this._pkt[0];\n      const payload = this._pkt; // Prepare for next packet\n\n      this._pktLen = 0;\n      this._pktLenBytes = 0;\n      this._pkt = undefined;\n      this._pktPos = 0;\n      const handler = this.server ? SERVER_HANDLERS[type] : CLIENT_HANDLERS[type];\n      if (!handler) return doFatalSFTPError(this, `Unknown packet type ${type}`);\n\n      if (this._version === -1) {\n        if (this.server) {\n          if (type !== REQUEST.INIT) return doFatalSFTPError(this, `Expected INIT packet, got ${type}`);\n        } else if (type !== RESPONSE.VERSION) {\n          return doFatalSFTPError(this, `Expected VERSION packet, got ${type}`);\n        }\n      }\n\n      if (handler(this, payload) === false) return;\n    }\n  }\n\n  end() {\n    this.destroy();\n  }\n\n  destroy() {\n    if (this.outgoing.state === 'open' || this.outgoing.state === 'eof') {\n      this.outgoing.state = 'closing';\n\n      this._protocol.channelClose(this.outgoing.id);\n    }\n  }\n\n  _init() {\n    this._init = noop;\n    if (!this.server) sendOrBuffer(this, CLIENT_VERSION_BUFFER);\n  } // ===========================================================================\n  // Client-specific ===========================================================\n  // ===========================================================================\n\n\n  createReadStream(path, options) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    return new ReadStream(this, path, options);\n  }\n\n  createWriteStream(path, options) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    return new WriteStream(this, path, options);\n  }\n\n  open(path, flags_, attrs, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    if (typeof attrs === 'function') {\n      cb = attrs;\n      attrs = undefined;\n    }\n\n    const flags = typeof flags_ === 'number' ? flags_ : stringToFlags(flags_);\n    if (flags === null) throw new Error(`Unknown flags string: ${flags_}`);\n    let attrsFlags = 0;\n    let attrsLen = 0;\n    if (typeof attrs === 'string' || typeof attrs === 'number') attrs = {\n      mode: attrs\n    };\n\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      attrsFlags = attrs.flags;\n      attrsLen = attrs.nb;\n    }\n    /*\n      uint32        id\n      string        filename\n      uint32        pflags\n      ATTRS         attrs\n    */\n\n\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.OPEN;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n    writeUInt32BE(buf, attrsFlags, p += 4);\n\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} OPEN`);\n  }\n\n  close(handle, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n    /*\n      uint32     id\n      string     handle\n    */\n\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.CLOSE;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(handle, p += 4);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} CLOSE`);\n  }\n\n  read(handle, buf, off, len, position, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n    if (!Buffer.isBuffer(buf)) throw new Error('buffer is not a Buffer');\n    if (off >= buf.length) throw new Error('offset is out of bounds');\n    if (off + len > buf.length) throw new Error('length extends beyond buffer');\n    if (position === null) throw new Error('null position currently unsupported');\n    read_(this, handle, buf, off, len, position, cb);\n  }\n\n  readData(handle, buf, off, len, position, cb) {\n    // Backwards compatibility\n    this.read(handle, buf, off, len, position, cb);\n  }\n\n  write(handle, buf, off, len, position, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n    if (!Buffer.isBuffer(buf)) throw new Error('buffer is not a Buffer');\n    if (off > buf.length) throw new Error('offset is out of bounds');\n    if (off + len > buf.length) throw new Error('length extends beyond buffer');\n    if (position === null) throw new Error('null position currently unsupported');\n\n    if (!len) {\n      cb && process.nextTick(cb, undefined, 0);\n      return;\n    }\n\n    const maxDataLen = this._maxWriteLen;\n    const overflow = Math.max(len - maxDataLen, 0);\n    const origPosition = position;\n    if (overflow) len = maxDataLen;\n    /*\n      uint32     id\n      string     handle\n      uint64     offset\n      string     data\n    */\n\n    const handleLen = handle.length;\n    let p = 9;\n    const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4 + len);\n    writeUInt32BE(out, out.length - 4, 0);\n    out[4] = REQUEST.WRITE;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(out, reqid, 5);\n    writeUInt32BE(out, handleLen, p);\n    out.set(handle, p += 4);\n    p += handleLen;\n\n    for (let i = 7; i >= 0; --i) {\n      out[p + i] = position & 0xFF;\n      position /= 256;\n    }\n\n    writeUInt32BE(out, len, p += 8);\n    bufferCopy(buf, out, off, off + len, p += 4);\n    this._requests[reqid] = {\n      cb: err => {\n        if (err) {\n          if (typeof cb === 'function') cb(err);\n        } else if (overflow) {\n          this.write(handle, buf, off + len, overflow, origPosition + len, cb);\n        } else if (typeof cb === 'function') {\n          cb(undefined, off + len);\n        }\n      }\n    };\n    const isSent = sendOrBuffer(this, out);\n\n    if (this._debug) {\n      const how = isSent ? 'Sent' : 'Buffered';\n\n      this._debug(`SFTP: Outbound: ${how} WRITE (id:${reqid})`);\n    }\n  }\n\n  writeData(handle, buf, off, len, position, cb) {\n    // Backwards compatibility\n    this.write(handle, buf, off, len, position, cb);\n  }\n\n  fastGet(remotePath, localPath, opts, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    fastXfer(this, fs, remotePath, localPath, opts, cb);\n  }\n\n  fastPut(localPath, remotePath, opts, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    fastXfer(fs, this, localPath, remotePath, opts, cb);\n  }\n\n  readFile(path, options, callback_) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    let callback;\n\n    if (typeof callback_ === 'function') {\n      callback = callback_;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n\n    if (typeof options === 'string') options = {\n      encoding: options,\n      flag: 'r'\n    };else if (!options) options = {\n      encoding: null,\n      flag: 'r'\n    };else if (typeof options !== 'object') throw new TypeError('Bad arguments');\n    const encoding = options.encoding;\n    if (encoding && !Buffer.isEncoding(encoding)) throw new Error(`Unknown encoding: ${encoding}`); // First stat the file, so we know the size.\n\n    let size;\n    let buffer; // Single buffer with file data\n\n    let buffers; // List for when size is unknown\n\n    let pos = 0;\n    let handle; // SFTPv3 does not support using -1 for read position, so we have to track\n    // read position manually\n\n    let bytesRead = 0;\n    const flag = options.flag || 'r';\n\n    const read = () => {\n      if (size === 0) {\n        buffer = Buffer.allocUnsafe(8192);\n        this.read(handle, buffer, 0, 8192, bytesRead, afterRead);\n      } else {\n        this.read(handle, buffer, pos, size - pos, bytesRead, afterRead);\n      }\n    };\n\n    const afterRead = (er, nbytes) => {\n      let eof;\n\n      if (er) {\n        eof = er.code === STATUS_CODE.EOF;\n\n        if (!eof) {\n          return this.close(handle, () => {\n            return callback && callback(er);\n          });\n        }\n      } else {\n        eof = false;\n      }\n\n      if (eof || size === 0 && nbytes === 0) return close();\n      bytesRead += nbytes;\n      pos += nbytes;\n\n      if (size !== 0) {\n        if (pos === size) close();else read();\n      } else {\n        // Unknown size, just read until we don't get bytes.\n        buffers.push(bufferSlice(buffer, 0, nbytes));\n        read();\n      }\n    };\n\n    afterRead._wantEOFError = true;\n\n    const close = () => {\n      this.close(handle, er => {\n        if (size === 0) {\n          // Collect the data into the buffers list.\n          buffer = Buffer.concat(buffers, pos);\n        } else if (pos < size) {\n          buffer = bufferSlice(buffer, 0, pos);\n        }\n\n        if (encoding) buffer = buffer.toString(encoding);\n        return callback && callback(er, buffer);\n      });\n    };\n\n    this.open(path, flag, 0o666, (er, handle_) => {\n      if (er) return callback && callback(er);\n      handle = handle_;\n\n      const tryStat = (er, st) => {\n        if (er) {\n          // Try stat() for sftp servers that may not support fstat() for\n          // whatever reason\n          this.stat(path, (er_, st_) => {\n            if (er_) {\n              return this.close(handle, () => {\n                callback && callback(er);\n              });\n            }\n\n            tryStat(null, st_);\n          });\n          return;\n        }\n\n        size = st.size || 0;\n\n        if (size === 0) {\n          // The kernel lies about many files.\n          // Go ahead and try to read some bytes.\n          buffers = [];\n          return read();\n        }\n\n        buffer = Buffer.allocUnsafe(size);\n        read();\n      };\n\n      this.fstat(handle, tryStat);\n    });\n  }\n\n  writeFile(path, data, options, callback_) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    let callback;\n\n    if (typeof callback_ === 'function') {\n      callback = callback_;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n\n    if (typeof options === 'string') options = {\n      encoding: options,\n      mode: 0o666,\n      flag: 'w'\n    };else if (!options) options = {\n      encoding: 'utf8',\n      mode: 0o666,\n      flag: 'w'\n    };else if (typeof options !== 'object') throw new TypeError('Bad arguments');\n    if (options.encoding && !Buffer.isEncoding(options.encoding)) throw new Error(`Unknown encoding: ${options.encoding}`);\n    const flag = options.flag || 'w';\n    this.open(path, flag, options.mode, (openErr, handle) => {\n      if (openErr) {\n        callback && callback(openErr);\n      } else {\n        const buffer = Buffer.isBuffer(data) ? data : Buffer.from('' + data, options.encoding || 'utf8');\n        const position = /a/.test(flag) ? null : 0; // SFTPv3 does not support the notion of 'current position'\n        // (null position), so we just attempt to append to the end of the file\n        // instead\n\n        if (position === null) {\n          const tryStat = (er, st) => {\n            if (er) {\n              // Try stat() for sftp servers that may not support fstat() for\n              // whatever reason\n              this.stat(path, (er_, st_) => {\n                if (er_) {\n                  return this.close(handle, () => {\n                    callback && callback(er);\n                  });\n                }\n\n                tryStat(null, st_);\n              });\n              return;\n            }\n\n            writeAll(this, handle, buffer, 0, buffer.length, st.size, callback);\n          };\n\n          this.fstat(handle, tryStat);\n          return;\n        }\n\n        writeAll(this, handle, buffer, 0, buffer.length, position, callback);\n      }\n    });\n  }\n\n  appendFile(path, data, options, callback_) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    let callback;\n\n    if (typeof callback_ === 'function') {\n      callback = callback_;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n\n    if (typeof options === 'string') options = {\n      encoding: options,\n      mode: 0o666,\n      flag: 'a'\n    };else if (!options) options = {\n      encoding: 'utf8',\n      mode: 0o666,\n      flag: 'a'\n    };else if (typeof options !== 'object') throw new TypeError('Bad arguments');\n    if (!options.flag) options = Object.assign({\n      flag: 'a'\n    }, options);\n    this.writeFile(path, data, options, callback);\n  }\n\n  exists(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    this.stat(path, err => {\n      cb && cb(err ? false : true);\n    });\n  }\n\n  unlink(filename, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    /*\n      uint32     id\n      string     filename\n    */\n\n    const fnameLen = Buffer.byteLength(filename);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + fnameLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.REMOVE;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, fnameLen, p);\n    buf.utf8Write(filename, p += 4, fnameLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} REMOVE`);\n  }\n\n  rename(oldPath, newPath, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    /*\n      uint32     id\n      string     oldpath\n      string     newpath\n    */\n\n    const oldLen = Buffer.byteLength(oldPath);\n    const newLen = Buffer.byteLength(newPath);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + oldLen + 4 + newLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.RENAME;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, oldLen, p);\n    buf.utf8Write(oldPath, p += 4, oldLen);\n    writeUInt32BE(buf, newLen, p += oldLen);\n    buf.utf8Write(newPath, p += 4, newLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} RENAME`);\n  }\n\n  mkdir(path, attrs, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    let flags = 0;\n    let attrsLen = 0;\n\n    if (typeof attrs === 'function') {\n      cb = attrs;\n      attrs = undefined;\n    }\n\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    }\n    /*\n      uint32     id\n      string     path\n      ATTRS      attrs\n    */\n\n\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.MKDIR;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} MKDIR`);\n  }\n\n  rmdir(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    /*\n      uint32     id\n      string     path\n    */\n\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.RMDIR;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} RMDIR`);\n  }\n\n  readdir(where, opts, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    if (typeof opts === 'function') {\n      cb = opts;\n      opts = {};\n    }\n\n    if (typeof opts !== 'object' || opts === null) opts = {};\n    const doFilter = opts && opts.full ? false : true;\n    if (!Buffer.isBuffer(where) && typeof where !== 'string') throw new Error('missing directory handle or path');\n\n    if (typeof where === 'string') {\n      const entries = [];\n      let e = 0;\n\n      const reread = (err, handle) => {\n        if (err) return cb(err);\n        this.readdir(handle, opts, (err, list) => {\n          const eof = err && err.code === STATUS_CODE.EOF;\n          if (err && !eof) return this.close(handle, () => cb(err));\n\n          if (eof) {\n            return this.close(handle, err => {\n              if (err) return cb(err);\n              cb(undefined, entries);\n            });\n          }\n\n          for (let i = 0; i < list.length; ++i, ++e) entries[e] = list[i];\n\n          reread(undefined, handle);\n        });\n      };\n\n      return this.opendir(where, reread);\n    }\n    /*\n      uint32     id\n      string     handle\n    */\n\n\n    const handleLen = where.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.READDIR;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(where, p += 4);\n    this._requests[reqid] = {\n      cb: doFilter ? (err, list) => {\n        if (typeof cb !== 'function') return;\n        if (err) return cb(err);\n\n        for (let i = list.length - 1; i >= 0; --i) {\n          if (list[i].filename === '.' || list[i].filename === '..') list.splice(i, 1);\n        }\n\n        cb(undefined, list);\n      } : cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READDIR`);\n  }\n\n  fstat(handle, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n    /*\n      uint32     id\n      string     handle\n    */\n\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.FSTAT;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(handle, p += 4);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} FSTAT`);\n  }\n\n  stat(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    /*\n      uint32     id\n      string     path\n    */\n\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.STAT;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} STAT`);\n  }\n\n  lstat(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    /*\n      uint32     id\n      string     path\n    */\n\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.LSTAT;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} LSTAT`);\n  }\n\n  opendir(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    /*\n      uint32     id\n      string     path\n    */\n\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.OPENDIR;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} OPENDIR`);\n  }\n\n  setstat(path, attrs, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    let flags = 0;\n    let attrsLen = 0;\n\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    } else if (typeof attrs === 'function') {\n      cb = attrs;\n    }\n    /*\n      uint32     id\n      string     path\n      ATTRS      attrs\n    */\n\n\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.SETSTAT;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} SETSTAT`);\n  }\n\n  fsetstat(handle, attrs, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n    let flags = 0;\n    let attrsLen = 0;\n\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    } else if (typeof attrs === 'function') {\n      cb = attrs;\n    }\n    /*\n      uint32     id\n      string     handle\n      ATTRS      attrs\n    */\n\n\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.FSETSTAT;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(handle, p += 4);\n    writeUInt32BE(buf, flags, p += handleLen);\n\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} FSETSTAT`);\n  }\n\n  futimes(handle, atime, mtime, cb) {\n    return this.fsetstat(handle, {\n      atime: toUnixTimestamp(atime),\n      mtime: toUnixTimestamp(mtime)\n    }, cb);\n  }\n\n  utimes(path, atime, mtime, cb) {\n    return this.setstat(path, {\n      atime: toUnixTimestamp(atime),\n      mtime: toUnixTimestamp(mtime)\n    }, cb);\n  }\n\n  fchown(handle, uid, gid, cb) {\n    return this.fsetstat(handle, {\n      uid: uid,\n      gid: gid\n    }, cb);\n  }\n\n  chown(path, uid, gid, cb) {\n    return this.setstat(path, {\n      uid: uid,\n      gid: gid\n    }, cb);\n  }\n\n  fchmod(handle, mode, cb) {\n    return this.fsetstat(handle, {\n      mode: mode\n    }, cb);\n  }\n\n  chmod(path, mode, cb) {\n    return this.setstat(path, {\n      mode: mode\n    }, cb);\n  }\n\n  readlink(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    /*\n      uint32     id\n      string     path\n    */\n\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.READLINK;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb: (err, names) => {\n        if (typeof cb !== 'function') return;\n        if (err) return cb(err);\n        if (!names || !names.length) return cb(new Error('Response missing link info'));\n        cb(undefined, names[0].filename);\n      }\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READLINK`);\n  }\n\n  symlink(targetPath, linkPath, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    /*\n      uint32     id\n      string     linkpath\n      string     targetpath\n    */\n\n    const linkLen = Buffer.byteLength(linkPath);\n    const targetLen = Buffer.byteLength(targetPath);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + linkLen + 4 + targetLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.SYMLINK;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    if (this._isOpenSSH) {\n      // OpenSSH has linkpath and targetpath positions switched\n      writeUInt32BE(buf, targetLen, p);\n      buf.utf8Write(targetPath, p += 4, targetLen);\n      writeUInt32BE(buf, linkLen, p += targetLen);\n      buf.utf8Write(linkPath, p += 4, linkLen);\n    } else {\n      writeUInt32BE(buf, linkLen, p);\n      buf.utf8Write(linkPath, p += 4, linkLen);\n      writeUInt32BE(buf, targetLen, p += linkLen);\n      buf.utf8Write(targetPath, p += 4, targetLen);\n    }\n\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} SYMLINK`);\n  }\n\n  realpath(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    /*\n      uint32     id\n      string     path\n    */\n\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.REALPATH;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb: (err, names) => {\n        if (typeof cb !== 'function') return;\n        if (err) return cb(err);\n        if (!names || !names.length) return cb(new Error('Response missing path info'));\n        cb(undefined, names[0].filename);\n      }\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} REALPATH`);\n  } // extended requests\n\n\n  ext_openssh_rename(oldPath, newPath, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['posix-rename@openssh.com'];\n    if (!ext || ext !== '1') throw new Error('Server does not support this extended request');\n    /*\n      uint32    id\n      string    \"posix-rename@openssh.com\"\n      string    oldpath\n      string    newpath\n    */\n\n    const oldLen = Buffer.byteLength(oldPath);\n    const newLen = Buffer.byteLength(newPath);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 24 + 4 + oldLen + 4 + newLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 24, p);\n    buf.utf8Write('posix-rename@openssh.com', p += 4, 24);\n    writeUInt32BE(buf, oldLen, p += 24);\n    buf.utf8Write(oldPath, p += 4, oldLen);\n    writeUInt32BE(buf, newLen, p += oldLen);\n    buf.utf8Write(newPath, p += 4, newLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n\n    if (this._debug) {\n      const which = isBuffered ? 'Buffered' : 'Sending';\n\n      this._debug(`SFTP: Outbound: ${which} posix-rename@openssh.com`);\n    }\n  }\n\n  ext_openssh_statvfs(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['statvfs@openssh.com'];\n    if (!ext || ext !== '2') throw new Error('Server does not support this extended request');\n    /*\n      uint32    id\n      string    \"statvfs@openssh.com\"\n      string    path\n    */\n\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 19 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 19, p);\n    buf.utf8Write('statvfs@openssh.com', p += 4, 19);\n    writeUInt32BE(buf, pathLen, p += 19);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      extended: 'statvfs@openssh.com',\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n\n    if (this._debug) {\n      const which = isBuffered ? 'Buffered' : 'Sending';\n\n      this._debug(`SFTP: Outbound: ${which} statvfs@openssh.com`);\n    }\n  }\n\n  ext_openssh_fstatvfs(handle, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['fstatvfs@openssh.com'];\n    if (!ext || ext !== '2') throw new Error('Server does not support this extended request');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n    /*\n      uint32    id\n      string    \"fstatvfs@openssh.com\"\n      string    handle\n    */\n\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 20, p);\n    buf.utf8Write('fstatvfs@openssh.com', p += 4, 20);\n    writeUInt32BE(buf, handleLen, p += 20);\n    buf.set(handle, p += 4);\n    this._requests[reqid] = {\n      extended: 'fstatvfs@openssh.com',\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n\n    if (this._debug) {\n      const which = isBuffered ? 'Buffered' : 'Sending';\n\n      this._debug(`SFTP: Outbound: ${which} fstatvfs@openssh.com`);\n    }\n  }\n\n  ext_openssh_hardlink(oldPath, newPath, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['hardlink@openssh.com'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n    /*\n      uint32    id\n      string    \"hardlink@openssh.com\"\n      string    oldpath\n      string    newpath\n    */\n\n    const oldLen = Buffer.byteLength(oldPath);\n    const newLen = Buffer.byteLength(newPath);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + oldLen + 4 + newLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 20, p);\n    buf.utf8Write('hardlink@openssh.com', p += 4, 20);\n    writeUInt32BE(buf, oldLen, p += 20);\n    buf.utf8Write(oldPath, p += 4, oldLen);\n    writeUInt32BE(buf, newLen, p += oldLen);\n    buf.utf8Write(newPath, p += 4, newLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n\n    if (this._debug) {\n      const which = isBuffered ? 'Buffered' : 'Sending';\n\n      this._debug(`SFTP: Outbound: ${which} hardlink@openssh.com`);\n    }\n  }\n\n  ext_openssh_fsync(handle, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['fsync@openssh.com'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n    /*\n      uint32    id\n      string    \"fsync@openssh.com\"\n      string    handle\n    */\n\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 17 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 17, p);\n    buf.utf8Write('fsync@openssh.com', p += 4, 17);\n    writeUInt32BE(buf, handleLen, p += 17);\n    buf.set(handle, p += 4);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} fsync@openssh.com`);\n  }\n\n  ext_openssh_lsetstat(path, attrs, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['lsetstat@openssh.com'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n    let flags = 0;\n    let attrsLen = 0;\n\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    } else if (typeof attrs === 'function') {\n      cb = attrs;\n    }\n    /*\n      uint32    id\n      string    \"lsetstat@openssh.com\"\n      string    path\n      ATTRS     attrs\n    */\n\n\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + pathLen + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 20, p);\n    buf.utf8Write('lsetstat@openssh.com', p += 4, 20);\n    writeUInt32BE(buf, pathLen, p += 20);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n\n    if (this._debug) {\n      const status = isBuffered ? 'Buffered' : 'Sending';\n\n      this._debug(`SFTP: Outbound: ${status} lsetstat@openssh.com`);\n    }\n  }\n\n  ext_openssh_expandPath(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['expand-path@openssh.com'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n    /*\n      uint32    id\n      string    \"expand-path@openssh.com\"\n      string    path\n    */\n\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 23 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 23, p);\n    buf.utf8Write('expand-path@openssh.com', p += 4, 23);\n    writeUInt32BE(buf, pathLen, p += 20);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n\n    if (this._debug) {\n      const status = isBuffered ? 'Buffered' : 'Sending';\n\n      this._debug(`SFTP: Outbound: ${status} expand-path@openssh.com`);\n    }\n  }\n\n  ext_copy_data(srcHandle, srcOffset, len, dstHandle, dstOffset, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['copy-data'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n    if (!Buffer.isBuffer(srcHandle)) throw new Error('Source handle is not a Buffer');\n    if (!Buffer.isBuffer(dstHandle)) throw new Error('Destination handle is not a Buffer');\n    /*\n      uint32    id\n      string    \"copy-data\"\n      string    read-from-handle\n      uint64    read-from-offset\n      uint64    read-data-length\n      string    write-to-handle\n      uint64    write-to-offset\n    */\n\n    let p = 0;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 9 + 4 + srcHandle.length + 8 + 8 + 4 + dstHandle.length + 8);\n    writeUInt32BE(buf, buf.length - 4, p);\n    p += 4;\n    buf[p] = REQUEST.EXTENDED;\n    ++p;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, p);\n    p += 4;\n    writeUInt32BE(buf, 9, p);\n    p += 4;\n    buf.utf8Write('copy-data', p, 9);\n    p += 9;\n    writeUInt32BE(buf, srcHandle.length, p);\n    p += 4;\n    buf.set(srcHandle, p);\n    p += srcHandle.length;\n\n    for (let i = 7; i >= 0; --i) {\n      buf[p + i] = srcOffset & 0xFF;\n      srcOffset /= 256;\n    }\n\n    p += 8;\n\n    for (let i = 7; i >= 0; --i) {\n      buf[p + i] = len & 0xFF;\n      len /= 256;\n    }\n\n    p += 8;\n    writeUInt32BE(buf, dstHandle.length, p);\n    p += 4;\n    buf.set(dstHandle, p);\n    p += dstHandle.length;\n\n    for (let i = 7; i >= 0; --i) {\n      buf[p + i] = dstOffset & 0xFF;\n      dstOffset /= 256;\n    }\n\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n\n    if (this._debug) {\n      const status = isBuffered ? 'Buffered' : 'Sending';\n\n      this._debug(`SFTP: Outbound: ${status} copy-data`);\n    }\n  } // ===========================================================================\n  // Server-specific ===========================================================\n  // ===========================================================================\n\n\n  handle(reqid, handle) {\n    if (!this.server) throw new Error('Server-only method called in client mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n    const handleLen = handle.length;\n    if (handleLen > 256) throw new Error('handle too large (> 256 bytes)');\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.HANDLE;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, handleLen, p);\n    if (handleLen) buf.set(handle, p += 4);\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} HANDLE`);\n  }\n\n  status(reqid, code, message) {\n    if (!this.server) throw new Error('Server-only method called in client mode');\n    if (!VALID_STATUS_CODES.has(code)) throw new Error(`Bad status code: ${code}`);\n    message || (message = '');\n    const msgLen = Buffer.byteLength(message);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 4 + msgLen + 4);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.STATUS;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, code, p);\n    writeUInt32BE(buf, msgLen, p += 4);\n    p += 4;\n\n    if (msgLen) {\n      buf.utf8Write(message, p, msgLen);\n      p += msgLen;\n    }\n\n    writeUInt32BE(buf, 0, p); // Empty language tag\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} STATUS`);\n  }\n\n  data(reqid, data, encoding) {\n    if (!this.server) throw new Error('Server-only method called in client mode');\n    const isBuffer = Buffer.isBuffer(data);\n    if (!isBuffer && typeof data !== 'string') throw new Error('data is not a Buffer or string');\n    let isUTF8;\n\n    if (!isBuffer && !encoding) {\n      encoding = undefined;\n      isUTF8 = true;\n    }\n\n    const dataLen = isBuffer ? data.length : Buffer.byteLength(data, encoding);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + dataLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.DATA;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, dataLen, p);\n\n    if (dataLen) {\n      if (isBuffer) buf.set(data, p += 4);else if (isUTF8) buf.utf8Write(data, p += 4, dataLen);else buf.write(data, p += 4, dataLen, encoding);\n    }\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} DATA`);\n  }\n\n  name(reqid, names) {\n    if (!this.server) throw new Error('Server-only method called in client mode');\n\n    if (!Array.isArray(names)) {\n      if (typeof names !== 'object' || names === null) throw new Error('names is not an object or array');\n      names = [names];\n    }\n\n    const count = names.length;\n    let namesLen = 0;\n    let nameAttrs;\n    const attrs = [];\n\n    for (let i = 0; i < count; ++i) {\n      const name = names[i];\n      const filename = !name || !name.filename || typeof name.filename !== 'string' ? '' : name.filename;\n      namesLen += 4 + Buffer.byteLength(filename);\n      const longname = !name || !name.longname || typeof name.longname !== 'string' ? '' : name.longname;\n      namesLen += 4 + Buffer.byteLength(longname);\n\n      if (typeof name.attrs === 'object' && name.attrs !== null) {\n        nameAttrs = attrsToBytes(name.attrs);\n        namesLen += 4 + nameAttrs.nb;\n\n        if (nameAttrs.nb) {\n          let bytes;\n\n          if (nameAttrs.nb === ATTRS_BUF.length) {\n            bytes = new Uint8Array(ATTRS_BUF);\n          } else {\n            bytes = new Uint8Array(nameAttrs.nb);\n            bufferCopy(ATTRS_BUF, bytes, 0, nameAttrs.nb, 0);\n          }\n\n          nameAttrs.bytes = bytes;\n        }\n\n        attrs.push(nameAttrs);\n      } else {\n        namesLen += 4;\n        attrs.push(null);\n      }\n    }\n\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + namesLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.NAME;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, count, p);\n    p += 4;\n\n    for (let i = 0; i < count; ++i) {\n      const name = names[i];\n      {\n        const filename = !name || !name.filename || typeof name.filename !== 'string' ? '' : name.filename;\n        const len = Buffer.byteLength(filename);\n        writeUInt32BE(buf, len, p);\n        p += 4;\n\n        if (len) {\n          buf.utf8Write(filename, p, len);\n          p += len;\n        }\n      }\n      {\n        const longname = !name || !name.longname || typeof name.longname !== 'string' ? '' : name.longname;\n        const len = Buffer.byteLength(longname);\n        writeUInt32BE(buf, len, p);\n        p += 4;\n\n        if (len) {\n          buf.utf8Write(longname, p, len);\n          p += len;\n        }\n      }\n      const attr = attrs[i];\n\n      if (attr) {\n        writeUInt32BE(buf, attr.flags, p);\n        p += 4;\n\n        if (attr.flags && attr.bytes) {\n          buf.set(attr.bytes, p);\n          p += attr.nb;\n        }\n      } else {\n        writeUInt32BE(buf, 0, p);\n        p += 4;\n      }\n    }\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} NAME`);\n  }\n\n  attrs(reqid, attrs) {\n    if (!this.server) throw new Error('Server-only method called in client mode');\n    if (typeof attrs !== 'object' || attrs === null) throw new Error('attrs is not an object');\n    attrs = attrsToBytes(attrs);\n    const flags = attrs.flags;\n    const attrsLen = attrs.nb;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.ATTRS;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, flags, p);\n\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} ATTRS`);\n  }\n\n}\n\nfunction tryCreateBuffer(size) {\n  try {\n    return Buffer.allocUnsafe(size);\n  } catch (ex) {\n    return ex;\n  }\n}\n\nfunction read_(self, handle, buf, off, len, position, cb, req_) {\n  const maxDataLen = self._maxReadLen;\n  const overflow = Math.max(len - maxDataLen, 0);\n  if (overflow) len = maxDataLen;\n  /*\n    uint32     id\n    string     handle\n    uint64     offset\n    uint32     len\n  */\n\n  const handleLen = handle.length;\n  let p = 9;\n  let pos = position;\n  const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4);\n  writeUInt32BE(out, out.length - 4, 0);\n  out[4] = REQUEST.READ;\n  const reqid = self._writeReqid = self._writeReqid + 1 & MAX_REQID;\n  writeUInt32BE(out, reqid, 5);\n  writeUInt32BE(out, handleLen, p);\n  out.set(handle, p += 4);\n  p += handleLen;\n\n  for (let i = 7; i >= 0; --i) {\n    out[p + i] = pos & 0xFF;\n    pos /= 256;\n  }\n\n  writeUInt32BE(out, len, p += 8);\n  if (typeof cb !== 'function') cb = noop;\n  const req = req_ || {\n    nb: 0,\n    position,\n    off,\n    origOff: off,\n    len: undefined,\n    overflow: undefined,\n    cb: (err, data, nb) => {\n      const len = req.len;\n      const overflow = req.overflow;\n\n      if (err) {\n        if (cb._wantEOFError || err.code !== STATUS_CODE.EOF) return cb(err);\n      } else if (nb > len) {\n        return cb(new Error('Received more data than requested'));\n      } else if (nb === len && overflow) {\n        req.nb += nb;\n        req.position += nb;\n        req.off += nb;\n        read_(self, handle, buf, req.off, overflow, req.position, cb, req);\n        return;\n      }\n\n      nb = nb || 0;\n      if (req.origOff === 0 && buf.length === req.nb) data = buf;else data = bufferSlice(buf, req.origOff, req.origOff + req.nb + nb);\n      cb(undefined, req.nb + nb, data, req.position);\n    },\n    buffer: undefined\n  };\n  req.len = len;\n  req.overflow = overflow; // TODO: avoid creating multiple buffer slices when we need to re-call read_()\n  // because of overflow\n\n  req.buffer = bufferSlice(buf, off, off + len);\n  self._requests[reqid] = req;\n  const isBuffered = sendOrBuffer(self, out);\n  self._debug && self._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READ`);\n}\n\nfunction fastXfer(src, dst, srcPath, dstPath, opts, cb) {\n  let concurrency = 64;\n  let chunkSize = 32768;\n  let onstep;\n  let mode;\n  let fileSize;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n  } else if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.concurrency === 'number' && opts.concurrency > 0 && !isNaN(opts.concurrency)) {\n      concurrency = opts.concurrency;\n    }\n\n    if (typeof opts.chunkSize === 'number' && opts.chunkSize > 0 && !isNaN(opts.chunkSize)) {\n      chunkSize = opts.chunkSize;\n    }\n\n    if (typeof opts.fileSize === 'number' && opts.fileSize > 0 && !isNaN(opts.fileSize)) {\n      fileSize = opts.fileSize;\n    }\n\n    if (typeof opts.step === 'function') onstep = opts.step;\n    if (typeof opts.mode === 'string' || typeof opts.mode === 'number') mode = modeNum(opts.mode);\n  } // Internal state variables\n\n\n  let fsize;\n  let pdst = 0;\n  let total = 0;\n  let hadError = false;\n  let srcHandle;\n  let dstHandle;\n  let readbuf;\n  let bufsize = chunkSize * concurrency;\n\n  function onerror(err) {\n    if (hadError) return;\n    hadError = true;\n    let left = 0;\n    let cbfinal;\n\n    if (srcHandle || dstHandle) {\n      cbfinal = () => {\n        if (--left === 0) cb(err);\n      };\n\n      if (srcHandle && (src === fs || src.outgoing.state === 'open')) ++left;\n      if (dstHandle && (dst === fs || dst.outgoing.state === 'open')) ++left;\n      if (srcHandle && (src === fs || src.outgoing.state === 'open')) src.close(srcHandle, cbfinal);\n      if (dstHandle && (dst === fs || dst.outgoing.state === 'open')) dst.close(dstHandle, cbfinal);\n    } else {\n      cb(err);\n    }\n  }\n\n  src.open(srcPath, 'r', (err, sourceHandle) => {\n    if (err) return onerror(err);\n    srcHandle = sourceHandle;\n    if (fileSize === undefined) src.fstat(srcHandle, tryStat);else tryStat(null, {\n      size: fileSize\n    });\n\n    function tryStat(err, attrs) {\n      if (err) {\n        if (src !== fs) {\n          // Try stat() for sftp servers that may not support fstat() for\n          // whatever reason\n          src.stat(srcPath, (err_, attrs_) => {\n            if (err_) return onerror(err);\n            tryStat(null, attrs_);\n          });\n          return;\n        }\n\n        return onerror(err);\n      }\n\n      fsize = attrs.size;\n      dst.open(dstPath, 'w', (err, destHandle) => {\n        if (err) return onerror(err);\n        dstHandle = destHandle;\n        if (fsize <= 0) return onerror(); // Use less memory where possible\n\n        while (bufsize > fsize) {\n          if (concurrency === 1) {\n            bufsize = fsize;\n            break;\n          }\n\n          bufsize -= chunkSize;\n          --concurrency;\n        }\n\n        readbuf = tryCreateBuffer(bufsize);\n        if (readbuf instanceof Error) return onerror(readbuf);\n\n        if (mode !== undefined) {\n          dst.fchmod(dstHandle, mode, function tryAgain(err) {\n            if (err) {\n              // Try chmod() for sftp servers that may not support fchmod()\n              // for whatever reason\n              dst.chmod(dstPath, mode, err_ => tryAgain());\n              return;\n            }\n\n            startReads();\n          });\n        } else {\n          startReads();\n        }\n\n        function onread(err, nb, data, dstpos, datapos, origChunkLen) {\n          if (err) return onerror(err);\n          datapos = datapos || 0;\n          dst.write(dstHandle, readbuf, datapos, nb, dstpos, writeCb);\n\n          function writeCb(err) {\n            if (err) return onerror(err);\n            total += nb;\n            onstep && onstep(total, nb, fsize);\n            if (nb < origChunkLen) return singleRead(datapos, dstpos + nb, origChunkLen - nb);\n\n            if (total === fsize) {\n              dst.close(dstHandle, err => {\n                dstHandle = undefined;\n                if (err) return onerror(err);\n                src.close(srcHandle, err => {\n                  srcHandle = undefined;\n                  if (err) return onerror(err);\n                  cb();\n                });\n              });\n              return;\n            }\n\n            if (pdst >= fsize) return;\n            const chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;\n            singleRead(datapos, pdst, chunk);\n            pdst += chunk;\n          }\n        }\n\n        function makeCb(psrc, pdst, chunk) {\n          return (err, nb, data) => {\n            onread(err, nb, data, pdst, psrc, chunk);\n          };\n        }\n\n        function singleRead(psrc, pdst, chunk) {\n          src.read(srcHandle, readbuf, psrc, chunk, pdst, makeCb(psrc, pdst, chunk));\n        }\n\n        function startReads() {\n          let reads = 0;\n          let psrc = 0;\n\n          while (pdst < fsize && reads < concurrency) {\n            const chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;\n            singleRead(psrc, pdst, chunk);\n            psrc += chunk;\n            pdst += chunk;\n            ++reads;\n          }\n        }\n      });\n    }\n  });\n}\n\nfunction writeAll(sftp, handle, buffer, offset, length, position, callback_) {\n  const callback = typeof callback_ === 'function' ? callback_ : undefined;\n  sftp.write(handle, buffer, offset, length, position, (writeErr, written) => {\n    if (writeErr) {\n      return sftp.close(handle, () => {\n        callback && callback(writeErr);\n      });\n    }\n\n    if (written === length) {\n      sftp.close(handle, callback);\n    } else {\n      offset += written;\n      length -= written;\n      position += written;\n      writeAll(sftp, handle, buffer, offset, length, position, callback);\n    }\n  });\n}\n\nclass Stats {\n  constructor(initial) {\n    this.mode = initial && initial.mode;\n    this.uid = initial && initial.uid;\n    this.gid = initial && initial.gid;\n    this.size = initial && initial.size;\n    this.atime = initial && initial.atime;\n    this.mtime = initial && initial.mtime;\n    this.extended = initial && initial.extended;\n  }\n\n  isDirectory() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFDIR;\n  }\n\n  isFile() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFREG;\n  }\n\n  isBlockDevice() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFBLK;\n  }\n\n  isCharacterDevice() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFCHR;\n  }\n\n  isSymbolicLink() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFLNK;\n  }\n\n  isFIFO() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFIFO;\n  }\n\n  isSocket() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFSOCK;\n  }\n\n}\n\nfunction attrsToBytes(attrs) {\n  let flags = 0;\n  let nb = 0;\n\n  if (typeof attrs === 'object' && attrs !== null) {\n    if (typeof attrs.size === 'number') {\n      flags |= ATTR.SIZE;\n      const val = attrs.size; // Big Endian\n\n      ATTRS_BUF[nb++] = val / 72057594037927940; // 2**56\n\n      ATTRS_BUF[nb++] = val / 281474976710656; // 2**48\n\n      ATTRS_BUF[nb++] = val / 1099511627776; // 2**40\n\n      ATTRS_BUF[nb++] = val / 4294967296; // 2**32\n\n      ATTRS_BUF[nb++] = val / 16777216; // 2**24\n\n      ATTRS_BUF[nb++] = val / 65536; // 2**16\n\n      ATTRS_BUF[nb++] = val / 256; // 2**8\n\n      ATTRS_BUF[nb++] = val;\n    }\n\n    if (typeof attrs.uid === 'number' && typeof attrs.gid === 'number') {\n      flags |= ATTR.UIDGID;\n      const uid = attrs.uid;\n      const gid = attrs.gid; // Big Endian\n\n      ATTRS_BUF[nb++] = uid >>> 24;\n      ATTRS_BUF[nb++] = uid >>> 16;\n      ATTRS_BUF[nb++] = uid >>> 8;\n      ATTRS_BUF[nb++] = uid;\n      ATTRS_BUF[nb++] = gid >>> 24;\n      ATTRS_BUF[nb++] = gid >>> 16;\n      ATTRS_BUF[nb++] = gid >>> 8;\n      ATTRS_BUF[nb++] = gid;\n    }\n\n    if (typeof attrs.mode === 'number' || typeof attrs.mode === 'string') {\n      const mode = modeNum(attrs.mode);\n      flags |= ATTR.PERMISSIONS; // Big Endian\n\n      ATTRS_BUF[nb++] = mode >>> 24;\n      ATTRS_BUF[nb++] = mode >>> 16;\n      ATTRS_BUF[nb++] = mode >>> 8;\n      ATTRS_BUF[nb++] = mode;\n    }\n\n    if ((typeof attrs.atime === 'number' || isDate(attrs.atime)) && (typeof attrs.mtime === 'number' || isDate(attrs.mtime))) {\n      const atime = toUnixTimestamp(attrs.atime);\n      const mtime = toUnixTimestamp(attrs.mtime);\n      flags |= ATTR.ACMODTIME; // Big Endian\n\n      ATTRS_BUF[nb++] = atime >>> 24;\n      ATTRS_BUF[nb++] = atime >>> 16;\n      ATTRS_BUF[nb++] = atime >>> 8;\n      ATTRS_BUF[nb++] = atime;\n      ATTRS_BUF[nb++] = mtime >>> 24;\n      ATTRS_BUF[nb++] = mtime >>> 16;\n      ATTRS_BUF[nb++] = mtime >>> 8;\n      ATTRS_BUF[nb++] = mtime;\n    } // TODO: extended attributes\n\n  }\n\n  return {\n    flags,\n    nb\n  };\n}\n\nfunction toUnixTimestamp(time) {\n  // eslint-disable-next-line no-self-compare\n  if (typeof time === 'number' && time === time) // Valid, non-NaN number\n    return time;\n  if (isDate(time)) return parseInt(time.getTime() / 1000, 10);\n  throw new Error(`Cannot parse time: ${time}`);\n}\n\nfunction modeNum(mode) {\n  // eslint-disable-next-line no-self-compare\n  if (typeof mode === 'number' && mode === mode) // Valid, non-NaN number\n    return mode;\n  if (typeof mode === 'string') return modeNum(parseInt(mode, 8));\n  throw new Error(`Cannot parse mode: ${mode}`);\n}\n\nconst stringFlagMap = {\n  'r': OPEN_MODE.READ,\n  'r+': OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'w': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'wx': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xw': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'w+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'wx+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xw+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'a': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'ax': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xa': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'a+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'ax+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xa+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL\n};\n\nfunction stringToFlags(str) {\n  const flags = stringFlagMap[str];\n  return flags !== undefined ? flags : null;\n}\n\nconst flagsToString = (() => {\n  const stringFlagMapKeys = Object.keys(stringFlagMap);\n  return flags => {\n    for (let i = 0; i < stringFlagMapKeys.length; ++i) {\n      const key = stringFlagMapKeys[i];\n      if (stringFlagMap[key] === flags) return key;\n    }\n\n    return null;\n  };\n})();\n\nfunction readAttrs(biOpt) {\n  /*\n    uint32   flags\n    uint64   size           present only if flag SSH_FILEXFER_ATTR_SIZE\n    uint32   uid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   gid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   permissions    present only if flag SSH_FILEXFER_ATTR_PERMISSIONS\n    uint32   atime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   mtime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   extended_count present only if flag SSH_FILEXFER_ATTR_EXTENDED\n    string   extended_type\n    string   extended_data\n    ...      more extended data (extended_type - extended_data pairs),\n               so that number of pairs equals extended_count\n  */\n  const flags = bufferParser.readUInt32BE();\n  if (flags === undefined) return;\n  const attrs = new Stats();\n\n  if (flags & ATTR.SIZE) {\n    const size = bufferParser.readUInt64BE(biOpt);\n    if (size === undefined) return;\n    attrs.size = size;\n  }\n\n  if (flags & ATTR.UIDGID) {\n    const uid = bufferParser.readUInt32BE();\n    const gid = bufferParser.readUInt32BE();\n    if (gid === undefined) return;\n    attrs.uid = uid;\n    attrs.gid = gid;\n  }\n\n  if (flags & ATTR.PERMISSIONS) {\n    const mode = bufferParser.readUInt32BE();\n    if (mode === undefined) return;\n    attrs.mode = mode;\n  }\n\n  if (flags & ATTR.ACMODTIME) {\n    const atime = bufferParser.readUInt32BE();\n    const mtime = bufferParser.readUInt32BE();\n    if (mtime === undefined) return;\n    attrs.atime = atime;\n    attrs.mtime = mtime;\n  }\n\n  if (flags & ATTR.EXTENDED) {\n    const count = bufferParser.readUInt32BE();\n    if (count === undefined) return;\n    const extended = {};\n\n    for (let i = 0; i < count; ++i) {\n      const type = bufferParser.readString(true);\n      const data = bufferParser.readString();\n      if (data === undefined) return;\n      extended[type] = data;\n    }\n\n    attrs.extended = extended;\n  }\n\n  return attrs;\n}\n\nfunction sendOrBuffer(sftp, payload) {\n  const ret = tryWritePayload(sftp, payload);\n\n  if (ret !== undefined) {\n    sftp._buffer.push(ret);\n\n    return false;\n  }\n\n  return true;\n}\n\nfunction tryWritePayload(sftp, payload) {\n  const outgoing = sftp.outgoing;\n  if (outgoing.state !== 'open') return;\n\n  if (outgoing.window === 0) {\n    sftp._waitWindow = true;\n    sftp._chunkcb = drainBuffer;\n    return payload;\n  }\n\n  let ret;\n  const len = payload.length;\n  let p = 0;\n\n  while (len - p > 0 && outgoing.window > 0) {\n    const actualLen = Math.min(len - p, outgoing.window, outgoing.packetSize);\n    outgoing.window -= actualLen;\n\n    if (outgoing.window === 0) {\n      sftp._waitWindow = true;\n      sftp._chunkcb = drainBuffer;\n    }\n\n    if (p === 0 && actualLen === len) {\n      sftp._protocol.channelData(sftp.outgoing.id, payload);\n    } else {\n      sftp._protocol.channelData(sftp.outgoing.id, bufferSlice(payload, p, p + actualLen));\n    }\n\n    p += actualLen;\n  }\n\n  if (len - p > 0) {\n    if (p > 0) ret = bufferSlice(payload, p, len);else ret = payload; // XXX: should never get here?\n  }\n\n  return ret;\n}\n\nfunction drainBuffer() {\n  this._chunkcb = undefined;\n  const buffer = this._buffer;\n  let i = 0;\n\n  while (i < buffer.length) {\n    const payload = buffer[i];\n    const ret = tryWritePayload(this, payload);\n\n    if (ret !== undefined) {\n      if (ret !== payload) buffer[i] = ret;\n      if (i > 0) this._buffer = buffer.slice(i);\n      return;\n    }\n\n    ++i;\n  }\n\n  if (i > 0) this._buffer = [];\n}\n\nfunction doFatalSFTPError(sftp, msg, noDebug) {\n  const err = new Error(msg);\n  err.level = 'sftp-protocol';\n  if (!noDebug && sftp._debug) sftp._debug(`SFTP: Inbound: ${msg}`);\n  sftp.emit('error', err);\n  sftp.destroy();\n  cleanupRequests(sftp);\n  return false;\n}\n\nfunction cleanupRequests(sftp) {\n  const keys = Object.keys(sftp._requests);\n  if (keys.length === 0) return;\n  const reqs = sftp._requests;\n  sftp._requests = {};\n  const err = new Error('No response from server');\n\n  for (let i = 0; i < keys.length; ++i) {\n    const req = reqs[keys[i]];\n    if (typeof req.cb === 'function') req.cb(err);\n  }\n}\n\nfunction requestLimits(sftp, cb) {\n  /*\n    uint32    id\n    string    \"limits@openssh.com\"\n  */\n  let p = 9;\n  const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 18);\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.EXTENDED;\n  const reqid = sftp._writeReqid = sftp._writeReqid + 1 & MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n  writeUInt32BE(buf, 18, p);\n  buf.utf8Write('limits@openssh.com', p += 4, 18);\n  sftp._requests[reqid] = {\n    extended: 'limits@openssh.com',\n    cb\n  };\n  const isBuffered = sendOrBuffer(sftp, buf);\n\n  if (sftp._debug) {\n    const which = isBuffered ? 'Buffered' : 'Sending';\n\n    sftp._debug(`SFTP: Outbound: ${which} limits@openssh.com`);\n  }\n}\n\nconst CLIENT_HANDLERS = {\n  [RESPONSE.VERSION]: (sftp, payload) => {\n    if (sftp._version !== -1) return doFatalSFTPError(sftp, 'Duplicate VERSION packet');\n    const extensions = {};\n    /*\n      uint32 version\n      <extension data>\n    */\n\n    bufferParser.init(payload, 1);\n    let version = bufferParser.readUInt32BE();\n\n    while (bufferParser.avail()) {\n      const extName = bufferParser.readString(true);\n      const extData = bufferParser.readString(true);\n\n      if (extData === undefined) {\n        version = undefined;\n        break;\n      }\n\n      extensions[extName] = extData;\n    }\n\n    bufferParser.clear();\n    if (version === undefined) return doFatalSFTPError(sftp, 'Malformed VERSION packet');\n\n    if (sftp._debug) {\n      const names = Object.keys(extensions);\n\n      if (names.length) {\n        sftp._debug(`SFTP: Inbound: Received VERSION (v${version}, exts:${names})`);\n      } else {\n        sftp._debug(`SFTP: Inbound: Received VERSION (v${version})`);\n      }\n    }\n\n    sftp._version = version;\n    sftp._extensions = extensions;\n\n    if (extensions['limits@openssh.com'] === '1') {\n      return requestLimits(sftp, (err, limits) => {\n        if (!err) {\n          if (limits.maxPktLen > 0) sftp._maxOutPktLen = limits.maxPktLen;\n          if (limits.maxReadLen > 0) sftp._maxReadLen = limits.maxReadLen;\n          if (limits.maxWriteLen > 0) sftp._maxWriteLen = limits.maxWriteLen;\n          sftp.maxOpenHandles = limits.maxOpenHandles > 0 ? limits.maxOpenHandles : Infinity;\n        }\n\n        sftp.emit('ready');\n      });\n    }\n\n    sftp.emit('ready');\n  },\n  [RESPONSE.STATUS]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      uint32     error/status code\n      string     error message (ISO-10646 UTF-8)\n      string     language tag\n    */\n\n    const errorCode = bufferParser.readUInt32BE();\n    const errorMsg = bufferParser.readString(true);\n    bufferParser.clear(); // Note: we avoid checking that the error message and language tag are in\n    // the packet because there are some broken implementations that incorrectly\n    // omit them. The language tag in general was never really used amongst ssh\n    // implementations, so in the case of a missing error message we just\n    // default to something sensible.\n\n    if (sftp._debug) {\n      const jsonMsg = JSON.stringify(errorMsg);\n\n      sftp._debug(`SFTP: Inbound: Received STATUS (id:${reqID}, ${errorCode}, ${jsonMsg})`);\n    }\n\n    const req = sftp._requests[reqID];\n    delete sftp._requests[reqID];\n\n    if (req && typeof req.cb === 'function') {\n      if (errorCode === STATUS_CODE.OK) {\n        req.cb();\n        return;\n      }\n\n      const err = new Error(errorMsg || STATUS_CODE_STR[errorCode] || 'Unknown status');\n      err.code = errorCode;\n      req.cb(err);\n    }\n  },\n  [RESPONSE.HANDLE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n    */\n\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n\n    if (handle === undefined) {\n      if (reqID !== undefined) delete sftp._requests[reqID];\n      return doFatalSFTPError(sftp, 'Malformed HANDLE packet');\n    }\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received HANDLE (id:${reqID})`);\n    const req = sftp._requests[reqID];\n    delete sftp._requests[reqID];\n    if (req && typeof req.cb === 'function') req.cb(undefined, handle);\n  },\n  [RESPONSE.DATA]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    let req;\n\n    if (reqID !== undefined) {\n      req = sftp._requests[reqID];\n      delete sftp._requests[reqID];\n    }\n    /*\n      string     data\n    */\n\n\n    if (req && typeof req.cb === 'function') {\n      if (req.buffer) {\n        // We have already pre-allocated space to store the data\n        const nb = bufferParser.readString(req.buffer);\n        bufferParser.clear();\n\n        if (nb !== undefined) {\n          sftp._debug && sftp._debug(`SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`);\n          req.cb(undefined, req.buffer, nb);\n          return;\n        }\n      } else {\n        const data = bufferParser.readString();\n        bufferParser.clear();\n\n        if (data !== undefined) {\n          sftp._debug && sftp._debug(`SFTP: Inbound: Received DATA (id:${reqID}, ${data.length})`);\n          req.cb(undefined, data);\n          return;\n        }\n      }\n    } else {\n      const nb = bufferParser.skipString();\n      bufferParser.clear();\n\n      if (nb !== undefined) {\n        sftp._debug && sftp._debug(`SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`);\n        return;\n      }\n    }\n\n    return doFatalSFTPError(sftp, 'Malformed DATA packet');\n  },\n  [RESPONSE.NAME]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    let req;\n\n    if (reqID !== undefined) {\n      req = sftp._requests[reqID];\n      delete sftp._requests[reqID];\n    }\n    /*\n      uint32     count\n      repeats count times:\n              string     filename\n              string     longname\n              ATTRS      attrs\n    */\n\n\n    const count = bufferParser.readUInt32BE();\n\n    if (count !== undefined) {\n      let names = [];\n\n      for (let i = 0; i < count; ++i) {\n        // We are going to assume UTF-8 for filenames despite the SFTPv3\n        // spec not specifying an encoding because the specs for newer\n        // versions of the protocol all explicitly specify UTF-8 for\n        // filenames\n        const filename = bufferParser.readString(true); // `longname` only exists in SFTPv3 and since it typically will\n        // contain the filename, we assume it is also UTF-8\n\n        const longname = bufferParser.readString(true);\n        const attrs = readAttrs(sftp._biOpt);\n\n        if (attrs === undefined) {\n          names = undefined;\n          break;\n        }\n\n        names.push({\n          filename,\n          longname,\n          attrs\n        });\n      }\n\n      if (names !== undefined) {\n        sftp._debug && sftp._debug(`SFTP: Inbound: Received NAME (id:${reqID}, ${names.length})`);\n        bufferParser.clear();\n        if (req && typeof req.cb === 'function') req.cb(undefined, names);\n        return;\n      }\n    }\n\n    bufferParser.clear();\n    return doFatalSFTPError(sftp, 'Malformed NAME packet');\n  },\n  [RESPONSE.ATTRS]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    let req;\n\n    if (reqID !== undefined) {\n      req = sftp._requests[reqID];\n      delete sftp._requests[reqID];\n    }\n    /*\n      ATTRS      attrs\n    */\n\n\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n\n    if (attrs !== undefined) {\n      sftp._debug && sftp._debug(`SFTP: Inbound: Received ATTRS (id:${reqID})`);\n      if (req && typeof req.cb === 'function') req.cb(undefined, attrs);\n      return;\n    }\n\n    return doFatalSFTPError(sftp, 'Malformed ATTRS packet');\n  },\n  [RESPONSE.EXTENDED]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n\n    if (reqID !== undefined) {\n      const req = sftp._requests[reqID];\n\n      if (req) {\n        delete sftp._requests[reqID];\n\n        switch (req.extended) {\n          case 'statvfs@openssh.com':\n          case 'fstatvfs@openssh.com':\n            {\n              /*\n                uint64    f_bsize   // file system block size\n                uint64    f_frsize  // fundamental fs block size\n                uint64    f_blocks  // number of blocks (unit f_frsize)\n                uint64    f_bfree   // free blocks in file system\n                uint64    f_bavail  // free blocks for non-root\n                uint64    f_files   // total file inodes\n                uint64    f_ffree   // free file inodes\n                uint64    f_favail  // free file inodes for to non-root\n                uint64    f_fsid    // file system id\n                uint64    f_flag    // bit mask of f_flag values\n                uint64    f_namemax // maximum filename length\n              */\n              const biOpt = sftp._biOpt;\n              const stats = {\n                f_bsize: bufferParser.readUInt64BE(biOpt),\n                f_frsize: bufferParser.readUInt64BE(biOpt),\n                f_blocks: bufferParser.readUInt64BE(biOpt),\n                f_bfree: bufferParser.readUInt64BE(biOpt),\n                f_bavail: bufferParser.readUInt64BE(biOpt),\n                f_files: bufferParser.readUInt64BE(biOpt),\n                f_ffree: bufferParser.readUInt64BE(biOpt),\n                f_favail: bufferParser.readUInt64BE(biOpt),\n                f_sid: bufferParser.readUInt64BE(biOpt),\n                f_flag: bufferParser.readUInt64BE(biOpt),\n                f_namemax: bufferParser.readUInt64BE(biOpt)\n              };\n              if (stats.f_namemax === undefined) break;\n\n              if (sftp._debug) {\n                sftp._debug('SFTP: Inbound: Received EXTENDED_REPLY ' + `(id:${reqID}, ${req.extended})`);\n              }\n\n              bufferParser.clear();\n              if (typeof req.cb === 'function') req.cb(undefined, stats);\n              return;\n            }\n\n          case 'limits@openssh.com':\n            {\n              /*\n                uint64          max-packet-length\n                uint64          max-read-length\n                uint64          max-write-length\n                uint64          max-open-handles\n              */\n              const limits = {\n                maxPktLen: bufferParser.readUInt64BE(),\n                maxReadLen: bufferParser.readUInt64BE(),\n                maxWriteLen: bufferParser.readUInt64BE(),\n                maxOpenHandles: bufferParser.readUInt64BE()\n              };\n              if (limits.maxOpenHandles === undefined) break;\n\n              if (sftp._debug) {\n                sftp._debug('SFTP: Inbound: Received EXTENDED_REPLY ' + `(id:${reqID}, ${req.extended})`);\n              }\n\n              bufferParser.clear();\n              if (typeof req.cb === 'function') req.cb(undefined, limits);\n              return;\n            }\n\n          default:\n            // Unknown extended request\n            sftp._debug && sftp._debug(`SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`);\n            bufferParser.clear();\n            if (typeof req.cb === 'function') req.cb();\n            return;\n        }\n      } else {\n        sftp._debug && sftp._debug(`SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`);\n        bufferParser.clear();\n        return;\n      }\n    }\n\n    bufferParser.clear();\n    return doFatalSFTPError(sftp, 'Malformed EXTENDED_REPLY packet');\n  }\n};\nconst SERVER_HANDLERS = {\n  [REQUEST.INIT]: (sftp, payload) => {\n    if (sftp._version !== -1) return doFatalSFTPError(sftp, 'Duplicate INIT packet');\n    const extensions = {};\n    /*\n      uint32 version\n      <extension data>\n    */\n\n    bufferParser.init(payload, 1);\n    let version = bufferParser.readUInt32BE();\n\n    while (bufferParser.avail()) {\n      const extName = bufferParser.readString(true);\n      const extData = bufferParser.readString(true);\n\n      if (extData === undefined) {\n        version = undefined;\n        break;\n      }\n\n      extensions[extName] = extData;\n    }\n\n    bufferParser.clear();\n    if (version === undefined) return doFatalSFTPError(sftp, 'Malformed INIT packet');\n\n    if (sftp._debug) {\n      const names = Object.keys(extensions);\n\n      if (names.length) {\n        sftp._debug(`SFTP: Inbound: Received INIT (v${version}, exts:${names})`);\n      } else {\n        sftp._debug(`SFTP: Inbound: Received INIT (v${version})`);\n      }\n    }\n\n    sendOrBuffer(sftp, SERVER_VERSION_BUFFER);\n    sftp._version = version;\n    sftp._extensions = extensions;\n    sftp.emit('ready');\n  },\n  [REQUEST.OPEN]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        filename\n      uint32        pflags\n      ATTRS         attrs\n    */\n\n    const filename = bufferParser.readString(true);\n    const pflags = bufferParser.readUInt32BE();\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n    if (attrs === undefined) return doFatalSFTPError(sftp, 'Malformed OPEN packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received OPEN (id:${reqID})`);\n\n    if (!sftp.emit('OPEN', reqID, filename, pflags, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.CLOSE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        handle\n    */\n\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n    if (handle === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed CLOSE packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received CLOSE (id:${reqID})`);\n\n    if (!sftp.emit('CLOSE', reqID, handle)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.READ]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n      uint64     offset\n      uint32     len\n    */\n\n    const handle = bufferParser.readString();\n    const offset = bufferParser.readUInt64BE(sftp._biOpt);\n    const len = bufferParser.readUInt32BE();\n    bufferParser.clear();\n    if (len === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed READ packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received READ (id:${reqID})`);\n\n    if (!sftp.emit('READ', reqID, handle, offset, len)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.WRITE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n      uint64     offset\n      string     data\n    */\n\n    const handle = bufferParser.readString();\n    const offset = bufferParser.readUInt64BE(sftp._biOpt);\n    const data = bufferParser.readString();\n    bufferParser.clear();\n    if (data === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed WRITE packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received WRITE (id:${reqID})`);\n\n    if (!sftp.emit('WRITE', reqID, handle, offset, data)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.LSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed LSTAT packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received LSTAT (id:${reqID})`);\n\n    if (!sftp.emit('LSTAT', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.FSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        handle\n    */\n\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n    if (handle === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed FSTAT packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received FSTAT (id:${reqID})`);\n\n    if (!sftp.emit('FSTAT', reqID, handle)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.SETSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n      ATTRS      attrs\n    */\n\n    const path = bufferParser.readString(true);\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n    if (attrs === undefined) return doFatalSFTPError(sftp, 'Malformed SETSTAT packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received SETSTAT (id:${reqID})`);\n\n    if (!sftp.emit('SETSTAT', reqID, path, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.FSETSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n      ATTRS      attrs\n    */\n\n    const handle = bufferParser.readString();\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n    if (attrs === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed FSETSTAT packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received FSETSTAT (id:${reqID})`);\n\n    if (!sftp.emit('FSETSTAT', reqID, handle, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.OPENDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed OPENDIR packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received OPENDIR (id:${reqID})`);\n\n    if (!sftp.emit('OPENDIR', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.READDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        handle\n    */\n\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n    if (handle === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed READDIR packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received READDIR (id:${reqID})`);\n\n    if (!sftp.emit('READDIR', reqID, handle)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.REMOVE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed REMOVE packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received REMOVE (id:${reqID})`);\n\n    if (!sftp.emit('REMOVE', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.MKDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n      ATTRS      attrs\n    */\n\n    const path = bufferParser.readString(true);\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n    if (attrs === undefined) return doFatalSFTPError(sftp, 'Malformed MKDIR packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received MKDIR (id:${reqID})`);\n\n    if (!sftp.emit('MKDIR', reqID, path, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.RMDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed RMDIR packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received RMDIR (id:${reqID})`);\n\n    if (!sftp.emit('RMDIR', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.REALPATH]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed REALPATH packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received REALPATH (id:${reqID})`);\n\n    if (!sftp.emit('REALPATH', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.STAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed STAT packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received STAT (id:${reqID})`);\n\n    if (!sftp.emit('STAT', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.RENAME]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     oldpath\n      string     newpath\n    */\n\n    const oldPath = bufferParser.readString(true);\n    const newPath = bufferParser.readString(true);\n    bufferParser.clear();\n    if (newPath === undefined) return doFatalSFTPError(sftp, 'Malformed RENAME packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received RENAME (id:${reqID})`);\n\n    if (!sftp.emit('RENAME', reqID, oldPath, newPath)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.READLINK]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed READLINK packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received READLINK (id:${reqID})`);\n\n    if (!sftp.emit('READLINK', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.SYMLINK]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     linkpath\n      string     targetpath\n    */\n\n    const linkPath = bufferParser.readString(true);\n    const targetPath = bufferParser.readString(true);\n    bufferParser.clear();\n    if (targetPath === undefined) return doFatalSFTPError(sftp, 'Malformed SYMLINK packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received SYMLINK (id:${reqID})`);\n    let handled;\n\n    if (sftp._isOpenSSH) {\n      // OpenSSH has linkpath and targetpath positions switched\n      handled = sftp.emit('SYMLINK', reqID, targetPath, linkPath);\n    } else {\n      handled = sftp.emit('SYMLINK', reqID, linkPath, targetPath);\n    }\n\n    if (!handled) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.EXTENDED]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     extended-request\n      ... any request-specific data ...\n    */\n\n    const extName = bufferParser.readString(true);\n\n    if (extName === undefined) {\n      bufferParser.clear();\n      return doFatalSFTPError(sftp, 'Malformed EXTENDED packet');\n    }\n\n    let extData;\n    if (bufferParser.avail()) extData = bufferParser.readRaw();\n    bufferParser.clear();\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received EXTENDED (id:${reqID})`);\n\n    if (!sftp.emit('EXTENDED', reqID, extName, extData)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  }\n}; // =============================================================================\n// ReadStream/WriteStream-related ==============================================\n// =============================================================================\n\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_OUT_OF_RANGE,\n  validateNumber\n} = require('./node-fs-compat');\n\nconst kMinPoolSpace = 128;\nlet pool; // It can happen that we expect to read a large chunk of data, and reserve\n// a large chunk of the pool accordingly, but the read() call only filled\n// a portion of it. If a concurrently executing read() then uses the same pool,\n// the \"reserved\" portion cannot be used, so we allow it to be re-used as a\n// new pool later.\n\nconst poolFragments = [];\n\nfunction allocNewPool(poolSize) {\n  if (poolFragments.length > 0) pool = poolFragments.pop();else pool = Buffer.allocUnsafe(poolSize);\n  pool.used = 0;\n} // Check the `this.start` and `this.end` of stream.\n\n\nfunction checkPosition(pos, name) {\n  if (!Number.isSafeInteger(pos)) {\n    validateNumber(pos, name);\n    if (!Number.isInteger(pos)) throw new ERR_OUT_OF_RANGE(name, 'an integer', pos);\n    throw new ERR_OUT_OF_RANGE(name, '>= 0 and <= 2 ** 53 - 1', pos);\n  }\n\n  if (pos < 0) throw new ERR_OUT_OF_RANGE(name, '>= 0 and <= 2 ** 53 - 1', pos);\n}\n\nfunction roundUpToMultipleOf8(n) {\n  return n + 7 & ~7; // Align to 8 byte boundary.\n}\n\nfunction ReadStream(sftp, path, options) {\n  if (options === undefined) options = {};else if (typeof options === 'string') options = {\n    encoding: options\n  };else if (options === null || typeof options !== 'object') throw new TypeError('\"options\" argument must be a string or an object');else options = Object.create(options); // A little bit bigger buffer and water marks by default\n\n  if (options.highWaterMark === undefined) options.highWaterMark = 64 * 1024; // For backwards compat do not emit close on destroy.\n\n  options.emitClose = false;\n  options.autoDestroy = false; // Node 14 major change.\n\n  ReadableStream.call(this, options);\n  this.path = path;\n  this.flags = options.flags === undefined ? 'r' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n  this.start = options.start;\n  this.end = options.end;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.bytesRead = 0;\n  this.isClosed = false;\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.sftp = sftp;\n  this._opening = false;\n\n  if (this.start !== undefined) {\n    checkPosition(this.start, 'start');\n    this.pos = this.start;\n  }\n\n  if (this.end === undefined) {\n    this.end = Infinity;\n  } else if (this.end !== Infinity) {\n    checkPosition(this.end, 'end');\n\n    if (this.start !== undefined && this.start > this.end) {\n      throw new ERR_OUT_OF_RANGE('start', `<= \"end\" (here: ${this.end})`, this.start);\n    }\n  }\n\n  this.on('end', function () {\n    if (this.autoClose) this.destroy();\n  });\n  if (!Buffer.isBuffer(this.handle)) this.open();\n}\n\ninherits(ReadStream, ReadableStream);\n\nReadStream.prototype.open = function () {\n  if (this._opening) return;\n  this._opening = true;\n  this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {\n    this._opening = false;\n\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose) this.destroy();\n      return;\n    }\n\n    this.handle = handle;\n    this.emit('open', handle);\n    this.emit('ready'); // Start the flow of data.\n\n    this.read();\n  });\n};\n\nReadStream.prototype._read = function (n) {\n  if (!Buffer.isBuffer(this.handle)) return this.once('open', () => this._read(n)); // XXX: safe to remove this?\n\n  if (this.destroyed) return;\n\n  if (!pool || pool.length - pool.used < kMinPoolSpace) {\n    // Discard the old pool.\n    allocNewPool(this.readableHighWaterMark || this._readableState.highWaterMark);\n  } // Grab another reference to the pool in the case that while we're\n  // in the thread pool another read() finishes up the pool, and\n  // allocates a new one.\n\n\n  const thisPool = pool;\n  let toRead = Math.min(pool.length - pool.used, n);\n  const start = pool.used;\n  if (this.end !== undefined) toRead = Math.min(this.end - this.pos + 1, toRead); // Already read everything we were supposed to read!\n  // treat as EOF.\n\n  if (toRead <= 0) return this.push(null); // the actual read.\n\n  this.sftp.read(this.handle, pool, pool.used, toRead, this.pos, (er, bytesRead) => {\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose) this.destroy();\n      return;\n    }\n\n    let b = null; // Now that we know how much data we have actually read, re-wind the\n    // 'used' field if we can, and otherwise allow the remainder of our\n    // reservation to be used as a new pool later.\n\n    if (start + toRead === thisPool.used && thisPool === pool) {\n      thisPool.used = roundUpToMultipleOf8(thisPool.used + bytesRead - toRead);\n    } else {\n      // Round down to the next lowest multiple of 8 to ensure the new pool\n      // fragment start and end positions are aligned to an 8 byte boundary.\n      const alignedEnd = start + toRead & ~7;\n      const alignedStart = roundUpToMultipleOf8(start + bytesRead);\n      if (alignedEnd - alignedStart >= kMinPoolSpace) poolFragments.push(thisPool.slice(alignedStart, alignedEnd));\n    }\n\n    if (bytesRead > 0) {\n      this.bytesRead += bytesRead;\n      b = thisPool.slice(start, start + bytesRead);\n    } // Move the pool positions, and internal position for reading.\n\n\n    this.pos += bytesRead;\n    this.push(b);\n  });\n  pool.used = roundUpToMultipleOf8(pool.used + toRead);\n};\n\nReadStream.prototype._destroy = function (err, cb) {\n  if (this._opening && !Buffer.isBuffer(this.handle)) {\n    this.once('open', closeStream.bind(null, this, cb, err));\n    return;\n  }\n\n  closeStream(this, cb, err);\n  this.handle = null;\n  this._opening = false;\n};\n\nfunction closeStream(stream, cb, err) {\n  if (!stream.handle) return onclose();\n  stream.sftp.close(stream.handle, onclose);\n\n  function onclose(er) {\n    er = er || err;\n    cb(er);\n    stream.isClosed = true;\n    if (!er) stream.emit('close');\n  }\n}\n\nReadStream.prototype.close = function (cb) {\n  this.destroy(null, cb);\n};\n\nObject.defineProperty(ReadStream.prototype, 'pending', {\n  get() {\n    return this.handle === null;\n  },\n\n  configurable: true\n}); // TODO: add `concurrency` setting to allow more than one in-flight WRITE\n// request to server to improve throughput\n\nfunction WriteStream(sftp, path, options) {\n  if (options === undefined) options = {};else if (typeof options === 'string') options = {\n    encoding: options\n  };else if (options === null || typeof options !== 'object') throw new TypeError('\"options\" argument must be a string or an object');else options = Object.create(options); // For backwards compat do not emit close on destroy.\n\n  options.emitClose = false;\n  options.autoDestroy = false; // Node 14 major change.\n\n  WritableStream.call(this, options);\n  this.path = path;\n  this.flags = options.flags === undefined ? 'w' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n  this.start = options.start;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.bytesWritten = 0;\n  this.isClosed = false;\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.sftp = sftp;\n  this._opening = false;\n\n  if (this.start !== undefined) {\n    checkPosition(this.start, 'start');\n    this.pos = this.start;\n  }\n\n  if (options.encoding) this.setDefaultEncoding(options.encoding); // Node v6.x only\n\n  this.on('finish', function () {\n    if (this._writableState.finalCalled) return;\n    if (this.autoClose) this.destroy();\n  });\n  if (!Buffer.isBuffer(this.handle)) this.open();\n}\n\ninherits(WriteStream, WritableStream);\n\nWriteStream.prototype._final = function (cb) {\n  if (this.autoClose) this.destroy();\n  cb();\n};\n\nWriteStream.prototype.open = function () {\n  if (this._opening) return;\n  this._opening = true;\n  this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {\n    this._opening = false;\n\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose) this.destroy();\n      return;\n    }\n\n    this.handle = handle;\n\n    const tryAgain = err => {\n      if (err) {\n        // Try chmod() for sftp servers that may not support fchmod() for\n        // whatever reason\n        this.sftp.chmod(this.path, this.mode, err_ => tryAgain());\n        return;\n      } // SFTPv3 requires absolute offsets, no matter the open flag used\n\n\n      if (this.flags[0] === 'a') {\n        const tryStat = (err, st) => {\n          if (err) {\n            // Try stat() for sftp servers that may not support fstat() for\n            // whatever reason\n            this.sftp.stat(this.path, (err_, st_) => {\n              if (err_) {\n                this.destroy();\n                this.emit('error', err);\n                return;\n              }\n\n              tryStat(null, st_);\n            });\n            return;\n          }\n\n          this.pos = st.size;\n          this.emit('open', handle);\n          this.emit('ready');\n        };\n\n        this.sftp.fstat(handle, tryStat);\n        return;\n      }\n\n      this.emit('open', handle);\n      this.emit('ready');\n    };\n\n    this.sftp.fchmod(handle, this.mode, tryAgain);\n  });\n};\n\nWriteStream.prototype._write = function (data, encoding, cb) {\n  if (!Buffer.isBuffer(data)) {\n    const err = new ERR_INVALID_ARG_TYPE('data', 'Buffer', data);\n    return this.emit('error', err);\n  }\n\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function () {\n      this._write(data, encoding, cb);\n    });\n  }\n\n  this.sftp.write(this.handle, data, 0, data.length, this.pos, (er, bytes) => {\n    if (er) {\n      if (this.autoClose) this.destroy();\n      return cb(er);\n    }\n\n    this.bytesWritten += bytes;\n    cb();\n  });\n  this.pos += data.length;\n};\n\nWriteStream.prototype._writev = function (data, cb) {\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function () {\n      this._writev(data, cb);\n    });\n  }\n\n  const sftp = this.sftp;\n  const handle = this.handle;\n  let writesLeft = data.length;\n\n  const onwrite = (er, bytes) => {\n    if (er) {\n      this.destroy();\n      return cb(er);\n    }\n\n    this.bytesWritten += bytes;\n    if (--writesLeft === 0) cb();\n  }; // TODO: try to combine chunks to reduce number of requests to the server?\n\n\n  for (let i = 0; i < data.length; ++i) {\n    const chunk = data[i].chunk;\n    sftp.write(handle, chunk, 0, chunk.length, this.pos, onwrite);\n    this.pos += chunk.length;\n  }\n};\n\nif (typeof WritableStream.prototype.destroy !== 'function') WriteStream.prototype.destroy = ReadStream.prototype.destroy;\nWriteStream.prototype._destroy = ReadStream.prototype._destroy;\n\nWriteStream.prototype.close = function (cb) {\n  if (cb) {\n    if (this.isClosed) {\n      process.nextTick(cb);\n      return;\n    }\n\n    this.on('close', cb);\n  } // If we are not autoClosing, we should call\n  // destroy on 'finish'.\n\n\n  if (!this.autoClose) this.on('finish', this.destroy.bind(this));\n  this.end();\n}; // There is no shutdown() for files.\n\n\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\nObject.defineProperty(WriteStream.prototype, 'pending', {\n  get() {\n    return this.handle === null;\n  },\n\n  configurable: true\n}); // =============================================================================\n\nmodule.exports = {\n  flagsToString,\n  OPEN_MODE,\n  SFTP,\n  Stats,\n  STATUS_CODE,\n  stringToFlags\n};","map":{"version":3,"names":["EventEmitter","require","fs","constants","Readable","ReadableStream","Writable","WritableStream","inherits","isDate","FastBuffer","Buffer","Symbol","species","bufferCopy","bufferSlice","makeBufferParser","writeUInt32BE","ATTR","SIZE","UIDGID","PERMISSIONS","ACMODTIME","EXTENDED","ATTRS_BUF","alloc","STATUS_CODE","OK","EOF","NO_SUCH_FILE","PERMISSION_DENIED","FAILURE","BAD_MESSAGE","NO_CONNECTION","CONNECTION_LOST","OP_UNSUPPORTED","VALID_STATUS_CODES","Map","Object","values","map","n","STATUS_CODE_STR","REQUEST","INIT","OPEN","CLOSE","READ","WRITE","LSTAT","FSTAT","SETSTAT","FSETSTAT","OPENDIR","READDIR","REMOVE","MKDIR","RMDIR","REALPATH","STAT","RENAME","READLINK","SYMLINK","RESPONSE","VERSION","STATUS","HANDLE","DATA","NAME","ATTRS","OPEN_MODE","APPEND","CREAT","TRUNC","EXCL","PKT_RW_OVERHEAD","MAX_REQID","CLIENT_VERSION_BUFFER","from","SERVER_VERSION_BUFFER","RE_OPENSSH","OPENSSH_MAX_PKT_LEN","bufferParser","fakeStderr","readable","writable","push","data","once","on","emit","end","noop","SFTP","constructor","client","chanInfo","cfg","remoteIdentRaw","_protocol","_remoteIdentRaw","server","_debug","debug","undefined","_isOpenSSH","test","_version","_extensions","_biOpt","biOpt","_pktLenBytes","_pktLen","_pktPos","_pktType","_pktData","_writeReqid","_requests","_maxInPktLen","_maxOutPktLen","_maxReadLen","_maxWriteLen","maxOpenHandles","_client","_callbacks","_hasX11","_exit","code","signal","dump","desc","_waitWindow","_chunkcb","_buffer","type","subtype","incoming","outgoing","stderr","cleanupRequests","p","length","nb","Math","min","doFatalSFTPError","max","_pkt","buffer","byteOffset","allocUnsafe","set","Uint8Array","payload","handler","SERVER_HANDLERS","CLIENT_HANDLERS","destroy","state","channelClose","id","_init","sendOrBuffer","createReadStream","path","options","Error","ReadStream","createWriteStream","WriteStream","open","flags_","attrs","cb","flags","stringToFlags","attrsFlags","attrsLen","mode","attrsToBytes","pathLen","byteLength","buf","reqid","utf8Write","isBuffered","close","handle","isBuffer","handleLen","read","off","len","position","read_","readData","write","process","nextTick","maxDataLen","overflow","origPosition","out","i","err","isSent","how","writeData","fastGet","remotePath","localPath","opts","fastXfer","fastPut","readFile","callback_","callback","encoding","flag","TypeError","isEncoding","size","buffers","pos","bytesRead","afterRead","er","nbytes","eof","_wantEOFError","concat","toString","handle_","tryStat","st","stat","er_","st_","fstat","writeFile","openErr","writeAll","appendFile","assign","exists","unlink","filename","fnameLen","rename","oldPath","newPath","oldLen","newLen","mkdir","rmdir","readdir","where","doFilter","full","entries","e","reread","list","opendir","splice","lstat","setstat","fsetstat","futimes","atime","mtime","toUnixTimestamp","utimes","fchown","uid","gid","chown","fchmod","chmod","readlink","names","symlink","targetPath","linkPath","linkLen","targetLen","realpath","ext_openssh_rename","ext","which","ext_openssh_statvfs","extended","ext_openssh_fstatvfs","ext_openssh_hardlink","ext_openssh_fsync","ext_openssh_lsetstat","status","ext_openssh_expandPath","ext_copy_data","srcHandle","srcOffset","dstHandle","dstOffset","message","has","msgLen","isUTF8","dataLen","name","Array","isArray","count","namesLen","nameAttrs","longname","bytes","attr","tryCreateBuffer","ex","self","req_","req","origOff","src","dst","srcPath","dstPath","concurrency","chunkSize","onstep","fileSize","isNaN","step","modeNum","fsize","pdst","total","hadError","readbuf","bufsize","onerror","left","cbfinal","sourceHandle","err_","attrs_","destHandle","tryAgain","startReads","onread","dstpos","datapos","origChunkLen","writeCb","singleRead","chunk","makeCb","psrc","reads","sftp","offset","writeErr","written","Stats","initial","isDirectory","S_IFMT","S_IFDIR","isFile","S_IFREG","isBlockDevice","S_IFBLK","isCharacterDevice","S_IFCHR","isSymbolicLink","S_IFLNK","isFIFO","S_IFIFO","isSocket","S_IFSOCK","val","time","parseInt","getTime","stringFlagMap","str","flagsToString","stringFlagMapKeys","keys","key","readAttrs","readUInt32BE","readUInt64BE","readString","ret","tryWritePayload","window","drainBuffer","actualLen","packetSize","channelData","slice","msg","noDebug","level","reqs","requestLimits","extensions","init","version","avail","extName","extData","clear","limits","maxPktLen","maxReadLen","maxWriteLen","Infinity","reqID","errorCode","errorMsg","jsonMsg","JSON","stringify","skipString","stats","f_bsize","f_frsize","f_blocks","f_bfree","f_bavail","f_files","f_ffree","f_favail","f_sid","f_flag","f_namemax","pflags","handled","readRaw","ERR_INVALID_ARG_TYPE","ERR_OUT_OF_RANGE","validateNumber","kMinPoolSpace","pool","poolFragments","allocNewPool","poolSize","pop","used","checkPosition","Number","isSafeInteger","isInteger","roundUpToMultipleOf8","create","highWaterMark","emitClose","autoDestroy","call","start","autoClose","isClosed","_opening","prototype","_read","destroyed","readableHighWaterMark","_readableState","thisPool","toRead","b","alignedEnd","alignedStart","_destroy","closeStream","bind","stream","onclose","defineProperty","get","configurable","bytesWritten","setDefaultEncoding","_writableState","finalCalled","_final","_write","_writev","writesLeft","onwrite","destroySoon","module","exports"],"sources":["/home/micqdf/AlpacaPunchTests/maintest/test1/client/node_modules/ssh2/lib/protocol/SFTP.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst fs = require('fs');\nconst { constants } = fs;\nconst {\n  Readable: ReadableStream,\n  Writable: WritableStream\n} = require('stream');\nconst { inherits, isDate } = require('util');\n\nconst FastBuffer = Buffer[Symbol.species];\n\nconst {\n  bufferCopy,\n  bufferSlice,\n  makeBufferParser,\n  writeUInt32BE,\n} = require('./utils.js');\n\nconst ATTR = {\n  SIZE: 0x00000001,\n  UIDGID: 0x00000002,\n  PERMISSIONS: 0x00000004,\n  ACMODTIME: 0x00000008,\n  EXTENDED: 0x80000000,\n};\n\n// Large enough to store all possible attributes\nconst ATTRS_BUF = Buffer.alloc(28);\n\nconst STATUS_CODE = {\n  OK: 0,\n  EOF: 1,\n  NO_SUCH_FILE: 2,\n  PERMISSION_DENIED: 3,\n  FAILURE: 4,\n  BAD_MESSAGE: 5,\n  NO_CONNECTION: 6,\n  CONNECTION_LOST: 7,\n  OP_UNSUPPORTED: 8\n};\n\nconst VALID_STATUS_CODES = new Map(\n  Object.values(STATUS_CODE).map((n) => [n, 1])\n);\n\nconst STATUS_CODE_STR = {\n  [STATUS_CODE.OK]: 'No error',\n  [STATUS_CODE.EOF]: 'End of file',\n  [STATUS_CODE.NO_SUCH_FILE]: 'No such file or directory',\n  [STATUS_CODE.PERMISSION_DENIED]: 'Permission denied',\n  [STATUS_CODE.FAILURE]: 'Failure',\n  [STATUS_CODE.BAD_MESSAGE]: 'Bad message',\n  [STATUS_CODE.NO_CONNECTION]: 'No connection',\n  [STATUS_CODE.CONNECTION_LOST]: 'Connection lost',\n  [STATUS_CODE.OP_UNSUPPORTED]: 'Operation unsupported',\n};\n\nconst REQUEST = {\n  INIT: 1,\n  OPEN: 3,\n  CLOSE: 4,\n  READ: 5,\n  WRITE: 6,\n  LSTAT: 7,\n  FSTAT: 8,\n  SETSTAT: 9,\n  FSETSTAT: 10,\n  OPENDIR: 11,\n  READDIR: 12,\n  REMOVE: 13,\n  MKDIR: 14,\n  RMDIR: 15,\n  REALPATH: 16,\n  STAT: 17,\n  RENAME: 18,\n  READLINK: 19,\n  SYMLINK: 20,\n  EXTENDED: 200\n};\n\nconst RESPONSE = {\n  VERSION: 2,\n  STATUS: 101,\n  HANDLE: 102,\n  DATA: 103,\n  NAME: 104,\n  ATTRS: 105,\n  EXTENDED: 201\n};\n\nconst OPEN_MODE = {\n  READ: 0x00000001,\n  WRITE: 0x00000002,\n  APPEND: 0x00000004,\n  CREAT: 0x00000008,\n  TRUNC: 0x00000010,\n  EXCL: 0x00000020\n};\n\nconst PKT_RW_OVERHEAD = 2 * 1024;\nconst MAX_REQID = 2 ** 32 - 1;\nconst CLIENT_VERSION_BUFFER = Buffer.from([\n  0, 0, 0, 5 /* length */,\n    REQUEST.INIT,\n    0, 0, 0, 3 /* version */\n]);\nconst SERVER_VERSION_BUFFER = Buffer.from([\n  0, 0, 0, 5 /* length */,\n    RESPONSE.VERSION,\n    0, 0, 0, 3 /* version */\n]);\n\nconst RE_OPENSSH = /^SSH-2.0-(?:OpenSSH|dropbear)/;\nconst OPENSSH_MAX_PKT_LEN = 256 * 1024;\n\nconst bufferParser = makeBufferParser();\n\nconst fakeStderr = {\n  readable: false,\n  writable: false,\n  push: (data) => {},\n  once: () => {},\n  on: () => {},\n  emit: () => {},\n  end: () => {},\n};\n\nfunction noop() {}\n\n// Emulates enough of `Channel` to be able to be used as a drop-in replacement\n// in order to process incoming data with as little overhead as possible\nclass SFTP extends EventEmitter {\n  constructor(client, chanInfo, cfg) {\n    super();\n\n    if (typeof cfg !== 'object' || !cfg)\n      cfg = {};\n\n    const remoteIdentRaw = client._protocol._remoteIdentRaw;\n\n    this.server = !!cfg.server;\n    this._debug = (typeof cfg.debug === 'function' ? cfg.debug : undefined);\n    this._isOpenSSH = (remoteIdentRaw && RE_OPENSSH.test(remoteIdentRaw));\n\n    this._version = -1;\n    this._extensions = {};\n    this._biOpt = cfg.biOpt;\n    this._pktLenBytes = 0;\n    this._pktLen = 0;\n    this._pktPos = 0;\n    this._pktType = 0;\n    this._pktData = undefined;\n    this._writeReqid = -1;\n    this._requests = {};\n    this._maxInPktLen = OPENSSH_MAX_PKT_LEN;\n    this._maxOutPktLen = 34000;\n    this._maxReadLen =\n      (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34000) - PKT_RW_OVERHEAD;\n    this._maxWriteLen =\n      (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34000) - PKT_RW_OVERHEAD;\n\n    this.maxOpenHandles = undefined;\n\n    // Channel compatibility\n    this._client = client;\n    this._protocol = client._protocol;\n    this._callbacks = [];\n    this._hasX11 = false;\n    this._exit = {\n      code: undefined,\n      signal: undefined,\n      dump: undefined,\n      desc: undefined,\n    };\n    this._waitWindow = false; // SSH-level backpressure\n    this._chunkcb = undefined;\n    this._buffer = [];\n    this.type = chanInfo.type;\n    this.subtype = undefined;\n    this.incoming = chanInfo.incoming;\n    this.outgoing = chanInfo.outgoing;\n    this.stderr = fakeStderr;\n    this.readable = true;\n  }\n\n  // This handles incoming data to parse\n  push(data) {\n    if (data === null) {\n      cleanupRequests(this);\n      if (!this.readable)\n        return;\n      // No more incoming data from the remote side\n      this.readable = false;\n      this.emit('end');\n      return;\n    }\n    /*\n        uint32             length\n        byte               type\n        byte[length - 1]   data payload\n    */\n    let p = 0;\n\n    while (p < data.length) {\n      if (this._pktLenBytes < 4) {\n        let nb = Math.min(4 - this._pktLenBytes, data.length - p);\n        this._pktLenBytes += nb;\n\n        while (nb--)\n          this._pktLen = (this._pktLen << 8) + data[p++];\n\n        if (this._pktLenBytes < 4)\n          return;\n        if (this._pktLen === 0)\n          return doFatalSFTPError(this, 'Invalid packet length');\n        if (this._pktLen > this._maxInPktLen) {\n          const max = this._maxInPktLen;\n          return doFatalSFTPError(\n            this,\n            `Packet length ${this._pktLen} exceeds max length of ${max}`\n          );\n        }\n        if (p >= data.length)\n          return;\n      }\n      if (this._pktPos < this._pktLen) {\n        const nb = Math.min(this._pktLen - this._pktPos, data.length - p);\n        if (p !== 0 || nb !== data.length) {\n          if (nb === this._pktLen) {\n            this._pkt = new FastBuffer(data.buffer, data.byteOffset + p, nb);\n          } else {\n            if (!this._pkt)\n              this._pkt = Buffer.allocUnsafe(this._pktLen);\n            this._pkt.set(\n              new Uint8Array(data.buffer, data.byteOffset + p, nb),\n              this._pktPos\n            );\n          }\n        } else if (nb === this._pktLen) {\n          this._pkt = data;\n        } else {\n          if (!this._pkt)\n            this._pkt = Buffer.allocUnsafe(this._pktLen);\n          this._pkt.set(data, this._pktPos);\n        }\n        p += nb;\n        this._pktPos += nb;\n        if (this._pktPos < this._pktLen)\n          return;\n      }\n\n      const type = this._pkt[0];\n      const payload = this._pkt;\n\n      // Prepare for next packet\n      this._pktLen = 0;\n      this._pktLenBytes = 0;\n      this._pkt = undefined;\n      this._pktPos = 0;\n\n      const handler = (this.server\n                       ? SERVER_HANDLERS[type]\n                       : CLIENT_HANDLERS[type]);\n      if (!handler)\n        return doFatalSFTPError(this, `Unknown packet type ${type}`);\n\n      if (this._version === -1) {\n        if (this.server) {\n          if (type !== REQUEST.INIT)\n            return doFatalSFTPError(this, `Expected INIT packet, got ${type}`);\n        } else if (type !== RESPONSE.VERSION) {\n          return doFatalSFTPError(this, `Expected VERSION packet, got ${type}`);\n        }\n      }\n\n      if (handler(this, payload) === false)\n        return;\n    }\n  }\n\n  end() {\n    this.destroy();\n  }\n  destroy() {\n    if (this.outgoing.state === 'open' || this.outgoing.state === 'eof') {\n      this.outgoing.state = 'closing';\n      this._protocol.channelClose(this.outgoing.id);\n    }\n  }\n  _init() {\n    this._init = noop;\n    if (!this.server)\n      sendOrBuffer(this, CLIENT_VERSION_BUFFER);\n  }\n\n  // ===========================================================================\n  // Client-specific ===========================================================\n  // ===========================================================================\n  createReadStream(path, options) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    return new ReadStream(this, path, options);\n  }\n  createWriteStream(path, options) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    return new WriteStream(this, path, options);\n  }\n  open(path, flags_, attrs, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    if (typeof attrs === 'function') {\n      cb = attrs;\n      attrs = undefined;\n    }\n\n    const flags = (typeof flags_ === 'number' ? flags_ : stringToFlags(flags_));\n    if (flags === null)\n      throw new Error(`Unknown flags string: ${flags_}`);\n\n    let attrsFlags = 0;\n    let attrsLen = 0;\n    if (typeof attrs === 'string' || typeof attrs === 'number')\n      attrs = { mode: attrs };\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      attrsFlags = attrs.flags;\n      attrsLen = attrs.nb;\n    }\n\n    /*\n      uint32        id\n      string        filename\n      uint32        pflags\n      ATTRS         attrs\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + 4 + attrsLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.OPEN;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n    writeUInt32BE(buf, attrsFlags, p += 4);\n    if (attrsLen) {\n      p += 4;\n\n      if (attrsLen === ATTRS_BUF.length)\n        buf.set(ATTRS_BUF, p);\n      else\n        bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n\n      p += attrsLen;\n    }\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} OPEN`\n    );\n  }\n  close(handle, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    if (!Buffer.isBuffer(handle))\n      throw new Error('handle is not a Buffer');\n\n    /*\n      uint32     id\n      string     handle\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.CLOSE;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(handle, p += 4);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} CLOSE`\n    );\n  }\n  read(handle, buf, off, len, position, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle))\n      throw new Error('handle is not a Buffer');\n    if (!Buffer.isBuffer(buf))\n      throw new Error('buffer is not a Buffer');\n    if (off >= buf.length)\n      throw new Error('offset is out of bounds');\n    if (off + len > buf.length)\n      throw new Error('length extends beyond buffer');\n    if (position === null)\n      throw new Error('null position currently unsupported');\n\n    read_(this, handle, buf, off, len, position, cb);\n  }\n  readData(handle, buf, off, len, position, cb) {\n    // Backwards compatibility\n    this.read(handle, buf, off, len, position, cb);\n  }\n  write(handle, buf, off, len, position, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    if (!Buffer.isBuffer(handle))\n      throw new Error('handle is not a Buffer');\n    if (!Buffer.isBuffer(buf))\n      throw new Error('buffer is not a Buffer');\n    if (off > buf.length)\n      throw new Error('offset is out of bounds');\n    if (off + len > buf.length)\n      throw new Error('length extends beyond buffer');\n    if (position === null)\n      throw new Error('null position currently unsupported');\n\n    if (!len) {\n      cb && process.nextTick(cb, undefined, 0);\n      return;\n    }\n\n    const maxDataLen = this._maxWriteLen;\n    const overflow = Math.max(len - maxDataLen, 0);\n    const origPosition = position;\n\n    if (overflow)\n      len = maxDataLen;\n\n    /*\n      uint32     id\n      string     handle\n      uint64     offset\n      string     data\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4 + len);\n\n    writeUInt32BE(out, out.length - 4, 0);\n    out[4] = REQUEST.WRITE;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(out, reqid, 5);\n\n    writeUInt32BE(out, handleLen, p);\n    out.set(handle, p += 4);\n    p += handleLen;\n    for (let i = 7; i >= 0; --i) {\n      out[p + i] = position & 0xFF;\n      position /= 256;\n    }\n    writeUInt32BE(out, len, p += 8);\n    bufferCopy(buf, out, off, off + len, p += 4);\n\n    this._requests[reqid] = {\n      cb: (err) => {\n        if (err) {\n          if (typeof cb === 'function')\n            cb(err);\n        } else if (overflow) {\n          this.write(handle,\n                     buf,\n                     off + len,\n                     overflow,\n                     origPosition + len,\n                     cb);\n        } else if (typeof cb === 'function') {\n          cb(undefined, off + len);\n        }\n      }\n    };\n\n    const isSent = sendOrBuffer(this, out);\n    if (this._debug) {\n      const how = (isSent ? 'Sent' : 'Buffered');\n      this._debug(`SFTP: Outbound: ${how} WRITE (id:${reqid})`);\n    }\n  }\n  writeData(handle, buf, off, len, position, cb) {\n    // Backwards compatibility\n    this.write(handle, buf, off, len, position, cb);\n  }\n  fastGet(remotePath, localPath, opts, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    fastXfer(this, fs, remotePath, localPath, opts, cb);\n  }\n  fastPut(localPath, remotePath, opts, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    fastXfer(fs, this, localPath, remotePath, opts, cb);\n  }\n  readFile(path, options, callback_) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    let callback;\n    if (typeof callback_ === 'function') {\n      callback = callback_;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n\n    if (typeof options === 'string')\n      options = { encoding: options, flag: 'r' };\n    else if (!options)\n      options = { encoding: null, flag: 'r' };\n    else if (typeof options !== 'object')\n      throw new TypeError('Bad arguments');\n\n    const encoding = options.encoding;\n    if (encoding && !Buffer.isEncoding(encoding))\n      throw new Error(`Unknown encoding: ${encoding}`);\n\n    // First stat the file, so we know the size.\n    let size;\n    let buffer; // Single buffer with file data\n    let buffers; // List for when size is unknown\n    let pos = 0;\n    let handle;\n\n    // SFTPv3 does not support using -1 for read position, so we have to track\n    // read position manually\n    let bytesRead = 0;\n\n    const flag = options.flag || 'r';\n\n    const read = () => {\n      if (size === 0) {\n        buffer = Buffer.allocUnsafe(8192);\n        this.read(handle, buffer, 0, 8192, bytesRead, afterRead);\n      } else {\n        this.read(handle, buffer, pos, size - pos, bytesRead, afterRead);\n      }\n    };\n\n    const afterRead = (er, nbytes) => {\n      let eof;\n      if (er) {\n        eof = (er.code === STATUS_CODE.EOF);\n        if (!eof) {\n          return this.close(handle, () => {\n            return callback && callback(er);\n          });\n        }\n      } else {\n        eof = false;\n      }\n\n      if (eof || (size === 0 && nbytes === 0))\n        return close();\n\n      bytesRead += nbytes;\n      pos += nbytes;\n      if (size !== 0) {\n        if (pos === size)\n          close();\n        else\n          read();\n      } else {\n        // Unknown size, just read until we don't get bytes.\n        buffers.push(bufferSlice(buffer, 0, nbytes));\n        read();\n      }\n    };\n    afterRead._wantEOFError = true;\n\n    const close = () => {\n      this.close(handle, (er) => {\n        if (size === 0) {\n          // Collect the data into the buffers list.\n          buffer = Buffer.concat(buffers, pos);\n        } else if (pos < size) {\n          buffer = bufferSlice(buffer, 0, pos);\n        }\n\n        if (encoding)\n          buffer = buffer.toString(encoding);\n        return callback && callback(er, buffer);\n      });\n    };\n\n    this.open(path, flag, 0o666, (er, handle_) => {\n      if (er)\n        return callback && callback(er);\n      handle = handle_;\n\n      const tryStat = (er, st) => {\n        if (er) {\n          // Try stat() for sftp servers that may not support fstat() for\n          // whatever reason\n          this.stat(path, (er_, st_) => {\n            if (er_) {\n              return this.close(handle, () => {\n                callback && callback(er);\n              });\n            }\n            tryStat(null, st_);\n          });\n          return;\n        }\n\n        size = st.size || 0;\n        if (size === 0) {\n          // The kernel lies about many files.\n          // Go ahead and try to read some bytes.\n          buffers = [];\n          return read();\n        }\n\n        buffer = Buffer.allocUnsafe(size);\n        read();\n      };\n      this.fstat(handle, tryStat);\n    });\n  }\n  writeFile(path, data, options, callback_) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    let callback;\n    if (typeof callback_ === 'function') {\n      callback = callback_;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n\n    if (typeof options === 'string')\n      options = { encoding: options, mode: 0o666, flag: 'w' };\n    else if (!options)\n      options = { encoding: 'utf8', mode: 0o666, flag: 'w' };\n    else if (typeof options !== 'object')\n      throw new TypeError('Bad arguments');\n\n    if (options.encoding && !Buffer.isEncoding(options.encoding))\n      throw new Error(`Unknown encoding: ${options.encoding}`);\n\n    const flag = options.flag || 'w';\n    this.open(path, flag, options.mode, (openErr, handle) => {\n      if (openErr) {\n        callback && callback(openErr);\n      } else {\n        const buffer = (Buffer.isBuffer(data)\n                        ? data\n                        : Buffer.from('' + data, options.encoding || 'utf8'));\n        const position = (/a/.test(flag) ? null : 0);\n\n        // SFTPv3 does not support the notion of 'current position'\n        // (null position), so we just attempt to append to the end of the file\n        // instead\n        if (position === null) {\n          const tryStat = (er, st) => {\n            if (er) {\n              // Try stat() for sftp servers that may not support fstat() for\n              // whatever reason\n              this.stat(path, (er_, st_) => {\n                if (er_) {\n                  return this.close(handle, () => {\n                    callback && callback(er);\n                  });\n                }\n                tryStat(null, st_);\n              });\n              return;\n            }\n            writeAll(this, handle, buffer, 0, buffer.length, st.size, callback);\n          };\n          this.fstat(handle, tryStat);\n          return;\n        }\n        writeAll(this, handle, buffer, 0, buffer.length, position, callback);\n      }\n    });\n  }\n  appendFile(path, data, options, callback_) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    let callback;\n    if (typeof callback_ === 'function') {\n      callback = callback_;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n\n    if (typeof options === 'string')\n      options = { encoding: options, mode: 0o666, flag: 'a' };\n    else if (!options)\n      options = { encoding: 'utf8', mode: 0o666, flag: 'a' };\n    else if (typeof options !== 'object')\n      throw new TypeError('Bad arguments');\n\n    if (!options.flag)\n      options = Object.assign({ flag: 'a' }, options);\n    this.writeFile(path, data, options, callback);\n  }\n  exists(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    this.stat(path, (err) => {\n      cb && cb(err ? false : true);\n    });\n  }\n  unlink(filename, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     filename\n    */\n    const fnameLen = Buffer.byteLength(filename);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + fnameLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.REMOVE;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, fnameLen, p);\n    buf.utf8Write(filename, p += 4, fnameLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} REMOVE`\n    );\n  }\n  rename(oldPath, newPath, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     oldpath\n      string     newpath\n    */\n    const oldLen = Buffer.byteLength(oldPath);\n    const newLen = Buffer.byteLength(newPath);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + oldLen + 4 + newLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.RENAME;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, oldLen, p);\n    buf.utf8Write(oldPath, p += 4, oldLen);\n    writeUInt32BE(buf, newLen, p += oldLen);\n    buf.utf8Write(newPath, p += 4, newLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} RENAME`\n    );\n  }\n  mkdir(path, attrs, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    let flags = 0;\n    let attrsLen = 0;\n\n    if (typeof attrs === 'function') {\n      cb = attrs;\n      attrs = undefined;\n    }\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    }\n\n    /*\n      uint32     id\n      string     path\n      ATTRS      attrs\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.MKDIR;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n    if (attrsLen) {\n      p += 4;\n\n      if (attrsLen === ATTRS_BUF.length)\n        buf.set(ATTRS_BUF, p);\n      else\n        bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n\n      p += attrsLen;\n    }\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} MKDIR`\n    );\n  }\n  rmdir(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.RMDIR;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} RMDIR`\n    );\n  }\n  readdir(where, opts, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    if (typeof opts === 'function') {\n      cb = opts;\n      opts = {};\n    }\n    if (typeof opts !== 'object' || opts === null)\n      opts = {};\n\n    const doFilter = (opts && opts.full ? false : true);\n\n    if (!Buffer.isBuffer(where) && typeof where !== 'string')\n      throw new Error('missing directory handle or path');\n\n    if (typeof where === 'string') {\n      const entries = [];\n      let e = 0;\n\n      const reread = (err, handle) => {\n        if (err)\n          return cb(err);\n\n        this.readdir(handle, opts, (err, list) => {\n          const eof = (err && err.code === STATUS_CODE.EOF);\n\n          if (err && !eof)\n            return this.close(handle, () => cb(err));\n\n          if (eof) {\n            return this.close(handle, (err) => {\n              if (err)\n                return cb(err);\n              cb(undefined, entries);\n            });\n          }\n\n          for (let i = 0; i < list.length; ++i, ++e)\n            entries[e] = list[i];\n\n          reread(undefined, handle);\n        });\n      };\n      return this.opendir(where, reread);\n    }\n\n    /*\n      uint32     id\n      string     handle\n    */\n    const handleLen = where.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.READDIR;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(where, p += 4);\n\n    this._requests[reqid] = {\n      cb: (doFilter\n           ? (err, list) => {\n               if (typeof cb !== 'function')\n                 return;\n               if (err)\n                 return cb(err);\n\n               for (let i = list.length - 1; i >= 0; --i) {\n                 if (list[i].filename === '.' || list[i].filename === '..')\n                   list.splice(i, 1);\n               }\n\n               cb(undefined, list);\n             }\n           : cb)\n    };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READDIR`\n    );\n  }\n  fstat(handle, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    if (!Buffer.isBuffer(handle))\n      throw new Error('handle is not a Buffer');\n\n    /*\n      uint32     id\n      string     handle\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.FSTAT;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(handle, p += 4);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} FSTAT`\n    );\n  }\n  stat(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.STAT;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} STAT`\n    );\n  }\n  lstat(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.LSTAT;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} LSTAT`\n    );\n  }\n  opendir(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.OPENDIR;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} OPENDIR`\n    );\n  }\n  setstat(path, attrs, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    let flags = 0;\n    let attrsLen = 0;\n\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    } else if (typeof attrs === 'function') {\n      cb = attrs;\n    }\n\n    /*\n      uint32     id\n      string     path\n      ATTRS      attrs\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.SETSTAT;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n    if (attrsLen) {\n      p += 4;\n\n      if (attrsLen === ATTRS_BUF.length)\n        buf.set(ATTRS_BUF, p);\n      else\n        bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n\n      p += attrsLen;\n    }\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} SETSTAT`\n    );\n  }\n  fsetstat(handle, attrs, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    if (!Buffer.isBuffer(handle))\n      throw new Error('handle is not a Buffer');\n\n    let flags = 0;\n    let attrsLen = 0;\n\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    } else if (typeof attrs === 'function') {\n      cb = attrs;\n    }\n\n    /*\n      uint32     id\n      string     handle\n      ATTRS      attrs\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 4 + attrsLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.FSETSTAT;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(handle, p += 4);\n    writeUInt32BE(buf, flags, p += handleLen);\n    if (attrsLen) {\n      p += 4;\n\n      if (attrsLen === ATTRS_BUF.length)\n        buf.set(ATTRS_BUF, p);\n      else\n        bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n\n      p += attrsLen;\n    }\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} FSETSTAT`\n    );\n  }\n  futimes(handle, atime, mtime, cb) {\n    return this.fsetstat(handle, {\n      atime: toUnixTimestamp(atime),\n      mtime: toUnixTimestamp(mtime)\n    }, cb);\n  }\n  utimes(path, atime, mtime, cb) {\n    return this.setstat(path, {\n      atime: toUnixTimestamp(atime),\n      mtime: toUnixTimestamp(mtime)\n    }, cb);\n  }\n  fchown(handle, uid, gid, cb) {\n    return this.fsetstat(handle, {\n      uid: uid,\n      gid: gid\n    }, cb);\n  }\n  chown(path, uid, gid, cb) {\n    return this.setstat(path, {\n      uid: uid,\n      gid: gid\n    }, cb);\n  }\n  fchmod(handle, mode, cb) {\n    return this.fsetstat(handle, {\n      mode: mode\n    }, cb);\n  }\n  chmod(path, mode, cb) {\n    return this.setstat(path, {\n      mode: mode\n    }, cb);\n  }\n  readlink(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.READLINK;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    this._requests[reqid] = {\n      cb: (err, names) => {\n        if (typeof cb !== 'function')\n          return;\n        if (err)\n          return cb(err);\n        if (!names || !names.length)\n          return cb(new Error('Response missing link info'));\n        cb(undefined, names[0].filename);\n      }\n    };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READLINK`\n    );\n  }\n  symlink(targetPath, linkPath, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     linkpath\n      string     targetpath\n    */\n    const linkLen = Buffer.byteLength(linkPath);\n    const targetLen = Buffer.byteLength(targetPath);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + linkLen + 4 + targetLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.SYMLINK;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    if (this._isOpenSSH) {\n      // OpenSSH has linkpath and targetpath positions switched\n      writeUInt32BE(buf, targetLen, p);\n      buf.utf8Write(targetPath, p += 4, targetLen);\n      writeUInt32BE(buf, linkLen, p += targetLen);\n      buf.utf8Write(linkPath, p += 4, linkLen);\n    } else {\n      writeUInt32BE(buf, linkLen, p);\n      buf.utf8Write(linkPath, p += 4, linkLen);\n      writeUInt32BE(buf, targetLen, p += linkLen);\n      buf.utf8Write(targetPath, p += 4, targetLen);\n    }\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} SYMLINK`\n    );\n  }\n  realpath(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.REALPATH;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    this._requests[reqid] = {\n      cb: (err, names) => {\n        if (typeof cb !== 'function')\n          return;\n        if (err)\n          return cb(err);\n        if (!names || !names.length)\n          return cb(new Error('Response missing path info'));\n        cb(undefined, names[0].filename);\n      }\n    };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} REALPATH`\n    );\n  }\n  // extended requests\n  ext_openssh_rename(oldPath, newPath, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    const ext = this._extensions['posix-rename@openssh.com'];\n    if (!ext || ext !== '1')\n      throw new Error('Server does not support this extended request');\n\n    /*\n      uint32    id\n      string    \"posix-rename@openssh.com\"\n      string    oldpath\n      string    newpath\n    */\n    const oldLen = Buffer.byteLength(oldPath);\n    const newLen = Buffer.byteLength(newPath);\n    let p = 9;\n    const buf =\n      Buffer.allocUnsafe(4 + 1 + 4 + 4 + 24 + 4 + oldLen + 4 + newLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, 24, p);\n    buf.utf8Write('posix-rename@openssh.com', p += 4, 24);\n    writeUInt32BE(buf, oldLen, p += 24);\n    buf.utf8Write(oldPath, p += 4, oldLen);\n    writeUInt32BE(buf, newLen, p += oldLen);\n    buf.utf8Write(newPath, p += 4, newLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const which = (isBuffered ? 'Buffered' : 'Sending');\n      this._debug(`SFTP: Outbound: ${which} posix-rename@openssh.com`);\n    }\n  }\n  ext_openssh_statvfs(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    const ext = this._extensions['statvfs@openssh.com'];\n    if (!ext || ext !== '2')\n      throw new Error('Server does not support this extended request');\n\n    /*\n      uint32    id\n      string    \"statvfs@openssh.com\"\n      string    path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 19 + 4 + pathLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, 19, p);\n    buf.utf8Write('statvfs@openssh.com', p += 4, 19);\n    writeUInt32BE(buf, pathLen, p += 19);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    this._requests[reqid] = { extended: 'statvfs@openssh.com', cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const which = (isBuffered ? 'Buffered' : 'Sending');\n      this._debug(`SFTP: Outbound: ${which} statvfs@openssh.com`);\n    }\n  }\n  ext_openssh_fstatvfs(handle, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    const ext = this._extensions['fstatvfs@openssh.com'];\n    if (!ext || ext !== '2')\n      throw new Error('Server does not support this extended request');\n    if (!Buffer.isBuffer(handle))\n      throw new Error('handle is not a Buffer');\n\n    /*\n      uint32    id\n      string    \"fstatvfs@openssh.com\"\n      string    handle\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + handleLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, 20, p);\n    buf.utf8Write('fstatvfs@openssh.com', p += 4, 20);\n    writeUInt32BE(buf, handleLen, p += 20);\n    buf.set(handle, p += 4);\n\n    this._requests[reqid] = { extended: 'fstatvfs@openssh.com', cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const which = (isBuffered ? 'Buffered' : 'Sending');\n      this._debug(`SFTP: Outbound: ${which} fstatvfs@openssh.com`);\n    }\n  }\n  ext_openssh_hardlink(oldPath, newPath, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    const ext = this._extensions['hardlink@openssh.com'];\n    if (ext !== '1')\n      throw new Error('Server does not support this extended request');\n\n    /*\n      uint32    id\n      string    \"hardlink@openssh.com\"\n      string    oldpath\n      string    newpath\n    */\n    const oldLen = Buffer.byteLength(oldPath);\n    const newLen = Buffer.byteLength(newPath);\n    let p = 9;\n    const buf =\n      Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + oldLen + 4 + newLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, 20, p);\n    buf.utf8Write('hardlink@openssh.com', p += 4, 20);\n    writeUInt32BE(buf, oldLen, p += 20);\n    buf.utf8Write(oldPath, p += 4, oldLen);\n    writeUInt32BE(buf, newLen, p += oldLen);\n    buf.utf8Write(newPath, p += 4, newLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const which = (isBuffered ? 'Buffered' : 'Sending');\n      this._debug(`SFTP: Outbound: ${which} hardlink@openssh.com`);\n    }\n  }\n  ext_openssh_fsync(handle, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    const ext = this._extensions['fsync@openssh.com'];\n    if (ext !== '1')\n      throw new Error('Server does not support this extended request');\n    if (!Buffer.isBuffer(handle))\n      throw new Error('handle is not a Buffer');\n\n    /*\n      uint32    id\n      string    \"fsync@openssh.com\"\n      string    handle\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 17 + 4 + handleLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, 17, p);\n    buf.utf8Write('fsync@openssh.com', p += 4, 17);\n    writeUInt32BE(buf, handleLen, p += 17);\n    buf.set(handle, p += 4);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} fsync@openssh.com`\n    );\n  }\n  ext_openssh_lsetstat(path, attrs, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    const ext = this._extensions['lsetstat@openssh.com'];\n    if (ext !== '1')\n      throw new Error('Server does not support this extended request');\n\n    let flags = 0;\n    let attrsLen = 0;\n\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    } else if (typeof attrs === 'function') {\n      cb = attrs;\n    }\n\n    /*\n      uint32    id\n      string    \"lsetstat@openssh.com\"\n      string    path\n      ATTRS     attrs\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf =\n      Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + pathLen + 4 + attrsLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, 20, p);\n    buf.utf8Write('lsetstat@openssh.com', p += 4, 20);\n\n    writeUInt32BE(buf, pathLen, p += 20);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    writeUInt32BE(buf, flags, p += pathLen);\n    if (attrsLen) {\n      p += 4;\n\n      if (attrsLen === ATTRS_BUF.length)\n        buf.set(ATTRS_BUF, p);\n      else\n        bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n\n      p += attrsLen;\n    }\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const status = (isBuffered ? 'Buffered' : 'Sending');\n      this._debug(`SFTP: Outbound: ${status} lsetstat@openssh.com`);\n    }\n  }\n  ext_openssh_expandPath(path, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    const ext = this._extensions['expand-path@openssh.com'];\n    if (ext !== '1')\n      throw new Error('Server does not support this extended request');\n\n    /*\n      uint32    id\n      string    \"expand-path@openssh.com\"\n      string    path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 23 + 4 + pathLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, 23, p);\n    buf.utf8Write('expand-path@openssh.com', p += 4, 23);\n\n    writeUInt32BE(buf, pathLen, p += 20);\n    buf.utf8Write(path, p += 4, pathLen);\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const status = (isBuffered ? 'Buffered' : 'Sending');\n      this._debug(`SFTP: Outbound: ${status} expand-path@openssh.com`);\n    }\n  }\n  ext_copy_data(srcHandle, srcOffset, len, dstHandle, dstOffset, cb) {\n    if (this.server)\n      throw new Error('Client-only method called in server mode');\n\n    const ext = this._extensions['copy-data'];\n    if (ext !== '1')\n      throw new Error('Server does not support this extended request');\n\n    if (!Buffer.isBuffer(srcHandle))\n      throw new Error('Source handle is not a Buffer');\n\n    if (!Buffer.isBuffer(dstHandle))\n      throw new Error('Destination handle is not a Buffer');\n\n    /*\n      uint32    id\n      string    \"copy-data\"\n      string    read-from-handle\n      uint64    read-from-offset\n      uint64    read-data-length\n      string    write-to-handle\n      uint64    write-to-offset\n    */\n    let p = 0;\n    const buf = Buffer.allocUnsafe(\n      4 + 1\n      + 4\n      + 4 + 9\n      + 4 + srcHandle.length\n      + 8\n      + 8\n      + 4 + dstHandle.length\n      + 8\n    );\n\n    writeUInt32BE(buf, buf.length - 4, p);\n    p += 4;\n\n    buf[p] = REQUEST.EXTENDED;\n    ++p;\n\n    const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;\n    writeUInt32BE(buf, reqid, p);\n    p += 4;\n\n    writeUInt32BE(buf, 9, p);\n    p += 4;\n    buf.utf8Write('copy-data', p, 9);\n    p += 9;\n\n    writeUInt32BE(buf, srcHandle.length, p);\n    p += 4;\n    buf.set(srcHandle, p);\n    p += srcHandle.length;\n\n    for (let i = 7; i >= 0; --i) {\n      buf[p + i] = srcOffset & 0xFF;\n      srcOffset /= 256;\n    }\n    p += 8;\n\n    for (let i = 7; i >= 0; --i) {\n      buf[p + i] = len & 0xFF;\n      len /= 256;\n    }\n    p += 8;\n\n    writeUInt32BE(buf, dstHandle.length, p);\n    p += 4;\n    buf.set(dstHandle, p);\n    p += dstHandle.length;\n\n    for (let i = 7; i >= 0; --i) {\n      buf[p + i] = dstOffset & 0xFF;\n      dstOffset /= 256;\n    }\n\n    this._requests[reqid] = { cb };\n\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const status = (isBuffered ? 'Buffered' : 'Sending');\n      this._debug(`SFTP: Outbound: ${status} copy-data`);\n    }\n  }\n  // ===========================================================================\n  // Server-specific ===========================================================\n  // ===========================================================================\n  handle(reqid, handle) {\n    if (!this.server)\n      throw new Error('Server-only method called in client mode');\n\n    if (!Buffer.isBuffer(handle))\n      throw new Error('handle is not a Buffer');\n\n    const handleLen = handle.length;\n\n    if (handleLen > 256)\n      throw new Error('handle too large (> 256 bytes)');\n\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.HANDLE;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, handleLen, p);\n    if (handleLen)\n      buf.set(handle, p += 4);\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} HANDLE`\n    );\n  }\n  status(reqid, code, message) {\n    if (!this.server)\n      throw new Error('Server-only method called in client mode');\n\n    if (!VALID_STATUS_CODES.has(code))\n      throw new Error(`Bad status code: ${code}`);\n\n    message || (message = '');\n\n    const msgLen = Buffer.byteLength(message);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 4 + msgLen + 4);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.STATUS;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, code, p);\n\n    writeUInt32BE(buf, msgLen, p += 4);\n    p += 4;\n    if (msgLen) {\n      buf.utf8Write(message, p, msgLen);\n      p += msgLen;\n    }\n\n    writeUInt32BE(buf, 0, p); // Empty language tag\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} STATUS`\n    );\n  }\n  data(reqid, data, encoding) {\n    if (!this.server)\n      throw new Error('Server-only method called in client mode');\n\n    const isBuffer = Buffer.isBuffer(data);\n\n    if (!isBuffer && typeof data !== 'string')\n      throw new Error('data is not a Buffer or string');\n\n    let isUTF8;\n    if (!isBuffer && !encoding) {\n      encoding = undefined;\n      isUTF8 = true;\n    }\n\n    const dataLen = (\n      isBuffer\n      ? data.length\n      : Buffer.byteLength(data, encoding)\n    );\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + dataLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.DATA;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, dataLen, p);\n    if (dataLen) {\n      if (isBuffer)\n        buf.set(data, p += 4);\n      else if (isUTF8)\n        buf.utf8Write(data, p += 4, dataLen);\n      else\n        buf.write(data, p += 4, dataLen, encoding);\n    }\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} DATA`\n    );\n  }\n  name(reqid, names) {\n    if (!this.server)\n      throw new Error('Server-only method called in client mode');\n\n    if (!Array.isArray(names)) {\n      if (typeof names !== 'object' || names === null)\n        throw new Error('names is not an object or array');\n      names = [ names ];\n    }\n\n    const count = names.length;\n    let namesLen = 0;\n    let nameAttrs;\n    const attrs = [];\n\n    for (let i = 0; i < count; ++i) {\n      const name = names[i];\n      const filename = (\n        !name || !name.filename || typeof name.filename !== 'string'\n        ? ''\n        : name.filename\n      );\n      namesLen += 4 + Buffer.byteLength(filename);\n      const longname = (\n        !name || !name.longname || typeof name.longname !== 'string'\n        ? ''\n        : name.longname\n      );\n      namesLen += 4 + Buffer.byteLength(longname);\n\n      if (typeof name.attrs === 'object' && name.attrs !== null) {\n        nameAttrs = attrsToBytes(name.attrs);\n        namesLen += 4 + nameAttrs.nb;\n\n        if (nameAttrs.nb) {\n          let bytes;\n\n          if (nameAttrs.nb === ATTRS_BUF.length) {\n            bytes = new Uint8Array(ATTRS_BUF);\n          } else {\n            bytes = new Uint8Array(nameAttrs.nb);\n            bufferCopy(ATTRS_BUF, bytes, 0, nameAttrs.nb, 0);\n          }\n\n          nameAttrs.bytes = bytes;\n        }\n\n        attrs.push(nameAttrs);\n      } else {\n        namesLen += 4;\n        attrs.push(null);\n      }\n    }\n\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + namesLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.NAME;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, count, p);\n\n    p += 4;\n\n    for (let i = 0; i < count; ++i) {\n      const name = names[i];\n\n      {\n        const filename = (\n          !name || !name.filename || typeof name.filename !== 'string'\n          ? ''\n          : name.filename\n        );\n        const len = Buffer.byteLength(filename);\n        writeUInt32BE(buf, len, p);\n        p += 4;\n        if (len) {\n          buf.utf8Write(filename, p, len);\n          p += len;\n        }\n      }\n\n      {\n        const longname = (\n          !name || !name.longname || typeof name.longname !== 'string'\n          ? ''\n          : name.longname\n        );\n        const len = Buffer.byteLength(longname);\n        writeUInt32BE(buf, len, p);\n        p += 4;\n        if (len) {\n          buf.utf8Write(longname, p, len);\n          p += len;\n        }\n      }\n\n      const attr = attrs[i];\n      if (attr) {\n        writeUInt32BE(buf, attr.flags, p);\n        p += 4;\n        if (attr.flags && attr.bytes) {\n          buf.set(attr.bytes, p);\n          p += attr.nb;\n        }\n      } else {\n        writeUInt32BE(buf, 0, p);\n        p += 4;\n      }\n    }\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} NAME`\n    );\n  }\n  attrs(reqid, attrs) {\n    if (!this.server)\n      throw new Error('Server-only method called in client mode');\n\n    if (typeof attrs !== 'object' || attrs === null)\n      throw new Error('attrs is not an object');\n\n    attrs = attrsToBytes(attrs);\n    const flags = attrs.flags;\n    const attrsLen = attrs.nb;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + attrsLen);\n\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.ATTRS;\n    writeUInt32BE(buf, reqid, 5);\n\n    writeUInt32BE(buf, flags, p);\n    if (attrsLen) {\n      p += 4;\n\n      if (attrsLen === ATTRS_BUF.length)\n        buf.set(ATTRS_BUF, p);\n      else\n        bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n\n      p += attrsLen;\n    }\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(\n      `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} ATTRS`\n    );\n  }\n}\n\nfunction tryCreateBuffer(size) {\n  try {\n    return Buffer.allocUnsafe(size);\n  } catch (ex) {\n    return ex;\n  }\n}\n\nfunction read_(self, handle, buf, off, len, position, cb, req_) {\n  const maxDataLen = self._maxReadLen;\n  const overflow = Math.max(len - maxDataLen, 0);\n\n  if (overflow)\n    len = maxDataLen;\n\n  /*\n    uint32     id\n    string     handle\n    uint64     offset\n    uint32     len\n  */\n  const handleLen = handle.length;\n  let p = 9;\n  let pos = position;\n  const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4);\n\n  writeUInt32BE(out, out.length - 4, 0);\n  out[4] = REQUEST.READ;\n  const reqid = self._writeReqid = (self._writeReqid + 1) & MAX_REQID;\n  writeUInt32BE(out, reqid, 5);\n\n  writeUInt32BE(out, handleLen, p);\n  out.set(handle, p += 4);\n  p += handleLen;\n  for (let i = 7; i >= 0; --i) {\n    out[p + i] = pos & 0xFF;\n    pos /= 256;\n  }\n  writeUInt32BE(out, len, p += 8);\n\n  if (typeof cb !== 'function')\n    cb = noop;\n\n  const req = (req_ || {\n    nb: 0,\n    position,\n    off,\n    origOff: off,\n    len: undefined,\n    overflow: undefined,\n    cb: (err, data, nb) => {\n      const len = req.len;\n      const overflow = req.overflow;\n\n      if (err) {\n        if (cb._wantEOFError || err.code !== STATUS_CODE.EOF)\n          return cb(err);\n      } else if (nb > len) {\n        return cb(new Error('Received more data than requested'));\n      } else if (nb === len && overflow) {\n        req.nb += nb;\n        req.position += nb;\n        req.off += nb;\n        read_(self, handle, buf, req.off, overflow, req.position, cb, req);\n        return;\n      }\n\n      nb = (nb || 0);\n      if (req.origOff === 0 && buf.length === req.nb)\n        data = buf;\n      else\n        data = bufferSlice(buf, req.origOff, req.origOff + req.nb + nb);\n      cb(undefined, req.nb + nb, data, req.position);\n    },\n    buffer: undefined,\n  });\n\n  req.len = len;\n  req.overflow = overflow;\n\n  // TODO: avoid creating multiple buffer slices when we need to re-call read_()\n  // because of overflow\n  req.buffer = bufferSlice(buf, off, off + len);\n\n  self._requests[reqid] = req;\n\n  const isBuffered = sendOrBuffer(self, out);\n  self._debug && self._debug(\n    `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READ`\n  );\n}\n\nfunction fastXfer(src, dst, srcPath, dstPath, opts, cb) {\n  let concurrency = 64;\n  let chunkSize = 32768;\n  let onstep;\n  let mode;\n  let fileSize;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n  } else if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.concurrency === 'number'\n        && opts.concurrency > 0\n        && !isNaN(opts.concurrency)) {\n      concurrency = opts.concurrency;\n    }\n    if (typeof opts.chunkSize === 'number'\n        && opts.chunkSize > 0\n        && !isNaN(opts.chunkSize)) {\n      chunkSize = opts.chunkSize;\n    }\n    if (typeof opts.fileSize === 'number'\n        && opts.fileSize > 0\n        && !isNaN(opts.fileSize)) {\n      fileSize = opts.fileSize;\n    }\n    if (typeof opts.step === 'function')\n      onstep = opts.step;\n\n    if (typeof opts.mode === 'string' || typeof opts.mode === 'number')\n      mode = modeNum(opts.mode);\n  }\n\n  // Internal state variables\n  let fsize;\n  let pdst = 0;\n  let total = 0;\n  let hadError = false;\n  let srcHandle;\n  let dstHandle;\n  let readbuf;\n  let bufsize = chunkSize * concurrency;\n\n  function onerror(err) {\n    if (hadError)\n      return;\n\n    hadError = true;\n\n    let left = 0;\n    let cbfinal;\n\n    if (srcHandle || dstHandle) {\n      cbfinal = () => {\n        if (--left === 0)\n          cb(err);\n      };\n      if (srcHandle && (src === fs || src.outgoing.state === 'open'))\n        ++left;\n      if (dstHandle && (dst === fs || dst.outgoing.state === 'open'))\n        ++left;\n      if (srcHandle && (src === fs || src.outgoing.state === 'open'))\n        src.close(srcHandle, cbfinal);\n      if (dstHandle && (dst === fs || dst.outgoing.state === 'open'))\n        dst.close(dstHandle, cbfinal);\n    } else {\n      cb(err);\n    }\n  }\n\n  src.open(srcPath, 'r', (err, sourceHandle) => {\n    if (err)\n      return onerror(err);\n\n    srcHandle = sourceHandle;\n\n    if (fileSize === undefined)\n      src.fstat(srcHandle, tryStat);\n    else\n      tryStat(null, { size: fileSize });\n\n    function tryStat(err, attrs) {\n      if (err) {\n        if (src !== fs) {\n          // Try stat() for sftp servers that may not support fstat() for\n          // whatever reason\n          src.stat(srcPath, (err_, attrs_) => {\n            if (err_)\n              return onerror(err);\n            tryStat(null, attrs_);\n          });\n          return;\n        }\n        return onerror(err);\n      }\n      fsize = attrs.size;\n\n      dst.open(dstPath, 'w', (err, destHandle) => {\n        if (err)\n          return onerror(err);\n\n        dstHandle = destHandle;\n\n        if (fsize <= 0)\n          return onerror();\n\n        // Use less memory where possible\n        while (bufsize > fsize) {\n          if (concurrency === 1) {\n            bufsize = fsize;\n            break;\n          }\n          bufsize -= chunkSize;\n          --concurrency;\n        }\n\n        readbuf = tryCreateBuffer(bufsize);\n        if (readbuf instanceof Error)\n          return onerror(readbuf);\n\n        if (mode !== undefined) {\n          dst.fchmod(dstHandle, mode, function tryAgain(err) {\n            if (err) {\n              // Try chmod() for sftp servers that may not support fchmod()\n              // for whatever reason\n              dst.chmod(dstPath, mode, (err_) => tryAgain());\n              return;\n            }\n            startReads();\n          });\n        } else {\n          startReads();\n        }\n\n        function onread(err, nb, data, dstpos, datapos, origChunkLen) {\n          if (err)\n            return onerror(err);\n\n          datapos = datapos || 0;\n\n          dst.write(dstHandle, readbuf, datapos, nb, dstpos, writeCb);\n\n          function writeCb(err) {\n            if (err)\n              return onerror(err);\n\n            total += nb;\n            onstep && onstep(total, nb, fsize);\n\n            if (nb < origChunkLen)\n              return singleRead(datapos, dstpos + nb, origChunkLen - nb);\n\n            if (total === fsize) {\n              dst.close(dstHandle, (err) => {\n                dstHandle = undefined;\n                if (err)\n                  return onerror(err);\n                src.close(srcHandle, (err) => {\n                  srcHandle = undefined;\n                  if (err)\n                    return onerror(err);\n                  cb();\n                });\n              });\n              return;\n            }\n\n            if (pdst >= fsize)\n              return;\n\n            const chunk =\n              (pdst + chunkSize > fsize ? fsize - pdst : chunkSize);\n            singleRead(datapos, pdst, chunk);\n            pdst += chunk;\n          }\n        }\n\n        function makeCb(psrc, pdst, chunk) {\n          return (err, nb, data) => {\n            onread(err, nb, data, pdst, psrc, chunk);\n          };\n        }\n\n        function singleRead(psrc, pdst, chunk) {\n          src.read(srcHandle,\n                   readbuf,\n                   psrc,\n                   chunk,\n                   pdst,\n                   makeCb(psrc, pdst, chunk));\n        }\n\n        function startReads() {\n          let reads = 0;\n          let psrc = 0;\n          while (pdst < fsize && reads < concurrency) {\n            const chunk =\n              (pdst + chunkSize > fsize ? fsize - pdst : chunkSize);\n            singleRead(psrc, pdst, chunk);\n            psrc += chunk;\n            pdst += chunk;\n            ++reads;\n          }\n        }\n      });\n    }\n  });\n}\n\nfunction writeAll(sftp, handle, buffer, offset, length, position, callback_) {\n  const callback = (typeof callback_ === 'function' ? callback_ : undefined);\n\n  sftp.write(handle,\n             buffer,\n             offset,\n             length,\n             position,\n             (writeErr, written) => {\n    if (writeErr) {\n      return sftp.close(handle, () => {\n        callback && callback(writeErr);\n      });\n    }\n    if (written === length) {\n      sftp.close(handle, callback);\n    } else {\n      offset += written;\n      length -= written;\n      position += written;\n      writeAll(sftp, handle, buffer, offset, length, position, callback);\n    }\n  });\n}\n\nclass Stats {\n  constructor(initial) {\n    this.mode = (initial && initial.mode);\n    this.uid = (initial && initial.uid);\n    this.gid = (initial && initial.gid);\n    this.size = (initial && initial.size);\n    this.atime = (initial && initial.atime);\n    this.mtime = (initial && initial.mtime);\n    this.extended = (initial && initial.extended);\n  }\n  isDirectory() {\n    return ((this.mode & constants.S_IFMT) === constants.S_IFDIR);\n  }\n  isFile() {\n    return ((this.mode & constants.S_IFMT) === constants.S_IFREG);\n  }\n  isBlockDevice() {\n    return ((this.mode & constants.S_IFMT) === constants.S_IFBLK);\n  }\n  isCharacterDevice() {\n    return ((this.mode & constants.S_IFMT) === constants.S_IFCHR);\n  }\n  isSymbolicLink() {\n    return ((this.mode & constants.S_IFMT) === constants.S_IFLNK);\n  }\n  isFIFO() {\n    return ((this.mode & constants.S_IFMT) === constants.S_IFIFO);\n  }\n  isSocket() {\n    return ((this.mode & constants.S_IFMT) === constants.S_IFSOCK);\n  }\n}\n\nfunction attrsToBytes(attrs) {\n  let flags = 0;\n  let nb = 0;\n\n  if (typeof attrs === 'object' && attrs !== null) {\n    if (typeof attrs.size === 'number') {\n      flags |= ATTR.SIZE;\n      const val = attrs.size;\n      // Big Endian\n      ATTRS_BUF[nb++] = val / 72057594037927940; // 2**56\n      ATTRS_BUF[nb++] = val / 281474976710656; // 2**48\n      ATTRS_BUF[nb++] = val / 1099511627776; // 2**40\n      ATTRS_BUF[nb++] = val / 4294967296; // 2**32\n      ATTRS_BUF[nb++] = val / 16777216; // 2**24\n      ATTRS_BUF[nb++] = val / 65536; // 2**16\n      ATTRS_BUF[nb++] = val / 256; // 2**8\n      ATTRS_BUF[nb++] = val;\n    }\n    if (typeof attrs.uid === 'number' && typeof attrs.gid === 'number') {\n      flags |= ATTR.UIDGID;\n      const uid = attrs.uid;\n      const gid = attrs.gid;\n      // Big Endian\n      ATTRS_BUF[nb++] = uid >>> 24;\n      ATTRS_BUF[nb++] = uid >>> 16;\n      ATTRS_BUF[nb++] = uid >>> 8;\n      ATTRS_BUF[nb++] = uid;\n      ATTRS_BUF[nb++] = gid >>> 24;\n      ATTRS_BUF[nb++] = gid >>> 16;\n      ATTRS_BUF[nb++] = gid >>> 8;\n      ATTRS_BUF[nb++] = gid;\n    }\n    if (typeof attrs.mode === 'number' || typeof attrs.mode === 'string') {\n      const mode = modeNum(attrs.mode);\n      flags |= ATTR.PERMISSIONS;\n      // Big Endian\n      ATTRS_BUF[nb++] = mode >>> 24;\n      ATTRS_BUF[nb++] = mode >>> 16;\n      ATTRS_BUF[nb++] = mode >>> 8;\n      ATTRS_BUF[nb++] = mode;\n    }\n    if ((typeof attrs.atime === 'number' || isDate(attrs.atime))\n        && (typeof attrs.mtime === 'number' || isDate(attrs.mtime))) {\n      const atime = toUnixTimestamp(attrs.atime);\n      const mtime = toUnixTimestamp(attrs.mtime);\n\n      flags |= ATTR.ACMODTIME;\n      // Big Endian\n      ATTRS_BUF[nb++] = atime >>> 24;\n      ATTRS_BUF[nb++] = atime >>> 16;\n      ATTRS_BUF[nb++] = atime >>> 8;\n      ATTRS_BUF[nb++] = atime;\n      ATTRS_BUF[nb++] = mtime >>> 24;\n      ATTRS_BUF[nb++] = mtime >>> 16;\n      ATTRS_BUF[nb++] = mtime >>> 8;\n      ATTRS_BUF[nb++] = mtime;\n    }\n    // TODO: extended attributes\n  }\n\n  return { flags, nb };\n}\n\nfunction toUnixTimestamp(time) {\n  // eslint-disable-next-line no-self-compare\n  if (typeof time === 'number' && time === time) // Valid, non-NaN number\n    return time;\n  if (isDate(time))\n    return parseInt(time.getTime() / 1000, 10);\n  throw new Error(`Cannot parse time: ${time}`);\n}\n\nfunction modeNum(mode) {\n  // eslint-disable-next-line no-self-compare\n  if (typeof mode === 'number' && mode === mode) // Valid, non-NaN number\n    return mode;\n  if (typeof mode === 'string')\n    return modeNum(parseInt(mode, 8));\n  throw new Error(`Cannot parse mode: ${mode}`);\n}\n\nconst stringFlagMap = {\n  'r': OPEN_MODE.READ,\n  'r+': OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'w': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'wx': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xw': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'w+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'wx+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'xw+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'a': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'ax': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xa': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'a+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'ax+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'xa+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL\n};\n\nfunction stringToFlags(str) {\n  const flags = stringFlagMap[str];\n  return (flags !== undefined ? flags : null);\n}\n\nconst flagsToString = (() => {\n  const stringFlagMapKeys = Object.keys(stringFlagMap);\n  return (flags) => {\n    for (let i = 0; i < stringFlagMapKeys.length; ++i) {\n      const key = stringFlagMapKeys[i];\n      if (stringFlagMap[key] === flags)\n        return key;\n    }\n    return null;\n  };\n})();\n\nfunction readAttrs(biOpt) {\n  /*\n    uint32   flags\n    uint64   size           present only if flag SSH_FILEXFER_ATTR_SIZE\n    uint32   uid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   gid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   permissions    present only if flag SSH_FILEXFER_ATTR_PERMISSIONS\n    uint32   atime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   mtime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   extended_count present only if flag SSH_FILEXFER_ATTR_EXTENDED\n    string   extended_type\n    string   extended_data\n    ...      more extended data (extended_type - extended_data pairs),\n               so that number of pairs equals extended_count\n  */\n  const flags = bufferParser.readUInt32BE();\n  if (flags === undefined)\n    return;\n\n  const attrs = new Stats();\n  if (flags & ATTR.SIZE) {\n    const size = bufferParser.readUInt64BE(biOpt);\n    if (size === undefined)\n      return;\n    attrs.size = size;\n  }\n\n  if (flags & ATTR.UIDGID) {\n    const uid = bufferParser.readUInt32BE();\n    const gid = bufferParser.readUInt32BE();\n    if (gid === undefined)\n      return;\n    attrs.uid = uid;\n    attrs.gid = gid;\n  }\n\n  if (flags & ATTR.PERMISSIONS) {\n    const mode = bufferParser.readUInt32BE();\n    if (mode === undefined)\n      return;\n    attrs.mode = mode;\n  }\n\n  if (flags & ATTR.ACMODTIME) {\n    const atime = bufferParser.readUInt32BE();\n    const mtime = bufferParser.readUInt32BE();\n    if (mtime === undefined)\n      return;\n    attrs.atime = atime;\n    attrs.mtime = mtime;\n  }\n\n  if (flags & ATTR.EXTENDED) {\n    const count = bufferParser.readUInt32BE();\n    if (count === undefined)\n      return;\n    const extended = {};\n    for (let i = 0; i < count; ++i) {\n      const type = bufferParser.readString(true);\n      const data = bufferParser.readString();\n      if (data === undefined)\n        return;\n      extended[type] = data;\n    }\n    attrs.extended = extended;\n  }\n\n  return attrs;\n}\n\nfunction sendOrBuffer(sftp, payload) {\n  const ret = tryWritePayload(sftp, payload);\n  if (ret !== undefined) {\n    sftp._buffer.push(ret);\n    return false;\n  }\n  return true;\n}\n\nfunction tryWritePayload(sftp, payload) {\n  const outgoing = sftp.outgoing;\n  if (outgoing.state !== 'open')\n    return;\n\n  if (outgoing.window === 0) {\n    sftp._waitWindow = true;\n    sftp._chunkcb = drainBuffer;\n    return payload;\n  }\n\n  let ret;\n  const len = payload.length;\n  let p = 0;\n\n  while (len - p > 0 && outgoing.window > 0) {\n    const actualLen = Math.min(len - p, outgoing.window, outgoing.packetSize);\n    outgoing.window -= actualLen;\n    if (outgoing.window === 0) {\n      sftp._waitWindow = true;\n      sftp._chunkcb = drainBuffer;\n    }\n\n    if (p === 0 && actualLen === len) {\n      sftp._protocol.channelData(sftp.outgoing.id, payload);\n    } else {\n      sftp._protocol.channelData(sftp.outgoing.id,\n                                 bufferSlice(payload, p, p + actualLen));\n    }\n\n    p += actualLen;\n  }\n\n  if (len - p > 0) {\n    if (p > 0)\n      ret = bufferSlice(payload, p, len);\n    else\n      ret = payload; // XXX: should never get here?\n  }\n\n  return ret;\n}\n\nfunction drainBuffer() {\n  this._chunkcb = undefined;\n  const buffer = this._buffer;\n  let i = 0;\n  while (i < buffer.length) {\n    const payload = buffer[i];\n    const ret = tryWritePayload(this, payload);\n    if (ret !== undefined) {\n      if (ret !== payload)\n        buffer[i] = ret;\n      if (i > 0)\n        this._buffer = buffer.slice(i);\n      return;\n    }\n    ++i;\n  }\n  if (i > 0)\n    this._buffer = [];\n}\n\nfunction doFatalSFTPError(sftp, msg, noDebug) {\n  const err = new Error(msg);\n  err.level = 'sftp-protocol';\n  if (!noDebug && sftp._debug)\n    sftp._debug(`SFTP: Inbound: ${msg}`);\n  sftp.emit('error', err);\n  sftp.destroy();\n  cleanupRequests(sftp);\n  return false;\n}\n\nfunction cleanupRequests(sftp) {\n  const keys = Object.keys(sftp._requests);\n  if (keys.length === 0)\n    return;\n\n  const reqs = sftp._requests;\n  sftp._requests = {};\n  const err = new Error('No response from server');\n  for (let i = 0; i < keys.length; ++i) {\n    const req = reqs[keys[i]];\n    if (typeof req.cb === 'function')\n      req.cb(err);\n  }\n}\n\nfunction requestLimits(sftp, cb) {\n  /*\n    uint32    id\n    string    \"limits@openssh.com\"\n  */\n  let p = 9;\n  const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 18);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.EXTENDED;\n  const reqid = sftp._writeReqid = (sftp._writeReqid + 1) & MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, 18, p);\n  buf.utf8Write('limits@openssh.com', p += 4, 18);\n\n  sftp._requests[reqid] = { extended: 'limits@openssh.com', cb };\n\n  const isBuffered = sendOrBuffer(sftp, buf);\n  if (sftp._debug) {\n    const which = (isBuffered ? 'Buffered' : 'Sending');\n    sftp._debug(`SFTP: Outbound: ${which} limits@openssh.com`);\n  }\n}\n\nconst CLIENT_HANDLERS = {\n  [RESPONSE.VERSION]: (sftp, payload) => {\n    if (sftp._version !== -1)\n      return doFatalSFTPError(sftp, 'Duplicate VERSION packet');\n\n    const extensions = {};\n\n    /*\n      uint32 version\n      <extension data>\n    */\n    bufferParser.init(payload, 1);\n    let version = bufferParser.readUInt32BE();\n    while (bufferParser.avail()) {\n      const extName = bufferParser.readString(true);\n      const extData = bufferParser.readString(true);\n      if (extData === undefined) {\n        version = undefined;\n        break;\n      }\n      extensions[extName] = extData;\n    }\n    bufferParser.clear();\n\n    if (version === undefined)\n      return doFatalSFTPError(sftp, 'Malformed VERSION packet');\n\n    if (sftp._debug) {\n      const names = Object.keys(extensions);\n      if (names.length) {\n        sftp._debug(\n          `SFTP: Inbound: Received VERSION (v${version}, exts:${names})`\n        );\n      } else {\n        sftp._debug(`SFTP: Inbound: Received VERSION (v${version})`);\n      }\n    }\n\n    sftp._version = version;\n    sftp._extensions = extensions;\n\n    if (extensions['limits@openssh.com'] === '1') {\n      return requestLimits(sftp, (err, limits) => {\n        if (!err) {\n          if (limits.maxPktLen > 0)\n            sftp._maxOutPktLen = limits.maxPktLen;\n          if (limits.maxReadLen > 0)\n            sftp._maxReadLen = limits.maxReadLen;\n          if (limits.maxWriteLen > 0)\n            sftp._maxWriteLen = limits.maxWriteLen;\n          sftp.maxOpenHandles = (\n            limits.maxOpenHandles > 0 ? limits.maxOpenHandles : Infinity\n          );\n        }\n        sftp.emit('ready');\n      });\n    }\n\n    sftp.emit('ready');\n  },\n  [RESPONSE.STATUS]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      uint32     error/status code\n      string     error message (ISO-10646 UTF-8)\n      string     language tag\n    */\n    const errorCode = bufferParser.readUInt32BE();\n    const errorMsg = bufferParser.readString(true);\n    bufferParser.clear();\n\n    // Note: we avoid checking that the error message and language tag are in\n    // the packet because there are some broken implementations that incorrectly\n    // omit them. The language tag in general was never really used amongst ssh\n    // implementations, so in the case of a missing error message we just\n    // default to something sensible.\n\n    if (sftp._debug) {\n      const jsonMsg = JSON.stringify(errorMsg);\n      sftp._debug(\n        `SFTP: Inbound: Received STATUS (id:${reqID}, ${errorCode}, ${jsonMsg})`\n      );\n    }\n    const req = sftp._requests[reqID];\n    delete sftp._requests[reqID];\n    if (req && typeof req.cb === 'function') {\n      if (errorCode === STATUS_CODE.OK) {\n        req.cb();\n        return;\n      }\n      const err = new Error(errorMsg\n                            || STATUS_CODE_STR[errorCode]\n                            || 'Unknown status');\n      err.code = errorCode;\n      req.cb(err);\n    }\n  },\n  [RESPONSE.HANDLE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n    */\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n\n    if (handle === undefined) {\n      if (reqID !== undefined)\n        delete sftp._requests[reqID];\n      return doFatalSFTPError(sftp, 'Malformed HANDLE packet');\n    }\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received HANDLE (id:${reqID})`);\n\n    const req = sftp._requests[reqID];\n    delete sftp._requests[reqID];\n    if (req && typeof req.cb === 'function')\n      req.cb(undefined, handle);\n  },\n  [RESPONSE.DATA]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    let req;\n    if (reqID !== undefined) {\n      req = sftp._requests[reqID];\n      delete sftp._requests[reqID];\n    }\n    /*\n      string     data\n    */\n    if (req && typeof req.cb === 'function') {\n      if (req.buffer) {\n        // We have already pre-allocated space to store the data\n\n        const nb = bufferParser.readString(req.buffer);\n        bufferParser.clear();\n\n        if (nb !== undefined) {\n          sftp._debug && sftp._debug(\n            `SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`\n          );\n          req.cb(undefined, req.buffer, nb);\n          return;\n        }\n      } else {\n        const data = bufferParser.readString();\n        bufferParser.clear();\n\n        if (data !== undefined) {\n          sftp._debug && sftp._debug(\n            `SFTP: Inbound: Received DATA (id:${reqID}, ${data.length})`\n          );\n          req.cb(undefined, data);\n          return;\n        }\n      }\n    } else {\n      const nb = bufferParser.skipString();\n      bufferParser.clear();\n      if (nb !== undefined) {\n        sftp._debug && sftp._debug(\n          `SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`\n        );\n        return;\n      }\n    }\n\n    return doFatalSFTPError(sftp, 'Malformed DATA packet');\n  },\n  [RESPONSE.NAME]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    let req;\n    if (reqID !== undefined) {\n      req = sftp._requests[reqID];\n      delete sftp._requests[reqID];\n    }\n    /*\n      uint32     count\n      repeats count times:\n              string     filename\n              string     longname\n              ATTRS      attrs\n    */\n    const count = bufferParser.readUInt32BE();\n    if (count !== undefined) {\n      let names = [];\n      for (let i = 0; i < count; ++i) {\n        // We are going to assume UTF-8 for filenames despite the SFTPv3\n        // spec not specifying an encoding because the specs for newer\n        // versions of the protocol all explicitly specify UTF-8 for\n        // filenames\n        const filename = bufferParser.readString(true);\n\n        // `longname` only exists in SFTPv3 and since it typically will\n        // contain the filename, we assume it is also UTF-8\n        const longname = bufferParser.readString(true);\n\n        const attrs = readAttrs(sftp._biOpt);\n        if (attrs === undefined) {\n          names = undefined;\n          break;\n        }\n        names.push({ filename, longname, attrs });\n      }\n      if (names !== undefined) {\n        sftp._debug && sftp._debug(\n          `SFTP: Inbound: Received NAME (id:${reqID}, ${names.length})`\n        );\n        bufferParser.clear();\n        if (req && typeof req.cb === 'function')\n          req.cb(undefined, names);\n        return;\n      }\n    }\n\n    bufferParser.clear();\n    return doFatalSFTPError(sftp, 'Malformed NAME packet');\n  },\n  [RESPONSE.ATTRS]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    let req;\n    if (reqID !== undefined) {\n      req = sftp._requests[reqID];\n      delete sftp._requests[reqID];\n    }\n    /*\n      ATTRS      attrs\n    */\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n    if (attrs !== undefined) {\n      sftp._debug && sftp._debug(`SFTP: Inbound: Received ATTRS (id:${reqID})`);\n      if (req && typeof req.cb === 'function')\n        req.cb(undefined, attrs);\n      return;\n    }\n\n    return doFatalSFTPError(sftp, 'Malformed ATTRS packet');\n  },\n  [RESPONSE.EXTENDED]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    if (reqID !== undefined) {\n      const req = sftp._requests[reqID];\n      if (req) {\n        delete sftp._requests[reqID];\n        switch (req.extended) {\n          case 'statvfs@openssh.com':\n          case 'fstatvfs@openssh.com': {\n            /*\n              uint64    f_bsize   // file system block size\n              uint64    f_frsize  // fundamental fs block size\n              uint64    f_blocks  // number of blocks (unit f_frsize)\n              uint64    f_bfree   // free blocks in file system\n              uint64    f_bavail  // free blocks for non-root\n              uint64    f_files   // total file inodes\n              uint64    f_ffree   // free file inodes\n              uint64    f_favail  // free file inodes for to non-root\n              uint64    f_fsid    // file system id\n              uint64    f_flag    // bit mask of f_flag values\n              uint64    f_namemax // maximum filename length\n            */\n            const biOpt = sftp._biOpt;\n            const stats = {\n              f_bsize: bufferParser.readUInt64BE(biOpt),\n              f_frsize: bufferParser.readUInt64BE(biOpt),\n              f_blocks: bufferParser.readUInt64BE(biOpt),\n              f_bfree: bufferParser.readUInt64BE(biOpt),\n              f_bavail: bufferParser.readUInt64BE(biOpt),\n              f_files: bufferParser.readUInt64BE(biOpt),\n              f_ffree: bufferParser.readUInt64BE(biOpt),\n              f_favail: bufferParser.readUInt64BE(biOpt),\n              f_sid: bufferParser.readUInt64BE(biOpt),\n              f_flag: bufferParser.readUInt64BE(biOpt),\n              f_namemax: bufferParser.readUInt64BE(biOpt),\n            };\n            if (stats.f_namemax === undefined)\n              break;\n            if (sftp._debug) {\n              sftp._debug(\n                'SFTP: Inbound: Received EXTENDED_REPLY '\n                  + `(id:${reqID}, ${req.extended})`\n              );\n            }\n            bufferParser.clear();\n            if (typeof req.cb === 'function')\n              req.cb(undefined, stats);\n            return;\n          }\n          case 'limits@openssh.com': {\n            /*\n              uint64          max-packet-length\n              uint64          max-read-length\n              uint64          max-write-length\n              uint64          max-open-handles\n            */\n            const limits = {\n              maxPktLen: bufferParser.readUInt64BE(),\n              maxReadLen: bufferParser.readUInt64BE(),\n              maxWriteLen: bufferParser.readUInt64BE(),\n              maxOpenHandles: bufferParser.readUInt64BE(),\n            };\n            if (limits.maxOpenHandles === undefined)\n              break;\n            if (sftp._debug) {\n              sftp._debug(\n                'SFTP: Inbound: Received EXTENDED_REPLY '\n                  + `(id:${reqID}, ${req.extended})`\n              );\n            }\n            bufferParser.clear();\n            if (typeof req.cb === 'function')\n              req.cb(undefined, limits);\n            return;\n          }\n          default:\n            // Unknown extended request\n            sftp._debug && sftp._debug(\n              `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`\n            );\n            bufferParser.clear();\n            if (typeof req.cb === 'function')\n              req.cb();\n            return;\n        }\n      } else {\n        sftp._debug && sftp._debug(\n          `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`\n        );\n        bufferParser.clear();\n        return;\n      }\n    }\n\n    bufferParser.clear();\n    return doFatalSFTPError(sftp, 'Malformed EXTENDED_REPLY packet');\n  },\n};\nconst SERVER_HANDLERS = {\n  [REQUEST.INIT]: (sftp, payload) => {\n    if (sftp._version !== -1)\n      return doFatalSFTPError(sftp, 'Duplicate INIT packet');\n\n    const extensions = {};\n\n    /*\n      uint32 version\n      <extension data>\n    */\n    bufferParser.init(payload, 1);\n    let version = bufferParser.readUInt32BE();\n    while (bufferParser.avail()) {\n      const extName = bufferParser.readString(true);\n      const extData = bufferParser.readString(true);\n      if (extData === undefined) {\n        version = undefined;\n        break;\n      }\n      extensions[extName] = extData;\n    }\n    bufferParser.clear();\n\n    if (version === undefined)\n      return doFatalSFTPError(sftp, 'Malformed INIT packet');\n\n    if (sftp._debug) {\n      const names = Object.keys(extensions);\n      if (names.length) {\n        sftp._debug(\n          `SFTP: Inbound: Received INIT (v${version}, exts:${names})`\n        );\n      } else {\n        sftp._debug(`SFTP: Inbound: Received INIT (v${version})`);\n      }\n    }\n\n    sendOrBuffer(sftp, SERVER_VERSION_BUFFER);\n\n    sftp._version = version;\n    sftp._extensions = extensions;\n    sftp.emit('ready');\n  },\n  [REQUEST.OPEN]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        filename\n      uint32        pflags\n      ATTRS         attrs\n    */\n    const filename = bufferParser.readString(true);\n    const pflags = bufferParser.readUInt32BE();\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n\n    if (attrs === undefined)\n      return doFatalSFTPError(sftp, 'Malformed OPEN packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received OPEN (id:${reqID})`);\n\n    if (!sftp.emit('OPEN', reqID, filename, pflags, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.CLOSE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        handle\n    */\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n\n    if (handle === undefined || handle.length > 256)\n      return doFatalSFTPError(sftp, 'Malformed CLOSE packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received CLOSE (id:${reqID})`);\n\n    if (!sftp.emit('CLOSE', reqID, handle)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.READ]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n      uint64     offset\n      uint32     len\n    */\n    const handle = bufferParser.readString();\n    const offset = bufferParser.readUInt64BE(sftp._biOpt);\n    const len = bufferParser.readUInt32BE();\n    bufferParser.clear();\n\n    if (len === undefined || handle.length > 256)\n      return doFatalSFTPError(sftp, 'Malformed READ packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received READ (id:${reqID})`);\n\n    if (!sftp.emit('READ', reqID, handle, offset, len)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.WRITE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n      uint64     offset\n      string     data\n    */\n    const handle = bufferParser.readString();\n    const offset = bufferParser.readUInt64BE(sftp._biOpt);\n    const data = bufferParser.readString();\n    bufferParser.clear();\n\n    if (data === undefined || handle.length > 256)\n      return doFatalSFTPError(sftp, 'Malformed WRITE packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received WRITE (id:${reqID})`);\n\n    if (!sftp.emit('WRITE', reqID, handle, offset, data)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.LSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (path === undefined)\n      return doFatalSFTPError(sftp, 'Malformed LSTAT packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received LSTAT (id:${reqID})`);\n\n    if (!sftp.emit('LSTAT', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.FSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        handle\n    */\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n\n    if (handle === undefined || handle.length > 256)\n      return doFatalSFTPError(sftp, 'Malformed FSTAT packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received FSTAT (id:${reqID})`);\n\n    if (!sftp.emit('FSTAT', reqID, handle)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.SETSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n      ATTRS      attrs\n    */\n    const path = bufferParser.readString(true);\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n\n    if (attrs === undefined)\n      return doFatalSFTPError(sftp, 'Malformed SETSTAT packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received SETSTAT (id:${reqID})`);\n\n    if (!sftp.emit('SETSTAT', reqID, path, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.FSETSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n      ATTRS      attrs\n    */\n    const handle = bufferParser.readString();\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n\n    if (attrs === undefined || handle.length > 256)\n      return doFatalSFTPError(sftp, 'Malformed FSETSTAT packet');\n\n    sftp._debug && sftp._debug(\n      `SFTP: Inbound: Received FSETSTAT (id:${reqID})`\n    );\n\n    if (!sftp.emit('FSETSTAT', reqID, handle, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.OPENDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (path === undefined)\n      return doFatalSFTPError(sftp, 'Malformed OPENDIR packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received OPENDIR (id:${reqID})`);\n\n    if (!sftp.emit('OPENDIR', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.READDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        handle\n    */\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n\n    if (handle === undefined || handle.length > 256)\n      return doFatalSFTPError(sftp, 'Malformed READDIR packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received READDIR (id:${reqID})`);\n\n    if (!sftp.emit('READDIR', reqID, handle)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.REMOVE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (path === undefined)\n      return doFatalSFTPError(sftp, 'Malformed REMOVE packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received REMOVE (id:${reqID})`);\n\n    if (!sftp.emit('REMOVE', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.MKDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n      ATTRS      attrs\n    */\n    const path = bufferParser.readString(true);\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n\n    if (attrs === undefined)\n      return doFatalSFTPError(sftp, 'Malformed MKDIR packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received MKDIR (id:${reqID})`);\n\n    if (!sftp.emit('MKDIR', reqID, path, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.RMDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (path === undefined)\n      return doFatalSFTPError(sftp, 'Malformed RMDIR packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received RMDIR (id:${reqID})`);\n\n    if (!sftp.emit('RMDIR', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.REALPATH]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (path === undefined)\n      return doFatalSFTPError(sftp, 'Malformed REALPATH packet');\n\n    sftp._debug && sftp._debug(\n      `SFTP: Inbound: Received REALPATH (id:${reqID})`\n    );\n\n    if (!sftp.emit('REALPATH', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.STAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (path === undefined)\n      return doFatalSFTPError(sftp, 'Malformed STAT packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received STAT (id:${reqID})`);\n\n    if (!sftp.emit('STAT', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.RENAME]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     oldpath\n      string     newpath\n    */\n    const oldPath = bufferParser.readString(true);\n    const newPath = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (newPath === undefined)\n      return doFatalSFTPError(sftp, 'Malformed RENAME packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received RENAME (id:${reqID})`);\n\n    if (!sftp.emit('RENAME', reqID, oldPath, newPath)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.READLINK]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (path === undefined)\n      return doFatalSFTPError(sftp, 'Malformed READLINK packet');\n\n    sftp._debug && sftp._debug(\n      `SFTP: Inbound: Received READLINK (id:${reqID})`\n    );\n\n    if (!sftp.emit('READLINK', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.SYMLINK]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     linkpath\n      string     targetpath\n    */\n    const linkPath = bufferParser.readString(true);\n    const targetPath = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (targetPath === undefined)\n      return doFatalSFTPError(sftp, 'Malformed SYMLINK packet');\n\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received SYMLINK (id:${reqID})`);\n\n    let handled;\n    if (sftp._isOpenSSH) {\n      // OpenSSH has linkpath and targetpath positions switched\n      handled = sftp.emit('SYMLINK', reqID, targetPath, linkPath);\n    } else {\n      handled = sftp.emit('SYMLINK', reqID, linkPath, targetPath);\n    }\n    if (!handled) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.EXTENDED]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     extended-request\n      ... any request-specific data ...\n    */\n    const extName = bufferParser.readString(true);\n    if (extName === undefined) {\n      bufferParser.clear();\n      return doFatalSFTPError(sftp, 'Malformed EXTENDED packet');\n    }\n\n    let extData;\n    if (bufferParser.avail())\n      extData = bufferParser.readRaw();\n    bufferParser.clear();\n\n    sftp._debug && sftp._debug(\n      `SFTP: Inbound: Received EXTENDED (id:${reqID})`\n    );\n\n    if (!sftp.emit('EXTENDED', reqID, extName, extData)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n};\n\n// =============================================================================\n// ReadStream/WriteStream-related ==============================================\n// =============================================================================\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_OUT_OF_RANGE,\n  validateNumber\n} = require('./node-fs-compat');\n\nconst kMinPoolSpace = 128;\n\nlet pool;\n// It can happen that we expect to read a large chunk of data, and reserve\n// a large chunk of the pool accordingly, but the read() call only filled\n// a portion of it. If a concurrently executing read() then uses the same pool,\n// the \"reserved\" portion cannot be used, so we allow it to be re-used as a\n// new pool later.\nconst poolFragments = [];\n\nfunction allocNewPool(poolSize) {\n  if (poolFragments.length > 0)\n    pool = poolFragments.pop();\n  else\n    pool = Buffer.allocUnsafe(poolSize);\n  pool.used = 0;\n}\n\n// Check the `this.start` and `this.end` of stream.\nfunction checkPosition(pos, name) {\n  if (!Number.isSafeInteger(pos)) {\n    validateNumber(pos, name);\n    if (!Number.isInteger(pos))\n      throw new ERR_OUT_OF_RANGE(name, 'an integer', pos);\n    throw new ERR_OUT_OF_RANGE(name, '>= 0 and <= 2 ** 53 - 1', pos);\n  }\n  if (pos < 0)\n    throw new ERR_OUT_OF_RANGE(name, '>= 0 and <= 2 ** 53 - 1', pos);\n}\n\nfunction roundUpToMultipleOf8(n) {\n  return (n + 7) & ~7;  // Align to 8 byte boundary.\n}\n\nfunction ReadStream(sftp, path, options) {\n  if (options === undefined)\n    options = {};\n  else if (typeof options === 'string')\n    options = { encoding: options };\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('\"options\" argument must be a string or an object');\n  else\n    options = Object.create(options);\n\n  // A little bit bigger buffer and water marks by default\n  if (options.highWaterMark === undefined)\n    options.highWaterMark = 64 * 1024;\n\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  options.autoDestroy = false; // Node 14 major change.\n\n  ReadableStream.call(this, options);\n\n  this.path = path;\n  this.flags = options.flags === undefined ? 'r' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.end = options.end;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.bytesRead = 0;\n  this.isClosed = false;\n\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.sftp = sftp;\n  this._opening = false;\n\n  if (this.start !== undefined) {\n    checkPosition(this.start, 'start');\n\n    this.pos = this.start;\n  }\n\n  if (this.end === undefined) {\n    this.end = Infinity;\n  } else if (this.end !== Infinity) {\n    checkPosition(this.end, 'end');\n\n    if (this.start !== undefined && this.start > this.end) {\n      throw new ERR_OUT_OF_RANGE(\n        'start',\n        `<= \"end\" (here: ${this.end})`,\n        this.start\n      );\n    }\n  }\n\n  this.on('end', function() {\n    if (this.autoClose)\n      this.destroy();\n  });\n\n  if (!Buffer.isBuffer(this.handle))\n    this.open();\n}\ninherits(ReadStream, ReadableStream);\n\nReadStream.prototype.open = function() {\n  if (this._opening)\n    return;\n\n  this._opening = true;\n\n  this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {\n    this._opening = false;\n\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose)\n        this.destroy();\n      return;\n    }\n\n    this.handle = handle;\n    this.emit('open', handle);\n    this.emit('ready');\n    // Start the flow of data.\n    this.read();\n  });\n};\n\nReadStream.prototype._read = function(n) {\n  if (!Buffer.isBuffer(this.handle))\n    return this.once('open', () => this._read(n));\n\n  // XXX: safe to remove this?\n  if (this.destroyed)\n    return;\n\n  if (!pool || pool.length - pool.used < kMinPoolSpace) {\n    // Discard the old pool.\n    allocNewPool(this.readableHighWaterMark\n                 || this._readableState.highWaterMark);\n  }\n\n  // Grab another reference to the pool in the case that while we're\n  // in the thread pool another read() finishes up the pool, and\n  // allocates a new one.\n  const thisPool = pool;\n  let toRead = Math.min(pool.length - pool.used, n);\n  const start = pool.used;\n\n  if (this.end !== undefined)\n    toRead = Math.min(this.end - this.pos + 1, toRead);\n\n  // Already read everything we were supposed to read!\n  // treat as EOF.\n  if (toRead <= 0)\n    return this.push(null);\n\n  // the actual read.\n  this.sftp.read(this.handle,\n                 pool,\n                 pool.used,\n                 toRead,\n                 this.pos,\n                 (er, bytesRead) => {\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose)\n        this.destroy();\n      return;\n    }\n    let b = null;\n\n    // Now that we know how much data we have actually read, re-wind the\n    // 'used' field if we can, and otherwise allow the remainder of our\n    // reservation to be used as a new pool later.\n    if (start + toRead === thisPool.used && thisPool === pool) {\n      thisPool.used = roundUpToMultipleOf8(thisPool.used + bytesRead - toRead);\n    } else {\n      // Round down to the next lowest multiple of 8 to ensure the new pool\n      // fragment start and end positions are aligned to an 8 byte boundary.\n      const alignedEnd = (start + toRead) & ~7;\n      const alignedStart = roundUpToMultipleOf8(start + bytesRead);\n      if (alignedEnd - alignedStart >= kMinPoolSpace)\n        poolFragments.push(thisPool.slice(alignedStart, alignedEnd));\n    }\n\n    if (bytesRead > 0) {\n      this.bytesRead += bytesRead;\n      b = thisPool.slice(start, start + bytesRead);\n    }\n\n    // Move the pool positions, and internal position for reading.\n    this.pos += bytesRead;\n\n    this.push(b);\n  });\n\n  pool.used = roundUpToMultipleOf8(pool.used + toRead);\n};\n\nReadStream.prototype._destroy = function(err, cb) {\n  if (this._opening && !Buffer.isBuffer(this.handle)) {\n    this.once('open', closeStream.bind(null, this, cb, err));\n    return;\n  }\n\n  closeStream(this, cb, err);\n  this.handle = null;\n  this._opening = false;\n};\n\nfunction closeStream(stream, cb, err) {\n  if (!stream.handle)\n    return onclose();\n\n  stream.sftp.close(stream.handle, onclose);\n\n  function onclose(er) {\n    er = er || err;\n    cb(er);\n    stream.isClosed = true;\n    if (!er)\n      stream.emit('close');\n  }\n}\n\nReadStream.prototype.close = function(cb) {\n  this.destroy(null, cb);\n};\n\nObject.defineProperty(ReadStream.prototype, 'pending', {\n  get() {\n    return this.handle === null;\n  },\n  configurable: true\n});\n\n// TODO: add `concurrency` setting to allow more than one in-flight WRITE\n// request to server to improve throughput\nfunction WriteStream(sftp, path, options) {\n  if (options === undefined)\n    options = {};\n  else if (typeof options === 'string')\n    options = { encoding: options };\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('\"options\" argument must be a string or an object');\n  else\n    options = Object.create(options);\n\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  options.autoDestroy = false; // Node 14 major change.\n\n  WritableStream.call(this, options);\n\n  this.path = path;\n  this.flags = options.flags === undefined ? 'w' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.bytesWritten = 0;\n  this.isClosed = false;\n\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.sftp = sftp;\n  this._opening = false;\n\n  if (this.start !== undefined) {\n    checkPosition(this.start, 'start');\n\n    this.pos = this.start;\n  }\n\n  if (options.encoding)\n    this.setDefaultEncoding(options.encoding);\n\n  // Node v6.x only\n  this.on('finish', function() {\n    if (this._writableState.finalCalled)\n      return;\n    if (this.autoClose)\n      this.destroy();\n  });\n\n  if (!Buffer.isBuffer(this.handle))\n    this.open();\n}\ninherits(WriteStream, WritableStream);\n\nWriteStream.prototype._final = function(cb) {\n  if (this.autoClose)\n    this.destroy();\n  cb();\n};\n\nWriteStream.prototype.open = function() {\n  if (this._opening)\n    return;\n\n  this._opening = true;\n\n  this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {\n    this._opening = false;\n\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose)\n        this.destroy();\n      return;\n    }\n\n    this.handle = handle;\n\n    const tryAgain = (err) => {\n      if (err) {\n        // Try chmod() for sftp servers that may not support fchmod() for\n        // whatever reason\n        this.sftp.chmod(this.path, this.mode, (err_) => tryAgain());\n        return;\n      }\n\n      // SFTPv3 requires absolute offsets, no matter the open flag used\n      if (this.flags[0] === 'a') {\n        const tryStat = (err, st) => {\n          if (err) {\n            // Try stat() for sftp servers that may not support fstat() for\n            // whatever reason\n            this.sftp.stat(this.path, (err_, st_) => {\n              if (err_) {\n                this.destroy();\n                this.emit('error', err);\n                return;\n              }\n              tryStat(null, st_);\n            });\n            return;\n          }\n\n          this.pos = st.size;\n          this.emit('open', handle);\n          this.emit('ready');\n        };\n\n        this.sftp.fstat(handle, tryStat);\n        return;\n      }\n\n      this.emit('open', handle);\n      this.emit('ready');\n    };\n\n    this.sftp.fchmod(handle, this.mode, tryAgain);\n  });\n};\n\nWriteStream.prototype._write = function(data, encoding, cb) {\n  if (!Buffer.isBuffer(data)) {\n    const err = new ERR_INVALID_ARG_TYPE('data', 'Buffer', data);\n    return this.emit('error', err);\n  }\n\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function() {\n      this._write(data, encoding, cb);\n    });\n  }\n\n  this.sftp.write(this.handle,\n                  data,\n                  0,\n                  data.length,\n                  this.pos,\n                  (er, bytes) => {\n    if (er) {\n      if (this.autoClose)\n        this.destroy();\n      return cb(er);\n    }\n    this.bytesWritten += bytes;\n    cb();\n  });\n\n  this.pos += data.length;\n};\n\nWriteStream.prototype._writev = function(data, cb) {\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function() {\n      this._writev(data, cb);\n    });\n  }\n\n  const sftp = this.sftp;\n  const handle = this.handle;\n  let writesLeft = data.length;\n\n  const onwrite = (er, bytes) => {\n    if (er) {\n      this.destroy();\n      return cb(er);\n    }\n    this.bytesWritten += bytes;\n    if (--writesLeft === 0)\n      cb();\n  };\n\n  // TODO: try to combine chunks to reduce number of requests to the server?\n  for (let i = 0; i < data.length; ++i) {\n    const chunk = data[i].chunk;\n\n    sftp.write(handle, chunk, 0, chunk.length, this.pos, onwrite);\n    this.pos += chunk.length;\n  }\n};\n\nif (typeof WritableStream.prototype.destroy !== 'function')\n  WriteStream.prototype.destroy = ReadStream.prototype.destroy;\n\nWriteStream.prototype._destroy = ReadStream.prototype._destroy;\nWriteStream.prototype.close = function(cb) {\n  if (cb) {\n    if (this.isClosed) {\n      process.nextTick(cb);\n      return;\n    }\n    this.on('close', cb);\n  }\n\n  // If we are not autoClosing, we should call\n  // destroy on 'finish'.\n  if (!this.autoClose)\n    this.on('finish', this.destroy.bind(this));\n\n  this.end();\n};\n\n// There is no shutdown() for files.\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\n\nObject.defineProperty(WriteStream.prototype, 'pending', {\n  get() {\n    return this.handle === null;\n  },\n  configurable: true\n});\n// =============================================================================\n\nmodule.exports = {\n  flagsToString,\n  OPEN_MODE,\n  SFTP,\n  Stats,\n  STATUS_CODE,\n  stringToFlags,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}