{"ast":null,"code":"// TODO:\n//    * utilize `crypto.create(Private|Public)Key()` and `keyObject.export()`\n//    * handle multi-line header values (OpenSSH)?\n//    * more thorough validation?\n'use strict';\n\nconst {\n  createDecipheriv,\n  createECDH,\n  createHash,\n  createHmac,\n  createSign,\n  createVerify,\n  getCiphers,\n  sign: sign_,\n  verify: verify_\n} = require('crypto');\n\nconst supportedOpenSSLCiphers = getCiphers();\n\nconst {\n  Ber\n} = require('asn1');\n\nconst bcrypt_pbkdf = require('bcrypt-pbkdf').pbkdf;\n\nconst {\n  CIPHER_INFO\n} = require('./crypto.js');\n\nconst {\n  eddsaSupported,\n  SUPPORTED_CIPHER\n} = require('./constants.js');\n\nconst {\n  bufferSlice,\n  makeBufferParser,\n  readString,\n  readUInt32BE,\n  writeUInt32BE\n} = require('./utils.js');\n\nconst SYM_HASH_ALGO = Symbol('Hash Algorithm');\nconst SYM_PRIV_PEM = Symbol('Private key PEM');\nconst SYM_PUB_PEM = Symbol('Public key PEM');\nconst SYM_PUB_SSH = Symbol('Public key SSH');\nconst SYM_DECRYPTED = Symbol('Decrypted Key'); // Create OpenSSL cipher name -> SSH cipher name conversion table\n\nconst CIPHER_INFO_OPENSSL = Object.create(null);\n{\n  const keys = Object.keys(CIPHER_INFO);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const cipherName = CIPHER_INFO[keys[i]].sslName;\n    if (!cipherName || CIPHER_INFO_OPENSSL[cipherName]) continue;\n    CIPHER_INFO_OPENSSL[cipherName] = CIPHER_INFO[keys[i]];\n  }\n}\nconst binaryKeyParser = makeBufferParser();\n\nfunction makePEM(type, data) {\n  data = data.base64Slice(0, data.length);\n  let formatted = data.replace(/.{64}/g, '$&\\n');\n  if (data.length & 63) formatted += '\\n';\n  return `-----BEGIN ${type} KEY-----\\n${formatted}-----END ${type} KEY-----`;\n}\n\nfunction combineBuffers(buf1, buf2) {\n  const result = Buffer.allocUnsafe(buf1.length + buf2.length);\n  result.set(buf1, 0);\n  result.set(buf2, buf1.length);\n  return result;\n}\n\nfunction skipFields(buf, nfields) {\n  const bufLen = buf.length;\n  let pos = buf._pos || 0;\n\n  for (let i = 0; i < nfields; ++i) {\n    const left = bufLen - pos;\n    if (pos >= bufLen || left < 4) return false;\n    const len = readUInt32BE(buf, pos);\n    if (left < 4 + len) return false;\n    pos += 4 + len;\n  }\n\n  buf._pos = pos;\n  return true;\n}\n\nfunction genOpenSSLRSAPub(n, e) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence(); // algorithm\n\n  asnWriter.startSequence();\n  asnWriter.writeOID('1.2.840.113549.1.1.1'); // rsaEncryption\n  // algorithm parameters (RSA has none)\n\n  asnWriter.writeNull();\n  asnWriter.endSequence(); // subjectPublicKey\n\n  asnWriter.startSequence(Ber.BitString);\n  asnWriter.writeByte(0x00);\n  asnWriter.startSequence();\n  asnWriter.writeBuffer(n, Ber.Integer);\n  asnWriter.writeBuffer(e, Ber.Integer);\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHRSAPub(n, e) {\n  const publicKey = Buffer.allocUnsafe(4 + 7 + 4 + e.length + 4 + n.length);\n  writeUInt32BE(publicKey, 7, 0);\n  publicKey.utf8Write('ssh-rsa', 4, 7);\n  let i = 4 + 7;\n  writeUInt32BE(publicKey, e.length, i);\n  publicKey.set(e, i += 4);\n  writeUInt32BE(publicKey, n.length, i += e.length);\n  publicKey.set(n, i + 4);\n  return publicKey;\n}\n\nconst genOpenSSLRSAPriv = (() => {\n  function genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp) {\n    const asnWriter = new Ber.Writer();\n    asnWriter.startSequence();\n    asnWriter.writeInt(0x00, Ber.Integer);\n    asnWriter.writeBuffer(n, Ber.Integer);\n    asnWriter.writeBuffer(e, Ber.Integer);\n    asnWriter.writeBuffer(d, Ber.Integer);\n    asnWriter.writeBuffer(p, Ber.Integer);\n    asnWriter.writeBuffer(q, Ber.Integer);\n    asnWriter.writeBuffer(dmp1, Ber.Integer);\n    asnWriter.writeBuffer(dmq1, Ber.Integer);\n    asnWriter.writeBuffer(iqmp, Ber.Integer);\n    asnWriter.endSequence();\n    return asnWriter.buffer;\n  }\n\n  function bigIntFromBuffer(buf) {\n    return BigInt(`0x${buf.hexSlice(0, buf.length)}`);\n  }\n\n  function bigIntToBuffer(bn) {\n    let hex = bn.toString(16);\n\n    if ((hex.length & 1) !== 0) {\n      hex = `0${hex}`;\n    } else {\n      const sigbit = hex.charCodeAt(0); // BER/DER integers require leading zero byte to denote a positive value\n      // when first byte >= 0x80\n\n      if (sigbit === 56\n      /* '8' */\n      || sigbit === 57\n      /* '9' */\n      || sigbit >= 97\n      /* 'a' */\n      && sigbit <= 102\n      /* 'f' */\n      ) {\n        hex = `00${hex}`;\n      }\n    }\n\n    return Buffer.from(hex, 'hex');\n  }\n\n  return function genOpenSSLRSAPriv(n, e, d, iqmp, p, q) {\n    const bn_d = bigIntFromBuffer(d);\n    const dmp1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(p) - 1n));\n    const dmq1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(q) - 1n));\n    return makePEM('RSA PRIVATE', genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp));\n  };\n})();\n\nfunction genOpenSSLDSAPub(p, q, g, y) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence(); // algorithm\n\n  asnWriter.startSequence();\n  asnWriter.writeOID('1.2.840.10040.4.1'); // id-dsa\n  // algorithm parameters\n\n  asnWriter.startSequence();\n  asnWriter.writeBuffer(p, Ber.Integer);\n  asnWriter.writeBuffer(q, Ber.Integer);\n  asnWriter.writeBuffer(g, Ber.Integer);\n  asnWriter.endSequence();\n  asnWriter.endSequence(); // subjectPublicKey\n\n  asnWriter.startSequence(Ber.BitString);\n  asnWriter.writeByte(0x00);\n  asnWriter.writeBuffer(y, Ber.Integer);\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHDSAPub(p, q, g, y) {\n  const publicKey = Buffer.allocUnsafe(4 + 7 + 4 + p.length + 4 + q.length + 4 + g.length + 4 + y.length);\n  writeUInt32BE(publicKey, 7, 0);\n  publicKey.utf8Write('ssh-dss', 4, 7);\n  let i = 4 + 7;\n  writeUInt32BE(publicKey, p.length, i);\n  publicKey.set(p, i += 4);\n  writeUInt32BE(publicKey, q.length, i += p.length);\n  publicKey.set(q, i += 4);\n  writeUInt32BE(publicKey, g.length, i += q.length);\n  publicKey.set(g, i += 4);\n  writeUInt32BE(publicKey, y.length, i += g.length);\n  publicKey.set(y, i + 4);\n  return publicKey;\n}\n\nfunction genOpenSSLDSAPriv(p, q, g, y, x) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  asnWriter.writeInt(0x00, Ber.Integer);\n  asnWriter.writeBuffer(p, Ber.Integer);\n  asnWriter.writeBuffer(q, Ber.Integer);\n  asnWriter.writeBuffer(g, Ber.Integer);\n  asnWriter.writeBuffer(y, Ber.Integer);\n  asnWriter.writeBuffer(x, Ber.Integer);\n  asnWriter.endSequence();\n  return makePEM('DSA PRIVATE', asnWriter.buffer);\n}\n\nfunction genOpenSSLEdPub(pub) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence(); // algorithm\n\n  asnWriter.startSequence();\n  asnWriter.writeOID('1.3.101.112'); // id-Ed25519\n\n  asnWriter.endSequence(); // PublicKey\n\n  asnWriter.startSequence(Ber.BitString);\n  asnWriter.writeByte(0x00); // XXX: hack to write a raw buffer without a tag -- yuck\n\n  asnWriter._ensure(pub.length);\n\n  asnWriter._buf.set(pub, asnWriter._offset);\n\n  asnWriter._offset += pub.length;\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHEdPub(pub) {\n  const publicKey = Buffer.allocUnsafe(4 + 11 + 4 + pub.length);\n  writeUInt32BE(publicKey, 11, 0);\n  publicKey.utf8Write('ssh-ed25519', 4, 11);\n  writeUInt32BE(publicKey, pub.length, 15);\n  publicKey.set(pub, 19);\n  return publicKey;\n}\n\nfunction genOpenSSLEdPriv(priv) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence(); // version\n\n  asnWriter.writeInt(0x00, Ber.Integer); // algorithm\n\n  asnWriter.startSequence();\n  asnWriter.writeOID('1.3.101.112'); // id-Ed25519\n\n  asnWriter.endSequence(); // PrivateKey\n\n  asnWriter.startSequence(Ber.OctetString);\n  asnWriter.writeBuffer(priv, Ber.OctetString);\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PRIVATE', asnWriter.buffer);\n}\n\nfunction genOpenSSLECDSAPub(oid, Q) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence(); // algorithm\n\n  asnWriter.startSequence();\n  asnWriter.writeOID('1.2.840.10045.2.1'); // id-ecPublicKey\n  // algorithm parameters (namedCurve)\n\n  asnWriter.writeOID(oid);\n  asnWriter.endSequence(); // subjectPublicKey\n\n  asnWriter.startSequence(Ber.BitString);\n  asnWriter.writeByte(0x00); // XXX: hack to write a raw buffer without a tag -- yuck\n\n  asnWriter._ensure(Q.length);\n\n  asnWriter._buf.set(Q, asnWriter._offset);\n\n  asnWriter._offset += Q.length; // end hack\n\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHECDSAPub(oid, Q) {\n  let curveName;\n\n  switch (oid) {\n    case '1.2.840.10045.3.1.7':\n      // prime256v1/secp256r1\n      curveName = 'nistp256';\n      break;\n\n    case '1.3.132.0.34':\n      // secp384r1\n      curveName = 'nistp384';\n      break;\n\n    case '1.3.132.0.35':\n      // secp521r1\n      curveName = 'nistp521';\n      break;\n\n    default:\n      return;\n  }\n\n  const publicKey = Buffer.allocUnsafe(4 + 19 + 4 + 8 + 4 + Q.length);\n  writeUInt32BE(publicKey, 19, 0);\n  publicKey.utf8Write(`ecdsa-sha2-${curveName}`, 4, 19);\n  writeUInt32BE(publicKey, 8, 23);\n  publicKey.utf8Write(curveName, 27, 8);\n  writeUInt32BE(publicKey, Q.length, 35);\n  publicKey.set(Q, 39);\n  return publicKey;\n}\n\nfunction genOpenSSLECDSAPriv(oid, pub, priv) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence(); // version\n\n  asnWriter.writeInt(0x01, Ber.Integer); // privateKey\n\n  asnWriter.writeBuffer(priv, Ber.OctetString); // parameters (optional)\n\n  asnWriter.startSequence(0xA0);\n  asnWriter.writeOID(oid);\n  asnWriter.endSequence(); // publicKey (optional)\n\n  asnWriter.startSequence(0xA1);\n  asnWriter.startSequence(Ber.BitString);\n  asnWriter.writeByte(0x00); // XXX: hack to write a raw buffer without a tag -- yuck\n\n  asnWriter._ensure(pub.length);\n\n  asnWriter._buf.set(pub, asnWriter._offset);\n\n  asnWriter._offset += pub.length; // end hack\n\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('EC PRIVATE', asnWriter.buffer);\n}\n\nfunction genOpenSSLECDSAPubFromPriv(curveName, priv) {\n  const tempECDH = createECDH(curveName);\n  tempECDH.setPrivateKey(priv);\n  return tempECDH.getPublicKey();\n}\n\nconst BaseKey = {\n  sign: (() => {\n    if (typeof sign_ === 'function') {\n      return function sign(data, algo) {\n        const pem = this[SYM_PRIV_PEM];\n        if (pem === null) return new Error('No private key available');\n        if (!algo || typeof algo !== 'string') algo = this[SYM_HASH_ALGO];\n\n        try {\n          return sign_(algo, data, pem);\n        } catch (ex) {\n          return ex;\n        }\n      };\n    }\n\n    return function sign(data, algo) {\n      const pem = this[SYM_PRIV_PEM];\n      if (pem === null) return new Error('No private key available');\n      if (!algo || typeof algo !== 'string') algo = this[SYM_HASH_ALGO];\n      const signature = createSign(algo);\n      signature.update(data);\n\n      try {\n        return signature.sign(pem);\n      } catch (ex) {\n        return ex;\n      }\n    };\n  })(),\n  verify: (() => {\n    if (typeof verify_ === 'function') {\n      return function verify(data, signature, algo) {\n        const pem = this[SYM_PUB_PEM];\n        if (pem === null) return new Error('No public key available');\n        if (!algo || typeof algo !== 'string') algo = this[SYM_HASH_ALGO];\n\n        try {\n          return verify_(algo, data, pem, signature);\n        } catch (ex) {\n          return ex;\n        }\n      };\n    }\n\n    return function verify(data, signature, algo) {\n      const pem = this[SYM_PUB_PEM];\n      if (pem === null) return new Error('No public key available');\n      if (!algo || typeof algo !== 'string') algo = this[SYM_HASH_ALGO];\n      const verifier = createVerify(algo);\n      verifier.update(data);\n\n      try {\n        return verifier.verify(pem, signature);\n      } catch (ex) {\n        return ex;\n      }\n    };\n  })(),\n  isPrivateKey: function isPrivateKey() {\n    return this[SYM_PRIV_PEM] !== null;\n  },\n  getPrivatePEM: function getPrivatePEM() {\n    return this[SYM_PRIV_PEM];\n  },\n  getPublicPEM: function getPublicPEM() {\n    return this[SYM_PUB_PEM];\n  },\n  getPublicSSH: function getPublicSSH() {\n    return this[SYM_PUB_SSH];\n  },\n  equals: function equals(key) {\n    const parsed = parseKey(key);\n    if (parsed instanceof Error) return false;\n    return this.type === parsed.type && this[SYM_PRIV_PEM] === parsed[SYM_PRIV_PEM] && this[SYM_PUB_PEM] === parsed[SYM_PUB_PEM] && this[SYM_PUB_SSH] === parsed[SYM_PUB_SSH];\n  }\n};\n\nfunction OpenSSH_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\n\nOpenSSH_Private.prototype = BaseKey;\n{\n  const regexp = /^-----BEGIN OPENSSH PRIVATE KEY-----(?:\\r\\n|\\n)([\\s\\S]+)(?:\\r\\n|\\n)-----END OPENSSH PRIVATE KEY-----$/;\n\n  OpenSSH_Private.parse = (str, passphrase) => {\n    const m = regexp.exec(str);\n    if (m === null) return null;\n    let ret;\n    const data = Buffer.from(m[1], 'base64');\n    if (data.length < 31) // magic (+ magic null term.) + minimum field lengths\n      return new Error('Malformed OpenSSH private key');\n    const magic = data.utf8Slice(0, 15);\n    if (magic !== 'openssh-key-v1\\0') return new Error(`Unsupported OpenSSH key magic: ${magic}`);\n    const cipherName = readString(data, 15, true);\n    if (cipherName === undefined) return new Error('Malformed OpenSSH private key');\n    if (cipherName !== 'none' && SUPPORTED_CIPHER.indexOf(cipherName) === -1) return new Error(`Unsupported cipher for OpenSSH key: ${cipherName}`);\n    const kdfName = readString(data, data._pos, true);\n    if (kdfName === undefined) return new Error('Malformed OpenSSH private key');\n\n    if (kdfName !== 'none') {\n      if (cipherName === 'none') return new Error('Malformed OpenSSH private key');\n      if (kdfName !== 'bcrypt') return new Error(`Unsupported kdf name for OpenSSH key: ${kdfName}`);\n\n      if (!passphrase) {\n        return new Error('Encrypted private OpenSSH key detected, but no passphrase given');\n      }\n    } else if (cipherName !== 'none') {\n      return new Error('Malformed OpenSSH private key');\n    }\n\n    let encInfo;\n    let cipherKey;\n    let cipherIV;\n    if (cipherName !== 'none') encInfo = CIPHER_INFO[cipherName];\n    const kdfOptions = readString(data, data._pos);\n    if (kdfOptions === undefined) return new Error('Malformed OpenSSH private key');\n\n    if (kdfOptions.length) {\n      switch (kdfName) {\n        case 'none':\n          return new Error('Malformed OpenSSH private key');\n\n        case 'bcrypt':\n          /*\n            string salt\n            uint32 rounds\n          */\n          const salt = readString(kdfOptions, 0);\n          if (salt === undefined || kdfOptions._pos + 4 > kdfOptions.length) return new Error('Malformed OpenSSH private key');\n          const rounds = readUInt32BE(kdfOptions, kdfOptions._pos);\n          const gen = Buffer.allocUnsafe(encInfo.keyLen + encInfo.ivLen);\n          const r = bcrypt_pbkdf(passphrase, passphrase.length, salt, salt.length, gen, gen.length, rounds);\n          if (r !== 0) return new Error('Failed to generate information to decrypt key');\n          cipherKey = bufferSlice(gen, 0, encInfo.keyLen);\n          cipherIV = bufferSlice(gen, encInfo.keyLen, gen.length);\n          break;\n      }\n    } else if (kdfName !== 'none') {\n      return new Error('Malformed OpenSSH private key');\n    }\n\n    if (data._pos + 3 >= data.length) return new Error('Malformed OpenSSH private key');\n    const keyCount = readUInt32BE(data, data._pos);\n    data._pos += 4;\n\n    if (keyCount > 0) {\n      // TODO: place sensible limit on max `keyCount`\n      // Read public keys first\n      for (let i = 0; i < keyCount; ++i) {\n        const pubData = readString(data, data._pos);\n        if (pubData === undefined) return new Error('Malformed OpenSSH private key');\n        const type = readString(pubData, 0, true);\n        if (type === undefined) return new Error('Malformed OpenSSH private key');\n      }\n\n      let privBlob = readString(data, data._pos);\n      if (privBlob === undefined) return new Error('Malformed OpenSSH private key');\n\n      if (cipherKey !== undefined) {\n        // Encrypted private key(s)\n        if (privBlob.length < encInfo.blockLen || privBlob.length % encInfo.blockLen !== 0) {\n          return new Error('Malformed OpenSSH private key');\n        }\n\n        try {\n          const options = {\n            authTagLength: encInfo.authLen\n          };\n          const decipher = createDecipheriv(encInfo.sslName, cipherKey, cipherIV, options);\n\n          if (encInfo.authLen > 0) {\n            if (data.length - data._pos < encInfo.authLen) return new Error('Malformed OpenSSH private key');\n            decipher.setAuthTag(bufferSlice(data, data._pos, data._pos += encInfo.authLen));\n          }\n\n          privBlob = combineBuffers(decipher.update(privBlob), decipher.final());\n        } catch (ex) {\n          return ex;\n        }\n      } // Nothing should we follow the private key(s), except a possible\n      // authentication tag for relevant ciphers\n\n\n      if (data._pos !== data.length) return new Error('Malformed OpenSSH private key');\n      ret = parseOpenSSHPrivKeys(privBlob, keyCount, cipherKey !== undefined);\n    } else {\n      ret = [];\n    }\n\n    if (ret instanceof Error) return ret; // This will need to change if/when OpenSSH ever starts storing multiple\n    // keys in their key files\n\n    return ret[0];\n  };\n\n  function parseOpenSSHPrivKeys(data, nkeys, decrypted) {\n    const keys = [];\n    /*\n      uint32  checkint\n      uint32  checkint\n      string  privatekey1\n      string  comment1\n      string  privatekey2\n      string  comment2\n      ...\n      string  privatekeyN\n      string  commentN\n      char  1\n      char  2\n      char  3\n      ...\n      char  padlen % 255\n    */\n\n    if (data.length < 8) return new Error('Malformed OpenSSH private key');\n    const check1 = readUInt32BE(data, 0);\n    const check2 = readUInt32BE(data, 4);\n\n    if (check1 !== check2) {\n      if (decrypted) {\n        return new Error('OpenSSH key integrity check failed -- bad passphrase?');\n      }\n\n      return new Error('OpenSSH key integrity check failed');\n    }\n\n    data._pos = 8;\n    let i;\n    let oid;\n\n    for (i = 0; i < nkeys; ++i) {\n      let algo;\n      let privPEM;\n      let pubPEM;\n      let pubSSH; // The OpenSSH documentation for the key format actually lies, the\n      // entirety of the private key content is not contained with a string\n      // field, it's actually the literal contents of the private key, so to be\n      // able to find the end of the key data you need to know the layout/format\n      // of each key type ...\n\n      const type = readString(data, data._pos, true);\n      if (type === undefined) return new Error('Malformed OpenSSH private key');\n\n      switch (type) {\n        case 'ssh-rsa':\n          {\n            /*\n              string  n -- public\n              string  e -- public\n              string  d -- private\n              string  iqmp -- private\n              string  p -- private\n              string  q -- private\n            */\n            const n = readString(data, data._pos);\n            if (n === undefined) return new Error('Malformed OpenSSH private key');\n            const e = readString(data, data._pos);\n            if (e === undefined) return new Error('Malformed OpenSSH private key');\n            const d = readString(data, data._pos);\n            if (d === undefined) return new Error('Malformed OpenSSH private key');\n            const iqmp = readString(data, data._pos);\n            if (iqmp === undefined) return new Error('Malformed OpenSSH private key');\n            const p = readString(data, data._pos);\n            if (p === undefined) return new Error('Malformed OpenSSH private key');\n            const q = readString(data, data._pos);\n            if (q === undefined) return new Error('Malformed OpenSSH private key');\n            pubPEM = genOpenSSLRSAPub(n, e);\n            pubSSH = genOpenSSHRSAPub(n, e);\n            privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);\n            algo = 'sha1';\n            break;\n          }\n\n        case 'ssh-dss':\n          {\n            /*\n              string  p -- public\n              string  q -- public\n              string  g -- public\n              string  y -- public\n              string  x -- private\n            */\n            const p = readString(data, data._pos);\n            if (p === undefined) return new Error('Malformed OpenSSH private key');\n            const q = readString(data, data._pos);\n            if (q === undefined) return new Error('Malformed OpenSSH private key');\n            const g = readString(data, data._pos);\n            if (g === undefined) return new Error('Malformed OpenSSH private key');\n            const y = readString(data, data._pos);\n            if (y === undefined) return new Error('Malformed OpenSSH private key');\n            const x = readString(data, data._pos);\n            if (x === undefined) return new Error('Malformed OpenSSH private key');\n            pubPEM = genOpenSSLDSAPub(p, q, g, y);\n            pubSSH = genOpenSSHDSAPub(p, q, g, y);\n            privPEM = genOpenSSLDSAPriv(p, q, g, y, x);\n            algo = 'sha1';\n            break;\n          }\n\n        case 'ssh-ed25519':\n          {\n            if (!eddsaSupported) return new Error(`Unsupported OpenSSH private key type: ${type}`);\n            /*\n              * string  public key\n              * string  private key + public key\n            */\n\n            const edpub = readString(data, data._pos);\n            if (edpub === undefined || edpub.length !== 32) return new Error('Malformed OpenSSH private key');\n            const edpriv = readString(data, data._pos);\n            if (edpriv === undefined || edpriv.length !== 64) return new Error('Malformed OpenSSH private key');\n            pubPEM = genOpenSSLEdPub(edpub);\n            pubSSH = genOpenSSHEdPub(edpub);\n            privPEM = genOpenSSLEdPriv(bufferSlice(edpriv, 0, 32));\n            algo = null;\n            break;\n          }\n\n        case 'ecdsa-sha2-nistp256':\n          algo = 'sha256';\n          oid = '1.2.840.10045.3.1.7';\n        // FALLTHROUGH\n\n        case 'ecdsa-sha2-nistp384':\n          if (algo === undefined) {\n            algo = 'sha384';\n            oid = '1.3.132.0.34';\n          }\n\n        // FALLTHROUGH\n\n        case 'ecdsa-sha2-nistp521':\n          {\n            if (algo === undefined) {\n              algo = 'sha512';\n              oid = '1.3.132.0.35';\n            }\n            /*\n              string  curve name\n              string  Q -- public\n              string  d -- private\n            */\n            // TODO: validate curve name against type\n\n\n            if (!skipFields(data, 1)) // Skip curve name\n              return new Error('Malformed OpenSSH private key');\n            const ecpub = readString(data, data._pos);\n            if (ecpub === undefined) return new Error('Malformed OpenSSH private key');\n            const ecpriv = readString(data, data._pos);\n            if (ecpriv === undefined) return new Error('Malformed OpenSSH private key');\n            pubPEM = genOpenSSLECDSAPub(oid, ecpub);\n            pubSSH = genOpenSSHECDSAPub(oid, ecpub);\n            privPEM = genOpenSSLECDSAPriv(oid, ecpub, ecpriv);\n            break;\n          }\n\n        default:\n          return new Error(`Unsupported OpenSSH private key type: ${type}`);\n      }\n\n      const privComment = readString(data, data._pos, true);\n      if (privComment === undefined) return new Error('Malformed OpenSSH private key');\n      keys.push(new OpenSSH_Private(type, privComment, privPEM, pubPEM, pubSSH, algo, decrypted));\n    }\n\n    let cnt = 0;\n\n    for (i = data._pos; i < data.length; ++i) {\n      if (data[i] !== ++cnt % 255) return new Error('Malformed OpenSSH private key');\n    }\n\n    return keys;\n  }\n}\n\nfunction OpenSSH_Old_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\n\nOpenSSH_Old_Private.prototype = BaseKey;\n{\n  const regexp = /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\\r\\n|\\n)((?:[^:]+:\\s*[\\S].*(?:\\r\\n|\\n))*)([\\s\\S]+)(?:\\r\\n|\\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;\n\n  OpenSSH_Old_Private.parse = (str, passphrase) => {\n    const m = regexp.exec(str);\n    if (m === null) return null;\n    let privBlob = Buffer.from(m[3], 'base64');\n    let headers = m[2];\n    let decrypted = false;\n\n    if (headers !== undefined) {\n      // encrypted key\n      headers = headers.split(/\\r\\n|\\n/g);\n\n      for (let i = 0; i < headers.length; ++i) {\n        const header = headers[i];\n        let sepIdx = header.indexOf(':');\n\n        if (header.slice(0, sepIdx) === 'DEK-Info') {\n          const val = header.slice(sepIdx + 2);\n          sepIdx = val.indexOf(',');\n          if (sepIdx === -1) continue;\n          const cipherName = val.slice(0, sepIdx).toLowerCase();\n\n          if (supportedOpenSSLCiphers.indexOf(cipherName) === -1) {\n            return new Error(`Cipher (${cipherName}) not supported ` + 'for encrypted OpenSSH private key');\n          }\n\n          const encInfo = CIPHER_INFO_OPENSSL[cipherName];\n\n          if (!encInfo) {\n            return new Error(`Cipher (${cipherName}) not supported ` + 'for encrypted OpenSSH private key');\n          }\n\n          const cipherIV = Buffer.from(val.slice(sepIdx + 1), 'hex');\n          if (cipherIV.length !== encInfo.ivLen) return new Error('Malformed encrypted OpenSSH private key');\n\n          if (!passphrase) {\n            return new Error('Encrypted OpenSSH private key detected, but no passphrase given');\n          }\n\n          const ivSlice = bufferSlice(cipherIV, 0, 8);\n          let cipherKey = createHash('md5').update(passphrase).update(ivSlice).digest();\n\n          while (cipherKey.length < encInfo.keyLen) {\n            cipherKey = combineBuffers(cipherKey, createHash('md5').update(cipherKey).update(passphrase).update(ivSlice).digest());\n          }\n\n          if (cipherKey.length > encInfo.keyLen) cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);\n\n          try {\n            const decipher = createDecipheriv(cipherName, cipherKey, cipherIV);\n            decipher.setAutoPadding(false);\n            privBlob = combineBuffers(decipher.update(privBlob), decipher.final());\n            decrypted = true;\n          } catch (ex) {\n            return ex;\n          }\n        }\n      }\n    }\n\n    let type;\n    let privPEM;\n    let pubPEM;\n    let pubSSH;\n    let algo;\n    let reader;\n    let errMsg = 'Malformed OpenSSH private key';\n    if (decrypted) errMsg += '. Bad passphrase?';\n\n    switch (m[1]) {\n      case 'RSA':\n        type = 'ssh-rsa';\n        privPEM = makePEM('RSA PRIVATE', privBlob);\n\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n\n          const n = reader.readString(Ber.Integer, true);\n          if (n === null) return new Error(errMsg);\n          const e = reader.readString(Ber.Integer, true);\n          if (e === null) return new Error(errMsg);\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n        } catch {\n          return new Error(errMsg);\n        }\n\n        algo = 'sha1';\n        break;\n\n      case 'DSA':\n        type = 'ssh-dss';\n        privPEM = makePEM('DSA PRIVATE', privBlob);\n\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n\n          const p = reader.readString(Ber.Integer, true);\n          if (p === null) return new Error(errMsg);\n          const q = reader.readString(Ber.Integer, true);\n          if (q === null) return new Error(errMsg);\n          const g = reader.readString(Ber.Integer, true);\n          if (g === null) return new Error(errMsg);\n          const y = reader.readString(Ber.Integer, true);\n          if (y === null) return new Error(errMsg);\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        } catch {\n          return new Error(errMsg);\n        }\n\n        algo = 'sha1';\n        break;\n\n      case 'EC':\n        let ecSSLName;\n        let ecPriv;\n        let ecOID;\n\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n\n          ecPriv = reader.readString(Ber.OctetString, true);\n          reader.readByte(); // Skip \"complex\" context type byte\n\n          const offset = reader.readLength(); // Skip context length\n\n          if (offset !== null) {\n            reader._offset = offset;\n            ecOID = reader.readOID();\n            if (ecOID === null) return new Error(errMsg);\n\n            switch (ecOID) {\n              case '1.2.840.10045.3.1.7':\n                // prime256v1/secp256r1\n                ecSSLName = 'prime256v1';\n                type = 'ecdsa-sha2-nistp256';\n                algo = 'sha256';\n                break;\n\n              case '1.3.132.0.34':\n                // secp384r1\n                ecSSLName = 'secp384r1';\n                type = 'ecdsa-sha2-nistp384';\n                algo = 'sha384';\n                break;\n\n              case '1.3.132.0.35':\n                // secp521r1\n                ecSSLName = 'secp521r1';\n                type = 'ecdsa-sha2-nistp521';\n                algo = 'sha512';\n                break;\n\n              default:\n                return new Error(`Unsupported private key EC OID: ${ecOID}`);\n            }\n          } else {\n            return new Error(errMsg);\n          }\n        } catch {\n          return new Error(errMsg);\n        }\n\n        privPEM = makePEM('EC PRIVATE', privBlob);\n        const pubBlob = genOpenSSLECDSAPubFromPriv(ecSSLName, ecPriv);\n        pubPEM = genOpenSSLECDSAPub(ecOID, pubBlob);\n        pubSSH = genOpenSSHECDSAPub(ecOID, pubBlob);\n        break;\n    }\n\n    return new OpenSSH_Old_Private(type, '', privPEM, pubPEM, pubSSH, algo, decrypted);\n  };\n}\n\nfunction PPK_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\n\nPPK_Private.prototype = BaseKey;\n{\n  const EMPTY_PASSPHRASE = Buffer.alloc(0);\n  const PPK_IV = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n  const PPK_PP1 = Buffer.from([0, 0, 0, 0]);\n  const PPK_PP2 = Buffer.from([0, 0, 0, 1]);\n  const regexp = /^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\\r?\\nEncryption: (aes256-cbc|none)\\r?\\nComment: ([^\\r\\n]*)\\r?\\nPublic-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-MAC: ([^\\r\\n]+)/;\n\n  PPK_Private.parse = (str, passphrase) => {\n    const m = regexp.exec(str);\n    if (m === null) return null; // m[1] = key type\n    // m[2] = encryption type\n    // m[3] = comment\n    // m[4] = base64-encoded public key data:\n    //         for \"ssh-rsa\":\n    //          string \"ssh-rsa\"\n    //          mpint  e    (public exponent)\n    //          mpint  n    (modulus)\n    //         for \"ssh-dss\":\n    //          string \"ssh-dss\"\n    //          mpint p     (modulus)\n    //          mpint q     (prime)\n    //          mpint g     (base number)\n    //          mpint y     (public key parameter: g^x mod p)\n    // m[5] = base64-encoded private key data:\n    //         for \"ssh-rsa\":\n    //          mpint  d    (private exponent)\n    //          mpint  p    (prime 1)\n    //          mpint  q    (prime 2)\n    //          mpint  iqmp ([inverse of q] mod p)\n    //         for \"ssh-dss\":\n    //          mpint x     (private key parameter)\n    // m[6] = SHA1 HMAC over:\n    //          string  name of algorithm (\"ssh-dss\", \"ssh-rsa\")\n    //          string  encryption type\n    //          string  comment\n    //          string  public key data\n    //          string  private-plaintext (including the final padding)\n\n    const cipherName = m[2];\n    const encrypted = cipherName !== 'none';\n\n    if (encrypted && !passphrase) {\n      return new Error('Encrypted PPK private key detected, but no passphrase given');\n    }\n\n    let privBlob = Buffer.from(m[5], 'base64');\n\n    if (encrypted) {\n      const encInfo = CIPHER_INFO[cipherName];\n      let cipherKey = combineBuffers(createHash('sha1').update(PPK_PP1).update(passphrase).digest(), createHash('sha1').update(PPK_PP2).update(passphrase).digest());\n      if (cipherKey.length > encInfo.keyLen) cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);\n\n      try {\n        const decipher = createDecipheriv(encInfo.sslName, cipherKey, PPK_IV);\n        decipher.setAutoPadding(false);\n        privBlob = combineBuffers(decipher.update(privBlob), decipher.final());\n      } catch (ex) {\n        return ex;\n      }\n    }\n\n    const type = m[1];\n    const comment = m[3];\n    const pubBlob = Buffer.from(m[4], 'base64');\n    const mac = m[6];\n    const typeLen = type.length;\n    const cipherNameLen = cipherName.length;\n    const commentLen = Buffer.byteLength(comment);\n    const pubLen = pubBlob.length;\n    const privLen = privBlob.length;\n    const macData = Buffer.allocUnsafe(4 + typeLen + 4 + cipherNameLen + 4 + commentLen + 4 + pubLen + 4 + privLen);\n    let p = 0;\n    writeUInt32BE(macData, typeLen, p);\n    macData.utf8Write(type, p += 4, typeLen);\n    writeUInt32BE(macData, cipherNameLen, p += typeLen);\n    macData.utf8Write(cipherName, p += 4, cipherNameLen);\n    writeUInt32BE(macData, commentLen, p += cipherNameLen);\n    macData.utf8Write(comment, p += 4, commentLen);\n    writeUInt32BE(macData, pubLen, p += commentLen);\n    macData.set(pubBlob, p += 4);\n    writeUInt32BE(macData, privLen, p += pubLen);\n    macData.set(privBlob, p + 4);\n    if (!passphrase) passphrase = EMPTY_PASSPHRASE;\n    const calcMAC = createHmac('sha1', createHash('sha1').update('putty-private-key-file-mac-key').update(passphrase).digest()).update(macData).digest('hex');\n\n    if (calcMAC !== mac) {\n      if (encrypted) {\n        return new Error('PPK private key integrity check failed -- bad passphrase?');\n      }\n\n      return new Error('PPK private key integrity check failed');\n    }\n\n    let pubPEM;\n    let pubSSH;\n    let privPEM;\n    pubBlob._pos = 0;\n    skipFields(pubBlob, 1); // skip (duplicate) key type\n\n    switch (type) {\n      case 'ssh-rsa':\n        {\n          const e = readString(pubBlob, pubBlob._pos);\n          if (e === undefined) return new Error('Malformed PPK public key');\n          const n = readString(pubBlob, pubBlob._pos);\n          if (n === undefined) return new Error('Malformed PPK public key');\n          const d = readString(privBlob, 0);\n          if (d === undefined) return new Error('Malformed PPK private key');\n          const p = readString(privBlob, privBlob._pos);\n          if (p === undefined) return new Error('Malformed PPK private key');\n          const q = readString(privBlob, privBlob._pos);\n          if (q === undefined) return new Error('Malformed PPK private key');\n          const iqmp = readString(privBlob, privBlob._pos);\n          if (iqmp === undefined) return new Error('Malformed PPK private key');\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n          privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);\n          break;\n        }\n\n      case 'ssh-dss':\n        {\n          const p = readString(pubBlob, pubBlob._pos);\n          if (p === undefined) return new Error('Malformed PPK public key');\n          const q = readString(pubBlob, pubBlob._pos);\n          if (q === undefined) return new Error('Malformed PPK public key');\n          const g = readString(pubBlob, pubBlob._pos);\n          if (g === undefined) return new Error('Malformed PPK public key');\n          const y = readString(pubBlob, pubBlob._pos);\n          if (y === undefined) return new Error('Malformed PPK public key');\n          const x = readString(privBlob, 0);\n          if (x === undefined) return new Error('Malformed PPK private key');\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n          privPEM = genOpenSSLDSAPriv(p, q, g, y, x);\n          break;\n        }\n    }\n\n    return new PPK_Private(type, comment, privPEM, pubPEM, pubSSH, 'sha1', encrypted);\n  };\n}\n\nfunction OpenSSH_Public(type, comment, pubPEM, pubSSH, algo) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = null;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = false;\n}\n\nOpenSSH_Public.prototype = BaseKey;\n{\n  let regexp;\n  if (eddsaSupported) regexp = /^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\\s+([\\S].*)?)$/;else regexp = /^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\\s+([\\S].*)?)$/;\n\n  OpenSSH_Public.parse = str => {\n    const m = regexp.exec(str);\n    if (m === null) return null; // m[1] = full type\n    // m[2] = base type\n    // m[3] = base64-encoded public key\n    // m[4] = comment\n\n    const fullType = m[1];\n    const baseType = m[2];\n    const data = Buffer.from(m[3], 'base64');\n    const comment = m[4] || '';\n    const type = readString(data, data._pos, true);\n    if (type === undefined || type.indexOf(baseType) !== 0) return new Error('Malformed OpenSSH public key');\n    return parseDER(data, baseType, comment, fullType);\n  };\n}\n\nfunction RFC4716_Public(type, comment, pubPEM, pubSSH, algo) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = null;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = false;\n}\n\nRFC4716_Public.prototype = BaseKey;\n{\n  const regexp = /^---- BEGIN SSH2 PUBLIC KEY ----(?:\\r?\\n)((?:.{0,72}\\r?\\n)+)---- END SSH2 PUBLIC KEY ----$/;\n  const RE_DATA = /^[A-Z0-9a-z/+=\\r\\n]+$/;\n  const RE_HEADER = /^([\\x21-\\x39\\x3B-\\x7E]{1,64}): ((?:[^\\\\]*\\\\\\r?\\n)*[^\\r\\n]+)\\r?\\n/gm;\n  const RE_HEADER_ENDS = /\\\\\\r?\\n/g;\n\n  RFC4716_Public.parse = str => {\n    let m = regexp.exec(str);\n    if (m === null) return null;\n    const body = m[1];\n    let dataStart = 0;\n    let comment = '';\n\n    while (m = RE_HEADER.exec(body)) {\n      const headerName = m[1];\n      const headerValue = m[2].replace(RE_HEADER_ENDS, '');\n\n      if (headerValue.length > 1024) {\n        RE_HEADER.lastIndex = 0;\n        return new Error('Malformed RFC4716 public key');\n      }\n\n      dataStart = RE_HEADER.lastIndex;\n\n      if (headerName.toLowerCase() === 'comment') {\n        comment = headerValue;\n\n        if (comment.length > 1 && comment.charCodeAt(0) === 34\n        /* '\"' */\n        && comment.charCodeAt(comment.length - 1) === 34\n        /* '\"' */\n        ) {\n          comment = comment.slice(1, -1);\n        }\n      }\n    }\n\n    let data = body.slice(dataStart);\n    if (!RE_DATA.test(data)) return new Error('Malformed RFC4716 public key');\n    data = Buffer.from(data, 'base64');\n    const type = readString(data, 0, true);\n    if (type === undefined) return new Error('Malformed RFC4716 public key');\n    let pubPEM = null;\n    let pubSSH = null;\n\n    switch (type) {\n      case 'ssh-rsa':\n        {\n          const e = readString(data, data._pos);\n          if (e === undefined) return new Error('Malformed RFC4716 public key');\n          const n = readString(data, data._pos);\n          if (n === undefined) return new Error('Malformed RFC4716 public key');\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n          break;\n        }\n\n      case 'ssh-dss':\n        {\n          const p = readString(data, data._pos);\n          if (p === undefined) return new Error('Malformed RFC4716 public key');\n          const q = readString(data, data._pos);\n          if (q === undefined) return new Error('Malformed RFC4716 public key');\n          const g = readString(data, data._pos);\n          if (g === undefined) return new Error('Malformed RFC4716 public key');\n          const y = readString(data, data._pos);\n          if (y === undefined) return new Error('Malformed RFC4716 public key');\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n          break;\n        }\n\n      default:\n        return new Error('Malformed RFC4716 public key');\n    }\n\n    return new RFC4716_Public(type, comment, pubPEM, pubSSH, 'sha1');\n  };\n}\n\nfunction parseDER(data, baseType, comment, fullType) {\n  if (!isSupportedKeyType(baseType)) return new Error(`Unsupported OpenSSH public key type: ${baseType}`);\n  let algo;\n  let oid;\n  let pubPEM = null;\n  let pubSSH = null;\n\n  switch (baseType) {\n    case 'ssh-rsa':\n      {\n        const e = readString(data, data._pos || 0);\n        if (e === undefined) return new Error('Malformed OpenSSH public key');\n        const n = readString(data, data._pos);\n        if (n === undefined) return new Error('Malformed OpenSSH public key');\n        pubPEM = genOpenSSLRSAPub(n, e);\n        pubSSH = genOpenSSHRSAPub(n, e);\n        algo = 'sha1';\n        break;\n      }\n\n    case 'ssh-dss':\n      {\n        const p = readString(data, data._pos || 0);\n        if (p === undefined) return new Error('Malformed OpenSSH public key');\n        const q = readString(data, data._pos);\n        if (q === undefined) return new Error('Malformed OpenSSH public key');\n        const g = readString(data, data._pos);\n        if (g === undefined) return new Error('Malformed OpenSSH public key');\n        const y = readString(data, data._pos);\n        if (y === undefined) return new Error('Malformed OpenSSH public key');\n        pubPEM = genOpenSSLDSAPub(p, q, g, y);\n        pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        algo = 'sha1';\n        break;\n      }\n\n    case 'ssh-ed25519':\n      {\n        const edpub = readString(data, data._pos || 0);\n        if (edpub === undefined || edpub.length !== 32) return new Error('Malformed OpenSSH public key');\n        pubPEM = genOpenSSLEdPub(edpub);\n        pubSSH = genOpenSSHEdPub(edpub);\n        algo = null;\n        break;\n      }\n\n    case 'ecdsa-sha2-nistp256':\n      algo = 'sha256';\n      oid = '1.2.840.10045.3.1.7';\n    // FALLTHROUGH\n\n    case 'ecdsa-sha2-nistp384':\n      if (algo === undefined) {\n        algo = 'sha384';\n        oid = '1.3.132.0.34';\n      }\n\n    // FALLTHROUGH\n\n    case 'ecdsa-sha2-nistp521':\n      {\n        if (algo === undefined) {\n          algo = 'sha512';\n          oid = '1.3.132.0.35';\n        } // TODO: validate curve name against type\n\n\n        if (!skipFields(data, 1)) // Skip curve name\n          return new Error('Malformed OpenSSH public key');\n        const ecpub = readString(data, data._pos || 0);\n        if (ecpub === undefined) return new Error('Malformed OpenSSH public key');\n        pubPEM = genOpenSSLECDSAPub(oid, ecpub);\n        pubSSH = genOpenSSHECDSAPub(oid, ecpub);\n        break;\n      }\n\n    default:\n      return new Error(`Unsupported OpenSSH public key type: ${baseType}`);\n  }\n\n  return new OpenSSH_Public(fullType, comment, pubPEM, pubSSH, algo);\n}\n\nfunction isSupportedKeyType(type) {\n  switch (type) {\n    case 'ssh-rsa':\n    case 'ssh-dss':\n    case 'ecdsa-sha2-nistp256':\n    case 'ecdsa-sha2-nistp384':\n    case 'ecdsa-sha2-nistp521':\n      return true;\n\n    case 'ssh-ed25519':\n      if (eddsaSupported) return true;\n    // FALLTHROUGH\n\n    default:\n      return false;\n  }\n}\n\nfunction isParsedKey(val) {\n  if (!val) return false;\n  return typeof val[SYM_DECRYPTED] === 'boolean';\n}\n\nfunction parseKey(data, passphrase) {\n  if (isParsedKey(data)) return data;\n  let origBuffer;\n\n  if (Buffer.isBuffer(data)) {\n    origBuffer = data;\n    data = data.utf8Slice(0, data.length).trim();\n  } else if (typeof data === 'string') {\n    data = data.trim();\n  } else {\n    return new Error('Key data must be a Buffer or string');\n  } // eslint-disable-next-line eqeqeq\n\n\n  if (passphrase != undefined) {\n    if (typeof passphrase === 'string') passphrase = Buffer.from(passphrase);else if (!Buffer.isBuffer(passphrase)) return new Error('Passphrase must be a string or Buffer when supplied');\n  }\n\n  let ret; // First try as printable string format (e.g. PEM)\n  // Private keys\n\n  if ((ret = OpenSSH_Private.parse(data, passphrase)) !== null) return ret;\n  if ((ret = OpenSSH_Old_Private.parse(data, passphrase)) !== null) return ret;\n  if ((ret = PPK_Private.parse(data, passphrase)) !== null) return ret; // Public keys\n\n  if ((ret = OpenSSH_Public.parse(data)) !== null) return ret;\n  if ((ret = RFC4716_Public.parse(data)) !== null) return ret; // Finally try as a binary format if we were originally passed binary data\n\n  if (origBuffer) {\n    binaryKeyParser.init(origBuffer, 0);\n    const type = binaryKeyParser.readString(true);\n\n    if (type !== undefined) {\n      data = binaryKeyParser.readRaw();\n\n      if (data !== undefined) {\n        ret = parseDER(data, type, '', type); // Ignore potentially useless errors in case the data was not actually\n        // in the binary format\n\n        if (ret instanceof Error) ret = null;\n      }\n    }\n\n    binaryKeyParser.clear();\n  }\n\n  if (ret) return ret;\n  return new Error('Unsupported key format');\n}\n\nmodule.exports = {\n  isParsedKey,\n  isSupportedKeyType,\n  parseDERKey: (data, type) => parseDER(data, type, '', type),\n  parseKey\n};","map":{"version":3,"names":["createDecipheriv","createECDH","createHash","createHmac","createSign","createVerify","getCiphers","sign","sign_","verify","verify_","require","supportedOpenSSLCiphers","Ber","bcrypt_pbkdf","pbkdf","CIPHER_INFO","eddsaSupported","SUPPORTED_CIPHER","bufferSlice","makeBufferParser","readString","readUInt32BE","writeUInt32BE","SYM_HASH_ALGO","Symbol","SYM_PRIV_PEM","SYM_PUB_PEM","SYM_PUB_SSH","SYM_DECRYPTED","CIPHER_INFO_OPENSSL","Object","create","keys","i","length","cipherName","sslName","binaryKeyParser","makePEM","type","data","base64Slice","formatted","replace","combineBuffers","buf1","buf2","result","Buffer","allocUnsafe","set","skipFields","buf","nfields","bufLen","pos","_pos","left","len","genOpenSSLRSAPub","n","e","asnWriter","Writer","startSequence","writeOID","writeNull","endSequence","BitString","writeByte","writeBuffer","Integer","buffer","genOpenSSHRSAPub","publicKey","utf8Write","genOpenSSLRSAPriv","genRSAASN1Buf","d","p","q","dmp1","dmq1","iqmp","writeInt","bigIntFromBuffer","BigInt","hexSlice","bigIntToBuffer","bn","hex","toString","sigbit","charCodeAt","from","bn_d","genOpenSSLDSAPub","g","y","genOpenSSHDSAPub","genOpenSSLDSAPriv","x","genOpenSSLEdPub","pub","_ensure","_buf","_offset","genOpenSSHEdPub","genOpenSSLEdPriv","priv","OctetString","genOpenSSLECDSAPub","oid","Q","genOpenSSHECDSAPub","curveName","genOpenSSLECDSAPriv","genOpenSSLECDSAPubFromPriv","tempECDH","setPrivateKey","getPublicKey","BaseKey","algo","pem","Error","ex","signature","update","verifier","isPrivateKey","getPrivatePEM","getPublicPEM","getPublicSSH","equals","key","parsed","parseKey","OpenSSH_Private","comment","privPEM","pubPEM","pubSSH","decrypted","prototype","regexp","parse","str","passphrase","m","exec","ret","magic","utf8Slice","undefined","indexOf","kdfName","encInfo","cipherKey","cipherIV","kdfOptions","salt","rounds","gen","keyLen","ivLen","r","keyCount","pubData","privBlob","blockLen","options","authTagLength","authLen","decipher","setAuthTag","final","parseOpenSSHPrivKeys","nkeys","check1","check2","edpub","edpriv","ecpub","ecpriv","privComment","push","cnt","OpenSSH_Old_Private","headers","split","header","sepIdx","slice","val","toLowerCase","ivSlice","digest","setAutoPadding","reader","errMsg","Reader","readSequence","readInt","ecSSLName","ecPriv","ecOID","readByte","offset","readLength","readOID","pubBlob","PPK_Private","EMPTY_PASSPHRASE","alloc","PPK_IV","PPK_PP1","PPK_PP2","encrypted","mac","typeLen","cipherNameLen","commentLen","byteLength","pubLen","privLen","macData","calcMAC","OpenSSH_Public","fullType","baseType","parseDER","RFC4716_Public","RE_DATA","RE_HEADER","RE_HEADER_ENDS","body","dataStart","headerName","headerValue","lastIndex","test","isSupportedKeyType","isParsedKey","origBuffer","isBuffer","trim","init","readRaw","clear","module","exports","parseDERKey"],"sources":["/home/micqdf/AlpacaPunchTests/maintest/test1/client/node_modules/ssh2/lib/protocol/keyParser.js"],"sourcesContent":["// TODO:\n//    * utilize `crypto.create(Private|Public)Key()` and `keyObject.export()`\n//    * handle multi-line header values (OpenSSH)?\n//    * more thorough validation?\n'use strict';\n\nconst {\n  createDecipheriv,\n  createECDH,\n  createHash,\n  createHmac,\n  createSign,\n  createVerify,\n  getCiphers,\n  sign: sign_,\n  verify: verify_,\n} = require('crypto');\nconst supportedOpenSSLCiphers = getCiphers();\n\nconst { Ber } = require('asn1');\nconst bcrypt_pbkdf = require('bcrypt-pbkdf').pbkdf;\n\nconst { CIPHER_INFO } = require('./crypto.js');\nconst { eddsaSupported, SUPPORTED_CIPHER } = require('./constants.js');\nconst {\n  bufferSlice,\n  makeBufferParser,\n  readString,\n  readUInt32BE,\n  writeUInt32BE,\n} = require('./utils.js');\n\nconst SYM_HASH_ALGO = Symbol('Hash Algorithm');\nconst SYM_PRIV_PEM = Symbol('Private key PEM');\nconst SYM_PUB_PEM = Symbol('Public key PEM');\nconst SYM_PUB_SSH = Symbol('Public key SSH');\nconst SYM_DECRYPTED = Symbol('Decrypted Key');\n\n// Create OpenSSL cipher name -> SSH cipher name conversion table\nconst CIPHER_INFO_OPENSSL = Object.create(null);\n{\n  const keys = Object.keys(CIPHER_INFO);\n  for (let i = 0; i < keys.length; ++i) {\n    const cipherName = CIPHER_INFO[keys[i]].sslName;\n    if (!cipherName || CIPHER_INFO_OPENSSL[cipherName])\n      continue;\n    CIPHER_INFO_OPENSSL[cipherName] = CIPHER_INFO[keys[i]];\n  }\n}\n\nconst binaryKeyParser = makeBufferParser();\n\nfunction makePEM(type, data) {\n  data = data.base64Slice(0, data.length);\n  let formatted = data.replace(/.{64}/g, '$&\\n');\n  if (data.length & 63)\n    formatted += '\\n';\n  return `-----BEGIN ${type} KEY-----\\n${formatted}-----END ${type} KEY-----`;\n}\n\nfunction combineBuffers(buf1, buf2) {\n  const result = Buffer.allocUnsafe(buf1.length + buf2.length);\n  result.set(buf1, 0);\n  result.set(buf2, buf1.length);\n  return result;\n}\n\nfunction skipFields(buf, nfields) {\n  const bufLen = buf.length;\n  let pos = (buf._pos || 0);\n  for (let i = 0; i < nfields; ++i) {\n    const left = (bufLen - pos);\n    if (pos >= bufLen || left < 4)\n      return false;\n    const len = readUInt32BE(buf, pos);\n    if (left < 4 + len)\n      return false;\n    pos += 4 + len;\n  }\n  buf._pos = pos;\n  return true;\n}\n\nfunction genOpenSSLRSAPub(n, e) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.113549.1.1.1'); // rsaEncryption\n      // algorithm parameters (RSA has none)\n      asnWriter.writeNull();\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      asnWriter.startSequence();\n        asnWriter.writeBuffer(n, Ber.Integer);\n        asnWriter.writeBuffer(e, Ber.Integer);\n      asnWriter.endSequence();\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHRSAPub(n, e) {\n  const publicKey = Buffer.allocUnsafe(4 + 7 + 4 + e.length + 4 + n.length);\n\n  writeUInt32BE(publicKey, 7, 0);\n  publicKey.utf8Write('ssh-rsa', 4, 7);\n\n  let i = 4 + 7;\n  writeUInt32BE(publicKey, e.length, i);\n  publicKey.set(e, i += 4);\n\n  writeUInt32BE(publicKey, n.length, i += e.length);\n  publicKey.set(n, i + 4);\n\n  return publicKey;\n}\n\nconst genOpenSSLRSAPriv = (() => {\n  function genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp) {\n    const asnWriter = new Ber.Writer();\n    asnWriter.startSequence();\n      asnWriter.writeInt(0x00, Ber.Integer);\n      asnWriter.writeBuffer(n, Ber.Integer);\n      asnWriter.writeBuffer(e, Ber.Integer);\n      asnWriter.writeBuffer(d, Ber.Integer);\n      asnWriter.writeBuffer(p, Ber.Integer);\n      asnWriter.writeBuffer(q, Ber.Integer);\n      asnWriter.writeBuffer(dmp1, Ber.Integer);\n      asnWriter.writeBuffer(dmq1, Ber.Integer);\n      asnWriter.writeBuffer(iqmp, Ber.Integer);\n    asnWriter.endSequence();\n    return asnWriter.buffer;\n  }\n\n  function bigIntFromBuffer(buf) {\n    return BigInt(`0x${buf.hexSlice(0, buf.length)}`);\n  }\n\n  function bigIntToBuffer(bn) {\n    let hex = bn.toString(16);\n    if ((hex.length & 1) !== 0) {\n      hex = `0${hex}`;\n    } else {\n      const sigbit = hex.charCodeAt(0);\n      // BER/DER integers require leading zero byte to denote a positive value\n      // when first byte >= 0x80\n      if (sigbit === 56/* '8' */\n          || sigbit === 57/* '9' */\n          || (sigbit >= 97/* 'a' */ && sigbit <= 102/* 'f' */)) {\n        hex = `00${hex}`;\n      }\n    }\n    return Buffer.from(hex, 'hex');\n  }\n\n  return function genOpenSSLRSAPriv(n, e, d, iqmp, p, q) {\n    const bn_d = bigIntFromBuffer(d);\n    const dmp1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(p) - 1n));\n    const dmq1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(q) - 1n));\n    return makePEM('RSA PRIVATE',\n                   genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp));\n  };\n})();\n\nfunction genOpenSSLDSAPub(p, q, g, y) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.10040.4.1'); // id-dsa\n      // algorithm parameters\n      asnWriter.startSequence();\n        asnWriter.writeBuffer(p, Ber.Integer);\n        asnWriter.writeBuffer(q, Ber.Integer);\n        asnWriter.writeBuffer(g, Ber.Integer);\n      asnWriter.endSequence();\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      asnWriter.writeBuffer(y, Ber.Integer);\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHDSAPub(p, q, g, y) {\n  const publicKey = Buffer.allocUnsafe(\n    4 + 7 + 4 + p.length + 4 + q.length + 4 + g.length + 4 + y.length\n  );\n\n  writeUInt32BE(publicKey, 7, 0);\n  publicKey.utf8Write('ssh-dss', 4, 7);\n\n  let i = 4 + 7;\n  writeUInt32BE(publicKey, p.length, i);\n  publicKey.set(p, i += 4);\n\n  writeUInt32BE(publicKey, q.length, i += p.length);\n  publicKey.set(q, i += 4);\n\n  writeUInt32BE(publicKey, g.length, i += q.length);\n  publicKey.set(g, i += 4);\n\n  writeUInt32BE(publicKey, y.length, i += g.length);\n  publicKey.set(y, i + 4);\n\n  return publicKey;\n}\n\nfunction genOpenSSLDSAPriv(p, q, g, y, x) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    asnWriter.writeInt(0x00, Ber.Integer);\n    asnWriter.writeBuffer(p, Ber.Integer);\n    asnWriter.writeBuffer(q, Ber.Integer);\n    asnWriter.writeBuffer(g, Ber.Integer);\n    asnWriter.writeBuffer(y, Ber.Integer);\n    asnWriter.writeBuffer(x, Ber.Integer);\n  asnWriter.endSequence();\n  return makePEM('DSA PRIVATE', asnWriter.buffer);\n}\n\nfunction genOpenSSLEdPub(pub) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.3.101.112'); // id-Ed25519\n    asnWriter.endSequence();\n\n    // PublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      // XXX: hack to write a raw buffer without a tag -- yuck\n      asnWriter._ensure(pub.length);\n      asnWriter._buf.set(pub, asnWriter._offset);\n      asnWriter._offset += pub.length;\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHEdPub(pub) {\n  const publicKey = Buffer.allocUnsafe(4 + 11 + 4 + pub.length);\n\n  writeUInt32BE(publicKey, 11, 0);\n  publicKey.utf8Write('ssh-ed25519', 4, 11);\n\n  writeUInt32BE(publicKey, pub.length, 15);\n  publicKey.set(pub, 19);\n\n  return publicKey;\n}\n\nfunction genOpenSSLEdPriv(priv) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // version\n    asnWriter.writeInt(0x00, Ber.Integer);\n\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.3.101.112'); // id-Ed25519\n    asnWriter.endSequence();\n\n    // PrivateKey\n    asnWriter.startSequence(Ber.OctetString);\n      asnWriter.writeBuffer(priv, Ber.OctetString);\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PRIVATE', asnWriter.buffer);\n}\n\nfunction genOpenSSLECDSAPub(oid, Q) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.10045.2.1'); // id-ecPublicKey\n      // algorithm parameters (namedCurve)\n      asnWriter.writeOID(oid);\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      // XXX: hack to write a raw buffer without a tag -- yuck\n      asnWriter._ensure(Q.length);\n      asnWriter._buf.set(Q, asnWriter._offset);\n      asnWriter._offset += Q.length;\n      // end hack\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHECDSAPub(oid, Q) {\n  let curveName;\n  switch (oid) {\n    case '1.2.840.10045.3.1.7':\n      // prime256v1/secp256r1\n      curveName = 'nistp256';\n      break;\n    case '1.3.132.0.34':\n      // secp384r1\n      curveName = 'nistp384';\n      break;\n    case '1.3.132.0.35':\n      // secp521r1\n      curveName = 'nistp521';\n      break;\n    default:\n      return;\n  }\n\n  const publicKey = Buffer.allocUnsafe(4 + 19 + 4 + 8 + 4 + Q.length);\n\n  writeUInt32BE(publicKey, 19, 0);\n  publicKey.utf8Write(`ecdsa-sha2-${curveName}`, 4, 19);\n\n  writeUInt32BE(publicKey, 8, 23);\n  publicKey.utf8Write(curveName, 27, 8);\n\n  writeUInt32BE(publicKey, Q.length, 35);\n  publicKey.set(Q, 39);\n\n  return publicKey;\n}\n\nfunction genOpenSSLECDSAPriv(oid, pub, priv) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // version\n    asnWriter.writeInt(0x01, Ber.Integer);\n    // privateKey\n    asnWriter.writeBuffer(priv, Ber.OctetString);\n    // parameters (optional)\n    asnWriter.startSequence(0xA0);\n      asnWriter.writeOID(oid);\n    asnWriter.endSequence();\n    // publicKey (optional)\n    asnWriter.startSequence(0xA1);\n      asnWriter.startSequence(Ber.BitString);\n        asnWriter.writeByte(0x00);\n        // XXX: hack to write a raw buffer without a tag -- yuck\n        asnWriter._ensure(pub.length);\n        asnWriter._buf.set(pub, asnWriter._offset);\n        asnWriter._offset += pub.length;\n        // end hack\n      asnWriter.endSequence();\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('EC PRIVATE', asnWriter.buffer);\n}\n\nfunction genOpenSSLECDSAPubFromPriv(curveName, priv) {\n  const tempECDH = createECDH(curveName);\n  tempECDH.setPrivateKey(priv);\n  return tempECDH.getPublicKey();\n}\n\nconst BaseKey = {\n  sign: (() => {\n    if (typeof sign_ === 'function') {\n      return function sign(data, algo) {\n        const pem = this[SYM_PRIV_PEM];\n        if (pem === null)\n          return new Error('No private key available');\n        if (!algo || typeof algo !== 'string')\n          algo = this[SYM_HASH_ALGO];\n        try {\n          return sign_(algo, data, pem);\n        } catch (ex) {\n          return ex;\n        }\n      };\n    }\n    return function sign(data, algo) {\n      const pem = this[SYM_PRIV_PEM];\n      if (pem === null)\n        return new Error('No private key available');\n      if (!algo || typeof algo !== 'string')\n        algo = this[SYM_HASH_ALGO];\n      const signature = createSign(algo);\n      signature.update(data);\n      try {\n        return signature.sign(pem);\n      } catch (ex) {\n        return ex;\n      }\n    };\n  })(),\n  verify: (() => {\n    if (typeof verify_ === 'function') {\n      return function verify(data, signature, algo) {\n        const pem = this[SYM_PUB_PEM];\n        if (pem === null)\n          return new Error('No public key available');\n        if (!algo || typeof algo !== 'string')\n          algo = this[SYM_HASH_ALGO];\n        try {\n          return verify_(algo, data, pem, signature);\n        } catch (ex) {\n          return ex;\n        }\n      };\n    }\n    return function verify(data, signature, algo) {\n      const pem = this[SYM_PUB_PEM];\n      if (pem === null)\n        return new Error('No public key available');\n      if (!algo || typeof algo !== 'string')\n        algo = this[SYM_HASH_ALGO];\n      const verifier = createVerify(algo);\n      verifier.update(data);\n      try {\n        return verifier.verify(pem, signature);\n      } catch (ex) {\n        return ex;\n      }\n    };\n  })(),\n  isPrivateKey: function isPrivateKey() {\n    return (this[SYM_PRIV_PEM] !== null);\n  },\n  getPrivatePEM: function getPrivatePEM() {\n    return this[SYM_PRIV_PEM];\n  },\n  getPublicPEM: function getPublicPEM() {\n    return this[SYM_PUB_PEM];\n  },\n  getPublicSSH: function getPublicSSH() {\n    return this[SYM_PUB_SSH];\n  },\n  equals: function equals(key) {\n    const parsed = parseKey(key);\n    if (parsed instanceof Error)\n      return false;\n    return (\n      this.type === parsed.type\n      && this[SYM_PRIV_PEM] === parsed[SYM_PRIV_PEM]\n      && this[SYM_PUB_PEM] === parsed[SYM_PUB_PEM]\n      && this[SYM_PUB_SSH] === parsed[SYM_PUB_SSH]\n    );\n  },\n};\n\n\nfunction OpenSSH_Private(type, comment, privPEM, pubPEM, pubSSH, algo,\n                         decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nOpenSSH_Private.prototype = BaseKey;\n{\n  const regexp = /^-----BEGIN OPENSSH PRIVATE KEY-----(?:\\r\\n|\\n)([\\s\\S]+)(?:\\r\\n|\\n)-----END OPENSSH PRIVATE KEY-----$/;\n  OpenSSH_Private.parse = (str, passphrase) => {\n    const m = regexp.exec(str);\n    if (m === null)\n      return null;\n    let ret;\n    const data = Buffer.from(m[1], 'base64');\n    if (data.length < 31) // magic (+ magic null term.) + minimum field lengths\n      return new Error('Malformed OpenSSH private key');\n    const magic = data.utf8Slice(0, 15);\n    if (magic !== 'openssh-key-v1\\0')\n      return new Error(`Unsupported OpenSSH key magic: ${magic}`);\n\n    const cipherName = readString(data, 15, true);\n    if (cipherName === undefined)\n      return new Error('Malformed OpenSSH private key');\n    if (cipherName !== 'none' && SUPPORTED_CIPHER.indexOf(cipherName) === -1)\n      return new Error(`Unsupported cipher for OpenSSH key: ${cipherName}`);\n\n    const kdfName = readString(data, data._pos, true);\n    if (kdfName === undefined)\n      return new Error('Malformed OpenSSH private key');\n    if (kdfName !== 'none') {\n      if (cipherName === 'none')\n        return new Error('Malformed OpenSSH private key');\n      if (kdfName !== 'bcrypt')\n        return new Error(`Unsupported kdf name for OpenSSH key: ${kdfName}`);\n      if (!passphrase) {\n        return new Error(\n          'Encrypted private OpenSSH key detected, but no passphrase given'\n        );\n      }\n    } else if (cipherName !== 'none') {\n      return new Error('Malformed OpenSSH private key');\n    }\n\n    let encInfo;\n    let cipherKey;\n    let cipherIV;\n    if (cipherName !== 'none')\n      encInfo = CIPHER_INFO[cipherName];\n    const kdfOptions = readString(data, data._pos);\n    if (kdfOptions === undefined)\n      return new Error('Malformed OpenSSH private key');\n    if (kdfOptions.length) {\n      switch (kdfName) {\n        case 'none':\n          return new Error('Malformed OpenSSH private key');\n        case 'bcrypt':\n          /*\n            string salt\n            uint32 rounds\n          */\n          const salt = readString(kdfOptions, 0);\n          if (salt === undefined || kdfOptions._pos + 4 > kdfOptions.length)\n            return new Error('Malformed OpenSSH private key');\n          const rounds = readUInt32BE(kdfOptions, kdfOptions._pos);\n          const gen = Buffer.allocUnsafe(encInfo.keyLen + encInfo.ivLen);\n          const r = bcrypt_pbkdf(passphrase,\n                                 passphrase.length,\n                                 salt,\n                                 salt.length,\n                                 gen,\n                                 gen.length,\n                                 rounds);\n          if (r !== 0)\n            return new Error('Failed to generate information to decrypt key');\n          cipherKey = bufferSlice(gen, 0, encInfo.keyLen);\n          cipherIV = bufferSlice(gen, encInfo.keyLen, gen.length);\n          break;\n      }\n    } else if (kdfName !== 'none') {\n      return new Error('Malformed OpenSSH private key');\n    }\n\n    if (data._pos + 3 >= data.length)\n      return new Error('Malformed OpenSSH private key');\n    const keyCount = readUInt32BE(data, data._pos);\n    data._pos += 4;\n\n    if (keyCount > 0) {\n      // TODO: place sensible limit on max `keyCount`\n\n      // Read public keys first\n      for (let i = 0; i < keyCount; ++i) {\n        const pubData = readString(data, data._pos);\n        if (pubData === undefined)\n          return new Error('Malformed OpenSSH private key');\n        const type = readString(pubData, 0, true);\n        if (type === undefined)\n          return new Error('Malformed OpenSSH private key');\n      }\n\n      let privBlob = readString(data, data._pos);\n      if (privBlob === undefined)\n        return new Error('Malformed OpenSSH private key');\n\n      if (cipherKey !== undefined) {\n        // Encrypted private key(s)\n        if (privBlob.length < encInfo.blockLen\n            || (privBlob.length % encInfo.blockLen) !== 0) {\n          return new Error('Malformed OpenSSH private key');\n        }\n        try {\n          const options = { authTagLength: encInfo.authLen };\n          const decipher = createDecipheriv(encInfo.sslName,\n                                            cipherKey,\n                                            cipherIV,\n                                            options);\n          if (encInfo.authLen > 0) {\n            if (data.length - data._pos < encInfo.authLen)\n              return new Error('Malformed OpenSSH private key');\n            decipher.setAuthTag(\n              bufferSlice(data, data._pos, data._pos += encInfo.authLen)\n            );\n          }\n          privBlob = combineBuffers(decipher.update(privBlob),\n                                    decipher.final());\n        } catch (ex) {\n          return ex;\n        }\n      }\n      // Nothing should we follow the private key(s), except a possible\n      // authentication tag for relevant ciphers\n      if (data._pos !== data.length)\n        return new Error('Malformed OpenSSH private key');\n\n      ret = parseOpenSSHPrivKeys(privBlob, keyCount, cipherKey !== undefined);\n    } else {\n      ret = [];\n    }\n    if (ret instanceof Error)\n      return ret;\n    // This will need to change if/when OpenSSH ever starts storing multiple\n    // keys in their key files\n    return ret[0];\n  };\n\n  function parseOpenSSHPrivKeys(data, nkeys, decrypted) {\n    const keys = [];\n    /*\n      uint32  checkint\n      uint32  checkint\n      string  privatekey1\n      string  comment1\n      string  privatekey2\n      string  comment2\n      ...\n      string  privatekeyN\n      string  commentN\n      char  1\n      char  2\n      char  3\n      ...\n      char  padlen % 255\n    */\n    if (data.length < 8)\n      return new Error('Malformed OpenSSH private key');\n    const check1 = readUInt32BE(data, 0);\n    const check2 = readUInt32BE(data, 4);\n    if (check1 !== check2) {\n      if (decrypted) {\n        return new Error(\n          'OpenSSH key integrity check failed -- bad passphrase?'\n        );\n      }\n      return new Error('OpenSSH key integrity check failed');\n    }\n    data._pos = 8;\n    let i;\n    let oid;\n    for (i = 0; i < nkeys; ++i) {\n      let algo;\n      let privPEM;\n      let pubPEM;\n      let pubSSH;\n      // The OpenSSH documentation for the key format actually lies, the\n      // entirety of the private key content is not contained with a string\n      // field, it's actually the literal contents of the private key, so to be\n      // able to find the end of the key data you need to know the layout/format\n      // of each key type ...\n      const type = readString(data, data._pos, true);\n      if (type === undefined)\n        return new Error('Malformed OpenSSH private key');\n\n      switch (type) {\n        case 'ssh-rsa': {\n          /*\n            string  n -- public\n            string  e -- public\n            string  d -- private\n            string  iqmp -- private\n            string  p -- private\n            string  q -- private\n          */\n          const n = readString(data, data._pos);\n          if (n === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const e = readString(data, data._pos);\n          if (e === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const d = readString(data, data._pos);\n          if (d === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const iqmp = readString(data, data._pos);\n          if (iqmp === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const p = readString(data, data._pos);\n          if (p === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const q = readString(data, data._pos);\n          if (q === undefined)\n            return new Error('Malformed OpenSSH private key');\n\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n          privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);\n          algo = 'sha1';\n          break;\n        }\n        case 'ssh-dss': {\n          /*\n            string  p -- public\n            string  q -- public\n            string  g -- public\n            string  y -- public\n            string  x -- private\n          */\n          const p = readString(data, data._pos);\n          if (p === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const q = readString(data, data._pos);\n          if (q === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const g = readString(data, data._pos);\n          if (g === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const y = readString(data, data._pos);\n          if (y === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const x = readString(data, data._pos);\n          if (x === undefined)\n            return new Error('Malformed OpenSSH private key');\n\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n          privPEM = genOpenSSLDSAPriv(p, q, g, y, x);\n          algo = 'sha1';\n          break;\n        }\n        case 'ssh-ed25519': {\n          if (!eddsaSupported)\n            return new Error(`Unsupported OpenSSH private key type: ${type}`);\n          /*\n            * string  public key\n            * string  private key + public key\n          */\n          const edpub = readString(data, data._pos);\n          if (edpub === undefined || edpub.length !== 32)\n            return new Error('Malformed OpenSSH private key');\n          const edpriv = readString(data, data._pos);\n          if (edpriv === undefined || edpriv.length !== 64)\n            return new Error('Malformed OpenSSH private key');\n\n          pubPEM = genOpenSSLEdPub(edpub);\n          pubSSH = genOpenSSHEdPub(edpub);\n          privPEM = genOpenSSLEdPriv(bufferSlice(edpriv, 0, 32));\n          algo = null;\n          break;\n        }\n        case 'ecdsa-sha2-nistp256':\n          algo = 'sha256';\n          oid = '1.2.840.10045.3.1.7';\n        // FALLTHROUGH\n        case 'ecdsa-sha2-nistp384':\n          if (algo === undefined) {\n            algo = 'sha384';\n            oid = '1.3.132.0.34';\n          }\n        // FALLTHROUGH\n        case 'ecdsa-sha2-nistp521': {\n          if (algo === undefined) {\n            algo = 'sha512';\n            oid = '1.3.132.0.35';\n          }\n          /*\n            string  curve name\n            string  Q -- public\n            string  d -- private\n          */\n          // TODO: validate curve name against type\n          if (!skipFields(data, 1)) // Skip curve name\n            return new Error('Malformed OpenSSH private key');\n          const ecpub = readString(data, data._pos);\n          if (ecpub === undefined)\n            return new Error('Malformed OpenSSH private key');\n          const ecpriv = readString(data, data._pos);\n          if (ecpriv === undefined)\n            return new Error('Malformed OpenSSH private key');\n\n          pubPEM = genOpenSSLECDSAPub(oid, ecpub);\n          pubSSH = genOpenSSHECDSAPub(oid, ecpub);\n          privPEM = genOpenSSLECDSAPriv(oid, ecpub, ecpriv);\n          break;\n        }\n        default:\n          return new Error(`Unsupported OpenSSH private key type: ${type}`);\n      }\n\n      const privComment = readString(data, data._pos, true);\n      if (privComment === undefined)\n        return new Error('Malformed OpenSSH private key');\n\n      keys.push(\n        new OpenSSH_Private(type, privComment, privPEM, pubPEM, pubSSH, algo,\n                            decrypted)\n      );\n    }\n    let cnt = 0;\n    for (i = data._pos; i < data.length; ++i) {\n      if (data[i] !== (++cnt % 255))\n        return new Error('Malformed OpenSSH private key');\n    }\n\n    return keys;\n  }\n}\n\n\nfunction OpenSSH_Old_Private(type, comment, privPEM, pubPEM, pubSSH, algo,\n                             decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nOpenSSH_Old_Private.prototype = BaseKey;\n{\n  const regexp = /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\\r\\n|\\n)((?:[^:]+:\\s*[\\S].*(?:\\r\\n|\\n))*)([\\s\\S]+)(?:\\r\\n|\\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;\n  OpenSSH_Old_Private.parse = (str, passphrase) => {\n    const m = regexp.exec(str);\n    if (m === null)\n      return null;\n    let privBlob = Buffer.from(m[3], 'base64');\n    let headers = m[2];\n    let decrypted = false;\n    if (headers !== undefined) {\n      // encrypted key\n      headers = headers.split(/\\r\\n|\\n/g);\n      for (let i = 0; i < headers.length; ++i) {\n        const header = headers[i];\n        let sepIdx = header.indexOf(':');\n        if (header.slice(0, sepIdx) === 'DEK-Info') {\n          const val = header.slice(sepIdx + 2);\n          sepIdx = val.indexOf(',');\n          if (sepIdx === -1)\n            continue;\n          const cipherName = val.slice(0, sepIdx).toLowerCase();\n          if (supportedOpenSSLCiphers.indexOf(cipherName) === -1) {\n            return new Error(\n              `Cipher (${cipherName}) not supported `\n                + 'for encrypted OpenSSH private key'\n            );\n          }\n          const encInfo = CIPHER_INFO_OPENSSL[cipherName];\n          if (!encInfo) {\n            return new Error(\n              `Cipher (${cipherName}) not supported `\n                + 'for encrypted OpenSSH private key'\n            );\n          }\n          const cipherIV = Buffer.from(val.slice(sepIdx + 1), 'hex');\n          if (cipherIV.length !== encInfo.ivLen)\n            return new Error('Malformed encrypted OpenSSH private key');\n          if (!passphrase) {\n            return new Error(\n              'Encrypted OpenSSH private key detected, but no passphrase given'\n            );\n          }\n          const ivSlice = bufferSlice(cipherIV, 0, 8);\n          let cipherKey = createHash('md5')\n                            .update(passphrase)\n                            .update(ivSlice)\n                            .digest();\n          while (cipherKey.length < encInfo.keyLen) {\n            cipherKey = combineBuffers(\n              cipherKey,\n              createHash('md5')\n                .update(cipherKey)\n                .update(passphrase)\n                .update(ivSlice)\n                .digest()\n            );\n          }\n          if (cipherKey.length > encInfo.keyLen)\n            cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);\n          try {\n            const decipher = createDecipheriv(cipherName, cipherKey, cipherIV);\n            decipher.setAutoPadding(false);\n            privBlob = combineBuffers(decipher.update(privBlob),\n                                      decipher.final());\n            decrypted = true;\n          } catch (ex) {\n            return ex;\n          }\n        }\n      }\n    }\n\n    let type;\n    let privPEM;\n    let pubPEM;\n    let pubSSH;\n    let algo;\n    let reader;\n    let errMsg = 'Malformed OpenSSH private key';\n    if (decrypted)\n      errMsg += '. Bad passphrase?';\n    switch (m[1]) {\n      case 'RSA':\n        type = 'ssh-rsa';\n        privPEM = makePEM('RSA PRIVATE', privBlob);\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          const n = reader.readString(Ber.Integer, true);\n          if (n === null)\n            return new Error(errMsg);\n          const e = reader.readString(Ber.Integer, true);\n          if (e === null)\n            return new Error(errMsg);\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n        } catch {\n          return new Error(errMsg);\n        }\n        algo = 'sha1';\n        break;\n      case 'DSA':\n        type = 'ssh-dss';\n        privPEM = makePEM('DSA PRIVATE', privBlob);\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          const p = reader.readString(Ber.Integer, true);\n          if (p === null)\n            return new Error(errMsg);\n          const q = reader.readString(Ber.Integer, true);\n          if (q === null)\n            return new Error(errMsg);\n          const g = reader.readString(Ber.Integer, true);\n          if (g === null)\n            return new Error(errMsg);\n          const y = reader.readString(Ber.Integer, true);\n          if (y === null)\n            return new Error(errMsg);\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        } catch {\n          return new Error(errMsg);\n        }\n        algo = 'sha1';\n        break;\n      case 'EC':\n        let ecSSLName;\n        let ecPriv;\n        let ecOID;\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          ecPriv = reader.readString(Ber.OctetString, true);\n          reader.readByte(); // Skip \"complex\" context type byte\n          const offset = reader.readLength(); // Skip context length\n          if (offset !== null) {\n            reader._offset = offset;\n            ecOID = reader.readOID();\n            if (ecOID === null)\n              return new Error(errMsg);\n            switch (ecOID) {\n              case '1.2.840.10045.3.1.7':\n                // prime256v1/secp256r1\n                ecSSLName = 'prime256v1';\n                type = 'ecdsa-sha2-nistp256';\n                algo = 'sha256';\n                break;\n              case '1.3.132.0.34':\n                // secp384r1\n                ecSSLName = 'secp384r1';\n                type = 'ecdsa-sha2-nistp384';\n                algo = 'sha384';\n                break;\n              case '1.3.132.0.35':\n                // secp521r1\n                ecSSLName = 'secp521r1';\n                type = 'ecdsa-sha2-nistp521';\n                algo = 'sha512';\n                break;\n              default:\n                return new Error(`Unsupported private key EC OID: ${ecOID}`);\n            }\n          } else {\n            return new Error(errMsg);\n          }\n        } catch {\n          return new Error(errMsg);\n        }\n        privPEM = makePEM('EC PRIVATE', privBlob);\n        const pubBlob = genOpenSSLECDSAPubFromPriv(ecSSLName, ecPriv);\n        pubPEM = genOpenSSLECDSAPub(ecOID, pubBlob);\n        pubSSH = genOpenSSHECDSAPub(ecOID, pubBlob);\n        break;\n    }\n\n    return new OpenSSH_Old_Private(type, '', privPEM, pubPEM, pubSSH, algo,\n                                   decrypted);\n  };\n}\n\n\nfunction PPK_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nPPK_Private.prototype = BaseKey;\n{\n  const EMPTY_PASSPHRASE = Buffer.alloc(0);\n  const PPK_IV = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n  const PPK_PP1 = Buffer.from([0, 0, 0, 0]);\n  const PPK_PP2 = Buffer.from([0, 0, 0, 1]);\n  const regexp = /^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\\r?\\nEncryption: (aes256-cbc|none)\\r?\\nComment: ([^\\r\\n]*)\\r?\\nPublic-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-MAC: ([^\\r\\n]+)/;\n  PPK_Private.parse = (str, passphrase) => {\n    const m = regexp.exec(str);\n    if (m === null)\n      return null;\n    // m[1] = key type\n    // m[2] = encryption type\n    // m[3] = comment\n    // m[4] = base64-encoded public key data:\n    //         for \"ssh-rsa\":\n    //          string \"ssh-rsa\"\n    //          mpint  e    (public exponent)\n    //          mpint  n    (modulus)\n    //         for \"ssh-dss\":\n    //          string \"ssh-dss\"\n    //          mpint p     (modulus)\n    //          mpint q     (prime)\n    //          mpint g     (base number)\n    //          mpint y     (public key parameter: g^x mod p)\n    // m[5] = base64-encoded private key data:\n    //         for \"ssh-rsa\":\n    //          mpint  d    (private exponent)\n    //          mpint  p    (prime 1)\n    //          mpint  q    (prime 2)\n    //          mpint  iqmp ([inverse of q] mod p)\n    //         for \"ssh-dss\":\n    //          mpint x     (private key parameter)\n    // m[6] = SHA1 HMAC over:\n    //          string  name of algorithm (\"ssh-dss\", \"ssh-rsa\")\n    //          string  encryption type\n    //          string  comment\n    //          string  public key data\n    //          string  private-plaintext (including the final padding)\n    const cipherName = m[2];\n    const encrypted = (cipherName !== 'none');\n    if (encrypted && !passphrase) {\n      return new Error(\n        'Encrypted PPK private key detected, but no passphrase given'\n      );\n    }\n\n    let privBlob = Buffer.from(m[5], 'base64');\n\n    if (encrypted) {\n      const encInfo = CIPHER_INFO[cipherName];\n      let cipherKey = combineBuffers(\n        createHash('sha1').update(PPK_PP1).update(passphrase).digest(),\n        createHash('sha1').update(PPK_PP2).update(passphrase).digest()\n      );\n      if (cipherKey.length > encInfo.keyLen)\n        cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);\n      try {\n        const decipher = createDecipheriv(encInfo.sslName,\n                                        cipherKey,\n                                        PPK_IV);\n        decipher.setAutoPadding(false);\n        privBlob = combineBuffers(decipher.update(privBlob),\n                                  decipher.final());\n      } catch (ex) {\n        return ex;\n      }\n    }\n\n    const type = m[1];\n    const comment = m[3];\n    const pubBlob = Buffer.from(m[4], 'base64');\n\n    const mac = m[6];\n    const typeLen = type.length;\n    const cipherNameLen = cipherName.length;\n    const commentLen = Buffer.byteLength(comment);\n    const pubLen = pubBlob.length;\n    const privLen = privBlob.length;\n    const macData = Buffer.allocUnsafe(4 + typeLen\n                                       + 4 + cipherNameLen\n                                       + 4 + commentLen\n                                       + 4 + pubLen\n                                       + 4 + privLen);\n    let p = 0;\n\n    writeUInt32BE(macData, typeLen, p);\n    macData.utf8Write(type, p += 4, typeLen);\n    writeUInt32BE(macData, cipherNameLen, p += typeLen);\n    macData.utf8Write(cipherName, p += 4, cipherNameLen);\n    writeUInt32BE(macData, commentLen, p += cipherNameLen);\n    macData.utf8Write(comment, p += 4, commentLen);\n    writeUInt32BE(macData, pubLen, p += commentLen);\n    macData.set(pubBlob, p += 4);\n    writeUInt32BE(macData, privLen, p += pubLen);\n    macData.set(privBlob, p + 4);\n\n    if (!passphrase)\n      passphrase = EMPTY_PASSPHRASE;\n\n    const calcMAC = createHmac(\n      'sha1',\n       createHash('sha1')\n         .update('putty-private-key-file-mac-key')\n         .update(passphrase)\n         .digest()\n    ).update(macData).digest('hex');\n\n    if (calcMAC !== mac) {\n      if (encrypted) {\n        return new Error(\n          'PPK private key integrity check failed -- bad passphrase?'\n        );\n      }\n      return new Error('PPK private key integrity check failed');\n    }\n\n    let pubPEM;\n    let pubSSH;\n    let privPEM;\n    pubBlob._pos = 0;\n    skipFields(pubBlob, 1); // skip (duplicate) key type\n    switch (type) {\n      case 'ssh-rsa': {\n        const e = readString(pubBlob, pubBlob._pos);\n        if (e === undefined)\n          return new Error('Malformed PPK public key');\n        const n = readString(pubBlob, pubBlob._pos);\n        if (n === undefined)\n          return new Error('Malformed PPK public key');\n        const d = readString(privBlob, 0);\n        if (d === undefined)\n          return new Error('Malformed PPK private key');\n        const p = readString(privBlob, privBlob._pos);\n        if (p === undefined)\n          return new Error('Malformed PPK private key');\n        const q = readString(privBlob, privBlob._pos);\n        if (q === undefined)\n          return new Error('Malformed PPK private key');\n        const iqmp = readString(privBlob, privBlob._pos);\n        if (iqmp === undefined)\n          return new Error('Malformed PPK private key');\n        pubPEM = genOpenSSLRSAPub(n, e);\n        pubSSH = genOpenSSHRSAPub(n, e);\n        privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);\n        break;\n      }\n      case 'ssh-dss': {\n        const p = readString(pubBlob, pubBlob._pos);\n        if (p === undefined)\n          return new Error('Malformed PPK public key');\n        const q = readString(pubBlob, pubBlob._pos);\n        if (q === undefined)\n          return new Error('Malformed PPK public key');\n        const g = readString(pubBlob, pubBlob._pos);\n        if (g === undefined)\n          return new Error('Malformed PPK public key');\n        const y = readString(pubBlob, pubBlob._pos);\n        if (y === undefined)\n          return new Error('Malformed PPK public key');\n        const x = readString(privBlob, 0);\n        if (x === undefined)\n          return new Error('Malformed PPK private key');\n\n        pubPEM = genOpenSSLDSAPub(p, q, g, y);\n        pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        privPEM = genOpenSSLDSAPriv(p, q, g, y, x);\n        break;\n      }\n    }\n\n    return new PPK_Private(type, comment, privPEM, pubPEM, pubSSH, 'sha1',\n                           encrypted);\n  };\n}\n\n\nfunction OpenSSH_Public(type, comment, pubPEM, pubSSH, algo) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = null;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = false;\n}\nOpenSSH_Public.prototype = BaseKey;\n{\n  let regexp;\n  if (eddsaSupported)\n    regexp = /^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\\s+([\\S].*)?)$/;\n  else\n    regexp = /^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\\s+([\\S].*)?)$/;\n  OpenSSH_Public.parse = (str) => {\n    const m = regexp.exec(str);\n    if (m === null)\n      return null;\n    // m[1] = full type\n    // m[2] = base type\n    // m[3] = base64-encoded public key\n    // m[4] = comment\n\n    const fullType = m[1];\n    const baseType = m[2];\n    const data = Buffer.from(m[3], 'base64');\n    const comment = (m[4] || '');\n\n    const type = readString(data, data._pos, true);\n    if (type === undefined || type.indexOf(baseType) !== 0)\n      return new Error('Malformed OpenSSH public key');\n\n    return parseDER(data, baseType, comment, fullType);\n  };\n}\n\n\nfunction RFC4716_Public(type, comment, pubPEM, pubSSH, algo) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = null;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = false;\n}\nRFC4716_Public.prototype = BaseKey;\n{\n  const regexp = /^---- BEGIN SSH2 PUBLIC KEY ----(?:\\r?\\n)((?:.{0,72}\\r?\\n)+)---- END SSH2 PUBLIC KEY ----$/;\n  const RE_DATA = /^[A-Z0-9a-z/+=\\r\\n]+$/;\n  const RE_HEADER = /^([\\x21-\\x39\\x3B-\\x7E]{1,64}): ((?:[^\\\\]*\\\\\\r?\\n)*[^\\r\\n]+)\\r?\\n/gm;\n  const RE_HEADER_ENDS = /\\\\\\r?\\n/g;\n  RFC4716_Public.parse = (str) => {\n    let m = regexp.exec(str);\n    if (m === null)\n      return null;\n\n    const body = m[1];\n    let dataStart = 0;\n    let comment = '';\n\n    while (m = RE_HEADER.exec(body)) {\n      const headerName = m[1];\n      const headerValue = m[2].replace(RE_HEADER_ENDS, '');\n      if (headerValue.length > 1024) {\n        RE_HEADER.lastIndex = 0;\n        return new Error('Malformed RFC4716 public key');\n      }\n\n      dataStart = RE_HEADER.lastIndex;\n\n      if (headerName.toLowerCase() === 'comment') {\n        comment = headerValue;\n        if (comment.length > 1\n            && comment.charCodeAt(0) === 34/* '\"' */\n            && comment.charCodeAt(comment.length - 1) === 34/* '\"' */) {\n          comment = comment.slice(1, -1);\n        }\n      }\n    }\n\n    let data = body.slice(dataStart);\n    if (!RE_DATA.test(data))\n      return new Error('Malformed RFC4716 public key');\n\n    data = Buffer.from(data, 'base64');\n\n    const type = readString(data, 0, true);\n    if (type === undefined)\n      return new Error('Malformed RFC4716 public key');\n\n    let pubPEM = null;\n    let pubSSH = null;\n    switch (type) {\n      case 'ssh-rsa': {\n        const e = readString(data, data._pos);\n        if (e === undefined)\n          return new Error('Malformed RFC4716 public key');\n        const n = readString(data, data._pos);\n        if (n === undefined)\n          return new Error('Malformed RFC4716 public key');\n        pubPEM = genOpenSSLRSAPub(n, e);\n        pubSSH = genOpenSSHRSAPub(n, e);\n        break;\n      }\n      case 'ssh-dss': {\n        const p = readString(data, data._pos);\n        if (p === undefined)\n          return new Error('Malformed RFC4716 public key');\n        const q = readString(data, data._pos);\n        if (q === undefined)\n          return new Error('Malformed RFC4716 public key');\n        const g = readString(data, data._pos);\n        if (g === undefined)\n          return new Error('Malformed RFC4716 public key');\n        const y = readString(data, data._pos);\n        if (y === undefined)\n          return new Error('Malformed RFC4716 public key');\n        pubPEM = genOpenSSLDSAPub(p, q, g, y);\n        pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        break;\n      }\n      default:\n        return new Error('Malformed RFC4716 public key');\n    }\n\n    return new RFC4716_Public(type, comment, pubPEM, pubSSH, 'sha1');\n  };\n}\n\n\nfunction parseDER(data, baseType, comment, fullType) {\n  if (!isSupportedKeyType(baseType))\n    return new Error(`Unsupported OpenSSH public key type: ${baseType}`);\n\n  let algo;\n  let oid;\n  let pubPEM = null;\n  let pubSSH = null;\n\n  switch (baseType) {\n    case 'ssh-rsa': {\n      const e = readString(data, data._pos || 0);\n      if (e === undefined)\n        return new Error('Malformed OpenSSH public key');\n      const n = readString(data, data._pos);\n      if (n === undefined)\n        return new Error('Malformed OpenSSH public key');\n      pubPEM = genOpenSSLRSAPub(n, e);\n      pubSSH = genOpenSSHRSAPub(n, e);\n      algo = 'sha1';\n      break;\n    }\n    case 'ssh-dss': {\n      const p = readString(data, data._pos || 0);\n      if (p === undefined)\n        return new Error('Malformed OpenSSH public key');\n      const q = readString(data, data._pos);\n      if (q === undefined)\n        return new Error('Malformed OpenSSH public key');\n      const g = readString(data, data._pos);\n      if (g === undefined)\n        return new Error('Malformed OpenSSH public key');\n      const y = readString(data, data._pos);\n      if (y === undefined)\n        return new Error('Malformed OpenSSH public key');\n      pubPEM = genOpenSSLDSAPub(p, q, g, y);\n      pubSSH = genOpenSSHDSAPub(p, q, g, y);\n      algo = 'sha1';\n      break;\n    }\n    case 'ssh-ed25519': {\n      const edpub = readString(data, data._pos || 0);\n      if (edpub === undefined || edpub.length !== 32)\n        return new Error('Malformed OpenSSH public key');\n      pubPEM = genOpenSSLEdPub(edpub);\n      pubSSH = genOpenSSHEdPub(edpub);\n      algo = null;\n      break;\n    }\n    case 'ecdsa-sha2-nistp256':\n      algo = 'sha256';\n      oid = '1.2.840.10045.3.1.7';\n    // FALLTHROUGH\n    case 'ecdsa-sha2-nistp384':\n      if (algo === undefined) {\n        algo = 'sha384';\n        oid = '1.3.132.0.34';\n      }\n    // FALLTHROUGH\n    case 'ecdsa-sha2-nistp521': {\n      if (algo === undefined) {\n        algo = 'sha512';\n        oid = '1.3.132.0.35';\n      }\n      // TODO: validate curve name against type\n      if (!skipFields(data, 1)) // Skip curve name\n        return new Error('Malformed OpenSSH public key');\n      const ecpub = readString(data, data._pos || 0);\n      if (ecpub === undefined)\n        return new Error('Malformed OpenSSH public key');\n      pubPEM = genOpenSSLECDSAPub(oid, ecpub);\n      pubSSH = genOpenSSHECDSAPub(oid, ecpub);\n      break;\n    }\n    default:\n      return new Error(`Unsupported OpenSSH public key type: ${baseType}`);\n  }\n\n  return new OpenSSH_Public(fullType, comment, pubPEM, pubSSH, algo);\n}\n\nfunction isSupportedKeyType(type) {\n  switch (type) {\n    case 'ssh-rsa':\n    case 'ssh-dss':\n    case 'ecdsa-sha2-nistp256':\n    case 'ecdsa-sha2-nistp384':\n    case 'ecdsa-sha2-nistp521':\n      return true;\n    case 'ssh-ed25519':\n      if (eddsaSupported)\n        return true;\n    // FALLTHROUGH\n    default:\n      return false;\n  }\n}\n\nfunction isParsedKey(val) {\n  if (!val)\n    return false;\n  return (typeof val[SYM_DECRYPTED] === 'boolean');\n}\n\nfunction parseKey(data, passphrase) {\n  if (isParsedKey(data))\n    return data;\n\n  let origBuffer;\n  if (Buffer.isBuffer(data)) {\n    origBuffer = data;\n    data = data.utf8Slice(0, data.length).trim();\n  } else if (typeof data === 'string') {\n    data = data.trim();\n  } else {\n    return new Error('Key data must be a Buffer or string');\n  }\n\n  // eslint-disable-next-line eqeqeq\n  if (passphrase != undefined) {\n    if (typeof passphrase === 'string')\n      passphrase = Buffer.from(passphrase);\n    else if (!Buffer.isBuffer(passphrase))\n      return new Error('Passphrase must be a string or Buffer when supplied');\n  }\n\n  let ret;\n\n  // First try as printable string format (e.g. PEM)\n\n  // Private keys\n  if ((ret = OpenSSH_Private.parse(data, passphrase)) !== null)\n    return ret;\n  if ((ret = OpenSSH_Old_Private.parse(data, passphrase)) !== null)\n    return ret;\n  if ((ret = PPK_Private.parse(data, passphrase)) !== null)\n    return ret;\n\n  // Public keys\n  if ((ret = OpenSSH_Public.parse(data)) !== null)\n    return ret;\n  if ((ret = RFC4716_Public.parse(data)) !== null)\n    return ret;\n\n  // Finally try as a binary format if we were originally passed binary data\n  if (origBuffer) {\n    binaryKeyParser.init(origBuffer, 0);\n    const type = binaryKeyParser.readString(true);\n    if (type !== undefined) {\n      data = binaryKeyParser.readRaw();\n      if (data !== undefined) {\n        ret = parseDER(data, type, '', type);\n        // Ignore potentially useless errors in case the data was not actually\n        // in the binary format\n        if (ret instanceof Error)\n          ret = null;\n      }\n    }\n    binaryKeyParser.clear();\n  }\n\n  if (ret)\n    return ret;\n\n  return new Error('Unsupported key format');\n}\n\nmodule.exports = {\n  isParsedKey,\n  isSupportedKeyType,\n  parseDERKey: (data, type) => parseDER(data, type, '', type),\n  parseKey,\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,MAAM;EACJA,gBADI;EAEJC,UAFI;EAGJC,UAHI;EAIJC,UAJI;EAKJC,UALI;EAMJC,YANI;EAOJC,UAPI;EAQJC,IAAI,EAAEC,KARF;EASJC,MAAM,EAAEC;AATJ,IAUFC,OAAO,CAAC,QAAD,CAVX;;AAWA,MAAMC,uBAAuB,GAAGN,UAAU,EAA1C;;AAEA,MAAM;EAAEO;AAAF,IAAUF,OAAO,CAAC,MAAD,CAAvB;;AACA,MAAMG,YAAY,GAAGH,OAAO,CAAC,cAAD,CAAP,CAAwBI,KAA7C;;AAEA,MAAM;EAAEC;AAAF,IAAkBL,OAAO,CAAC,aAAD,CAA/B;;AACA,MAAM;EAAEM,cAAF;EAAkBC;AAAlB,IAAuCP,OAAO,CAAC,gBAAD,CAApD;;AACA,MAAM;EACJQ,WADI;EAEJC,gBAFI;EAGJC,UAHI;EAIJC,YAJI;EAKJC;AALI,IAMFZ,OAAO,CAAC,YAAD,CANX;;AAQA,MAAMa,aAAa,GAAGC,MAAM,CAAC,gBAAD,CAA5B;AACA,MAAMC,YAAY,GAAGD,MAAM,CAAC,iBAAD,CAA3B;AACA,MAAME,WAAW,GAAGF,MAAM,CAAC,gBAAD,CAA1B;AACA,MAAMG,WAAW,GAAGH,MAAM,CAAC,gBAAD,CAA1B;AACA,MAAMI,aAAa,GAAGJ,MAAM,CAAC,eAAD,CAA5B,C,CAEA;;AACA,MAAMK,mBAAmB,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAA5B;AACA;EACE,MAAMC,IAAI,GAAGF,MAAM,CAACE,IAAP,CAAYjB,WAAZ,CAAb;;EACA,KAAK,IAAIkB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,IAAI,CAACE,MAAzB,EAAiC,EAAED,CAAnC,EAAsC;IACpC,MAAME,UAAU,GAAGpB,WAAW,CAACiB,IAAI,CAACC,CAAD,CAAL,CAAX,CAAqBG,OAAxC;IACA,IAAI,CAACD,UAAD,IAAeN,mBAAmB,CAACM,UAAD,CAAtC,EACE;IACFN,mBAAmB,CAACM,UAAD,CAAnB,GAAkCpB,WAAW,CAACiB,IAAI,CAACC,CAAD,CAAL,CAA7C;EACD;AACF;AAED,MAAMI,eAAe,GAAGlB,gBAAgB,EAAxC;;AAEA,SAASmB,OAAT,CAAiBC,IAAjB,EAAuBC,IAAvB,EAA6B;EAC3BA,IAAI,GAAGA,IAAI,CAACC,WAAL,CAAiB,CAAjB,EAAoBD,IAAI,CAACN,MAAzB,CAAP;EACA,IAAIQ,SAAS,GAAGF,IAAI,CAACG,OAAL,CAAa,QAAb,EAAuB,MAAvB,CAAhB;EACA,IAAIH,IAAI,CAACN,MAAL,GAAc,EAAlB,EACEQ,SAAS,IAAI,IAAb;EACF,OAAQ,cAAaH,IAAK,cAAaG,SAAU,YAAWH,IAAK,WAAjE;AACD;;AAED,SAASK,cAAT,CAAwBC,IAAxB,EAA8BC,IAA9B,EAAoC;EAClC,MAAMC,MAAM,GAAGC,MAAM,CAACC,WAAP,CAAmBJ,IAAI,CAACX,MAAL,GAAcY,IAAI,CAACZ,MAAtC,CAAf;EACAa,MAAM,CAACG,GAAP,CAAWL,IAAX,EAAiB,CAAjB;EACAE,MAAM,CAACG,GAAP,CAAWJ,IAAX,EAAiBD,IAAI,CAACX,MAAtB;EACA,OAAOa,MAAP;AACD;;AAED,SAASI,UAAT,CAAoBC,GAApB,EAAyBC,OAAzB,EAAkC;EAChC,MAAMC,MAAM,GAAGF,GAAG,CAAClB,MAAnB;EACA,IAAIqB,GAAG,GAAIH,GAAG,CAACI,IAAJ,IAAY,CAAvB;;EACA,KAAK,IAAIvB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoB,OAApB,EAA6B,EAAEpB,CAA/B,EAAkC;IAChC,MAAMwB,IAAI,GAAIH,MAAM,GAAGC,GAAvB;IACA,IAAIA,GAAG,IAAID,MAAP,IAAiBG,IAAI,GAAG,CAA5B,EACE,OAAO,KAAP;IACF,MAAMC,GAAG,GAAGrC,YAAY,CAAC+B,GAAD,EAAMG,GAAN,CAAxB;IACA,IAAIE,IAAI,GAAG,IAAIC,GAAf,EACE,OAAO,KAAP;IACFH,GAAG,IAAI,IAAIG,GAAX;EACD;;EACDN,GAAG,CAACI,IAAJ,GAAWD,GAAX;EACA,OAAO,IAAP;AACD;;AAED,SAASI,gBAAT,CAA0BC,CAA1B,EAA6BC,CAA7B,EAAgC;EAC9B,MAAMC,SAAS,GAAG,IAAIlD,GAAG,CAACmD,MAAR,EAAlB;EACAD,SAAS,CAACE,aAAV,GAF8B,CAG5B;;EACAF,SAAS,CAACE,aAAV;EACEF,SAAS,CAACG,QAAV,CAAmB,sBAAnB,EAL0B,CAKkB;EAC5C;;EACAH,SAAS,CAACI,SAAV;EACFJ,SAAS,CAACK,WAAV,GAR4B,CAU5B;;EACAL,SAAS,CAACE,aAAV,CAAwBpD,GAAG,CAACwD,SAA5B;EACEN,SAAS,CAACO,SAAV,CAAoB,IAApB;EACAP,SAAS,CAACE,aAAV;EACEF,SAAS,CAACQ,WAAV,CAAsBV,CAAtB,EAAyBhD,GAAG,CAAC2D,OAA7B;EACAT,SAAS,CAACQ,WAAV,CAAsBT,CAAtB,EAAyBjD,GAAG,CAAC2D,OAA7B;EACFT,SAAS,CAACK,WAAV;EACFL,SAAS,CAACK,WAAV;EACFL,SAAS,CAACK,WAAV;EACA,OAAO7B,OAAO,CAAC,QAAD,EAAWwB,SAAS,CAACU,MAArB,CAAd;AACD;;AAED,SAASC,gBAAT,CAA0Bb,CAA1B,EAA6BC,CAA7B,EAAgC;EAC9B,MAAMa,SAAS,GAAG1B,MAAM,CAACC,WAAP,CAAmB,IAAI,CAAJ,GAAQ,CAAR,GAAYY,CAAC,CAAC3B,MAAd,GAAuB,CAAvB,GAA2B0B,CAAC,CAAC1B,MAAhD,CAAlB;EAEAZ,aAAa,CAACoD,SAAD,EAAY,CAAZ,EAAe,CAAf,CAAb;EACAA,SAAS,CAACC,SAAV,CAAoB,SAApB,EAA+B,CAA/B,EAAkC,CAAlC;EAEA,IAAI1C,CAAC,GAAG,IAAI,CAAZ;EACAX,aAAa,CAACoD,SAAD,EAAYb,CAAC,CAAC3B,MAAd,EAAsBD,CAAtB,CAAb;EACAyC,SAAS,CAACxB,GAAV,CAAcW,CAAd,EAAiB5B,CAAC,IAAI,CAAtB;EAEAX,aAAa,CAACoD,SAAD,EAAYd,CAAC,CAAC1B,MAAd,EAAsBD,CAAC,IAAI4B,CAAC,CAAC3B,MAA7B,CAAb;EACAwC,SAAS,CAACxB,GAAV,CAAcU,CAAd,EAAiB3B,CAAC,GAAG,CAArB;EAEA,OAAOyC,SAAP;AACD;;AAED,MAAME,iBAAiB,GAAG,CAAC,MAAM;EAC/B,SAASC,aAAT,CAAuBjB,CAAvB,EAA0BC,CAA1B,EAA6BiB,CAA7B,EAAgCC,CAAhC,EAAmCC,CAAnC,EAAsCC,IAAtC,EAA4CC,IAA5C,EAAkDC,IAAlD,EAAwD;IACtD,MAAMrB,SAAS,GAAG,IAAIlD,GAAG,CAACmD,MAAR,EAAlB;IACAD,SAAS,CAACE,aAAV;IACEF,SAAS,CAACsB,QAAV,CAAmB,IAAnB,EAAyBxE,GAAG,CAAC2D,OAA7B;IACAT,SAAS,CAACQ,WAAV,CAAsBV,CAAtB,EAAyBhD,GAAG,CAAC2D,OAA7B;IACAT,SAAS,CAACQ,WAAV,CAAsBT,CAAtB,EAAyBjD,GAAG,CAAC2D,OAA7B;IACAT,SAAS,CAACQ,WAAV,CAAsBQ,CAAtB,EAAyBlE,GAAG,CAAC2D,OAA7B;IACAT,SAAS,CAACQ,WAAV,CAAsBS,CAAtB,EAAyBnE,GAAG,CAAC2D,OAA7B;IACAT,SAAS,CAACQ,WAAV,CAAsBU,CAAtB,EAAyBpE,GAAG,CAAC2D,OAA7B;IACAT,SAAS,CAACQ,WAAV,CAAsBW,IAAtB,EAA4BrE,GAAG,CAAC2D,OAAhC;IACAT,SAAS,CAACQ,WAAV,CAAsBY,IAAtB,EAA4BtE,GAAG,CAAC2D,OAAhC;IACAT,SAAS,CAACQ,WAAV,CAAsBa,IAAtB,EAA4BvE,GAAG,CAAC2D,OAAhC;IACFT,SAAS,CAACK,WAAV;IACA,OAAOL,SAAS,CAACU,MAAjB;EACD;;EAED,SAASa,gBAAT,CAA0BjC,GAA1B,EAA+B;IAC7B,OAAOkC,MAAM,CAAE,KAAIlC,GAAG,CAACmC,QAAJ,CAAa,CAAb,EAAgBnC,GAAG,CAAClB,MAApB,CAA4B,EAAlC,CAAb;EACD;;EAED,SAASsD,cAAT,CAAwBC,EAAxB,EAA4B;IAC1B,IAAIC,GAAG,GAAGD,EAAE,CAACE,QAAH,CAAY,EAAZ,CAAV;;IACA,IAAI,CAACD,GAAG,CAACxD,MAAJ,GAAa,CAAd,MAAqB,CAAzB,EAA4B;MAC1BwD,GAAG,GAAI,IAAGA,GAAI,EAAd;IACD,CAFD,MAEO;MACL,MAAME,MAAM,GAAGF,GAAG,CAACG,UAAJ,CAAe,CAAf,CAAf,CADK,CAEL;MACA;;MACA,IAAID,MAAM,KAAK;MAAE;MAAb,GACGA,MAAM,KAAK;MAAE;MADhB,GAEIA,MAAM,IAAI;MAAE;MAAZ,GAAyBA,MAAM,IAAI;MAAG;MAF9C,EAE0D;QACxDF,GAAG,GAAI,KAAIA,GAAI,EAAf;MACD;IACF;;IACD,OAAO1C,MAAM,CAAC8C,IAAP,CAAYJ,GAAZ,EAAiB,KAAjB,CAAP;EACD;;EAED,OAAO,SAASd,iBAAT,CAA2BhB,CAA3B,EAA8BC,CAA9B,EAAiCiB,CAAjC,EAAoCK,IAApC,EAA0CJ,CAA1C,EAA6CC,CAA7C,EAAgD;IACrD,MAAMe,IAAI,GAAGV,gBAAgB,CAACP,CAAD,CAA7B;IACA,MAAMG,IAAI,GAAGO,cAAc,CAACO,IAAI,IAAIV,gBAAgB,CAACN,CAAD,CAAhB,GAAsB,EAA1B,CAAL,CAA3B;IACA,MAAMG,IAAI,GAAGM,cAAc,CAACO,IAAI,IAAIV,gBAAgB,CAACL,CAAD,CAAhB,GAAsB,EAA1B,CAAL,CAA3B;IACA,OAAO1C,OAAO,CAAC,aAAD,EACCuC,aAAa,CAACjB,CAAD,EAAIC,CAAJ,EAAOiB,CAAP,EAAUC,CAAV,EAAaC,CAAb,EAAgBC,IAAhB,EAAsBC,IAAtB,EAA4BC,IAA5B,CADd,CAAd;EAED,CAND;AAOD,CA7CyB,GAA1B;;AA+CA,SAASa,gBAAT,CAA0BjB,CAA1B,EAA6BC,CAA7B,EAAgCiB,CAAhC,EAAmCC,CAAnC,EAAsC;EACpC,MAAMpC,SAAS,GAAG,IAAIlD,GAAG,CAACmD,MAAR,EAAlB;EACAD,SAAS,CAACE,aAAV,GAFoC,CAGlC;;EACAF,SAAS,CAACE,aAAV;EACEF,SAAS,CAACG,QAAV,CAAmB,mBAAnB,EALgC,CAKS;EACzC;;EACAH,SAAS,CAACE,aAAV;EACEF,SAAS,CAACQ,WAAV,CAAsBS,CAAtB,EAAyBnE,GAAG,CAAC2D,OAA7B;EACAT,SAAS,CAACQ,WAAV,CAAsBU,CAAtB,EAAyBpE,GAAG,CAAC2D,OAA7B;EACAT,SAAS,CAACQ,WAAV,CAAsB2B,CAAtB,EAAyBrF,GAAG,CAAC2D,OAA7B;EACFT,SAAS,CAACK,WAAV;EACFL,SAAS,CAACK,WAAV,GAZkC,CAclC;;EACAL,SAAS,CAACE,aAAV,CAAwBpD,GAAG,CAACwD,SAA5B;EACEN,SAAS,CAACO,SAAV,CAAoB,IAApB;EACAP,SAAS,CAACQ,WAAV,CAAsB4B,CAAtB,EAAyBtF,GAAG,CAAC2D,OAA7B;EACFT,SAAS,CAACK,WAAV;EACFL,SAAS,CAACK,WAAV;EACA,OAAO7B,OAAO,CAAC,QAAD,EAAWwB,SAAS,CAACU,MAArB,CAAd;AACD;;AAED,SAAS2B,gBAAT,CAA0BpB,CAA1B,EAA6BC,CAA7B,EAAgCiB,CAAhC,EAAmCC,CAAnC,EAAsC;EACpC,MAAMxB,SAAS,GAAG1B,MAAM,CAACC,WAAP,CAChB,IAAI,CAAJ,GAAQ,CAAR,GAAY8B,CAAC,CAAC7C,MAAd,GAAuB,CAAvB,GAA2B8C,CAAC,CAAC9C,MAA7B,GAAsC,CAAtC,GAA0C+D,CAAC,CAAC/D,MAA5C,GAAqD,CAArD,GAAyDgE,CAAC,CAAChE,MAD3C,CAAlB;EAIAZ,aAAa,CAACoD,SAAD,EAAY,CAAZ,EAAe,CAAf,CAAb;EACAA,SAAS,CAACC,SAAV,CAAoB,SAApB,EAA+B,CAA/B,EAAkC,CAAlC;EAEA,IAAI1C,CAAC,GAAG,IAAI,CAAZ;EACAX,aAAa,CAACoD,SAAD,EAAYK,CAAC,CAAC7C,MAAd,EAAsBD,CAAtB,CAAb;EACAyC,SAAS,CAACxB,GAAV,CAAc6B,CAAd,EAAiB9C,CAAC,IAAI,CAAtB;EAEAX,aAAa,CAACoD,SAAD,EAAYM,CAAC,CAAC9C,MAAd,EAAsBD,CAAC,IAAI8C,CAAC,CAAC7C,MAA7B,CAAb;EACAwC,SAAS,CAACxB,GAAV,CAAc8B,CAAd,EAAiB/C,CAAC,IAAI,CAAtB;EAEAX,aAAa,CAACoD,SAAD,EAAYuB,CAAC,CAAC/D,MAAd,EAAsBD,CAAC,IAAI+C,CAAC,CAAC9C,MAA7B,CAAb;EACAwC,SAAS,CAACxB,GAAV,CAAc+C,CAAd,EAAiBhE,CAAC,IAAI,CAAtB;EAEAX,aAAa,CAACoD,SAAD,EAAYwB,CAAC,CAAChE,MAAd,EAAsBD,CAAC,IAAIgE,CAAC,CAAC/D,MAA7B,CAAb;EACAwC,SAAS,CAACxB,GAAV,CAAcgD,CAAd,EAAiBjE,CAAC,GAAG,CAArB;EAEA,OAAOyC,SAAP;AACD;;AAED,SAAS0B,iBAAT,CAA2BrB,CAA3B,EAA8BC,CAA9B,EAAiCiB,CAAjC,EAAoCC,CAApC,EAAuCG,CAAvC,EAA0C;EACxC,MAAMvC,SAAS,GAAG,IAAIlD,GAAG,CAACmD,MAAR,EAAlB;EACAD,SAAS,CAACE,aAAV;EACEF,SAAS,CAACsB,QAAV,CAAmB,IAAnB,EAAyBxE,GAAG,CAAC2D,OAA7B;EACAT,SAAS,CAACQ,WAAV,CAAsBS,CAAtB,EAAyBnE,GAAG,CAAC2D,OAA7B;EACAT,SAAS,CAACQ,WAAV,CAAsBU,CAAtB,EAAyBpE,GAAG,CAAC2D,OAA7B;EACAT,SAAS,CAACQ,WAAV,CAAsB2B,CAAtB,EAAyBrF,GAAG,CAAC2D,OAA7B;EACAT,SAAS,CAACQ,WAAV,CAAsB4B,CAAtB,EAAyBtF,GAAG,CAAC2D,OAA7B;EACAT,SAAS,CAACQ,WAAV,CAAsB+B,CAAtB,EAAyBzF,GAAG,CAAC2D,OAA7B;EACFT,SAAS,CAACK,WAAV;EACA,OAAO7B,OAAO,CAAC,aAAD,EAAgBwB,SAAS,CAACU,MAA1B,CAAd;AACD;;AAED,SAAS8B,eAAT,CAAyBC,GAAzB,EAA8B;EAC5B,MAAMzC,SAAS,GAAG,IAAIlD,GAAG,CAACmD,MAAR,EAAlB;EACAD,SAAS,CAACE,aAAV,GAF4B,CAG1B;;EACAF,SAAS,CAACE,aAAV;EACEF,SAAS,CAACG,QAAV,CAAmB,aAAnB,EALwB,CAKW;;EACrCH,SAAS,CAACK,WAAV,GAN0B,CAQ1B;;EACAL,SAAS,CAACE,aAAV,CAAwBpD,GAAG,CAACwD,SAA5B;EACEN,SAAS,CAACO,SAAV,CAAoB,IAApB,EAVwB,CAWxB;;EACAP,SAAS,CAAC0C,OAAV,CAAkBD,GAAG,CAACrE,MAAtB;;EACA4B,SAAS,CAAC2C,IAAV,CAAevD,GAAf,CAAmBqD,GAAnB,EAAwBzC,SAAS,CAAC4C,OAAlC;;EACA5C,SAAS,CAAC4C,OAAV,IAAqBH,GAAG,CAACrE,MAAzB;EACF4B,SAAS,CAACK,WAAV;EACFL,SAAS,CAACK,WAAV;EACA,OAAO7B,OAAO,CAAC,QAAD,EAAWwB,SAAS,CAACU,MAArB,CAAd;AACD;;AAED,SAASmC,eAAT,CAAyBJ,GAAzB,EAA8B;EAC5B,MAAM7B,SAAS,GAAG1B,MAAM,CAACC,WAAP,CAAmB,IAAI,EAAJ,GAAS,CAAT,GAAasD,GAAG,CAACrE,MAApC,CAAlB;EAEAZ,aAAa,CAACoD,SAAD,EAAY,EAAZ,EAAgB,CAAhB,CAAb;EACAA,SAAS,CAACC,SAAV,CAAoB,aAApB,EAAmC,CAAnC,EAAsC,EAAtC;EAEArD,aAAa,CAACoD,SAAD,EAAY6B,GAAG,CAACrE,MAAhB,EAAwB,EAAxB,CAAb;EACAwC,SAAS,CAACxB,GAAV,CAAcqD,GAAd,EAAmB,EAAnB;EAEA,OAAO7B,SAAP;AACD;;AAED,SAASkC,gBAAT,CAA0BC,IAA1B,EAAgC;EAC9B,MAAM/C,SAAS,GAAG,IAAIlD,GAAG,CAACmD,MAAR,EAAlB;EACAD,SAAS,CAACE,aAAV,GAF8B,CAG5B;;EACAF,SAAS,CAACsB,QAAV,CAAmB,IAAnB,EAAyBxE,GAAG,CAAC2D,OAA7B,EAJ4B,CAM5B;;EACAT,SAAS,CAACE,aAAV;EACEF,SAAS,CAACG,QAAV,CAAmB,aAAnB,EAR0B,CAQS;;EACrCH,SAAS,CAACK,WAAV,GAT4B,CAW5B;;EACAL,SAAS,CAACE,aAAV,CAAwBpD,GAAG,CAACkG,WAA5B;EACEhD,SAAS,CAACQ,WAAV,CAAsBuC,IAAtB,EAA4BjG,GAAG,CAACkG,WAAhC;EACFhD,SAAS,CAACK,WAAV;EACFL,SAAS,CAACK,WAAV;EACA,OAAO7B,OAAO,CAAC,SAAD,EAAYwB,SAAS,CAACU,MAAtB,CAAd;AACD;;AAED,SAASuC,kBAAT,CAA4BC,GAA5B,EAAiCC,CAAjC,EAAoC;EAClC,MAAMnD,SAAS,GAAG,IAAIlD,GAAG,CAACmD,MAAR,EAAlB;EACAD,SAAS,CAACE,aAAV,GAFkC,CAGhC;;EACAF,SAAS,CAACE,aAAV;EACEF,SAAS,CAACG,QAAV,CAAmB,mBAAnB,EAL8B,CAKW;EACzC;;EACAH,SAAS,CAACG,QAAV,CAAmB+C,GAAnB;EACFlD,SAAS,CAACK,WAAV,GARgC,CAUhC;;EACAL,SAAS,CAACE,aAAV,CAAwBpD,GAAG,CAACwD,SAA5B;EACEN,SAAS,CAACO,SAAV,CAAoB,IAApB,EAZ8B,CAa9B;;EACAP,SAAS,CAAC0C,OAAV,CAAkBS,CAAC,CAAC/E,MAApB;;EACA4B,SAAS,CAAC2C,IAAV,CAAevD,GAAf,CAAmB+D,CAAnB,EAAsBnD,SAAS,CAAC4C,OAAhC;;EACA5C,SAAS,CAAC4C,OAAV,IAAqBO,CAAC,CAAC/E,MAAvB,CAhB8B,CAiB9B;;EACF4B,SAAS,CAACK,WAAV;EACFL,SAAS,CAACK,WAAV;EACA,OAAO7B,OAAO,CAAC,QAAD,EAAWwB,SAAS,CAACU,MAArB,CAAd;AACD;;AAED,SAAS0C,kBAAT,CAA4BF,GAA5B,EAAiCC,CAAjC,EAAoC;EAClC,IAAIE,SAAJ;;EACA,QAAQH,GAAR;IACE,KAAK,qBAAL;MACE;MACAG,SAAS,GAAG,UAAZ;MACA;;IACF,KAAK,cAAL;MACE;MACAA,SAAS,GAAG,UAAZ;MACA;;IACF,KAAK,cAAL;MACE;MACAA,SAAS,GAAG,UAAZ;MACA;;IACF;MACE;EAdJ;;EAiBA,MAAMzC,SAAS,GAAG1B,MAAM,CAACC,WAAP,CAAmB,IAAI,EAAJ,GAAS,CAAT,GAAa,CAAb,GAAiB,CAAjB,GAAqBgE,CAAC,CAAC/E,MAA1C,CAAlB;EAEAZ,aAAa,CAACoD,SAAD,EAAY,EAAZ,EAAgB,CAAhB,CAAb;EACAA,SAAS,CAACC,SAAV,CAAqB,cAAawC,SAAU,EAA5C,EAA+C,CAA/C,EAAkD,EAAlD;EAEA7F,aAAa,CAACoD,SAAD,EAAY,CAAZ,EAAe,EAAf,CAAb;EACAA,SAAS,CAACC,SAAV,CAAoBwC,SAApB,EAA+B,EAA/B,EAAmC,CAAnC;EAEA7F,aAAa,CAACoD,SAAD,EAAYuC,CAAC,CAAC/E,MAAd,EAAsB,EAAtB,CAAb;EACAwC,SAAS,CAACxB,GAAV,CAAc+D,CAAd,EAAiB,EAAjB;EAEA,OAAOvC,SAAP;AACD;;AAED,SAAS0C,mBAAT,CAA6BJ,GAA7B,EAAkCT,GAAlC,EAAuCM,IAAvC,EAA6C;EAC3C,MAAM/C,SAAS,GAAG,IAAIlD,GAAG,CAACmD,MAAR,EAAlB;EACAD,SAAS,CAACE,aAAV,GAF2C,CAGzC;;EACAF,SAAS,CAACsB,QAAV,CAAmB,IAAnB,EAAyBxE,GAAG,CAAC2D,OAA7B,EAJyC,CAKzC;;EACAT,SAAS,CAACQ,WAAV,CAAsBuC,IAAtB,EAA4BjG,GAAG,CAACkG,WAAhC,EANyC,CAOzC;;EACAhD,SAAS,CAACE,aAAV,CAAwB,IAAxB;EACEF,SAAS,CAACG,QAAV,CAAmB+C,GAAnB;EACFlD,SAAS,CAACK,WAAV,GAVyC,CAWzC;;EACAL,SAAS,CAACE,aAAV,CAAwB,IAAxB;EACEF,SAAS,CAACE,aAAV,CAAwBpD,GAAG,CAACwD,SAA5B;EACEN,SAAS,CAACO,SAAV,CAAoB,IAApB,EAdqC,CAerC;;EACAP,SAAS,CAAC0C,OAAV,CAAkBD,GAAG,CAACrE,MAAtB;;EACA4B,SAAS,CAAC2C,IAAV,CAAevD,GAAf,CAAmBqD,GAAnB,EAAwBzC,SAAS,CAAC4C,OAAlC;;EACA5C,SAAS,CAAC4C,OAAV,IAAqBH,GAAG,CAACrE,MAAzB,CAlBqC,CAmBrC;;EACF4B,SAAS,CAACK,WAAV;EACFL,SAAS,CAACK,WAAV;EACFL,SAAS,CAACK,WAAV;EACA,OAAO7B,OAAO,CAAC,YAAD,EAAewB,SAAS,CAACU,MAAzB,CAAd;AACD;;AAED,SAAS6C,0BAAT,CAAoCF,SAApC,EAA+CN,IAA/C,EAAqD;EACnD,MAAMS,QAAQ,GAAGtH,UAAU,CAACmH,SAAD,CAA3B;EACAG,QAAQ,CAACC,aAAT,CAAuBV,IAAvB;EACA,OAAOS,QAAQ,CAACE,YAAT,EAAP;AACD;;AAED,MAAMC,OAAO,GAAG;EACdnH,IAAI,EAAE,CAAC,MAAM;IACX,IAAI,OAAOC,KAAP,KAAiB,UAArB,EAAiC;MAC/B,OAAO,SAASD,IAAT,CAAckC,IAAd,EAAoBkF,IAApB,EAA0B;QAC/B,MAAMC,GAAG,GAAG,KAAKlG,YAAL,CAAZ;QACA,IAAIkG,GAAG,KAAK,IAAZ,EACE,OAAO,IAAIC,KAAJ,CAAU,0BAAV,CAAP;QACF,IAAI,CAACF,IAAD,IAAS,OAAOA,IAAP,KAAgB,QAA7B,EACEA,IAAI,GAAG,KAAKnG,aAAL,CAAP;;QACF,IAAI;UACF,OAAOhB,KAAK,CAACmH,IAAD,EAAOlF,IAAP,EAAamF,GAAb,CAAZ;QACD,CAFD,CAEE,OAAOE,EAAP,EAAW;UACX,OAAOA,EAAP;QACD;MACF,CAXD;IAYD;;IACD,OAAO,SAASvH,IAAT,CAAckC,IAAd,EAAoBkF,IAApB,EAA0B;MAC/B,MAAMC,GAAG,GAAG,KAAKlG,YAAL,CAAZ;MACA,IAAIkG,GAAG,KAAK,IAAZ,EACE,OAAO,IAAIC,KAAJ,CAAU,0BAAV,CAAP;MACF,IAAI,CAACF,IAAD,IAAS,OAAOA,IAAP,KAAgB,QAA7B,EACEA,IAAI,GAAG,KAAKnG,aAAL,CAAP;MACF,MAAMuG,SAAS,GAAG3H,UAAU,CAACuH,IAAD,CAA5B;MACAI,SAAS,CAACC,MAAV,CAAiBvF,IAAjB;;MACA,IAAI;QACF,OAAOsF,SAAS,CAACxH,IAAV,CAAeqH,GAAf,CAAP;MACD,CAFD,CAEE,OAAOE,EAAP,EAAW;QACX,OAAOA,EAAP;MACD;IACF,CAbD;EAcD,CA7BK,GADQ;EA+BdrH,MAAM,EAAE,CAAC,MAAM;IACb,IAAI,OAAOC,OAAP,KAAmB,UAAvB,EAAmC;MACjC,OAAO,SAASD,MAAT,CAAgBgC,IAAhB,EAAsBsF,SAAtB,EAAiCJ,IAAjC,EAAuC;QAC5C,MAAMC,GAAG,GAAG,KAAKjG,WAAL,CAAZ;QACA,IAAIiG,GAAG,KAAK,IAAZ,EACE,OAAO,IAAIC,KAAJ,CAAU,yBAAV,CAAP;QACF,IAAI,CAACF,IAAD,IAAS,OAAOA,IAAP,KAAgB,QAA7B,EACEA,IAAI,GAAG,KAAKnG,aAAL,CAAP;;QACF,IAAI;UACF,OAAOd,OAAO,CAACiH,IAAD,EAAOlF,IAAP,EAAamF,GAAb,EAAkBG,SAAlB,CAAd;QACD,CAFD,CAEE,OAAOD,EAAP,EAAW;UACX,OAAOA,EAAP;QACD;MACF,CAXD;IAYD;;IACD,OAAO,SAASrH,MAAT,CAAgBgC,IAAhB,EAAsBsF,SAAtB,EAAiCJ,IAAjC,EAAuC;MAC5C,MAAMC,GAAG,GAAG,KAAKjG,WAAL,CAAZ;MACA,IAAIiG,GAAG,KAAK,IAAZ,EACE,OAAO,IAAIC,KAAJ,CAAU,yBAAV,CAAP;MACF,IAAI,CAACF,IAAD,IAAS,OAAOA,IAAP,KAAgB,QAA7B,EACEA,IAAI,GAAG,KAAKnG,aAAL,CAAP;MACF,MAAMyG,QAAQ,GAAG5H,YAAY,CAACsH,IAAD,CAA7B;MACAM,QAAQ,CAACD,MAAT,CAAgBvF,IAAhB;;MACA,IAAI;QACF,OAAOwF,QAAQ,CAACxH,MAAT,CAAgBmH,GAAhB,EAAqBG,SAArB,CAAP;MACD,CAFD,CAEE,OAAOD,EAAP,EAAW;QACX,OAAOA,EAAP;MACD;IACF,CAbD;EAcD,CA7BO,GA/BM;EA6DdI,YAAY,EAAE,SAASA,YAAT,GAAwB;IACpC,OAAQ,KAAKxG,YAAL,MAAuB,IAA/B;EACD,CA/Da;EAgEdyG,aAAa,EAAE,SAASA,aAAT,GAAyB;IACtC,OAAO,KAAKzG,YAAL,CAAP;EACD,CAlEa;EAmEd0G,YAAY,EAAE,SAASA,YAAT,GAAwB;IACpC,OAAO,KAAKzG,WAAL,CAAP;EACD,CArEa;EAsEd0G,YAAY,EAAE,SAASA,YAAT,GAAwB;IACpC,OAAO,KAAKzG,WAAL,CAAP;EACD,CAxEa;EAyEd0G,MAAM,EAAE,SAASA,MAAT,CAAgBC,GAAhB,EAAqB;IAC3B,MAAMC,MAAM,GAAGC,QAAQ,CAACF,GAAD,CAAvB;IACA,IAAIC,MAAM,YAAYX,KAAtB,EACE,OAAO,KAAP;IACF,OACE,KAAKrF,IAAL,KAAcgG,MAAM,CAAChG,IAArB,IACG,KAAKd,YAAL,MAAuB8G,MAAM,CAAC9G,YAAD,CADhC,IAEG,KAAKC,WAAL,MAAsB6G,MAAM,CAAC7G,WAAD,CAF/B,IAGG,KAAKC,WAAL,MAAsB4G,MAAM,CAAC5G,WAAD,CAJjC;EAMD;AAnFa,CAAhB;;AAuFA,SAAS8G,eAAT,CAAyBlG,IAAzB,EAA+BmG,OAA/B,EAAwCC,OAAxC,EAAiDC,MAAjD,EAAyDC,MAAzD,EAAiEnB,IAAjE,EACyBoB,SADzB,EACoC;EAClC,KAAKvG,IAAL,GAAYA,IAAZ;EACA,KAAKmG,OAAL,GAAeA,OAAf;EACA,KAAKjH,YAAL,IAAqBkH,OAArB;EACA,KAAKjH,WAAL,IAAoBkH,MAApB;EACA,KAAKjH,WAAL,IAAoBkH,MAApB;EACA,KAAKtH,aAAL,IAAsBmG,IAAtB;EACA,KAAK9F,aAAL,IAAsBkH,SAAtB;AACD;;AACDL,eAAe,CAACM,SAAhB,GAA4BtB,OAA5B;AACA;EACE,MAAMuB,MAAM,GAAG,uGAAf;;EACAP,eAAe,CAACQ,KAAhB,GAAwB,CAACC,GAAD,EAAMC,UAAN,KAAqB;IAC3C,MAAMC,CAAC,GAAGJ,MAAM,CAACK,IAAP,CAAYH,GAAZ,CAAV;IACA,IAAIE,CAAC,KAAK,IAAV,EACE,OAAO,IAAP;IACF,IAAIE,GAAJ;IACA,MAAM9G,IAAI,GAAGQ,MAAM,CAAC8C,IAAP,CAAYsD,CAAC,CAAC,CAAD,CAAb,EAAkB,QAAlB,CAAb;IACA,IAAI5G,IAAI,CAACN,MAAL,GAAc,EAAlB,EAAsB;MACpB,OAAO,IAAI0F,KAAJ,CAAU,+BAAV,CAAP;IACF,MAAM2B,KAAK,GAAG/G,IAAI,CAACgH,SAAL,CAAe,CAAf,EAAkB,EAAlB,CAAd;IACA,IAAID,KAAK,KAAK,kBAAd,EACE,OAAO,IAAI3B,KAAJ,CAAW,kCAAiC2B,KAAM,EAAlD,CAAP;IAEF,MAAMpH,UAAU,GAAGf,UAAU,CAACoB,IAAD,EAAO,EAAP,EAAW,IAAX,CAA7B;IACA,IAAIL,UAAU,KAAKsH,SAAnB,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;IACF,IAAIzF,UAAU,KAAK,MAAf,IAAyBlB,gBAAgB,CAACyI,OAAjB,CAAyBvH,UAAzB,MAAyC,CAAC,CAAvE,EACE,OAAO,IAAIyF,KAAJ,CAAW,uCAAsCzF,UAAW,EAA5D,CAAP;IAEF,MAAMwH,OAAO,GAAGvI,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,EAAkB,IAAlB,CAA1B;IACA,IAAImG,OAAO,KAAKF,SAAhB,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;;IACF,IAAI+B,OAAO,KAAK,MAAhB,EAAwB;MACtB,IAAIxH,UAAU,KAAK,MAAnB,EACE,OAAO,IAAIyF,KAAJ,CAAU,+BAAV,CAAP;MACF,IAAI+B,OAAO,KAAK,QAAhB,EACE,OAAO,IAAI/B,KAAJ,CAAW,yCAAwC+B,OAAQ,EAA3D,CAAP;;MACF,IAAI,CAACR,UAAL,EAAiB;QACf,OAAO,IAAIvB,KAAJ,CACL,iEADK,CAAP;MAGD;IACF,CAVD,MAUO,IAAIzF,UAAU,KAAK,MAAnB,EAA2B;MAChC,OAAO,IAAIyF,KAAJ,CAAU,+BAAV,CAAP;IACD;;IAED,IAAIgC,OAAJ;IACA,IAAIC,SAAJ;IACA,IAAIC,QAAJ;IACA,IAAI3H,UAAU,KAAK,MAAnB,EACEyH,OAAO,GAAG7I,WAAW,CAACoB,UAAD,CAArB;IACF,MAAM4H,UAAU,GAAG3I,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAA7B;IACA,IAAIuG,UAAU,KAAKN,SAAnB,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;;IACF,IAAImC,UAAU,CAAC7H,MAAf,EAAuB;MACrB,QAAQyH,OAAR;QACE,KAAK,MAAL;UACE,OAAO,IAAI/B,KAAJ,CAAU,+BAAV,CAAP;;QACF,KAAK,QAAL;UACE;AACV;AACA;AACA;UACU,MAAMoC,IAAI,GAAG5I,UAAU,CAAC2I,UAAD,EAAa,CAAb,CAAvB;UACA,IAAIC,IAAI,KAAKP,SAAT,IAAsBM,UAAU,CAACvG,IAAX,GAAkB,CAAlB,GAAsBuG,UAAU,CAAC7H,MAA3D,EACE,OAAO,IAAI0F,KAAJ,CAAU,+BAAV,CAAP;UACF,MAAMqC,MAAM,GAAG5I,YAAY,CAAC0I,UAAD,EAAaA,UAAU,CAACvG,IAAxB,CAA3B;UACA,MAAM0G,GAAG,GAAGlH,MAAM,CAACC,WAAP,CAAmB2G,OAAO,CAACO,MAAR,GAAiBP,OAAO,CAACQ,KAA5C,CAAZ;UACA,MAAMC,CAAC,GAAGxJ,YAAY,CAACsI,UAAD,EACCA,UAAU,CAACjH,MADZ,EAEC8H,IAFD,EAGCA,IAAI,CAAC9H,MAHN,EAICgI,GAJD,EAKCA,GAAG,CAAChI,MALL,EAMC+H,MAND,CAAtB;UAOA,IAAII,CAAC,KAAK,CAAV,EACE,OAAO,IAAIzC,KAAJ,CAAU,+CAAV,CAAP;UACFiC,SAAS,GAAG3I,WAAW,CAACgJ,GAAD,EAAM,CAAN,EAASN,OAAO,CAACO,MAAjB,CAAvB;UACAL,QAAQ,GAAG5I,WAAW,CAACgJ,GAAD,EAAMN,OAAO,CAACO,MAAd,EAAsBD,GAAG,CAAChI,MAA1B,CAAtB;UACA;MAxBJ;IA0BD,CA3BD,MA2BO,IAAIyH,OAAO,KAAK,MAAhB,EAAwB;MAC7B,OAAO,IAAI/B,KAAJ,CAAU,+BAAV,CAAP;IACD;;IAED,IAAIpF,IAAI,CAACgB,IAAL,GAAY,CAAZ,IAAiBhB,IAAI,CAACN,MAA1B,EACE,OAAO,IAAI0F,KAAJ,CAAU,+BAAV,CAAP;IACF,MAAM0C,QAAQ,GAAGjJ,YAAY,CAACmB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAA7B;IACAhB,IAAI,CAACgB,IAAL,IAAa,CAAb;;IAEA,IAAI8G,QAAQ,GAAG,CAAf,EAAkB;MAChB;MAEA;MACA,KAAK,IAAIrI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqI,QAApB,EAA8B,EAAErI,CAAhC,EAAmC;QACjC,MAAMsI,OAAO,GAAGnJ,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAA1B;QACA,IAAI+G,OAAO,KAAKd,SAAhB,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;QACF,MAAMrF,IAAI,GAAGnB,UAAU,CAACmJ,OAAD,EAAU,CAAV,EAAa,IAAb,CAAvB;QACA,IAAIhI,IAAI,KAAKkH,SAAb,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;MACH;;MAED,IAAI4C,QAAQ,GAAGpJ,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAAzB;MACA,IAAIgH,QAAQ,KAAKf,SAAjB,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;;MAEF,IAAIiC,SAAS,KAAKJ,SAAlB,EAA6B;QAC3B;QACA,IAAIe,QAAQ,CAACtI,MAAT,GAAkB0H,OAAO,CAACa,QAA1B,IACID,QAAQ,CAACtI,MAAT,GAAkB0H,OAAO,CAACa,QAA3B,KAAyC,CADhD,EACmD;UACjD,OAAO,IAAI7C,KAAJ,CAAU,+BAAV,CAAP;QACD;;QACD,IAAI;UACF,MAAM8C,OAAO,GAAG;YAAEC,aAAa,EAAEf,OAAO,CAACgB;UAAzB,CAAhB;UACA,MAAMC,QAAQ,GAAG9K,gBAAgB,CAAC6J,OAAO,CAACxH,OAAT,EACCyH,SADD,EAECC,QAFD,EAGCY,OAHD,CAAjC;;UAIA,IAAId,OAAO,CAACgB,OAAR,GAAkB,CAAtB,EAAyB;YACvB,IAAIpI,IAAI,CAACN,MAAL,GAAcM,IAAI,CAACgB,IAAnB,GAA0BoG,OAAO,CAACgB,OAAtC,EACE,OAAO,IAAIhD,KAAJ,CAAU,+BAAV,CAAP;YACFiD,QAAQ,CAACC,UAAT,CACE5J,WAAW,CAACsB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,EAAkBhB,IAAI,CAACgB,IAAL,IAAaoG,OAAO,CAACgB,OAAvC,CADb;UAGD;;UACDJ,QAAQ,GAAG5H,cAAc,CAACiI,QAAQ,CAAC9C,MAAT,CAAgByC,QAAhB,CAAD,EACCK,QAAQ,CAACE,KAAT,EADD,CAAzB;QAED,CAfD,CAeE,OAAOlD,EAAP,EAAW;UACX,OAAOA,EAAP;QACD;MACF,CAzCe,CA0ChB;MACA;;;MACA,IAAIrF,IAAI,CAACgB,IAAL,KAAchB,IAAI,CAACN,MAAvB,EACE,OAAO,IAAI0F,KAAJ,CAAU,+BAAV,CAAP;MAEF0B,GAAG,GAAG0B,oBAAoB,CAACR,QAAD,EAAWF,QAAX,EAAqBT,SAAS,KAAKJ,SAAnC,CAA1B;IACD,CAhDD,MAgDO;MACLH,GAAG,GAAG,EAAN;IACD;;IACD,IAAIA,GAAG,YAAY1B,KAAnB,EACE,OAAO0B,GAAP,CAnIyC,CAoI3C;IACA;;IACA,OAAOA,GAAG,CAAC,CAAD,CAAV;EACD,CAvID;;EAyIA,SAAS0B,oBAAT,CAA8BxI,IAA9B,EAAoCyI,KAApC,EAA2CnC,SAA3C,EAAsD;IACpD,MAAM9G,IAAI,GAAG,EAAb;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACI,IAAIQ,IAAI,CAACN,MAAL,GAAc,CAAlB,EACE,OAAO,IAAI0F,KAAJ,CAAU,+BAAV,CAAP;IACF,MAAMsD,MAAM,GAAG7J,YAAY,CAACmB,IAAD,EAAO,CAAP,CAA3B;IACA,MAAM2I,MAAM,GAAG9J,YAAY,CAACmB,IAAD,EAAO,CAAP,CAA3B;;IACA,IAAI0I,MAAM,KAAKC,MAAf,EAAuB;MACrB,IAAIrC,SAAJ,EAAe;QACb,OAAO,IAAIlB,KAAJ,CACL,uDADK,CAAP;MAGD;;MACD,OAAO,IAAIA,KAAJ,CAAU,oCAAV,CAAP;IACD;;IACDpF,IAAI,CAACgB,IAAL,GAAY,CAAZ;IACA,IAAIvB,CAAJ;IACA,IAAI+E,GAAJ;;IACA,KAAK/E,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGgJ,KAAhB,EAAuB,EAAEhJ,CAAzB,EAA4B;MAC1B,IAAIyF,IAAJ;MACA,IAAIiB,OAAJ;MACA,IAAIC,MAAJ;MACA,IAAIC,MAAJ,CAJ0B,CAK1B;MACA;MACA;MACA;MACA;;MACA,MAAMtG,IAAI,GAAGnB,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,EAAkB,IAAlB,CAAvB;MACA,IAAIjB,IAAI,KAAKkH,SAAb,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;;MAEF,QAAQrF,IAAR;QACE,KAAK,SAAL;UAAgB;YACd;AACV;AACA;AACA;AACA;AACA;AACA;AACA;YACU,MAAMqB,CAAC,GAAGxC,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;YACA,IAAII,CAAC,KAAK6F,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;YACF,MAAM/D,CAAC,GAAGzC,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;YACA,IAAIK,CAAC,KAAK4F,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;YACF,MAAM9C,CAAC,GAAG1D,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;YACA,IAAIsB,CAAC,KAAK2E,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;YACF,MAAMzC,IAAI,GAAG/D,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAAvB;YACA,IAAI2B,IAAI,KAAKsE,SAAb,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;YACF,MAAM7C,CAAC,GAAG3D,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;YACA,IAAIuB,CAAC,KAAK0E,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;YACF,MAAM5C,CAAC,GAAG5D,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;YACA,IAAIwB,CAAC,KAAKyE,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;YAEFgB,MAAM,GAAGjF,gBAAgB,CAACC,CAAD,EAAIC,CAAJ,CAAzB;YACAgF,MAAM,GAAGpE,gBAAgB,CAACb,CAAD,EAAIC,CAAJ,CAAzB;YACA8E,OAAO,GAAG/D,iBAAiB,CAAChB,CAAD,EAAIC,CAAJ,EAAOiB,CAAP,EAAUK,IAAV,EAAgBJ,CAAhB,EAAmBC,CAAnB,CAA3B;YACA0C,IAAI,GAAG,MAAP;YACA;UACD;;QACD,KAAK,SAAL;UAAgB;YACd;AACV;AACA;AACA;AACA;AACA;AACA;YACU,MAAM3C,CAAC,GAAG3D,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;YACA,IAAIuB,CAAC,KAAK0E,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;YACF,MAAM5C,CAAC,GAAG5D,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;YACA,IAAIwB,CAAC,KAAKyE,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;YACF,MAAM3B,CAAC,GAAG7E,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;YACA,IAAIyC,CAAC,KAAKwD,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;YACF,MAAM1B,CAAC,GAAG9E,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;YACA,IAAI0C,CAAC,KAAKuD,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;YACF,MAAMvB,CAAC,GAAGjF,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;YACA,IAAI6C,CAAC,KAAKoD,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;YAEFgB,MAAM,GAAG5C,gBAAgB,CAACjB,CAAD,EAAIC,CAAJ,EAAOiB,CAAP,EAAUC,CAAV,CAAzB;YACA2C,MAAM,GAAG1C,gBAAgB,CAACpB,CAAD,EAAIC,CAAJ,EAAOiB,CAAP,EAAUC,CAAV,CAAzB;YACAyC,OAAO,GAAGvC,iBAAiB,CAACrB,CAAD,EAAIC,CAAJ,EAAOiB,CAAP,EAAUC,CAAV,EAAaG,CAAb,CAA3B;YACAqB,IAAI,GAAG,MAAP;YACA;UACD;;QACD,KAAK,aAAL;UAAoB;YAClB,IAAI,CAAC1G,cAAL,EACE,OAAO,IAAI4G,KAAJ,CAAW,yCAAwCrF,IAAK,EAAxD,CAAP;YACF;AACV;AACA;AACA;;YACU,MAAM6I,KAAK,GAAGhK,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAAxB;YACA,IAAI4H,KAAK,KAAK3B,SAAV,IAAuB2B,KAAK,CAAClJ,MAAN,KAAiB,EAA5C,EACE,OAAO,IAAI0F,KAAJ,CAAU,+BAAV,CAAP;YACF,MAAMyD,MAAM,GAAGjK,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAAzB;YACA,IAAI6H,MAAM,KAAK5B,SAAX,IAAwB4B,MAAM,CAACnJ,MAAP,KAAkB,EAA9C,EACE,OAAO,IAAI0F,KAAJ,CAAU,+BAAV,CAAP;YAEFgB,MAAM,GAAGtC,eAAe,CAAC8E,KAAD,CAAxB;YACAvC,MAAM,GAAGlC,eAAe,CAACyE,KAAD,CAAxB;YACAzC,OAAO,GAAG/B,gBAAgB,CAAC1F,WAAW,CAACmK,MAAD,EAAS,CAAT,EAAY,EAAZ,CAAZ,CAA1B;YACA3D,IAAI,GAAG,IAAP;YACA;UACD;;QACD,KAAK,qBAAL;UACEA,IAAI,GAAG,QAAP;UACAV,GAAG,GAAG,qBAAN;QACF;;QACA,KAAK,qBAAL;UACE,IAAIU,IAAI,KAAK+B,SAAb,EAAwB;YACtB/B,IAAI,GAAG,QAAP;YACAV,GAAG,GAAG,cAAN;UACD;;QACH;;QACA,KAAK,qBAAL;UAA4B;YAC1B,IAAIU,IAAI,KAAK+B,SAAb,EAAwB;cACtB/B,IAAI,GAAG,QAAP;cACAV,GAAG,GAAG,cAAN;YACD;YACD;AACV;AACA;AACA;AACA;YACU;;;YACA,IAAI,CAAC7D,UAAU,CAACX,IAAD,EAAO,CAAP,CAAf,EAA0B;cACxB,OAAO,IAAIoF,KAAJ,CAAU,+BAAV,CAAP;YACF,MAAM0D,KAAK,GAAGlK,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAAxB;YACA,IAAI8H,KAAK,KAAK7B,SAAd,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;YACF,MAAM2D,MAAM,GAAGnK,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAAzB;YACA,IAAI+H,MAAM,KAAK9B,SAAf,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;YAEFgB,MAAM,GAAG7B,kBAAkB,CAACC,GAAD,EAAMsE,KAAN,CAA3B;YACAzC,MAAM,GAAG3B,kBAAkB,CAACF,GAAD,EAAMsE,KAAN,CAA3B;YACA3C,OAAO,GAAGvB,mBAAmB,CAACJ,GAAD,EAAMsE,KAAN,EAAaC,MAAb,CAA7B;YACA;UACD;;QACD;UACE,OAAO,IAAI3D,KAAJ,CAAW,yCAAwCrF,IAAK,EAAxD,CAAP;MAzHJ;;MA4HA,MAAMiJ,WAAW,GAAGpK,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,EAAkB,IAAlB,CAA9B;MACA,IAAIgI,WAAW,KAAK/B,SAApB,EACE,OAAO,IAAI7B,KAAJ,CAAU,+BAAV,CAAP;MAEF5F,IAAI,CAACyJ,IAAL,CACE,IAAIhD,eAAJ,CAAoBlG,IAApB,EAA0BiJ,WAA1B,EAAuC7C,OAAvC,EAAgDC,MAAhD,EAAwDC,MAAxD,EAAgEnB,IAAhE,EACoBoB,SADpB,CADF;IAID;;IACD,IAAI4C,GAAG,GAAG,CAAV;;IACA,KAAKzJ,CAAC,GAAGO,IAAI,CAACgB,IAAd,EAAoBvB,CAAC,GAAGO,IAAI,CAACN,MAA7B,EAAqC,EAAED,CAAvC,EAA0C;MACxC,IAAIO,IAAI,CAACP,CAAD,CAAJ,KAAa,EAAEyJ,GAAF,GAAQ,GAAzB,EACE,OAAO,IAAI9D,KAAJ,CAAU,+BAAV,CAAP;IACH;;IAED,OAAO5F,IAAP;EACD;AACF;;AAGD,SAAS2J,mBAAT,CAA6BpJ,IAA7B,EAAmCmG,OAAnC,EAA4CC,OAA5C,EAAqDC,MAArD,EAA6DC,MAA7D,EAAqEnB,IAArE,EAC6BoB,SAD7B,EACwC;EACtC,KAAKvG,IAAL,GAAYA,IAAZ;EACA,KAAKmG,OAAL,GAAeA,OAAf;EACA,KAAKjH,YAAL,IAAqBkH,OAArB;EACA,KAAKjH,WAAL,IAAoBkH,MAApB;EACA,KAAKjH,WAAL,IAAoBkH,MAApB;EACA,KAAKtH,aAAL,IAAsBmG,IAAtB;EACA,KAAK9F,aAAL,IAAsBkH,SAAtB;AACD;;AACD6C,mBAAmB,CAAC5C,SAApB,GAAgCtB,OAAhC;AACA;EACE,MAAMuB,MAAM,GAAG,kJAAf;;EACA2C,mBAAmB,CAAC1C,KAApB,GAA4B,CAACC,GAAD,EAAMC,UAAN,KAAqB;IAC/C,MAAMC,CAAC,GAAGJ,MAAM,CAACK,IAAP,CAAYH,GAAZ,CAAV;IACA,IAAIE,CAAC,KAAK,IAAV,EACE,OAAO,IAAP;IACF,IAAIoB,QAAQ,GAAGxH,MAAM,CAAC8C,IAAP,CAAYsD,CAAC,CAAC,CAAD,CAAb,EAAkB,QAAlB,CAAf;IACA,IAAIwC,OAAO,GAAGxC,CAAC,CAAC,CAAD,CAAf;IACA,IAAIN,SAAS,GAAG,KAAhB;;IACA,IAAI8C,OAAO,KAAKnC,SAAhB,EAA2B;MACzB;MACAmC,OAAO,GAAGA,OAAO,CAACC,KAAR,CAAc,UAAd,CAAV;;MACA,KAAK,IAAI5J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2J,OAAO,CAAC1J,MAA5B,EAAoC,EAAED,CAAtC,EAAyC;QACvC,MAAM6J,MAAM,GAAGF,OAAO,CAAC3J,CAAD,CAAtB;QACA,IAAI8J,MAAM,GAAGD,MAAM,CAACpC,OAAP,CAAe,GAAf,CAAb;;QACA,IAAIoC,MAAM,CAACE,KAAP,CAAa,CAAb,EAAgBD,MAAhB,MAA4B,UAAhC,EAA4C;UAC1C,MAAME,GAAG,GAAGH,MAAM,CAACE,KAAP,CAAaD,MAAM,GAAG,CAAtB,CAAZ;UACAA,MAAM,GAAGE,GAAG,CAACvC,OAAJ,CAAY,GAAZ,CAAT;UACA,IAAIqC,MAAM,KAAK,CAAC,CAAhB,EACE;UACF,MAAM5J,UAAU,GAAG8J,GAAG,CAACD,KAAJ,CAAU,CAAV,EAAaD,MAAb,EAAqBG,WAArB,EAAnB;;UACA,IAAIvL,uBAAuB,CAAC+I,OAAxB,CAAgCvH,UAAhC,MAAgD,CAAC,CAArD,EAAwD;YACtD,OAAO,IAAIyF,KAAJ,CACJ,WAAUzF,UAAW,kBAAtB,GACI,mCAFC,CAAP;UAID;;UACD,MAAMyH,OAAO,GAAG/H,mBAAmB,CAACM,UAAD,CAAnC;;UACA,IAAI,CAACyH,OAAL,EAAc;YACZ,OAAO,IAAIhC,KAAJ,CACJ,WAAUzF,UAAW,kBAAtB,GACI,mCAFC,CAAP;UAID;;UACD,MAAM2H,QAAQ,GAAG9G,MAAM,CAAC8C,IAAP,CAAYmG,GAAG,CAACD,KAAJ,CAAUD,MAAM,GAAG,CAAnB,CAAZ,EAAmC,KAAnC,CAAjB;UACA,IAAIjC,QAAQ,CAAC5H,MAAT,KAAoB0H,OAAO,CAACQ,KAAhC,EACE,OAAO,IAAIxC,KAAJ,CAAU,yCAAV,CAAP;;UACF,IAAI,CAACuB,UAAL,EAAiB;YACf,OAAO,IAAIvB,KAAJ,CACL,iEADK,CAAP;UAGD;;UACD,MAAMuE,OAAO,GAAGjL,WAAW,CAAC4I,QAAD,EAAW,CAAX,EAAc,CAAd,CAA3B;UACA,IAAID,SAAS,GAAG5J,UAAU,CAAC,KAAD,CAAV,CACG8H,MADH,CACUoB,UADV,EAEGpB,MAFH,CAEUoE,OAFV,EAGGC,MAHH,EAAhB;;UAIA,OAAOvC,SAAS,CAAC3H,MAAV,GAAmB0H,OAAO,CAACO,MAAlC,EAA0C;YACxCN,SAAS,GAAGjH,cAAc,CACxBiH,SADwB,EAExB5J,UAAU,CAAC,KAAD,CAAV,CACG8H,MADH,CACU8B,SADV,EAEG9B,MAFH,CAEUoB,UAFV,EAGGpB,MAHH,CAGUoE,OAHV,EAIGC,MAJH,EAFwB,CAA1B;UAQD;;UACD,IAAIvC,SAAS,CAAC3H,MAAV,GAAmB0H,OAAO,CAACO,MAA/B,EACEN,SAAS,GAAG3I,WAAW,CAAC2I,SAAD,EAAY,CAAZ,EAAeD,OAAO,CAACO,MAAvB,CAAvB;;UACF,IAAI;YACF,MAAMU,QAAQ,GAAG9K,gBAAgB,CAACoC,UAAD,EAAa0H,SAAb,EAAwBC,QAAxB,CAAjC;YACAe,QAAQ,CAACwB,cAAT,CAAwB,KAAxB;YACA7B,QAAQ,GAAG5H,cAAc,CAACiI,QAAQ,CAAC9C,MAAT,CAAgByC,QAAhB,CAAD,EACCK,QAAQ,CAACE,KAAT,EADD,CAAzB;YAEAjC,SAAS,GAAG,IAAZ;UACD,CAND,CAME,OAAOjB,EAAP,EAAW;YACX,OAAOA,EAAP;UACD;QACF;MACF;IACF;;IAED,IAAItF,IAAJ;IACA,IAAIoG,OAAJ;IACA,IAAIC,MAAJ;IACA,IAAIC,MAAJ;IACA,IAAInB,IAAJ;IACA,IAAI4E,MAAJ;IACA,IAAIC,MAAM,GAAG,+BAAb;IACA,IAAIzD,SAAJ,EACEyD,MAAM,IAAI,mBAAV;;IACF,QAAQnD,CAAC,CAAC,CAAD,CAAT;MACE,KAAK,KAAL;QACE7G,IAAI,GAAG,SAAP;QACAoG,OAAO,GAAGrG,OAAO,CAAC,aAAD,EAAgBkI,QAAhB,CAAjB;;QACA,IAAI;UACF8B,MAAM,GAAG,IAAI1L,GAAG,CAAC4L,MAAR,CAAehC,QAAf,CAAT;UACA8B,MAAM,CAACG,YAAP;UACAH,MAAM,CAACI,OAAP,GAHE,CAGgB;;UAClB,MAAM9I,CAAC,GAAG0I,MAAM,CAAClL,UAAP,CAAkBR,GAAG,CAAC2D,OAAtB,EAA+B,IAA/B,CAAV;UACA,IAAIX,CAAC,KAAK,IAAV,EACE,OAAO,IAAIgE,KAAJ,CAAU2E,MAAV,CAAP;UACF,MAAM1I,CAAC,GAAGyI,MAAM,CAAClL,UAAP,CAAkBR,GAAG,CAAC2D,OAAtB,EAA+B,IAA/B,CAAV;UACA,IAAIV,CAAC,KAAK,IAAV,EACE,OAAO,IAAI+D,KAAJ,CAAU2E,MAAV,CAAP;UACF3D,MAAM,GAAGjF,gBAAgB,CAACC,CAAD,EAAIC,CAAJ,CAAzB;UACAgF,MAAM,GAAGpE,gBAAgB,CAACb,CAAD,EAAIC,CAAJ,CAAzB;QACD,CAZD,CAYE,MAAM;UACN,OAAO,IAAI+D,KAAJ,CAAU2E,MAAV,CAAP;QACD;;QACD7E,IAAI,GAAG,MAAP;QACA;;MACF,KAAK,KAAL;QACEnF,IAAI,GAAG,SAAP;QACAoG,OAAO,GAAGrG,OAAO,CAAC,aAAD,EAAgBkI,QAAhB,CAAjB;;QACA,IAAI;UACF8B,MAAM,GAAG,IAAI1L,GAAG,CAAC4L,MAAR,CAAehC,QAAf,CAAT;UACA8B,MAAM,CAACG,YAAP;UACAH,MAAM,CAACI,OAAP,GAHE,CAGgB;;UAClB,MAAM3H,CAAC,GAAGuH,MAAM,CAAClL,UAAP,CAAkBR,GAAG,CAAC2D,OAAtB,EAA+B,IAA/B,CAAV;UACA,IAAIQ,CAAC,KAAK,IAAV,EACE,OAAO,IAAI6C,KAAJ,CAAU2E,MAAV,CAAP;UACF,MAAMvH,CAAC,GAAGsH,MAAM,CAAClL,UAAP,CAAkBR,GAAG,CAAC2D,OAAtB,EAA+B,IAA/B,CAAV;UACA,IAAIS,CAAC,KAAK,IAAV,EACE,OAAO,IAAI4C,KAAJ,CAAU2E,MAAV,CAAP;UACF,MAAMtG,CAAC,GAAGqG,MAAM,CAAClL,UAAP,CAAkBR,GAAG,CAAC2D,OAAtB,EAA+B,IAA/B,CAAV;UACA,IAAI0B,CAAC,KAAK,IAAV,EACE,OAAO,IAAI2B,KAAJ,CAAU2E,MAAV,CAAP;UACF,MAAMrG,CAAC,GAAGoG,MAAM,CAAClL,UAAP,CAAkBR,GAAG,CAAC2D,OAAtB,EAA+B,IAA/B,CAAV;UACA,IAAI2B,CAAC,KAAK,IAAV,EACE,OAAO,IAAI0B,KAAJ,CAAU2E,MAAV,CAAP;UACF3D,MAAM,GAAG5C,gBAAgB,CAACjB,CAAD,EAAIC,CAAJ,EAAOiB,CAAP,EAAUC,CAAV,CAAzB;UACA2C,MAAM,GAAG1C,gBAAgB,CAACpB,CAAD,EAAIC,CAAJ,EAAOiB,CAAP,EAAUC,CAAV,CAAzB;QACD,CAlBD,CAkBE,MAAM;UACN,OAAO,IAAI0B,KAAJ,CAAU2E,MAAV,CAAP;QACD;;QACD7E,IAAI,GAAG,MAAP;QACA;;MACF,KAAK,IAAL;QACE,IAAIiF,SAAJ;QACA,IAAIC,MAAJ;QACA,IAAIC,KAAJ;;QACA,IAAI;UACFP,MAAM,GAAG,IAAI1L,GAAG,CAAC4L,MAAR,CAAehC,QAAf,CAAT;UACA8B,MAAM,CAACG,YAAP;UACAH,MAAM,CAACI,OAAP,GAHE,CAGgB;;UAClBE,MAAM,GAAGN,MAAM,CAAClL,UAAP,CAAkBR,GAAG,CAACkG,WAAtB,EAAmC,IAAnC,CAAT;UACAwF,MAAM,CAACQ,QAAP,GALE,CAKiB;;UACnB,MAAMC,MAAM,GAAGT,MAAM,CAACU,UAAP,EAAf,CANE,CAMkC;;UACpC,IAAID,MAAM,KAAK,IAAf,EAAqB;YACnBT,MAAM,CAAC5F,OAAP,GAAiBqG,MAAjB;YACAF,KAAK,GAAGP,MAAM,CAACW,OAAP,EAAR;YACA,IAAIJ,KAAK,KAAK,IAAd,EACE,OAAO,IAAIjF,KAAJ,CAAU2E,MAAV,CAAP;;YACF,QAAQM,KAAR;cACE,KAAK,qBAAL;gBACE;gBACAF,SAAS,GAAG,YAAZ;gBACApK,IAAI,GAAG,qBAAP;gBACAmF,IAAI,GAAG,QAAP;gBACA;;cACF,KAAK,cAAL;gBACE;gBACAiF,SAAS,GAAG,WAAZ;gBACApK,IAAI,GAAG,qBAAP;gBACAmF,IAAI,GAAG,QAAP;gBACA;;cACF,KAAK,cAAL;gBACE;gBACAiF,SAAS,GAAG,WAAZ;gBACApK,IAAI,GAAG,qBAAP;gBACAmF,IAAI,GAAG,QAAP;gBACA;;cACF;gBACE,OAAO,IAAIE,KAAJ,CAAW,mCAAkCiF,KAAM,EAAnD,CAAP;YApBJ;UAsBD,CA3BD,MA2BO;YACL,OAAO,IAAIjF,KAAJ,CAAU2E,MAAV,CAAP;UACD;QACF,CArCD,CAqCE,MAAM;UACN,OAAO,IAAI3E,KAAJ,CAAU2E,MAAV,CAAP;QACD;;QACD5D,OAAO,GAAGrG,OAAO,CAAC,YAAD,EAAekI,QAAf,CAAjB;QACA,MAAM0C,OAAO,GAAG7F,0BAA0B,CAACsF,SAAD,EAAYC,MAAZ,CAA1C;QACAhE,MAAM,GAAG7B,kBAAkB,CAAC8F,KAAD,EAAQK,OAAR,CAA3B;QACArE,MAAM,GAAG3B,kBAAkB,CAAC2F,KAAD,EAAQK,OAAR,CAA3B;QACA;IA/FJ;;IAkGA,OAAO,IAAIvB,mBAAJ,CAAwBpJ,IAAxB,EAA8B,EAA9B,EAAkCoG,OAAlC,EAA2CC,MAA3C,EAAmDC,MAAnD,EAA2DnB,IAA3D,EACwBoB,SADxB,CAAP;EAED,CAnLD;AAoLD;;AAGD,SAASqE,WAAT,CAAqB5K,IAArB,EAA2BmG,OAA3B,EAAoCC,OAApC,EAA6CC,MAA7C,EAAqDC,MAArD,EAA6DnB,IAA7D,EAAmEoB,SAAnE,EAA8E;EAC5E,KAAKvG,IAAL,GAAYA,IAAZ;EACA,KAAKmG,OAAL,GAAeA,OAAf;EACA,KAAKjH,YAAL,IAAqBkH,OAArB;EACA,KAAKjH,WAAL,IAAoBkH,MAApB;EACA,KAAKjH,WAAL,IAAoBkH,MAApB;EACA,KAAKtH,aAAL,IAAsBmG,IAAtB;EACA,KAAK9F,aAAL,IAAsBkH,SAAtB;AACD;;AACDqE,WAAW,CAACpE,SAAZ,GAAwBtB,OAAxB;AACA;EACE,MAAM2F,gBAAgB,GAAGpK,MAAM,CAACqK,KAAP,CAAa,CAAb,CAAzB;EACA,MAAMC,MAAM,GAAGtK,MAAM,CAAC8C,IAAP,CAAY,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B,EAAkC,CAAlC,EAAqC,CAArC,EAAwC,CAAxC,EAA2C,CAA3C,EAA8C,CAA9C,CAAZ,CAAf;EACA,MAAMyH,OAAO,GAAGvK,MAAM,CAAC8C,IAAP,CAAY,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAZ,CAAhB;EACA,MAAM0H,OAAO,GAAGxK,MAAM,CAAC8C,IAAP,CAAY,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAZ,CAAhB;EACA,MAAMkD,MAAM,GAAG,4MAAf;;EACAmE,WAAW,CAAClE,KAAZ,GAAoB,CAACC,GAAD,EAAMC,UAAN,KAAqB;IACvC,MAAMC,CAAC,GAAGJ,MAAM,CAACK,IAAP,CAAYH,GAAZ,CAAV;IACA,IAAIE,CAAC,KAAK,IAAV,EACE,OAAO,IAAP,CAHqC,CAIvC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IACA,MAAMjH,UAAU,GAAGiH,CAAC,CAAC,CAAD,CAApB;IACA,MAAMqE,SAAS,GAAItL,UAAU,KAAK,MAAlC;;IACA,IAAIsL,SAAS,IAAI,CAACtE,UAAlB,EAA8B;MAC5B,OAAO,IAAIvB,KAAJ,CACL,6DADK,CAAP;IAGD;;IAED,IAAI4C,QAAQ,GAAGxH,MAAM,CAAC8C,IAAP,CAAYsD,CAAC,CAAC,CAAD,CAAb,EAAkB,QAAlB,CAAf;;IAEA,IAAIqE,SAAJ,EAAe;MACb,MAAM7D,OAAO,GAAG7I,WAAW,CAACoB,UAAD,CAA3B;MACA,IAAI0H,SAAS,GAAGjH,cAAc,CAC5B3C,UAAU,CAAC,MAAD,CAAV,CAAmB8H,MAAnB,CAA0BwF,OAA1B,EAAmCxF,MAAnC,CAA0CoB,UAA1C,EAAsDiD,MAAtD,EAD4B,EAE5BnM,UAAU,CAAC,MAAD,CAAV,CAAmB8H,MAAnB,CAA0ByF,OAA1B,EAAmCzF,MAAnC,CAA0CoB,UAA1C,EAAsDiD,MAAtD,EAF4B,CAA9B;MAIA,IAAIvC,SAAS,CAAC3H,MAAV,GAAmB0H,OAAO,CAACO,MAA/B,EACEN,SAAS,GAAG3I,WAAW,CAAC2I,SAAD,EAAY,CAAZ,EAAeD,OAAO,CAACO,MAAvB,CAAvB;;MACF,IAAI;QACF,MAAMU,QAAQ,GAAG9K,gBAAgB,CAAC6J,OAAO,CAACxH,OAAT,EACDyH,SADC,EAEDyD,MAFC,CAAjC;QAGAzC,QAAQ,CAACwB,cAAT,CAAwB,KAAxB;QACA7B,QAAQ,GAAG5H,cAAc,CAACiI,QAAQ,CAAC9C,MAAT,CAAgByC,QAAhB,CAAD,EACCK,QAAQ,CAACE,KAAT,EADD,CAAzB;MAED,CAPD,CAOE,OAAOlD,EAAP,EAAW;QACX,OAAOA,EAAP;MACD;IACF;;IAED,MAAMtF,IAAI,GAAG6G,CAAC,CAAC,CAAD,CAAd;IACA,MAAMV,OAAO,GAAGU,CAAC,CAAC,CAAD,CAAjB;IACA,MAAM8D,OAAO,GAAGlK,MAAM,CAAC8C,IAAP,CAAYsD,CAAC,CAAC,CAAD,CAAb,EAAkB,QAAlB,CAAhB;IAEA,MAAMsE,GAAG,GAAGtE,CAAC,CAAC,CAAD,CAAb;IACA,MAAMuE,OAAO,GAAGpL,IAAI,CAACL,MAArB;IACA,MAAM0L,aAAa,GAAGzL,UAAU,CAACD,MAAjC;IACA,MAAM2L,UAAU,GAAG7K,MAAM,CAAC8K,UAAP,CAAkBpF,OAAlB,CAAnB;IACA,MAAMqF,MAAM,GAAGb,OAAO,CAAChL,MAAvB;IACA,MAAM8L,OAAO,GAAGxD,QAAQ,CAACtI,MAAzB;IACA,MAAM+L,OAAO,GAAGjL,MAAM,CAACC,WAAP,CAAmB,IAAI0K,OAAJ,GACE,CADF,GACMC,aADN,GAEE,CAFF,GAEMC,UAFN,GAGE,CAHF,GAGME,MAHN,GAIE,CAJF,GAIMC,OAJzB,CAAhB;IAKA,IAAIjJ,CAAC,GAAG,CAAR;IAEAzD,aAAa,CAAC2M,OAAD,EAAUN,OAAV,EAAmB5I,CAAnB,CAAb;IACAkJ,OAAO,CAACtJ,SAAR,CAAkBpC,IAAlB,EAAwBwC,CAAC,IAAI,CAA7B,EAAgC4I,OAAhC;IACArM,aAAa,CAAC2M,OAAD,EAAUL,aAAV,EAAyB7I,CAAC,IAAI4I,OAA9B,CAAb;IACAM,OAAO,CAACtJ,SAAR,CAAkBxC,UAAlB,EAA8B4C,CAAC,IAAI,CAAnC,EAAsC6I,aAAtC;IACAtM,aAAa,CAAC2M,OAAD,EAAUJ,UAAV,EAAsB9I,CAAC,IAAI6I,aAA3B,CAAb;IACAK,OAAO,CAACtJ,SAAR,CAAkB+D,OAAlB,EAA2B3D,CAAC,IAAI,CAAhC,EAAmC8I,UAAnC;IACAvM,aAAa,CAAC2M,OAAD,EAAUF,MAAV,EAAkBhJ,CAAC,IAAI8I,UAAvB,CAAb;IACAI,OAAO,CAAC/K,GAAR,CAAYgK,OAAZ,EAAqBnI,CAAC,IAAI,CAA1B;IACAzD,aAAa,CAAC2M,OAAD,EAAUD,OAAV,EAAmBjJ,CAAC,IAAIgJ,MAAxB,CAAb;IACAE,OAAO,CAAC/K,GAAR,CAAYsH,QAAZ,EAAsBzF,CAAC,GAAG,CAA1B;IAEA,IAAI,CAACoE,UAAL,EACEA,UAAU,GAAGiE,gBAAb;IAEF,MAAMc,OAAO,GAAGhO,UAAU,CACxB,MADwB,EAEvBD,UAAU,CAAC,MAAD,CAAV,CACG8H,MADH,CACU,gCADV,EAEGA,MAFH,CAEUoB,UAFV,EAGGiD,MAHH,EAFuB,CAAV,CAMdrE,MANc,CAMPkG,OANO,EAME7B,MANF,CAMS,KANT,CAAhB;;IAQA,IAAI8B,OAAO,KAAKR,GAAhB,EAAqB;MACnB,IAAID,SAAJ,EAAe;QACb,OAAO,IAAI7F,KAAJ,CACL,2DADK,CAAP;MAGD;;MACD,OAAO,IAAIA,KAAJ,CAAU,wCAAV,CAAP;IACD;;IAED,IAAIgB,MAAJ;IACA,IAAIC,MAAJ;IACA,IAAIF,OAAJ;IACAuE,OAAO,CAAC1J,IAAR,GAAe,CAAf;IACAL,UAAU,CAAC+J,OAAD,EAAU,CAAV,CAAV,CAlHuC,CAkHf;;IACxB,QAAQ3K,IAAR;MACE,KAAK,SAAL;QAAgB;UACd,MAAMsB,CAAC,GAAGzC,UAAU,CAAC8L,OAAD,EAAUA,OAAO,CAAC1J,IAAlB,CAApB;UACA,IAAIK,CAAC,KAAK4F,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,0BAAV,CAAP;UACF,MAAMhE,CAAC,GAAGxC,UAAU,CAAC8L,OAAD,EAAUA,OAAO,CAAC1J,IAAlB,CAApB;UACA,IAAII,CAAC,KAAK6F,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,0BAAV,CAAP;UACF,MAAM9C,CAAC,GAAG1D,UAAU,CAACoJ,QAAD,EAAW,CAAX,CAApB;UACA,IAAI1F,CAAC,KAAK2E,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,2BAAV,CAAP;UACF,MAAM7C,CAAC,GAAG3D,UAAU,CAACoJ,QAAD,EAAWA,QAAQ,CAAChH,IAApB,CAApB;UACA,IAAIuB,CAAC,KAAK0E,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,2BAAV,CAAP;UACF,MAAM5C,CAAC,GAAG5D,UAAU,CAACoJ,QAAD,EAAWA,QAAQ,CAAChH,IAApB,CAApB;UACA,IAAIwB,CAAC,KAAKyE,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,2BAAV,CAAP;UACF,MAAMzC,IAAI,GAAG/D,UAAU,CAACoJ,QAAD,EAAWA,QAAQ,CAAChH,IAApB,CAAvB;UACA,IAAI2B,IAAI,KAAKsE,SAAb,EACE,OAAO,IAAI7B,KAAJ,CAAU,2BAAV,CAAP;UACFgB,MAAM,GAAGjF,gBAAgB,CAACC,CAAD,EAAIC,CAAJ,CAAzB;UACAgF,MAAM,GAAGpE,gBAAgB,CAACb,CAAD,EAAIC,CAAJ,CAAzB;UACA8E,OAAO,GAAG/D,iBAAiB,CAAChB,CAAD,EAAIC,CAAJ,EAAOiB,CAAP,EAAUK,IAAV,EAAgBJ,CAAhB,EAAmBC,CAAnB,CAA3B;UACA;QACD;;MACD,KAAK,SAAL;QAAgB;UACd,MAAMD,CAAC,GAAG3D,UAAU,CAAC8L,OAAD,EAAUA,OAAO,CAAC1J,IAAlB,CAApB;UACA,IAAIuB,CAAC,KAAK0E,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,0BAAV,CAAP;UACF,MAAM5C,CAAC,GAAG5D,UAAU,CAAC8L,OAAD,EAAUA,OAAO,CAAC1J,IAAlB,CAApB;UACA,IAAIwB,CAAC,KAAKyE,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,0BAAV,CAAP;UACF,MAAM3B,CAAC,GAAG7E,UAAU,CAAC8L,OAAD,EAAUA,OAAO,CAAC1J,IAAlB,CAApB;UACA,IAAIyC,CAAC,KAAKwD,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,0BAAV,CAAP;UACF,MAAM1B,CAAC,GAAG9E,UAAU,CAAC8L,OAAD,EAAUA,OAAO,CAAC1J,IAAlB,CAApB;UACA,IAAI0C,CAAC,KAAKuD,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,0BAAV,CAAP;UACF,MAAMvB,CAAC,GAAGjF,UAAU,CAACoJ,QAAD,EAAW,CAAX,CAApB;UACA,IAAInE,CAAC,KAAKoD,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,2BAAV,CAAP;UAEFgB,MAAM,GAAG5C,gBAAgB,CAACjB,CAAD,EAAIC,CAAJ,EAAOiB,CAAP,EAAUC,CAAV,CAAzB;UACA2C,MAAM,GAAG1C,gBAAgB,CAACpB,CAAD,EAAIC,CAAJ,EAAOiB,CAAP,EAAUC,CAAV,CAAzB;UACAyC,OAAO,GAAGvC,iBAAiB,CAACrB,CAAD,EAAIC,CAAJ,EAAOiB,CAAP,EAAUC,CAAV,EAAaG,CAAb,CAA3B;UACA;QACD;IA9CH;;IAiDA,OAAO,IAAI8G,WAAJ,CAAgB5K,IAAhB,EAAsBmG,OAAtB,EAA+BC,OAA/B,EAAwCC,MAAxC,EAAgDC,MAAhD,EAAwD,MAAxD,EACgB4E,SADhB,CAAP;EAED,CAtKD;AAuKD;;AAGD,SAASU,cAAT,CAAwB5L,IAAxB,EAA8BmG,OAA9B,EAAuCE,MAAvC,EAA+CC,MAA/C,EAAuDnB,IAAvD,EAA6D;EAC3D,KAAKnF,IAAL,GAAYA,IAAZ;EACA,KAAKmG,OAAL,GAAeA,OAAf;EACA,KAAKjH,YAAL,IAAqB,IAArB;EACA,KAAKC,WAAL,IAAoBkH,MAApB;EACA,KAAKjH,WAAL,IAAoBkH,MAApB;EACA,KAAKtH,aAAL,IAAsBmG,IAAtB;EACA,KAAK9F,aAAL,IAAsB,KAAtB;AACD;;AACDuM,cAAc,CAACpF,SAAf,GAA2BtB,OAA3B;AACA;EACE,IAAIuB,MAAJ;EACA,IAAIhI,cAAJ,EACEgI,MAAM,GAAG,oIAAT,CADF,KAGEA,MAAM,GAAG,4HAAT;;EACFmF,cAAc,CAAClF,KAAf,GAAwBC,GAAD,IAAS;IAC9B,MAAME,CAAC,GAAGJ,MAAM,CAACK,IAAP,CAAYH,GAAZ,CAAV;IACA,IAAIE,CAAC,KAAK,IAAV,EACE,OAAO,IAAP,CAH4B,CAI9B;IACA;IACA;IACA;;IAEA,MAAMgF,QAAQ,GAAGhF,CAAC,CAAC,CAAD,CAAlB;IACA,MAAMiF,QAAQ,GAAGjF,CAAC,CAAC,CAAD,CAAlB;IACA,MAAM5G,IAAI,GAAGQ,MAAM,CAAC8C,IAAP,CAAYsD,CAAC,CAAC,CAAD,CAAb,EAAkB,QAAlB,CAAb;IACA,MAAMV,OAAO,GAAIU,CAAC,CAAC,CAAD,CAAD,IAAQ,EAAzB;IAEA,MAAM7G,IAAI,GAAGnB,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,EAAkB,IAAlB,CAAvB;IACA,IAAIjB,IAAI,KAAKkH,SAAT,IAAsBlH,IAAI,CAACmH,OAAL,CAAa2E,QAAb,MAA2B,CAArD,EACE,OAAO,IAAIzG,KAAJ,CAAU,8BAAV,CAAP;IAEF,OAAO0G,QAAQ,CAAC9L,IAAD,EAAO6L,QAAP,EAAiB3F,OAAjB,EAA0B0F,QAA1B,CAAf;EACD,CAnBD;AAoBD;;AAGD,SAASG,cAAT,CAAwBhM,IAAxB,EAA8BmG,OAA9B,EAAuCE,MAAvC,EAA+CC,MAA/C,EAAuDnB,IAAvD,EAA6D;EAC3D,KAAKnF,IAAL,GAAYA,IAAZ;EACA,KAAKmG,OAAL,GAAeA,OAAf;EACA,KAAKjH,YAAL,IAAqB,IAArB;EACA,KAAKC,WAAL,IAAoBkH,MAApB;EACA,KAAKjH,WAAL,IAAoBkH,MAApB;EACA,KAAKtH,aAAL,IAAsBmG,IAAtB;EACA,KAAK9F,aAAL,IAAsB,KAAtB;AACD;;AACD2M,cAAc,CAACxF,SAAf,GAA2BtB,OAA3B;AACA;EACE,MAAMuB,MAAM,GAAG,4FAAf;EACA,MAAMwF,OAAO,GAAG,uBAAhB;EACA,MAAMC,SAAS,GAAG,oEAAlB;EACA,MAAMC,cAAc,GAAG,UAAvB;;EACAH,cAAc,CAACtF,KAAf,GAAwBC,GAAD,IAAS;IAC9B,IAAIE,CAAC,GAAGJ,MAAM,CAACK,IAAP,CAAYH,GAAZ,CAAR;IACA,IAAIE,CAAC,KAAK,IAAV,EACE,OAAO,IAAP;IAEF,MAAMuF,IAAI,GAAGvF,CAAC,CAAC,CAAD,CAAd;IACA,IAAIwF,SAAS,GAAG,CAAhB;IACA,IAAIlG,OAAO,GAAG,EAAd;;IAEA,OAAOU,CAAC,GAAGqF,SAAS,CAACpF,IAAV,CAAesF,IAAf,CAAX,EAAiC;MAC/B,MAAME,UAAU,GAAGzF,CAAC,CAAC,CAAD,CAApB;MACA,MAAM0F,WAAW,GAAG1F,CAAC,CAAC,CAAD,CAAD,CAAKzG,OAAL,CAAa+L,cAAb,EAA6B,EAA7B,CAApB;;MACA,IAAII,WAAW,CAAC5M,MAAZ,GAAqB,IAAzB,EAA+B;QAC7BuM,SAAS,CAACM,SAAV,GAAsB,CAAtB;QACA,OAAO,IAAInH,KAAJ,CAAU,8BAAV,CAAP;MACD;;MAEDgH,SAAS,GAAGH,SAAS,CAACM,SAAtB;;MAEA,IAAIF,UAAU,CAAC3C,WAAX,OAA6B,SAAjC,EAA4C;QAC1CxD,OAAO,GAAGoG,WAAV;;QACA,IAAIpG,OAAO,CAACxG,MAAR,GAAiB,CAAjB,IACGwG,OAAO,CAAC7C,UAAR,CAAmB,CAAnB,MAA0B;QAAE;QAD/B,GAEG6C,OAAO,CAAC7C,UAAR,CAAmB6C,OAAO,CAACxG,MAAR,GAAiB,CAApC,MAA2C;QAAE;QAFpD,EAE+D;UAC7DwG,OAAO,GAAGA,OAAO,CAACsD,KAAR,CAAc,CAAd,EAAiB,CAAC,CAAlB,CAAV;QACD;MACF;IACF;;IAED,IAAIxJ,IAAI,GAAGmM,IAAI,CAAC3C,KAAL,CAAW4C,SAAX,CAAX;IACA,IAAI,CAACJ,OAAO,CAACQ,IAAR,CAAaxM,IAAb,CAAL,EACE,OAAO,IAAIoF,KAAJ,CAAU,8BAAV,CAAP;IAEFpF,IAAI,GAAGQ,MAAM,CAAC8C,IAAP,CAAYtD,IAAZ,EAAkB,QAAlB,CAAP;IAEA,MAAMD,IAAI,GAAGnB,UAAU,CAACoB,IAAD,EAAO,CAAP,EAAU,IAAV,CAAvB;IACA,IAAID,IAAI,KAAKkH,SAAb,EACE,OAAO,IAAI7B,KAAJ,CAAU,8BAAV,CAAP;IAEF,IAAIgB,MAAM,GAAG,IAAb;IACA,IAAIC,MAAM,GAAG,IAAb;;IACA,QAAQtG,IAAR;MACE,KAAK,SAAL;QAAgB;UACd,MAAMsB,CAAC,GAAGzC,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;UACA,IAAIK,CAAC,KAAK4F,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,8BAAV,CAAP;UACF,MAAMhE,CAAC,GAAGxC,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;UACA,IAAII,CAAC,KAAK6F,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,8BAAV,CAAP;UACFgB,MAAM,GAAGjF,gBAAgB,CAACC,CAAD,EAAIC,CAAJ,CAAzB;UACAgF,MAAM,GAAGpE,gBAAgB,CAACb,CAAD,EAAIC,CAAJ,CAAzB;UACA;QACD;;MACD,KAAK,SAAL;QAAgB;UACd,MAAMkB,CAAC,GAAG3D,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;UACA,IAAIuB,CAAC,KAAK0E,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,8BAAV,CAAP;UACF,MAAM5C,CAAC,GAAG5D,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;UACA,IAAIwB,CAAC,KAAKyE,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,8BAAV,CAAP;UACF,MAAM3B,CAAC,GAAG7E,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;UACA,IAAIyC,CAAC,KAAKwD,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,8BAAV,CAAP;UACF,MAAM1B,CAAC,GAAG9E,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;UACA,IAAI0C,CAAC,KAAKuD,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,8BAAV,CAAP;UACFgB,MAAM,GAAG5C,gBAAgB,CAACjB,CAAD,EAAIC,CAAJ,EAAOiB,CAAP,EAAUC,CAAV,CAAzB;UACA2C,MAAM,GAAG1C,gBAAgB,CAACpB,CAAD,EAAIC,CAAJ,EAAOiB,CAAP,EAAUC,CAAV,CAAzB;UACA;QACD;;MACD;QACE,OAAO,IAAI0B,KAAJ,CAAU,8BAAV,CAAP;IA9BJ;;IAiCA,OAAO,IAAI2G,cAAJ,CAAmBhM,IAAnB,EAAyBmG,OAAzB,EAAkCE,MAAlC,EAA0CC,MAA1C,EAAkD,MAAlD,CAAP;EACD,CA3ED;AA4ED;;AAGD,SAASyF,QAAT,CAAkB9L,IAAlB,EAAwB6L,QAAxB,EAAkC3F,OAAlC,EAA2C0F,QAA3C,EAAqD;EACnD,IAAI,CAACa,kBAAkB,CAACZ,QAAD,CAAvB,EACE,OAAO,IAAIzG,KAAJ,CAAW,wCAAuCyG,QAAS,EAA3D,CAAP;EAEF,IAAI3G,IAAJ;EACA,IAAIV,GAAJ;EACA,IAAI4B,MAAM,GAAG,IAAb;EACA,IAAIC,MAAM,GAAG,IAAb;;EAEA,QAAQwF,QAAR;IACE,KAAK,SAAL;MAAgB;QACd,MAAMxK,CAAC,GAAGzC,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAL,IAAa,CAApB,CAApB;QACA,IAAIK,CAAC,KAAK4F,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,8BAAV,CAAP;QACF,MAAMhE,CAAC,GAAGxC,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;QACA,IAAII,CAAC,KAAK6F,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,8BAAV,CAAP;QACFgB,MAAM,GAAGjF,gBAAgB,CAACC,CAAD,EAAIC,CAAJ,CAAzB;QACAgF,MAAM,GAAGpE,gBAAgB,CAACb,CAAD,EAAIC,CAAJ,CAAzB;QACA6D,IAAI,GAAG,MAAP;QACA;MACD;;IACD,KAAK,SAAL;MAAgB;QACd,MAAM3C,CAAC,GAAG3D,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAL,IAAa,CAApB,CAApB;QACA,IAAIuB,CAAC,KAAK0E,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,8BAAV,CAAP;QACF,MAAM5C,CAAC,GAAG5D,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;QACA,IAAIwB,CAAC,KAAKyE,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,8BAAV,CAAP;QACF,MAAM3B,CAAC,GAAG7E,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;QACA,IAAIyC,CAAC,KAAKwD,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,8BAAV,CAAP;QACF,MAAM1B,CAAC,GAAG9E,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAZ,CAApB;QACA,IAAI0C,CAAC,KAAKuD,SAAV,EACE,OAAO,IAAI7B,KAAJ,CAAU,8BAAV,CAAP;QACFgB,MAAM,GAAG5C,gBAAgB,CAACjB,CAAD,EAAIC,CAAJ,EAAOiB,CAAP,EAAUC,CAAV,CAAzB;QACA2C,MAAM,GAAG1C,gBAAgB,CAACpB,CAAD,EAAIC,CAAJ,EAAOiB,CAAP,EAAUC,CAAV,CAAzB;QACAwB,IAAI,GAAG,MAAP;QACA;MACD;;IACD,KAAK,aAAL;MAAoB;QAClB,MAAM0D,KAAK,GAAGhK,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAL,IAAa,CAApB,CAAxB;QACA,IAAI4H,KAAK,KAAK3B,SAAV,IAAuB2B,KAAK,CAAClJ,MAAN,KAAiB,EAA5C,EACE,OAAO,IAAI0F,KAAJ,CAAU,8BAAV,CAAP;QACFgB,MAAM,GAAGtC,eAAe,CAAC8E,KAAD,CAAxB;QACAvC,MAAM,GAAGlC,eAAe,CAACyE,KAAD,CAAxB;QACA1D,IAAI,GAAG,IAAP;QACA;MACD;;IACD,KAAK,qBAAL;MACEA,IAAI,GAAG,QAAP;MACAV,GAAG,GAAG,qBAAN;IACF;;IACA,KAAK,qBAAL;MACE,IAAIU,IAAI,KAAK+B,SAAb,EAAwB;QACtB/B,IAAI,GAAG,QAAP;QACAV,GAAG,GAAG,cAAN;MACD;;IACH;;IACA,KAAK,qBAAL;MAA4B;QAC1B,IAAIU,IAAI,KAAK+B,SAAb,EAAwB;UACtB/B,IAAI,GAAG,QAAP;UACAV,GAAG,GAAG,cAAN;QACD,CAJyB,CAK1B;;;QACA,IAAI,CAAC7D,UAAU,CAACX,IAAD,EAAO,CAAP,CAAf,EAA0B;UACxB,OAAO,IAAIoF,KAAJ,CAAU,8BAAV,CAAP;QACF,MAAM0D,KAAK,GAAGlK,UAAU,CAACoB,IAAD,EAAOA,IAAI,CAACgB,IAAL,IAAa,CAApB,CAAxB;QACA,IAAI8H,KAAK,KAAK7B,SAAd,EACE,OAAO,IAAI7B,KAAJ,CAAU,8BAAV,CAAP;QACFgB,MAAM,GAAG7B,kBAAkB,CAACC,GAAD,EAAMsE,KAAN,CAA3B;QACAzC,MAAM,GAAG3B,kBAAkB,CAACF,GAAD,EAAMsE,KAAN,CAA3B;QACA;MACD;;IACD;MACE,OAAO,IAAI1D,KAAJ,CAAW,wCAAuCyG,QAAS,EAA3D,CAAP;EAlEJ;;EAqEA,OAAO,IAAIF,cAAJ,CAAmBC,QAAnB,EAA6B1F,OAA7B,EAAsCE,MAAtC,EAA8CC,MAA9C,EAAsDnB,IAAtD,CAAP;AACD;;AAED,SAASuH,kBAAT,CAA4B1M,IAA5B,EAAkC;EAChC,QAAQA,IAAR;IACE,KAAK,SAAL;IACA,KAAK,SAAL;IACA,KAAK,qBAAL;IACA,KAAK,qBAAL;IACA,KAAK,qBAAL;MACE,OAAO,IAAP;;IACF,KAAK,aAAL;MACE,IAAIvB,cAAJ,EACE,OAAO,IAAP;IACJ;;IACA;MACE,OAAO,KAAP;EAZJ;AAcD;;AAED,SAASkO,WAAT,CAAqBjD,GAArB,EAA0B;EACxB,IAAI,CAACA,GAAL,EACE,OAAO,KAAP;EACF,OAAQ,OAAOA,GAAG,CAACrK,aAAD,CAAV,KAA8B,SAAtC;AACD;;AAED,SAAS4G,QAAT,CAAkBhG,IAAlB,EAAwB2G,UAAxB,EAAoC;EAClC,IAAI+F,WAAW,CAAC1M,IAAD,CAAf,EACE,OAAOA,IAAP;EAEF,IAAI2M,UAAJ;;EACA,IAAInM,MAAM,CAACoM,QAAP,CAAgB5M,IAAhB,CAAJ,EAA2B;IACzB2M,UAAU,GAAG3M,IAAb;IACAA,IAAI,GAAGA,IAAI,CAACgH,SAAL,CAAe,CAAf,EAAkBhH,IAAI,CAACN,MAAvB,EAA+BmN,IAA/B,EAAP;EACD,CAHD,MAGO,IAAI,OAAO7M,IAAP,KAAgB,QAApB,EAA8B;IACnCA,IAAI,GAAGA,IAAI,CAAC6M,IAAL,EAAP;EACD,CAFM,MAEA;IACL,OAAO,IAAIzH,KAAJ,CAAU,qCAAV,CAAP;EACD,CAZiC,CAclC;;;EACA,IAAIuB,UAAU,IAAIM,SAAlB,EAA6B;IAC3B,IAAI,OAAON,UAAP,KAAsB,QAA1B,EACEA,UAAU,GAAGnG,MAAM,CAAC8C,IAAP,CAAYqD,UAAZ,CAAb,CADF,KAEK,IAAI,CAACnG,MAAM,CAACoM,QAAP,CAAgBjG,UAAhB,CAAL,EACH,OAAO,IAAIvB,KAAJ,CAAU,qDAAV,CAAP;EACH;;EAED,IAAI0B,GAAJ,CAtBkC,CAwBlC;EAEA;;EACA,IAAI,CAACA,GAAG,GAAGb,eAAe,CAACQ,KAAhB,CAAsBzG,IAAtB,EAA4B2G,UAA5B,CAAP,MAAoD,IAAxD,EACE,OAAOG,GAAP;EACF,IAAI,CAACA,GAAG,GAAGqC,mBAAmB,CAAC1C,KAApB,CAA0BzG,IAA1B,EAAgC2G,UAAhC,CAAP,MAAwD,IAA5D,EACE,OAAOG,GAAP;EACF,IAAI,CAACA,GAAG,GAAG6D,WAAW,CAAClE,KAAZ,CAAkBzG,IAAlB,EAAwB2G,UAAxB,CAAP,MAAgD,IAApD,EACE,OAAOG,GAAP,CAhCgC,CAkClC;;EACA,IAAI,CAACA,GAAG,GAAG6E,cAAc,CAAClF,KAAf,CAAqBzG,IAArB,CAAP,MAAuC,IAA3C,EACE,OAAO8G,GAAP;EACF,IAAI,CAACA,GAAG,GAAGiF,cAAc,CAACtF,KAAf,CAAqBzG,IAArB,CAAP,MAAuC,IAA3C,EACE,OAAO8G,GAAP,CAtCgC,CAwClC;;EACA,IAAI6F,UAAJ,EAAgB;IACd9M,eAAe,CAACiN,IAAhB,CAAqBH,UAArB,EAAiC,CAAjC;IACA,MAAM5M,IAAI,GAAGF,eAAe,CAACjB,UAAhB,CAA2B,IAA3B,CAAb;;IACA,IAAImB,IAAI,KAAKkH,SAAb,EAAwB;MACtBjH,IAAI,GAAGH,eAAe,CAACkN,OAAhB,EAAP;;MACA,IAAI/M,IAAI,KAAKiH,SAAb,EAAwB;QACtBH,GAAG,GAAGgF,QAAQ,CAAC9L,IAAD,EAAOD,IAAP,EAAa,EAAb,EAAiBA,IAAjB,CAAd,CADsB,CAEtB;QACA;;QACA,IAAI+G,GAAG,YAAY1B,KAAnB,EACE0B,GAAG,GAAG,IAAN;MACH;IACF;;IACDjH,eAAe,CAACmN,KAAhB;EACD;;EAED,IAAIlG,GAAJ,EACE,OAAOA,GAAP;EAEF,OAAO,IAAI1B,KAAJ,CAAU,wBAAV,CAAP;AACD;;AAED6H,MAAM,CAACC,OAAP,GAAiB;EACfR,WADe;EAEfD,kBAFe;EAGfU,WAAW,EAAE,CAACnN,IAAD,EAAOD,IAAP,KAAgB+L,QAAQ,CAAC9L,IAAD,EAAOD,IAAP,EAAa,EAAb,EAAiBA,IAAjB,CAHtB;EAIfiG;AAJe,CAAjB"},"metadata":{},"sourceType":"script"}