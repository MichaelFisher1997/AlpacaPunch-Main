{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('sodium-randbytes'), require('elliptic'), require('hash.js'), require('hmac-drbg'), require('@zilliqa-js/util'), require('tslib'), require('aes-js'), require('pbkdf2'), require('scrypt-js'), require('uuid')) : typeof define === 'function' && define.amd ? define(['exports', 'sodium-randbytes', 'elliptic', 'hash.js', 'hmac-drbg', '@zilliqa-js/util', 'tslib', 'aes-js', 'pbkdf2', 'scrypt-js', 'uuid'], factory) : factory(global.zjsCrypto = {}, global['sodium-randbytes'], global.elliptic, global.hash.js, global['hmac-drbg'], global['@zilliqa-js/util'], global.tslib, global['aes-js'], global.pbkdf2, global['scrypt-js'], global.uuid);\n})(this, function (exports, randbytes, elliptic, hashjs, DRBG, util, tslib, aes, pbkdf2, scrypt, uuid) {\n  'use strict';\n\n  randbytes = randbytes && randbytes.hasOwnProperty('default') ? randbytes['default'] : randbytes;\n  var elliptic__default = 'default' in elliptic ? elliptic['default'] : elliptic;\n  hashjs = hashjs && hashjs.hasOwnProperty('default') ? hashjs['default'] : hashjs;\n  DRBG = DRBG && DRBG.hasOwnProperty('default') ? DRBG['default'] : DRBG;\n  aes = aes && aes.hasOwnProperty('default') ? aes['default'] : aes;\n  scrypt = scrypt && scrypt.hasOwnProperty('default') ? scrypt['default'] : scrypt; //  Copyright (C) 2018 Zilliqa\n\n  var randomBytes = function (bytes) {\n    // For node enviroment, use sodium-native because we prefer kernel CSPRNG.\n    // References:\n    // - https://paragonie.com/blog/2016/05/how-generate-secure-random-numbers-in-various-programming-languages#nodejs-csprng\n    // - https://github.com/nodejs/node/issues/5798\n    var b = randbytes(bytes);\n    return b.toString('hex');\n  }; //  Copyright (C) 2018 Zilliqa\n\n\n  var secp256k1 = new elliptic.ec('secp256k1');\n  var curve = secp256k1.curve;\n  var PRIVKEY_SIZE_BYTES = 32; // Public key is a point (x, y) on the curve.\n  // Each coordinate requires 32 bytes.\n  // In its compressed form it suffices to store the x co-ordinate\n  // and the sign for y.\n  // Hence a total of 33 bytes.\n\n  var PUBKEY_COMPRESSED_SIZE_BYTES = 33; // Personalization string used for HMAC-DRBG instantiation.\n\n  var ALG = Buffer.from('Schnorr+SHA256  ', 'ascii'); // The length in bytes of the string above.\n\n  var ALG_LEN = 16; // The length in bytes of entropy inputs to HMAC-DRBG\n\n  var ENT_LEN = 32;\n  var HEX_ENC = 'hex';\n  /**\r\n   * generatePrivateKey\r\n   *\r\n   * @returns {string} - the hex-encoded private key\r\n   */\n\n  var generatePrivateKey$$1 = function () {\n    return secp256k1.genKeyPair({\n      entropy: randomBytes(secp256k1.curve.n.byteLength()),\n      entropyEnc: HEX_ENC,\n      pers: 'zilliqajs+secp256k1+SHA256'\n    }).getPrivate().toString(16, PRIVKEY_SIZE_BYTES * 2);\n  };\n  /**\r\n   * Hash (r | M).\r\n   * @param {Buffer} msg\r\n   * @param {BN} r\r\n   *\r\n   * @returns {Buffer}\r\n   */\n\n\n  var hash$$1 = function (q, pubkey, msg) {\n    var sha256 = hashjs.sha256();\n    var totalLength = PUBKEY_COMPRESSED_SIZE_BYTES * 2 + msg.byteLength; // 33 q + 33 pubkey + variable msgLen\n\n    var Q = q.toArrayLike(Buffer, 'be', 33);\n    var B = Buffer.allocUnsafe(totalLength);\n    Q.copy(B, 0);\n    pubkey.copy(B, 33);\n    msg.copy(B, 66);\n    return new util.BN(sha256.update(B).digest('hex'), 16);\n  };\n  /**\r\n   * sign\r\n   *\r\n   * @param {Buffer} msg\r\n   * @param {Buffer} key\r\n   * @param {Buffer} pubkey\r\n   *\r\n   * @returns {Signature}\r\n   */\n\n\n  var sign$$1 = function (msg, privKey, pubKey) {\n    var prv = new util.BN(privKey);\n    var drbg = getDRBG(msg);\n    var len = curve.n.byteLength();\n    var sig;\n\n    while (!sig) {\n      var k = new util.BN(drbg.generate(len));\n      sig = trySign$$1(msg, k, prv, pubKey);\n    }\n\n    return sig;\n  };\n  /**\r\n   * trySign\r\n   *\r\n   * @param {Buffer} msg - the message to sign over\r\n   * @param {BN} k - output of the HMAC-DRBG\r\n   * @param {BN} privateKey - the private key\r\n   * @param {Buffer} pubKey - the public key\r\n   *\r\n   * @returns {Signature | null =>}\r\n   */\n\n\n  var trySign$$1 = function (msg, k, privKey, pubKey) {\n    if (privKey.isZero()) {\n      throw new Error('Bad private key.');\n    }\n\n    if (privKey.gte(curve.n)) {\n      throw new Error('Bad private key.');\n    } // 1a. check that k is not 0\n\n\n    if (k.isZero()) {\n      return null;\n    } // 1b. check that k is < the order of the group\n\n\n    if (k.gte(curve.n)) {\n      return null;\n    } // 2. Compute commitment Q = kG, where g is the base point\n\n\n    var Q = curve.g.mul(k); // convert the commitment to octets first\n\n    var compressedQ = new util.BN(Q.encodeCompressed()); // 3. Compute the challenge r = H(Q || pubKey || msg)\n    // mod reduce the r value by the order of secp256k1, n\n\n    var r = hash$$1(compressedQ, pubKey, msg).umod(curve.n);\n    var h = r.clone();\n\n    if (h.isZero()) {\n      return null;\n    } // 4. Compute s = k - r * prv\n    // 4a. Compute r * prv\n\n\n    var s = h.imul(privKey).umod(curve.n); // 4b. Compute s = k - r * prv mod n\n\n    s = k.isub(s).umod(curve.n);\n\n    if (s.isZero()) {\n      return null;\n    }\n\n    return new Signature({\n      r: r,\n      s: s\n    });\n  };\n  /**\r\n   * Verify signature.\r\n   *\r\n   * @param {Buffer} msg\r\n   * @param {Buffer} signature\r\n   * @param {Buffer} key\r\n   *\r\n   * @returns {boolean}\r\n   *\r\n   * 1. Check if r,s is in [1, ..., order-1]\r\n   * 2. Compute Q = sG + r*kpub\r\n   * 3. If Q = O (the neutral point), return 0;\r\n   * 4. r' = H(Q, kpub, m)\r\n   * 5. return r' == r\r\n   */\n\n\n  var verify$$1 = function (msg, signature, key) {\n    var sig = new Signature(signature);\n\n    if (sig.s.isZero() || sig.r.isZero()) {\n      throw new Error('Invalid signature');\n    }\n\n    if (sig.s.isNeg() || sig.r.isNeg()) {\n      throw new Error('Invalid signature');\n    }\n\n    if (sig.s.gte(curve.n) || sig.r.gte(curve.n)) {\n      throw new Error('Invalid signature');\n    }\n\n    var kpub = curve.decodePoint(key);\n\n    if (!curve.validate(kpub)) {\n      throw new Error('Invalid public key');\n    }\n\n    var l = kpub.mul(sig.r);\n    var r = curve.g.mul(sig.s);\n    var Q = l.add(r);\n\n    if (Q.isInfinity()) {\n      throw new Error('Invalid intermediate point.');\n    }\n\n    var compressedQ = new util.BN(Q.encodeCompressed());\n    var r1 = hash$$1(compressedQ, key, msg).umod(curve.n);\n\n    if (r1.isZero()) {\n      throw new Error('Invalid hash.');\n    }\n\n    return r1.eq(sig.r);\n  };\n\n  var toSignature$$1 = function (serialised) {\n    var r = serialised.slice(0, 64);\n    var s = serialised.slice(64);\n    return new Signature({\n      r: r,\n      s: s\n    });\n  };\n  /**\r\n   * Instantiate an HMAC-DRBG.\r\n   *\r\n   * @param {Buffer} msg - used as nonce\r\n   *\r\n   * @returns {DRBG}\r\n   */\n\n\n  var getDRBG = function (msg) {\n    var entropy = randomBytes(ENT_LEN);\n    var pers = Buffer.allocUnsafe(ALG_LEN + ENT_LEN);\n    Buffer.from(randomBytes(ENT_LEN)).copy(pers, 0);\n    ALG.copy(pers, ENT_LEN);\n    return new DRBG({\n      hash: hashjs.sha256,\n      entropy: entropy,\n      nonce: msg,\n      pers: pers\n    });\n  };\n\n  var schnorr = /*#__PURE__*/Object.freeze({\n    generatePrivateKey: generatePrivateKey$$1,\n    hash: hash$$1,\n    sign: sign$$1,\n    trySign: trySign$$1,\n    verify: verify$$1,\n    toSignature: toSignature$$1\n  }); //  Copyright (C) 2018 Zilliqa\n  // This replaces `elliptic/lib/elliptic/ec/signature`.\n  // Q. Why do we replace `elliptic/lib/elliptic/ec/signature` with this?\n  // A. At the moment, Signature() in 'elliptic' is not exposed.\n\n  var Signature =\n  /** @class */\n  function () {\n    function Signature(options) {\n      var isValid = options.r && options.s;\n\n      if (!isValid) {\n        throw new Error('Signature without r or s');\n      }\n\n      this.r = new util.BN(options.r, 16);\n      this.s = new util.BN(options.s, 16);\n    }\n\n    return Signature;\n  }(); //  Copyright (C) 2018 Zilliqa\n  // This code is taken from https://github.com/sipa/bech32/tree/bdc264f84014c234e908d72026b7b780122be11f/ref/javascript\n  // Copyright (c) 2017 Pieter Wuille\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a copy\n  // of this software and associated documentation files (the \"Software\"), to deal\n  // in the Software without restriction, including without limitation the rights\n  // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  // copies of the Software, and to permit persons to whom the Software is\n  // furnished to do so, subject to the following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included in\n  // all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  // THE SOFTWARE.\n\n\n  var CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\n  var GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n\n  var polymod = function (values) {\n    var chk = 1;\n\n    for (var p = 0; p < values.length; ++p) {\n      var top_1 = chk >> 25;\n      chk = (chk & 0x1ffffff) << 5 ^ values[p];\n\n      for (var i = 0; i < 5; ++i) {\n        if (top_1 >> i & 1) {\n          chk ^= GENERATOR[i];\n        }\n      }\n    }\n\n    return chk;\n  };\n\n  var hrpExpand = function (hrp) {\n    var ret = [];\n    var p;\n\n    for (p = 0; p < hrp.length; ++p) {\n      ret.push(hrp.charCodeAt(p) >> 5);\n    }\n\n    ret.push(0);\n\n    for (p = 0; p < hrp.length; ++p) {\n      ret.push(hrp.charCodeAt(p) & 31);\n    }\n\n    return Buffer.from(ret);\n  };\n\n  function verifyChecksum(hrp, data) {\n    return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;\n  }\n\n  function createChecksum(hrp, data) {\n    var values = Buffer.concat([Buffer.from(hrpExpand(hrp)), data, Buffer.from([0, 0, 0, 0, 0, 0])]); // var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n\n    var mod = polymod(values) ^ 1;\n    var ret = [];\n\n    for (var p = 0; p < 6; ++p) {\n      ret.push(mod >> 5 * (5 - p) & 31);\n    }\n\n    return Buffer.from(ret);\n  }\n\n  var encode = function (hrp, data) {\n    var combined = Buffer.concat([data, createChecksum(hrp, data)]);\n    var ret = hrp + '1';\n\n    for (var p = 0; p < combined.length; ++p) {\n      ret += CHARSET.charAt(combined[p]);\n    }\n\n    return ret;\n  };\n\n  var decode = function (bechString) {\n    var p;\n    var hasLower = false;\n    var hasUpper = false;\n\n    for (p = 0; p < bechString.length; ++p) {\n      if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {\n        return null;\n      }\n\n      if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {\n        hasLower = true;\n      }\n\n      if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {\n        hasUpper = true;\n      }\n    }\n\n    if (hasLower && hasUpper) {\n      return null;\n    }\n\n    bechString = bechString.toLowerCase();\n    var pos = bechString.lastIndexOf('1');\n\n    if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {\n      return null;\n    }\n\n    var hrp = bechString.substring(0, pos);\n    var data = [];\n\n    for (p = pos + 1; p < bechString.length; ++p) {\n      var d = CHARSET.indexOf(bechString.charAt(p));\n\n      if (d === -1) {\n        return null;\n      }\n\n      data.push(d);\n    }\n\n    if (!verifyChecksum(hrp, Buffer.from(data))) {\n      return null;\n    }\n\n    return {\n      hrp: hrp,\n      data: Buffer.from(data.slice(0, data.length - 6))\n    };\n  }; // HRP is the human-readable part of zilliqa bech32 addresses\n\n\n  var HRP = 'zil';\n  /**\r\n   * convertBits\r\n   *\r\n   * groups buffers of a certain width to buffers of the desired width.\r\n   *\r\n   * For example, converts byte buffers to buffers of maximum 5 bit numbers,\r\n   * padding those numbers as necessary. Necessary for encoding Ethereum-style\r\n   * addresses as bech32 ones.\r\n   *\r\n   * @param {Buffer} data\r\n   * @param {number} fromWidth\r\n   * @param {number} toWidth\r\n   * @param {boolean} pad\r\n   * @returns {Buffer|null}\r\n   */\n\n  var convertBits = function (data, fromWidth, toWidth, pad) {\n    if (pad === void 0) {\n      pad = true;\n    }\n\n    var acc = 0;\n    var bits = 0;\n    var ret = [];\n    var maxv = (1 << toWidth) - 1;\n\n    for (var p = 0; p < data.length; ++p) {\n      var value = data[p];\n\n      if (value < 0 || value >> fromWidth !== 0) {\n        return null;\n      }\n\n      acc = acc << fromWidth | value;\n      bits += fromWidth;\n\n      while (bits >= toWidth) {\n        bits -= toWidth;\n        ret.push(acc >> bits & maxv);\n      }\n    }\n\n    if (pad) {\n      if (bits > 0) {\n        ret.push(acc << toWidth - bits & maxv);\n      }\n    } else if (bits >= fromWidth || acc << toWidth - bits & maxv) {\n      return null;\n    }\n\n    return Buffer.from(ret);\n  };\n  /**\r\n   * toBech32Address\r\n   *\r\n   * Encodes a canonical 20-byte Ethereum-style address as a bech32 zilliqa\r\n   * address.\r\n   *\r\n   * The expected format is zil1<address><checksum> where address and checksum\r\n   * are the result of bech32 encoding a Buffer containing the address bytes.\r\n   *\r\n   * @param {string} 20 byte canonical address\r\n   * @returns {string} 38 char bech32 encoded zilliqa address\r\n   */\n\n\n  var toBech32Address = function (address) {\n    if (!util.validation.isAddress(address)) {\n      throw new Error('Invalid address format.');\n    }\n\n    var addrBz = convertBits(Buffer.from(address.replace('0x', ''), 'hex'), 8, 5);\n\n    if (addrBz === null) {\n      throw new Error('Could not convert byte Buffer to 5-bit Buffer');\n    }\n\n    return encode(HRP, addrBz);\n  };\n  /**\r\n   * fromBech32Address\r\n   *\r\n   * @param {string} address - a valid Zilliqa bech32 address\r\n   * @returns {string} a canonical 20-byte Ethereum-style address\r\n   */\n\n\n  var fromBech32Address = function (address) {\n    var res = decode(address);\n\n    if (res === null) {\n      throw new Error('Invalid bech32 address');\n    }\n\n    var hrp = res.hrp,\n        data = res.data;\n    var shouldBe = HRP;\n\n    if (hrp !== shouldBe) {\n      throw new Error(\"Expected hrp to be \" + shouldBe + \" but got \" + hrp);\n    }\n\n    var buf = convertBits(data, 5, 8, false);\n\n    if (buf === null) {\n      throw new Error('Could not convert buffer to bytes');\n    }\n\n    return toChecksumAddress(buf.toString('hex'));\n  }; //  Copyright (C) 2018 Zilliqa\n\n\n  var secp256k1$1 = new elliptic__default.ec('secp256k1');\n  /**\r\n   * getAddressFromPrivateKey\r\n   *\r\n   * takes a hex-encoded string (private key) and returns its corresponding\r\n   * 20-byte hex-encoded address.\r\n   *\r\n   * @param {string} privateKey\r\n   * @returns {string}\r\n   */\n\n  var getAddressFromPrivateKey = function (privateKey) {\n    var normalizedPrviateKey = normalizePrivateKey(privateKey);\n    var keyPair = secp256k1$1.keyFromPrivate(normalizedPrviateKey, 'hex');\n    var pub = keyPair.getPublic(true, 'hex');\n    return toChecksumAddress(hashjs.sha256().update(pub, 'hex').digest('hex').slice(24));\n  };\n  /**\r\n   * getPubKeyFromPrivateKey\r\n   *\r\n   * takes a hex-encoded string (private key) and returns its corresponding\r\n   * hex-encoded 33-byte public key.\r\n   *\r\n   * @param {string} privateKey\r\n   * @returns {string}\r\n   */\n\n\n  var getPubKeyFromPrivateKey = function (privateKey) {\n    var normalizedPrviateKey = normalizePrivateKey(privateKey);\n    var keyPair = secp256k1$1.keyFromPrivate(normalizedPrviateKey, 'hex');\n    return keyPair.getPublic(true, 'hex');\n  };\n  /**\r\n   * getAccountFrom0xPrivateKey\r\n   *\r\n   * Utility method for recovering account from 0x private key.\r\n   * See https://github.com/Zilliqa/zilliqa-js/pull/159\r\n   * @param privateKeyWith0x : private key with 0x prefix\r\n   */\n\n\n  var getAccountFrom0xPrivateKey = function (privateKeyWith0x) {\n    var privateKeyWithout0x = normalizePrivateKey(privateKeyWith0x);\n    var keyPair = secp256k1$1.keyFromPrivate(privateKeyWith0x, 'hex');\n    var publicKeyWith0x = keyPair.getPublic(true, 'hex');\n    var addressWith0x = getAddressFromPublicKey(publicKeyWith0x);\n    var bech32With0x = toBech32Address(addressWith0x);\n    var with0x = {\n      prv: privateKeyWith0x,\n      pub: publicKeyWith0x,\n      addr: addressWith0x,\n      bech32: bech32With0x\n    };\n    var keyPair2 = secp256k1$1.keyFromPrivate(privateKeyWithout0x, 'hex');\n    var publicKeyWithout0x = keyPair2.getPublic(true, 'hex');\n    var addressWithout0x = getAddressFromPublicKey(publicKeyWithout0x);\n    var bech32Without0x = toBech32Address(addressWithout0x);\n    var without0x = {\n      prv: privateKeyWithout0x,\n      pub: publicKeyWithout0x,\n      addr: addressWithout0x,\n      bech32: bech32Without0x\n    };\n    var privateKeyAfterChange = keyPair.getPrivate('hex');\n    var publicKeyAfterChange = keyPair.getPublic(true, 'hex');\n    var addressAfterChange = getAddressFromPublicKey(publicKeyAfterChange);\n    var bech32AfterChange = toBech32Address(addressAfterChange);\n    var changed = {\n      prv: privateKeyAfterChange,\n      pub: publicKeyAfterChange,\n      addr: addressAfterChange,\n      bech32: bech32AfterChange\n    };\n    return {\n      with0x: with0x,\n      without0x: without0x,\n      changed: changed\n    };\n  };\n  /**\r\n   * compressPublicKey\r\n   *\r\n   * @param {string} publicKey - 65-byte public key, a point (x, y)\r\n   *\r\n   * @returns {string}\r\n   */\n\n\n  var compressPublicKey = function (publicKey) {\n    return secp256k1$1.keyFromPublic(publicKey, 'hex').getPublic(true, 'hex');\n  };\n  /**\r\n   * getAddressFromPublicKey\r\n   *\r\n   * takes hex-encoded string and returns the corresponding address\r\n   *\r\n   * @param {string} pubKey\r\n   * @returns {string}\r\n   */\n\n\n  var getAddressFromPublicKey = function (publicKey) {\n    var normalized = publicKey.toLowerCase().replace('0x', '');\n    return toChecksumAddress(hashjs.sha256().update(normalized, 'hex').digest('hex').slice(24));\n  };\n  /**\r\n   * toChecksumAddress\r\n   *\r\n   * takes hex-encoded string and returns the corresponding address\r\n   *\r\n   * @param {string} address\r\n   * @returns {string}\r\n   */\n\n\n  var toChecksumAddress = function (address) {\n    if (!util.validation.isAddress(address)) {\n      throw new Error(address + \" is not a valid base 16 address\");\n    }\n\n    address = address.toLowerCase().replace('0x', '');\n    var hash = hashjs.sha256().update(address, 'hex').digest('hex');\n    var v = new util.BN(hash, 'hex', 'be');\n    var ret = '0x';\n\n    for (var i = 0; i < address.length; i++) {\n      if ('0123456789'.indexOf(address[i]) !== -1) {\n        ret += address[i];\n      } else {\n        ret += v.and(new util.BN(2).pow(new util.BN(255 - 6 * i))).gte(new util.BN(1)) ? address[i].toUpperCase() : address[i].toLowerCase();\n      }\n    }\n\n    return ret;\n  };\n  /**\r\n   * isValidChecksumAddress\r\n   *\r\n   * takes hex-encoded string and returns boolean if address is checksumed\r\n   *\r\n   * @param {string} address\r\n   * @returns {boolean}\r\n   */\n\n\n  var isValidChecksumAddress = function (address) {\n    return util.validation.isAddress(address.replace('0x', '')) && toChecksumAddress(address) === address;\n  };\n  /**\r\n   * normaliseAddress\r\n   *\r\n   * takes in a base16 address or a zilliqa bech32 encoded address\r\n   * and returns a checksum base16 address. If the address is neither a base16\r\n   * nor bech32 address, the code will return an error\r\n   * @param {string)} address\r\n   * @returns {string}\r\n   */\n\n\n  var normaliseAddress = function (address) {\n    if (util.validation.isBech32(address)) {\n      return fromBech32Address(address);\n    }\n\n    if (!isValidChecksumAddress(address)) {\n      throw Error('Wrong address format, should be either bech32 or checksummed address');\n    }\n\n    return address;\n  };\n  /**\r\n   * encodeBase58 - may be required for DID public key\r\n   * undeprecating this function after version 2.0.0\r\n   *\r\n   * @param {string} hex - base 16 encoded string\r\n   * @returns {string} - big endian base 58 encoded string\r\n   */\n\n\n  var encodeBase58 = function (hex) {\n    var clean = hex.toLowerCase().replace('0x', '');\n    var tbl = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n    var base = new util.BN(58);\n    var zero = new util.BN(0);\n    var x = new util.BN(clean, 16);\n    var res = '';\n\n    while (x.gt(zero)) {\n      var rem = x.mod(base).toNumber(); // safe, always < 58\n      // big endian\n\n      res = tbl[rem] + res; // quotient, remainders thrown away in integer division\n\n      x = x.div(base);\n    } // convert to big endian in case the input hex is little endian\n\n\n    var hexBE = x.toString('hex', clean.length);\n\n    for (var i = 0; i < hexBE.length; i += 2) {\n      if (hex[i] === '0' && hex[i + 1] === '0') {\n        res = tbl[0] + res;\n      } else {\n        break;\n      }\n    }\n\n    return res;\n  };\n  /**\r\n   * decodeBase58 - may be required for DID public key\r\n   * undeprecating this function after version 2.0.0\r\n   *\r\n   * @param {string} raw - base 58 string\r\n   * @returns {string} - big endian base 16 string\r\n   */\n\n\n  var decodeBase58 = function (raw) {\n    var tbl = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n    var base = new util.BN(58);\n    var zero = new util.BN(0);\n    var isBreak = false;\n    var n = new util.BN(0);\n    var leader = '';\n\n    for (var i = 0; i < raw.length; i++) {\n      var char = raw.charAt(i);\n      var weight = new util.BN(tbl.indexOf(char));\n      n = n.mul(base).add(weight); // check if padding required\n\n      if (!isBreak) {\n        if (i - 1 > 0 && raw[i - 1] !== '1') {\n          isBreak = true;\n          continue;\n        }\n\n        if (char === '1') {\n          leader += '00';\n        }\n      }\n    }\n\n    if (n.eq(zero)) {\n      return leader;\n    }\n\n    var res = leader + n.toString('hex');\n\n    if (res.length % 2 !== 0) {\n      res = '0' + res;\n    }\n\n    return res;\n  };\n  /**\r\n   * verifyPrivateKey\r\n   *\r\n   * @param {string|Buffer} privateKey\r\n   * @returns {boolean}\r\n   */\n\n\n  var verifyPrivateKey = function (privateKey) {\n    var keyPair = secp256k1$1.keyFromPrivate(privateKey, 'hex');\n    var result = keyPair.validate().result;\n    return result;\n  };\n  /**\r\n   * normalizePrivateKey : normalise private key from 0x or without 0x prefix\r\n   *\r\n   * @param {string} privateKey\r\n   * @returns {string}\r\n   */\n\n\n  var normalizePrivateKey = function (privateKey) {\n    try {\n      if (!util.validation.isPrivateKey(privateKey)) {\n        throw new Error('Private key is not correct');\n      }\n\n      var normalized = privateKey.toLowerCase().replace('0x', '');\n\n      if (!verifyPrivateKey(normalized)) {\n        throw new Error('Private key is not correct');\n      }\n\n      return normalized;\n    } catch (error) {\n      throw error;\n    }\n  }; //  Copyright (C) 2018 Zilliqa\n\n\n  var ALGO_IDENTIFIER = 'aes-128-ctr';\n  /**\r\n   * getDerivedKey\r\n   *\r\n   * NOTE: only scrypt and pbkdf2 are supported.\r\n   *\r\n   * @param {Buffer} key - the passphrase\r\n   * @param {KDF} kdf - the key derivation function to be used\r\n   * @param {KDFParams} params - params for the kdf\r\n   *\r\n   * @returns {Promise<Buffer>}\r\n   */\n\n  function getDerivedKey(key, kdf, params) {\n    return tslib.__awaiter(this, void 0, void 0, function () {\n      var salt, _a, c, dklen, _b, n, r, p, dklen, derivedKeyInt8Array;\n\n      return tslib.__generator(this, function (_c) {\n        salt = Buffer.from(params.salt, 'hex');\n\n        if (kdf === 'pbkdf2') {\n          _a = params, c = _a.c, dklen = _a.dklen;\n          return [2\n          /*return*/\n          , pbkdf2.pbkdf2Sync(key, salt, c, dklen, 'sha256')];\n        }\n\n        if (kdf === 'scrypt') {\n          _b = params, n = _b.n, r = _b.r, p = _b.p, dklen = _b.dklen;\n          derivedKeyInt8Array = scrypt.syncScrypt(key, salt, n, r, p, dklen);\n          return [2\n          /*return*/\n          , Buffer.from(derivedKeyInt8Array)];\n        }\n\n        throw new Error('Only pbkdf2 and scrypt are supported');\n      });\n    });\n  }\n  /**\r\n   * encryptPrivateKey\r\n   *\r\n   * Encodes and encrypts an account in the format specified by\r\n   * https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition.\r\n   * However, note that, in keeping with the hash function used by Zilliqa's\r\n   * core protocol, the MAC is generated using sha256 instead of keccak.\r\n   *\r\n   * NOTE: only scrypt and pbkdf2 are supported.\r\n   *\r\n   * @param {KDF} kdf - the key derivation function to be used\r\n   * @param {string} privateKey - hex-encoded private key\r\n   * @param {string} passphrase - a passphrase used for encryption\r\n   *\r\n   * @returns {Promise<string>}\r\n   */\n\n\n  var encryptPrivateKey = function (kdf, privateKey, passphrase) {\n    return tslib.__awaiter(void 0, void 0, void 0, function () {\n      var address, salt, iv, kdfparams, derivedKey, cipher, ciphertext;\n      return tslib.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            address = getAddressFromPrivateKey(privateKey);\n            salt = randomBytes(32);\n            iv = Buffer.from(randomBytes(16), 'hex');\n            kdfparams = {\n              salt: salt,\n              n: 8192,\n              c: 262144,\n              r: 8,\n              p: 1,\n              dklen: 32\n            };\n            return [4\n            /*yield*/\n            , getDerivedKey(Buffer.from(passphrase), kdf, kdfparams)];\n\n          case 1:\n            derivedKey = _a.sent();\n            cipher = new aes.ModeOfOperation.ctr(derivedKey.slice(0, 16), new aes.Counter(iv));\n            ciphertext = Buffer.from(cipher.encrypt(Buffer.from(privateKey, 'hex')));\n            return [2\n            /*return*/\n            , JSON.stringify({\n              address: address,\n              crypto: {\n                cipher: ALGO_IDENTIFIER,\n                cipherparams: {\n                  iv: iv.toString('hex')\n                },\n                ciphertext: ciphertext.toString('hex'),\n                kdf: kdf,\n                kdfparams: kdfparams,\n                mac: hashjs // @ts-ignore\n                .hmac(hashjs.sha256, derivedKey, 'hex').update(Buffer.concat([derivedKey.slice(16, 32), ciphertext, iv, Buffer.from(ALGO_IDENTIFIER)]), 'hex').digest('hex')\n              },\n              id: uuid.v4({\n                random: util.bytes.hexToIntArray(randomBytes(16))\n              }),\n              version: 3\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   * decryptPrivateKey\r\n   *\r\n   * Recovers the private key from a keystore file using the given passphrase.\r\n   *\r\n   * @param {string} passphrase\r\n   * @param {KeystoreV3} keystore\r\n   * @returns {Promise<string>}\r\n   */\n\n\n  var decryptPrivateKey = function (passphrase, keystore) {\n    return tslib.__awaiter(void 0, void 0, void 0, function () {\n      var ciphertext, iv, kdfparams, derivedKey, mac, cipher;\n      return tslib.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ciphertext = Buffer.from(keystore.crypto.ciphertext, 'hex');\n            iv = Buffer.from(keystore.crypto.cipherparams.iv, 'hex');\n            kdfparams = keystore.crypto.kdfparams;\n            return [4\n            /*yield*/\n            , getDerivedKey(Buffer.from(passphrase), keystore.crypto.kdf, kdfparams)];\n\n          case 1:\n            derivedKey = _a.sent();\n            mac = hashjs // @ts-ignore\n            .hmac(hashjs.sha256, derivedKey, 'hex').update(Buffer.concat([derivedKey.slice(16, 32), ciphertext, iv, Buffer.from(ALGO_IDENTIFIER)]), 'hex').digest('hex'); // we need to do a byte-by-byte comparison to avoid non-constant time side\n            // channel attacks.\n\n            if (!util.bytes.isEqual(mac.toUpperCase(), keystore.crypto.mac.toUpperCase())) {\n              return [2\n              /*return*/\n              , Promise.reject('Failed to decrypt.')];\n            }\n\n            cipher = new aes.ModeOfOperation.ctr(derivedKey.slice(0, 16), new aes.Counter(iv));\n            return [2\n            /*return*/\n            , Buffer.from(cipher.decrypt(ciphertext)).toString('hex')];\n        }\n      });\n    });\n  }; //  Copyright (C) 2018 Zilliqa\n  //  Copyright (C) 2018 Zilliqa\n\n  /**\r\n   * sign\r\n   *\r\n   * @param {string} hash - hex-encoded hash of the data to be signed\r\n   *\r\n   * @returns {string} the signature\r\n   */\n\n\n  var sign$1 = function (msg, privateKey, pubKey) {\n    var sig = sign$$1(msg, Buffer.from(privateKey, 'hex'), Buffer.from(pubKey, 'hex'));\n    var r = sig.r.toString('hex');\n    var s = sig.s.toString('hex');\n\n    while (r.length < 64) {\n      r = '0' + r;\n    }\n\n    while (s.length < 64) {\n      s = '0' + s;\n    }\n\n    return r + s;\n  };\n\n  exports.sign = sign$1;\n  exports.schnorr = schnorr;\n  exports.Signature = Signature;\n  exports.getAddressFromPrivateKey = getAddressFromPrivateKey;\n  exports.getPubKeyFromPrivateKey = getPubKeyFromPrivateKey;\n  exports.getAccountFrom0xPrivateKey = getAccountFrom0xPrivateKey;\n  exports.compressPublicKey = compressPublicKey;\n  exports.getAddressFromPublicKey = getAddressFromPublicKey;\n  exports.toChecksumAddress = toChecksumAddress;\n  exports.isValidChecksumAddress = isValidChecksumAddress;\n  exports.normaliseAddress = normaliseAddress;\n  exports.encodeBase58 = encodeBase58;\n  exports.decodeBase58 = decodeBase58;\n  exports.verifyPrivateKey = verifyPrivateKey;\n  exports.normalizePrivateKey = normalizePrivateKey;\n  exports.encryptPrivateKey = encryptPrivateKey;\n  exports.decryptPrivateKey = decryptPrivateKey;\n  exports.randomBytes = randomBytes;\n  exports.encode = encode;\n  exports.decode = decode;\n  exports.HRP = HRP;\n  exports.convertBits = convertBits;\n  exports.toBech32Address = toBech32Address;\n  exports.fromBech32Address = fromBech32Address;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"mappings":"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","names":["randomBytes","bytes","b","randbytes","toString","secp256k1","ec","curve","PRIVKEY_SIZE_BYTES","PUBKEY_COMPRESSED_SIZE_BYTES","ALG","Buffer","from","ALG_LEN","ENT_LEN","HEX_ENC","generatePrivateKey","genKeyPair","entropy","n","byteLength","entropyEnc","pers","getPrivate","hash","q","pubkey","msg","sha256","hashjs","totalLength","Q","toArrayLike","B","allocUnsafe","copy","BN","update","digest","sign","privKey","pubKey","prv","drbg","getDRBG","len","sig","k","generate","trySign","isZero","Error","gte","g","mul","compressedQ","encodeCompressed","r","umod","h","clone","s","imul","isub","Signature","verify","signature","key","isNeg","kpub","decodePoint","validate","l","add","isInfinity","r1","eq","toSignature","serialised","slice","DRBG","nonce","options","isValid","CHARSET","GENERATOR","polymod","values","chk","p","length","top_1","i","hrpExpand","hrp","ret","push","charCodeAt","verifyChecksum","data","concat","createChecksum","mod","encode","combined","charAt","decode","bechString","hasLower","hasUpper","toLowerCase","pos","lastIndexOf","substring","d","indexOf","HRP","convertBits","fromWidth","toWidth","pad","acc","bits","maxv","value","toBech32Address","address","validation","isAddress","addrBz","replace","fromBech32Address","res","shouldBe","buf","toChecksumAddress","elliptic","getAddressFromPrivateKey","privateKey","normalizedPrviateKey","normalizePrivateKey","keyPair","keyFromPrivate","pub","getPublic","getPubKeyFromPrivateKey","getAccountFrom0xPrivateKey","privateKeyWith0x","privateKeyWithout0x","publicKeyWith0x","addressWith0x","getAddressFromPublicKey","bech32With0x","with0x","addr","bech32","keyPair2","publicKeyWithout0x","addressWithout0x","bech32Without0x","without0x","privateKeyAfterChange","publicKeyAfterChange","addressAfterChange","bech32AfterChange","changed","compressPublicKey","publicKey","keyFromPublic","normalized","v","and","pow","toUpperCase","isValidChecksumAddress","normaliseAddress","isBech32","encodeBase58","hex","clean","tbl","base","zero","x","gt","rem","toNumber","div","hexBE","decodeBase58","raw","isBreak","leader","char","weight","verifyPrivateKey","result","isPrivateKey","error","ALGO_IDENTIFIER","getDerivedKey","kdf","params","salt","_a","c","dklen","pbkdf2Sync","_b","derivedKeyInt8Array","scrypt","syncScrypt","encryptPrivateKey","passphrase","iv","kdfparams","derivedKey","cipher","aes","ModeOfOperation","ctr","Counter","ciphertext","encrypt","JSON","stringify","crypto","cipherparams","mac","hmac","id","uuidv4","random","hexToIntArray","version","decryptPrivateKey","keystore","isEqual","Promise","reject","decrypt","schnorr.sign"],"sources":["/home/micqdf/Documents/this/test1/client/node_modules/@zilliqa-js/crypto/src/random.ts","/home/micqdf/Documents/this/test1/client/node_modules/@zilliqa-js/crypto/src/schnorr.ts","/home/micqdf/Documents/this/test1/client/node_modules/@zilliqa-js/crypto/src/signature.ts","/home/micqdf/Documents/this/test1/client/node_modules/@zilliqa-js/crypto/src/bech32.ts","/home/micqdf/Documents/this/test1/client/node_modules/@zilliqa-js/crypto/src/util.ts","/home/micqdf/Documents/this/test1/client/node_modules/@zilliqa-js/crypto/src/keystore.ts","/home/micqdf/Documents/this/test1/client/node_modules/@zilliqa-js/crypto/src/types.ts","/home/micqdf/Documents/this/test1/client/node_modules/@zilliqa-js/crypto/src/index.ts"],"sourcesContent":["//  Copyright (C) 2018 Zilliqa\n//\n//  This file is part of zilliqa-js\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  This program is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * randomBytes\n *\n * Uses JS-native CSPRNG to generate a specified number of bytes.\n * NOTE: this method throws if no PRNG is available.\n *\n * @param {number} bytes\n * @returns {string}\n */\n\nimport randbytes from 'sodium-randbytes';\n\nexport const randomBytes = (bytes: number) => {\n  // For node enviroment, use sodium-native because we prefer kernel CSPRNG.\n  // References:\n  // - https://paragonie.com/blog/2016/05/how-generate-secure-random-numbers-in-various-programming-languages#nodejs-csprng\n  // - https://github.com/nodejs/node/issues/5798\n  const b = randbytes(bytes);\n  return b.toString('hex');\n};\n","//  Copyright (C) 2018 Zilliqa\n//\n//  This file is part of zilliqa-js\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  This program is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport { ec } from 'elliptic';\nimport hashjs from 'hash.js';\nimport DRBG from 'hmac-drbg';\n\nimport { BN } from '@zilliqa-js/util';\n\nimport { randomBytes } from './random';\nimport { Signature } from '.';\n\nconst secp256k1 = new ec('secp256k1');\nconst curve = secp256k1.curve;\nconst PRIVKEY_SIZE_BYTES = 32;\n// Public key is a point (x, y) on the curve.\n// Each coordinate requires 32 bytes.\n// In its compressed form it suffices to store the x co-ordinate\n// and the sign for y.\n// Hence a total of 33 bytes.\nconst PUBKEY_COMPRESSED_SIZE_BYTES = 33;\n// Personalization string used for HMAC-DRBG instantiation.\nconst ALG = Buffer.from('Schnorr+SHA256  ', 'ascii');\n// The length in bytes of the string above.\nconst ALG_LEN = 16;\n// The length in bytes of entropy inputs to HMAC-DRBG\nconst ENT_LEN = 32;\n\nconst HEX_ENC: 'hex' = 'hex';\n\n/**\n * generatePrivateKey\n *\n * @returns {string} - the hex-encoded private key\n */\nexport const generatePrivateKey = (): string => {\n  return secp256k1\n    .genKeyPair({\n      entropy: randomBytes(secp256k1.curve.n.byteLength()),\n      entropyEnc: HEX_ENC,\n      pers: 'zilliqajs+secp256k1+SHA256',\n    })\n    .getPrivate()\n    .toString(16, PRIVKEY_SIZE_BYTES * 2);\n};\n\n/**\n * Hash (r | M).\n * @param {Buffer} msg\n * @param {BN} r\n *\n * @returns {Buffer}\n */\n\nexport const hash = (q: BN, pubkey: Buffer, msg: Buffer) => {\n  const sha256 = hashjs.sha256();\n  const totalLength = PUBKEY_COMPRESSED_SIZE_BYTES * 2 + msg.byteLength; // 33 q + 33 pubkey + variable msgLen\n  const Q = q.toArrayLike(Buffer, 'be', 33);\n  const B = Buffer.allocUnsafe(totalLength);\n\n  Q.copy(B, 0);\n  pubkey.copy(B, 33);\n  msg.copy(B, 66);\n\n  return new BN(sha256.update(B).digest('hex'), 16);\n};\n\n/**\n * sign\n *\n * @param {Buffer} msg\n * @param {Buffer} key\n * @param {Buffer} pubkey\n *\n * @returns {Signature}\n */\nexport const sign = (\n  msg: Buffer,\n  privKey: Buffer,\n  pubKey: Buffer,\n): Signature => {\n  const prv = new BN(privKey);\n  const drbg = getDRBG(msg);\n  const len = curve.n.byteLength();\n\n  let sig;\n  while (!sig) {\n    const k = new BN(drbg.generate(len));\n    sig = trySign(msg, k, prv, pubKey);\n  }\n\n  return sig;\n};\n\n/**\n * trySign\n *\n * @param {Buffer} msg - the message to sign over\n * @param {BN} k - output of the HMAC-DRBG\n * @param {BN} privateKey - the private key\n * @param {Buffer} pubKey - the public key\n *\n * @returns {Signature | null =>}\n */\nexport const trySign = (\n  msg: Buffer,\n  k: BN,\n  privKey: BN,\n  pubKey: Buffer,\n): Signature | null => {\n  if (privKey.isZero()) {\n    throw new Error('Bad private key.');\n  }\n\n  if (privKey.gte(curve.n)) {\n    throw new Error('Bad private key.');\n  }\n\n  // 1a. check that k is not 0\n  if (k.isZero()) {\n    return null;\n  }\n  // 1b. check that k is < the order of the group\n  if (k.gte(curve.n)) {\n    return null;\n  }\n\n  // 2. Compute commitment Q = kG, where g is the base point\n  const Q = curve.g.mul(k);\n  // convert the commitment to octets first\n  const compressedQ = new BN(Q.encodeCompressed());\n\n  // 3. Compute the challenge r = H(Q || pubKey || msg)\n  // mod reduce the r value by the order of secp256k1, n\n  const r = hash(compressedQ, pubKey, msg).umod(curve.n);\n  const h = r.clone();\n\n  if (h.isZero()) {\n    return null;\n  }\n\n  // 4. Compute s = k - r * prv\n  // 4a. Compute r * prv\n  let s = h.imul(privKey).umod(curve.n);\n  // 4b. Compute s = k - r * prv mod n\n  s = k.isub(s).umod(curve.n);\n\n  if (s.isZero()) {\n    return null;\n  }\n\n  return new Signature({ r, s });\n};\n\n/**\n * Verify signature.\n *\n * @param {Buffer} msg\n * @param {Buffer} signature\n * @param {Buffer} key\n *\n * @returns {boolean}\n *\n * 1. Check if r,s is in [1, ..., order-1]\n * 2. Compute Q = sG + r*kpub\n * 3. If Q = O (the neutral point), return 0;\n * 4. r' = H(Q, kpub, m)\n * 5. return r' == r\n */\nexport const verify = (msg: Buffer, signature: Signature, key: Buffer) => {\n  const sig = new Signature(signature);\n\n  if (sig.s.isZero() || sig.r.isZero()) {\n    throw new Error('Invalid signature');\n  }\n\n  if (sig.s.isNeg() || sig.r.isNeg()) {\n    throw new Error('Invalid signature');\n  }\n\n  if (sig.s.gte(curve.n) || sig.r.gte(curve.n)) {\n    throw new Error('Invalid signature');\n  }\n\n  const kpub = curve.decodePoint(key);\n  if (!curve.validate(kpub)) {\n    throw new Error('Invalid public key');\n  }\n\n  const l = kpub.mul(sig.r);\n  const r = curve.g.mul(sig.s);\n\n  const Q = l.add(r);\n\n  if (Q.isInfinity()) {\n    throw new Error('Invalid intermediate point.');\n  }\n\n  const compressedQ = new BN(Q.encodeCompressed());\n\n  const r1 = hash(compressedQ, key, msg).umod(curve.n);\n\n  if (r1.isZero()) {\n    throw new Error('Invalid hash.');\n  }\n\n  return r1.eq(sig.r);\n};\n\nexport const toSignature = (serialised: string): Signature => {\n  const r = serialised.slice(0, 64);\n  const s = serialised.slice(64);\n\n  return new Signature({ r, s });\n};\n\n/**\n * Instantiate an HMAC-DRBG.\n *\n * @param {Buffer} msg - used as nonce\n *\n * @returns {DRBG}\n */\nconst getDRBG = (msg: Buffer) => {\n  const entropy = randomBytes(ENT_LEN);\n  const pers = Buffer.allocUnsafe(ALG_LEN + ENT_LEN);\n\n  Buffer.from(randomBytes(ENT_LEN)).copy(pers, 0);\n  ALG.copy(pers, ENT_LEN);\n\n  return new DRBG({\n    hash: hashjs.sha256,\n    entropy,\n    nonce: msg,\n    pers,\n  });\n};\n","//  Copyright (C) 2018 Zilliqa\n//\n//  This file is part of zilliqa-js\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  This program is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport { BN } from '@zilliqa-js/util';\n\ninterface SignatureOptions {\n  r: number | string | number[] | Uint8Array | Buffer | BN;\n  s: number | string | number[] | Uint8Array | Buffer | BN;\n}\n\n// This replaces `elliptic/lib/elliptic/ec/signature`.\n// Q. Why do we replace `elliptic/lib/elliptic/ec/signature` with this?\n// A. At the moment, Signature() in 'elliptic' is not exposed.\nexport class Signature {\n  r: BN;\n  s: BN;\n  constructor(options: SignatureOptions) {\n    const isValid = options.r && options.s;\n    if (!isValid) {\n      throw new Error('Signature without r or s');\n    }\n    this.r = new BN(options.r, 16);\n    this.s = new BN(options.s, 16);\n  }\n}\n","//  Copyright (C) 2018 Zilliqa\n//\n//  This file is part of zilliqa-js\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  This program is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport { validation } from '@zilliqa-js/util';\n\nimport { toChecksumAddress } from './util';\n// This code is taken from https://github.com/sipa/bech32/tree/bdc264f84014c234e908d72026b7b780122be11f/ref/javascript\n// Copyright (c) 2017 Pieter Wuille\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nconst CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n\nconst polymod = (values: Buffer): number => {\n  let chk = 1;\n  for (let p = 0; p < values.length; ++p) {\n    const top = chk >> 25;\n    chk = ((chk & 0x1ffffff) << 5) ^ values[p];\n    for (let i = 0; i < 5; ++i) {\n      if ((top >> i) & 1) {\n        chk ^= GENERATOR[i];\n      }\n    }\n  }\n  return chk;\n};\n\nconst hrpExpand = (hrp: string): Buffer => {\n  const ret = [];\n  let p;\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) >> 5);\n  }\n  ret.push(0);\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) & 31);\n  }\n  return Buffer.from(ret);\n};\n\nfunction verifyChecksum(hrp: string, data: Buffer) {\n  return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;\n}\n\nfunction createChecksum(hrp: string, data: Buffer) {\n  const values = Buffer.concat([\n    Buffer.from(hrpExpand(hrp)),\n    data,\n    Buffer.from([0, 0, 0, 0, 0, 0]),\n  ]);\n  // var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n  const mod = polymod(values) ^ 1;\n  const ret = [];\n  for (let p = 0; p < 6; ++p) {\n    ret.push((mod >> (5 * (5 - p))) & 31);\n  }\n  return Buffer.from(ret);\n}\n\nexport const encode = (hrp: string, data: Buffer) => {\n  const combined = Buffer.concat([data, createChecksum(hrp, data)]);\n  let ret = hrp + '1';\n  for (let p = 0; p < combined.length; ++p) {\n    ret += CHARSET.charAt(combined[p]);\n  }\n  return ret;\n};\n\nexport const decode = (bechString: string) => {\n  let p;\n  let hasLower = false;\n  let hasUpper = false;\n  for (p = 0; p < bechString.length; ++p) {\n    if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {\n      return null;\n    }\n    if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {\n      hasLower = true;\n    }\n    if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {\n      hasUpper = true;\n    }\n  }\n  if (hasLower && hasUpper) {\n    return null;\n  }\n  bechString = bechString.toLowerCase();\n  const pos = bechString.lastIndexOf('1');\n  if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {\n    return null;\n  }\n  const hrp = bechString.substring(0, pos);\n  const data = [];\n  for (p = pos + 1; p < bechString.length; ++p) {\n    const d = CHARSET.indexOf(bechString.charAt(p));\n    if (d === -1) {\n      return null;\n    }\n    data.push(d);\n  }\n\n  if (!verifyChecksum(hrp, Buffer.from(data))) {\n    return null;\n  }\n\n  return { hrp, data: Buffer.from(data.slice(0, data.length - 6)) };\n};\n\n// HRP is the human-readable part of zilliqa bech32 addresses\nexport const HRP = 'zil';\n\n/**\n * convertBits\n *\n * groups buffers of a certain width to buffers of the desired width.\n *\n * For example, converts byte buffers to buffers of maximum 5 bit numbers,\n * padding those numbers as necessary. Necessary for encoding Ethereum-style\n * addresses as bech32 ones.\n *\n * @param {Buffer} data\n * @param {number} fromWidth\n * @param {number} toWidth\n * @param {boolean} pad\n * @returns {Buffer|null}\n */\nexport const convertBits = (\n  data: Buffer,\n  fromWidth: number,\n  toWidth: number,\n  pad: boolean = true,\n) => {\n  let acc = 0;\n  let bits = 0;\n  const ret = [];\n  const maxv = (1 << toWidth) - 1;\n  for (let p = 0; p < data.length; ++p) {\n    const value = data[p];\n    if (value < 0 || value >> fromWidth !== 0) {\n      return null;\n    }\n    acc = (acc << fromWidth) | value;\n    bits += fromWidth;\n    while (bits >= toWidth) {\n      bits -= toWidth;\n      ret.push((acc >> bits) & maxv);\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      ret.push((acc << (toWidth - bits)) & maxv);\n    }\n  } else if (bits >= fromWidth || (acc << (toWidth - bits)) & maxv) {\n    return null;\n  }\n\n  return Buffer.from(ret);\n};\n\n/**\n * toBech32Address\n *\n * Encodes a canonical 20-byte Ethereum-style address as a bech32 zilliqa\n * address.\n *\n * The expected format is zil1<address><checksum> where address and checksum\n * are the result of bech32 encoding a Buffer containing the address bytes.\n *\n * @param {string} 20 byte canonical address\n * @returns {string} 38 char bech32 encoded zilliqa address\n */\nexport const toBech32Address = (address: string): string => {\n  if (!validation.isAddress(address)) {\n    throw new Error('Invalid address format.');\n  }\n\n  const addrBz = convertBits(\n    Buffer.from(address.replace('0x', ''), 'hex'),\n    8,\n    5,\n  );\n\n  if (addrBz === null) {\n    throw new Error('Could not convert byte Buffer to 5-bit Buffer');\n  }\n\n  return encode(HRP, addrBz);\n};\n\n/**\n * fromBech32Address\n *\n * @param {string} address - a valid Zilliqa bech32 address\n * @returns {string} a canonical 20-byte Ethereum-style address\n */\nexport const fromBech32Address = (address: string): string => {\n  const res = decode(address);\n\n  if (res === null) {\n    throw new Error('Invalid bech32 address');\n  }\n\n  const { hrp, data } = res;\n\n  const shouldBe = HRP;\n  if (hrp !== shouldBe) {\n    throw new Error(`Expected hrp to be ${shouldBe} but got ${hrp}`);\n  }\n\n  const buf = convertBits(data, 5, 8, false);\n\n  if (buf === null) {\n    throw new Error('Could not convert buffer to bytes');\n  }\n\n  return toChecksumAddress(buf.toString('hex'));\n};\n","//  Copyright (C) 2018 Zilliqa\n//\n//  This file is part of zilliqa-js\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  This program is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport elliptic from 'elliptic';\nimport hashjs from 'hash.js';\n\nimport { BN, validation } from '@zilliqa-js/util';\n\nimport { fromBech32Address, toBech32Address } from './bech32';\n\nconst secp256k1 = new elliptic.ec('secp256k1');\n\n/**\n * getAddressFromPrivateKey\n *\n * takes a hex-encoded string (private key) and returns its corresponding\n * 20-byte hex-encoded address.\n *\n * @param {string} privateKey\n * @returns {string}\n */\nexport const getAddressFromPrivateKey = (privateKey: string): string => {\n  const normalizedPrviateKey = normalizePrivateKey(privateKey);\n  const keyPair = secp256k1.keyFromPrivate(normalizedPrviateKey, 'hex');\n  const pub = keyPair.getPublic(true, 'hex');\n\n  return toChecksumAddress(\n    hashjs.sha256().update(pub, 'hex').digest('hex').slice(24),\n  );\n};\n\n/**\n * getPubKeyFromPrivateKey\n *\n * takes a hex-encoded string (private key) and returns its corresponding\n * hex-encoded 33-byte public key.\n *\n * @param {string} privateKey\n * @returns {string}\n */\nexport const getPubKeyFromPrivateKey = (privateKey: string) => {\n  const normalizedPrviateKey = normalizePrivateKey(privateKey);\n  const keyPair = secp256k1.keyFromPrivate(normalizedPrviateKey, 'hex');\n  return keyPair.getPublic(true, 'hex');\n};\n\n/**\n * getAccountFrom0xPrivateKey\n *\n * Utility method for recovering account from 0x private key.\n * See https://github.com/Zilliqa/zilliqa-js/pull/159\n * @param privateKeyWith0x : private key with 0x prefix\n */\n\nexport const getAccountFrom0xPrivateKey = (privateKeyWith0x: string) => {\n  const privateKeyWithout0x = normalizePrivateKey(privateKeyWith0x);\n  const keyPair = secp256k1.keyFromPrivate(privateKeyWith0x, 'hex');\n  const publicKeyWith0x = keyPair.getPublic(true, 'hex');\n  const addressWith0x = getAddressFromPublicKey(publicKeyWith0x);\n  const bech32With0x = toBech32Address(addressWith0x);\n  const with0x = {\n    prv: privateKeyWith0x,\n    pub: publicKeyWith0x,\n    addr: addressWith0x,\n    bech32: bech32With0x,\n  };\n\n  const keyPair2 = secp256k1.keyFromPrivate(privateKeyWithout0x, 'hex');\n  const publicKeyWithout0x = keyPair2.getPublic(true, 'hex');\n  const addressWithout0x = getAddressFromPublicKey(publicKeyWithout0x);\n  const bech32Without0x = toBech32Address(addressWithout0x);\n  const without0x = {\n    prv: privateKeyWithout0x,\n    pub: publicKeyWithout0x,\n    addr: addressWithout0x,\n    bech32: bech32Without0x,\n  };\n\n  const privateKeyAfterChange = keyPair.getPrivate('hex');\n  const publicKeyAfterChange = keyPair.getPublic(true, 'hex');\n  const addressAfterChange = getAddressFromPublicKey(publicKeyAfterChange);\n  const bech32AfterChange = toBech32Address(addressAfterChange);\n\n  const changed = {\n    prv: privateKeyAfterChange,\n    pub: publicKeyAfterChange,\n    addr: addressAfterChange,\n    bech32: bech32AfterChange,\n  };\n\n  return {\n    with0x,\n    without0x,\n    changed,\n  };\n};\n\n/**\n * compressPublicKey\n *\n * @param {string} publicKey - 65-byte public key, a point (x, y)\n *\n * @returns {string}\n */\nexport const compressPublicKey = (publicKey: string): string => {\n  return secp256k1.keyFromPublic(publicKey, 'hex').getPublic(true, 'hex');\n};\n\n/**\n * getAddressFromPublicKey\n *\n * takes hex-encoded string and returns the corresponding address\n *\n * @param {string} pubKey\n * @returns {string}\n */\nexport const getAddressFromPublicKey = (publicKey: string) => {\n  const normalized = publicKey.toLowerCase().replace('0x', '');\n  return toChecksumAddress(\n    hashjs.sha256().update(normalized, 'hex').digest('hex').slice(24),\n  );\n};\n\n/**\n * toChecksumAddress\n *\n * takes hex-encoded string and returns the corresponding address\n *\n * @param {string} address\n * @returns {string}\n */\nexport const toChecksumAddress = (address: string): string => {\n  if (!validation.isAddress(address)) {\n    throw new Error(`${address} is not a valid base 16 address`);\n  }\n\n  address = address.toLowerCase().replace('0x', '');\n  const hash = hashjs.sha256().update(address, 'hex').digest('hex');\n  const v = new BN(hash, 'hex', 'be');\n  let ret = '0x';\n\n  for (let i = 0; i < address.length; i++) {\n    if ('0123456789'.indexOf(address[i]) !== -1) {\n      ret += address[i];\n    } else {\n      ret += v.and(new BN(2).pow(new BN(255 - 6 * i))).gte(new BN(1))\n        ? address[i].toUpperCase()\n        : address[i].toLowerCase();\n    }\n  }\n\n  return ret;\n};\n\n/**\n * isValidChecksumAddress\n *\n * takes hex-encoded string and returns boolean if address is checksumed\n *\n * @param {string} address\n * @returns {boolean}\n */\nexport const isValidChecksumAddress = (address: string): boolean => {\n  return (\n    validation.isAddress(address.replace('0x', '')) &&\n    toChecksumAddress(address) === address\n  );\n};\n\n/**\n * normaliseAddress\n *\n * takes in a base16 address or a zilliqa bech32 encoded address\n * and returns a checksum base16 address. If the address is neither a base16\n * nor bech32 address, the code will return an error\n * @param {string)} address\n * @returns {string}\n */\nexport const normaliseAddress = (address: string): string => {\n  if (validation.isBech32(address)) {\n    return fromBech32Address(address);\n  }\n\n  if (!isValidChecksumAddress(address)) {\n    throw Error(\n      'Wrong address format, should be either bech32 or checksummed address',\n    );\n  }\n\n  return address;\n};\n\n/**\n * encodeBase58 - may be required for DID public key\n * undeprecating this function after version 2.0.0\n *\n * @param {string} hex - base 16 encoded string\n * @returns {string} - big endian base 58 encoded string\n */\nexport const encodeBase58 = (hex: string): string => {\n  const clean = hex.toLowerCase().replace('0x', '');\n  const tbl = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n  const base = new BN(58);\n  const zero = new BN(0);\n  let x = new BN(clean, 16);\n  let res = '';\n\n  while (x.gt(zero)) {\n    const rem = x.mod(base).toNumber(); // safe, always < 58\n    // big endian\n    res = tbl[rem] + res;\n    // quotient, remainders thrown away in integer division\n    x = x.div(base);\n  }\n\n  // convert to big endian in case the input hex is little endian\n  const hexBE = x.toString('hex', clean.length);\n  for (let i = 0; i < hexBE.length; i += 2) {\n    if (hex[i] === '0' && hex[i + 1] === '0') {\n      res = tbl[0] + res;\n    } else {\n      break;\n    }\n  }\n\n  return res;\n};\n\n/**\n * decodeBase58 - may be required for DID public key\n * undeprecating this function after version 2.0.0\n *\n * @param {string} raw - base 58 string\n * @returns {string} - big endian base 16 string\n */\nexport const decodeBase58 = (raw: string): string => {\n  const tbl = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n  const base = new BN(58);\n  const zero = new BN(0);\n  let isBreak = false;\n  let n = new BN(0);\n  let leader = '';\n\n  for (let i = 0; i < raw.length; i++) {\n    const char = raw.charAt(i);\n    const weight = new BN(tbl.indexOf(char));\n    n = n.mul(base).add(weight);\n\n    // check if padding required\n    if (!isBreak) {\n      if (i - 1 > 0 && raw[i - 1] !== '1') {\n        isBreak = true;\n        continue;\n      }\n      if (char === '1') {\n        leader += '00';\n      }\n    }\n  }\n  if (n.eq(zero)) {\n    return leader;\n  }\n\n  let res = leader + n.toString('hex');\n  if (res.length % 2 !== 0) {\n    res = '0' + res;\n  }\n\n  return res;\n};\n\n/**\n * verifyPrivateKey\n *\n * @param {string|Buffer} privateKey\n * @returns {boolean}\n */\nexport const verifyPrivateKey = (privateKey: string): boolean => {\n  const keyPair = secp256k1.keyFromPrivate(privateKey, 'hex');\n  const { result } = keyPair.validate();\n  return result;\n};\n\n/**\n * normalizePrivateKey : normalise private key from 0x or without 0x prefix\n *\n * @param {string} privateKey\n * @returns {string}\n */\n\nexport const normalizePrivateKey = (privateKey: string): string => {\n  try {\n    if (!validation.isPrivateKey(privateKey)) {\n      throw new Error('Private key is not correct');\n    }\n    const normalized = privateKey.toLowerCase().replace('0x', '');\n    if (!verifyPrivateKey(normalized)) {\n      throw new Error('Private key is not correct');\n    }\n    return normalized;\n  } catch (error) {\n    throw error;\n  }\n};\n","//  Copyright (C) 2018 Zilliqa\n//\n//  This file is part of zilliqa-js\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  This program is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport aes from 'aes-js';\nimport hashjs from 'hash.js';\nimport { pbkdf2Sync } from 'pbkdf2';\nimport scrypt from 'scrypt-js';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport { bytes } from '@zilliqa-js/util';\n\nimport { randomBytes } from './random';\nimport {\n  KeystoreV3,\n  KDF,\n  KDFParams,\n  PBKDF2Params,\n  ScryptParams,\n} from './types';\nimport { getAddressFromPrivateKey } from './util';\n\nconst ALGO_IDENTIFIER = 'aes-128-ctr';\n\n/**\n * getDerivedKey\n *\n * NOTE: only scrypt and pbkdf2 are supported.\n *\n * @param {Buffer} key - the passphrase\n * @param {KDF} kdf - the key derivation function to be used\n * @param {KDFParams} params - params for the kdf\n *\n * @returns {Promise<Buffer>}\n */\nasync function getDerivedKey(\n  key: Buffer,\n  kdf: KDF,\n  params: KDFParams,\n): Promise<Buffer> {\n  const salt = Buffer.from(params.salt, 'hex');\n\n  if (kdf === 'pbkdf2') {\n    const { c, dklen } = params as PBKDF2Params;\n    return pbkdf2Sync(key, salt, c, dklen, 'sha256');\n  }\n\n  if (kdf === 'scrypt') {\n    const { n, r, p, dklen } = params as ScryptParams;\n    const derivedKeyInt8Array = scrypt.syncScrypt(key, salt, n, r, p, dklen);\n    return Buffer.from(derivedKeyInt8Array);\n  }\n\n  throw new Error('Only pbkdf2 and scrypt are supported');\n}\n\n/**\n * encryptPrivateKey\n *\n * Encodes and encrypts an account in the format specified by\n * https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition.\n * However, note that, in keeping with the hash function used by Zilliqa's\n * core protocol, the MAC is generated using sha256 instead of keccak.\n *\n * NOTE: only scrypt and pbkdf2 are supported.\n *\n * @param {KDF} kdf - the key derivation function to be used\n * @param {string} privateKey - hex-encoded private key\n * @param {string} passphrase - a passphrase used for encryption\n *\n * @returns {Promise<string>}\n */\nexport const encryptPrivateKey = async (\n  kdf: KDF,\n  privateKey: string,\n  passphrase: string,\n): Promise<string> => {\n  const address = getAddressFromPrivateKey(privateKey);\n  const salt = randomBytes(32);\n  const iv = Buffer.from(randomBytes(16), 'hex');\n  const kdfparams = {\n    salt,\n    n: 8192,\n    c: 262144,\n    r: 8,\n    p: 1,\n    dklen: 32,\n  };\n\n  const derivedKey = await getDerivedKey(\n    Buffer.from(passphrase),\n    kdf,\n    kdfparams,\n  );\n  const cipher = new aes.ModeOfOperation.ctr(\n    derivedKey.slice(0, 16),\n    new aes.Counter(iv),\n  );\n  const ciphertext = Buffer.from(\n    cipher.encrypt(Buffer.from(privateKey, 'hex')),\n  );\n\n  return JSON.stringify({\n    address,\n    crypto: {\n      cipher: ALGO_IDENTIFIER,\n      cipherparams: {\n        iv: iv.toString('hex'),\n      },\n      ciphertext: ciphertext.toString('hex'),\n      kdf,\n      kdfparams,\n      mac: hashjs\n        // @ts-ignore\n        .hmac(hashjs.sha256, derivedKey, 'hex')\n        .update(\n          Buffer.concat([\n            derivedKey.slice(16, 32),\n            ciphertext,\n            iv,\n            Buffer.from(ALGO_IDENTIFIER),\n          ]),\n          'hex',\n        )\n        .digest('hex'),\n    },\n    id: uuidv4({ random: bytes.hexToIntArray(randomBytes(16)) }),\n    version: 3,\n  });\n};\n\n/**\n * decryptPrivateKey\n *\n * Recovers the private key from a keystore file using the given passphrase.\n *\n * @param {string} passphrase\n * @param {KeystoreV3} keystore\n * @returns {Promise<string>}\n */\nexport const decryptPrivateKey = async (\n  passphrase: string,\n  keystore: KeystoreV3,\n): Promise<string> => {\n  const ciphertext = Buffer.from(keystore.crypto.ciphertext, 'hex');\n  const iv = Buffer.from(keystore.crypto.cipherparams.iv, 'hex');\n  const kdfparams = keystore.crypto.kdfparams;\n\n  const derivedKey = await getDerivedKey(\n    Buffer.from(passphrase),\n    keystore.crypto.kdf,\n    kdfparams,\n  );\n\n  const mac = hashjs\n    // @ts-ignore\n    .hmac(hashjs.sha256, derivedKey, 'hex')\n    .update(\n      Buffer.concat([\n        derivedKey.slice(16, 32),\n        ciphertext,\n        iv,\n        Buffer.from(ALGO_IDENTIFIER),\n      ]),\n      'hex',\n    )\n    .digest('hex');\n\n  // we need to do a byte-by-byte comparison to avoid non-constant time side\n  // channel attacks.\n  if (!bytes.isEqual(mac.toUpperCase(), keystore.crypto.mac.toUpperCase())) {\n    return Promise.reject('Failed to decrypt.');\n  }\n\n  const cipher = new aes.ModeOfOperation.ctr(\n    derivedKey.slice(0, 16),\n    new aes.Counter(iv),\n  );\n\n  return Buffer.from(cipher.decrypt(ciphertext)).toString('hex');\n};\n","//  Copyright (C) 2018 Zilliqa\n//\n//  This file is part of zilliqa-js\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  This program is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nexport type KDF = 'pbkdf2' | 'scrypt';\n\nexport interface PBKDF2Params {\n  salt: string;\n  dklen: number;\n  c: number;\n}\n\nexport interface ScryptParams {\n  salt: string;\n  dklen: number;\n  n: number;\n  r: number;\n  p: number;\n}\n\nexport type KDFParams = PBKDF2Params | ScryptParams;\n\nexport interface KeystoreV3 {\n  address: string;\n  crypto: {\n    cipher: string;\n    cipherparams: {\n      iv: string;\n    };\n    ciphertext: string;\n    kdf: KDF;\n    kdfparams: KDFParams;\n    mac: string;\n  };\n  id: string;\n  version: 3;\n}\n","//  Copyright (C) 2018 Zilliqa\n//\n//  This file is part of zilliqa-js\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  This program is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport * as schnorr from './schnorr';\n\nimport { Signature } from './signature';\n\n/**\n * sign\n *\n * @param {string} hash - hex-encoded hash of the data to be signed\n *\n * @returns {string} the signature\n */\nexport const sign = (\n  msg: Buffer,\n  privateKey: string,\n  pubKey: string,\n): string => {\n  const sig = schnorr.sign(\n    msg,\n    Buffer.from(privateKey, 'hex'),\n    Buffer.from(pubKey, 'hex'),\n  );\n\n  let r = sig.r.toString('hex');\n  let s = sig.s.toString('hex');\n  while (r.length < 64) {\n    r = '0' + r;\n  }\n  while (s.length < 64) {\n    s = '0' + s;\n  }\n\n  return r + s;\n};\n\nexport { schnorr, Signature };\nexport * from './util';\nexport * from './keystore';\nexport * from './random';\nexport * from './types';\nexport * from './bech32';\n"]},"metadata":{},"sourceType":"script"}