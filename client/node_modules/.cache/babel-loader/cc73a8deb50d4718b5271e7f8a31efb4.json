{"ast":null,"code":"'use strict';\n\nconst {\n  createDiffieHellman,\n  createDiffieHellmanGroup,\n  createECDH,\n  createHash,\n  createPublicKey,\n  diffieHellman,\n  generateKeyPairSync,\n  randomFillSync\n} = require('crypto');\n\nconst {\n  Ber\n} = require('asn1');\n\nconst {\n  COMPAT,\n  curve25519Supported,\n  DEFAULT_KEX,\n  DEFAULT_SERVER_HOST_KEY,\n  DEFAULT_CIPHER,\n  DEFAULT_MAC,\n  DEFAULT_COMPRESSION,\n  DISCONNECT_REASON,\n  MESSAGE\n} = require('./constants.js');\n\nconst {\n  CIPHER_INFO,\n  createCipher,\n  createDecipher,\n  MAC_INFO\n} = require('./crypto.js');\n\nconst {\n  parseDERKey\n} = require('./keyParser.js');\n\nconst {\n  bufferFill,\n  bufferParser,\n  convertSignature,\n  doFatalError,\n  FastBuffer,\n  sigSSHToASN1,\n  writeUInt32BE\n} = require('./utils.js');\n\nconst {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter\n} = require('./zlib.js');\n\nlet MESSAGE_HANDLERS;\nconst GEX_MIN_BITS = 2048; // RFC 8270\n\nconst GEX_MAX_BITS = 8192; // RFC 8270\n\nconst EMPTY_BUFFER = Buffer.alloc(0); // Client/Server\n\nfunction kexinit(self) {\n  /*\n    byte         SSH_MSG_KEXINIT\n    byte[16]     cookie (random bytes)\n    name-list    kex_algorithms\n    name-list    server_host_key_algorithms\n    name-list    encryption_algorithms_client_to_server\n    name-list    encryption_algorithms_server_to_client\n    name-list    mac_algorithms_client_to_server\n    name-list    mac_algorithms_server_to_client\n    name-list    compression_algorithms_client_to_server\n    name-list    compression_algorithms_server_to_client\n    name-list    languages_client_to_server\n    name-list    languages_server_to_client\n    boolean      first_kex_packet_follows\n    uint32       0 (reserved for future extension)\n  */\n  let payload;\n\n  if (self._compatFlags & COMPAT.BAD_DHGEX) {\n    const entry = self._offer.lists.kex;\n    let kex = entry.array;\n    let found = false;\n\n    for (let i = 0; i < kex.length; ++i) {\n      if (kex[i].includes('group-exchange')) {\n        if (!found) {\n          found = true; // Copy array lazily\n\n          kex = kex.slice();\n        }\n\n        kex.splice(i--, 1);\n      }\n    }\n\n    if (found) {\n      let len = 1 + 16 + self._offer.totalSize + 1 + 4;\n      const newKexBuf = Buffer.from(kex.join(','));\n      len -= entry.buffer.length - newKexBuf.length;\n      const all = self._offer.lists.all;\n      const rest = new Uint8Array(all.buffer, all.byteOffset + 4 + entry.buffer.length, all.length - (4 + entry.buffer.length));\n      payload = Buffer.allocUnsafe(len);\n      writeUInt32BE(payload, newKexBuf.length, 17);\n      payload.set(newKexBuf, 17 + 4);\n      payload.set(rest, 17 + 4 + newKexBuf.length);\n    }\n  }\n\n  if (payload === undefined) {\n    payload = Buffer.allocUnsafe(1 + 16 + self._offer.totalSize + 1 + 4);\n\n    self._offer.copyAllTo(payload, 17);\n  }\n\n  self._debug && self._debug('Outbound: Sending KEXINIT');\n  payload[0] = MESSAGE.KEXINIT;\n  randomFillSync(payload, 1, 16); // Zero-fill first_kex_packet_follows and reserved bytes\n\n  bufferFill(payload, 0, payload.length - 5);\n  self._kexinit = payload; // Needed to correct the starting position in allocated \"packets\" when packets\n  // will be buffered due to active key exchange\n\n  self._packetRW.write.allocStart = 0; // TODO: only create single buffer and set _kexinit as slice of packet instead\n\n  {\n    const p = self._packetRW.write.allocStartKEX;\n\n    const packet = self._packetRW.write.alloc(payload.length, true);\n\n    packet.set(payload, p);\n\n    self._cipher.encrypt(self._packetRW.write.finalize(packet, true));\n  }\n}\n\nfunction handleKexInit(self, payload) {\n  /*\n    byte         SSH_MSG_KEXINIT\n    byte[16]     cookie (random bytes)\n    name-list    kex_algorithms\n    name-list    server_host_key_algorithms\n    name-list    encryption_algorithms_client_to_server\n    name-list    encryption_algorithms_server_to_client\n    name-list    mac_algorithms_client_to_server\n    name-list    mac_algorithms_server_to_client\n    name-list    compression_algorithms_client_to_server\n    name-list    compression_algorithms_server_to_client\n    name-list    languages_client_to_server\n    name-list    languages_server_to_client\n    boolean      first_kex_packet_follows\n    uint32       0 (reserved for future extension)\n  */\n  const init = {\n    kex: undefined,\n    serverHostKey: undefined,\n    cs: {\n      cipher: undefined,\n      mac: undefined,\n      compress: undefined,\n      lang: undefined\n    },\n    sc: {\n      cipher: undefined,\n      mac: undefined,\n      compress: undefined,\n      lang: undefined\n    }\n  };\n  bufferParser.init(payload, 17);\n\n  if ((init.kex = bufferParser.readList()) === undefined || (init.serverHostKey = bufferParser.readList()) === undefined || (init.cs.cipher = bufferParser.readList()) === undefined || (init.sc.cipher = bufferParser.readList()) === undefined || (init.cs.mac = bufferParser.readList()) === undefined || (init.sc.mac = bufferParser.readList()) === undefined || (init.cs.compress = bufferParser.readList()) === undefined || (init.sc.compress = bufferParser.readList()) === undefined || (init.cs.lang = bufferParser.readList()) === undefined || (init.sc.lang = bufferParser.readList()) === undefined) {\n    bufferParser.clear();\n    return doFatalError(self, 'Received malformed KEXINIT', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n\n  const pos = bufferParser.pos();\n  const firstFollows = pos < payload.length && payload[pos] === 1;\n  bufferParser.clear();\n  const local = self._offer;\n  const remote = init;\n  let localKex = local.lists.kex.array;\n\n  if (self._compatFlags & COMPAT.BAD_DHGEX) {\n    let found = false;\n\n    for (let i = 0; i < localKex.length; ++i) {\n      if (localKex[i].indexOf('group-exchange') !== -1) {\n        if (!found) {\n          found = true; // Copy array lazily\n\n          localKex = localKex.slice();\n        }\n\n        localKex.splice(i--, 1);\n      }\n    }\n  }\n\n  let clientList;\n  let serverList;\n  let i;\n  const debug = self._debug;\n  debug && debug('Inbound: Handshake in progress'); // Key exchange method =======================================================\n\n  debug && debug(`Handshake: (local) KEX method: ${localKex}`);\n  debug && debug(`Handshake: (remote) KEX method: ${remote.kex}`);\n\n  if (self._server) {\n    serverList = localKex;\n    clientList = remote.kex;\n  } else {\n    serverList = remote.kex;\n    clientList = localKex;\n  } // Check for agreeable key exchange algorithm\n\n\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching key exchange algorithm');\n    return doFatalError(self, 'Handshake failed: no matching key exchange algorithm', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n\n  init.kex = clientList[i];\n  debug && debug(`Handshake: KEX algorithm: ${clientList[i]}`);\n\n  if (firstFollows && (!remote.kex.length || clientList[i] !== remote.kex[0])) {\n    // Ignore next inbound packet, it was a wrong first guess at KEX algorithm\n    self._skipNextInboundPacket = true;\n  } // Server host key format ====================================================\n\n\n  const localSrvHostKey = local.lists.serverHostKey.array;\n  debug && debug(`Handshake: (local) Host key format: ${localSrvHostKey}`);\n  debug && debug(`Handshake: (remote) Host key format: ${remote.serverHostKey}`);\n\n  if (self._server) {\n    serverList = localSrvHostKey;\n    clientList = remote.serverHostKey;\n  } else {\n    serverList = remote.serverHostKey;\n    clientList = localSrvHostKey;\n  } // Check for agreeable server host key format\n\n\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching host key format');\n    return doFatalError(self, 'Handshake failed: no matching host key format', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n\n  init.serverHostKey = clientList[i];\n  debug && debug(`Handshake: Host key format: ${clientList[i]}`); // Client->Server cipher =====================================================\n\n  const localCSCipher = local.lists.cs.cipher.array;\n  debug && debug(`Handshake: (local) C->S cipher: ${localCSCipher}`);\n  debug && debug(`Handshake: (remote) C->S cipher: ${remote.cs.cipher}`);\n\n  if (self._server) {\n    serverList = localCSCipher;\n    clientList = remote.cs.cipher;\n  } else {\n    serverList = remote.cs.cipher;\n    clientList = localCSCipher;\n  } // Check for agreeable client->server cipher\n\n\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching C->S cipher');\n    return doFatalError(self, 'Handshake failed: no matching C->S cipher', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n\n  init.cs.cipher = clientList[i];\n  debug && debug(`Handshake: C->S Cipher: ${clientList[i]}`); // Server->Client cipher =====================================================\n\n  const localSCCipher = local.lists.sc.cipher.array;\n  debug && debug(`Handshake: (local) S->C cipher: ${localSCCipher}`);\n  debug && debug(`Handshake: (remote) S->C cipher: ${remote.sc.cipher}`);\n\n  if (self._server) {\n    serverList = localSCCipher;\n    clientList = remote.sc.cipher;\n  } else {\n    serverList = remote.sc.cipher;\n    clientList = localSCCipher;\n  } // Check for agreeable server->client cipher\n\n\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching S->C cipher');\n    return doFatalError(self, 'Handshake failed: no matching S->C cipher', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n\n  init.sc.cipher = clientList[i];\n  debug && debug(`Handshake: S->C cipher: ${clientList[i]}`); // Client->Server MAC ========================================================\n\n  const localCSMAC = local.lists.cs.mac.array;\n  debug && debug(`Handshake: (local) C->S MAC: ${localCSMAC}`);\n  debug && debug(`Handshake: (remote) C->S MAC: ${remote.cs.mac}`);\n\n  if (CIPHER_INFO[init.cs.cipher].authLen > 0) {\n    init.cs.mac = '';\n    debug && debug('Handshake: C->S MAC: <implicit>');\n  } else {\n    if (self._server) {\n      serverList = localCSMAC;\n      clientList = remote.cs.mac;\n    } else {\n      serverList = remote.cs.mac;\n      clientList = localCSMAC;\n    } // Check for agreeable client->server hmac algorithm\n\n\n    for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n\n    if (i === clientList.length) {\n      // No suitable match found!\n      debug && debug('Handshake: No matching C->S MAC');\n      return doFatalError(self, 'Handshake failed: no matching C->S MAC', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    }\n\n    init.cs.mac = clientList[i];\n    debug && debug(`Handshake: C->S MAC: ${clientList[i]}`);\n  } // Server->Client MAC ========================================================\n\n\n  const localSCMAC = local.lists.sc.mac.array;\n  debug && debug(`Handshake: (local) S->C MAC: ${localSCMAC}`);\n  debug && debug(`Handshake: (remote) S->C MAC: ${remote.sc.mac}`);\n\n  if (CIPHER_INFO[init.sc.cipher].authLen > 0) {\n    init.sc.mac = '';\n    debug && debug('Handshake: S->C MAC: <implicit>');\n  } else {\n    if (self._server) {\n      serverList = localSCMAC;\n      clientList = remote.sc.mac;\n    } else {\n      serverList = remote.sc.mac;\n      clientList = localSCMAC;\n    } // Check for agreeable server->client hmac algorithm\n\n\n    for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n\n    if (i === clientList.length) {\n      // No suitable match found!\n      debug && debug('Handshake: No matching S->C MAC');\n      return doFatalError(self, 'Handshake failed: no matching S->C MAC', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    }\n\n    init.sc.mac = clientList[i];\n    debug && debug(`Handshake: S->C MAC: ${clientList[i]}`);\n  } // Client->Server compression ================================================\n\n\n  const localCSCompress = local.lists.cs.compress.array;\n  debug && debug(`Handshake: (local) C->S compression: ${localCSCompress}`);\n  debug && debug(`Handshake: (remote) C->S compression: ${remote.cs.compress}`);\n\n  if (self._server) {\n    serverList = localCSCompress;\n    clientList = remote.cs.compress;\n  } else {\n    serverList = remote.cs.compress;\n    clientList = localCSCompress;\n  } // Check for agreeable client->server compression algorithm\n\n\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching C->S compression');\n    return doFatalError(self, 'Handshake failed: no matching C->S compression', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n\n  init.cs.compress = clientList[i];\n  debug && debug(`Handshake: C->S compression: ${clientList[i]}`); // Server->Client compression ================================================\n\n  const localSCCompress = local.lists.sc.compress.array;\n  debug && debug(`Handshake: (local) S->C compression: ${localSCCompress}`);\n  debug && debug(`Handshake: (remote) S->C compression: ${remote.sc.compress}`);\n\n  if (self._server) {\n    serverList = localSCCompress;\n    clientList = remote.sc.compress;\n  } else {\n    serverList = remote.sc.compress;\n    clientList = localSCCompress;\n  } // Check for agreeable server->client compression algorithm\n\n\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching S->C compression');\n    return doFatalError(self, 'Handshake failed: no matching S->C compression', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n\n  init.sc.compress = clientList[i];\n  debug && debug(`Handshake: S->C compression: ${clientList[i]}`);\n  init.cs.lang = '';\n  init.sc.lang = ''; // XXX: hack -- find a better way to do this\n\n  if (self._kex) {\n    if (!self._kexinit) {\n      // We received a rekey request, but we haven't sent a KEXINIT in response\n      // yet\n      kexinit(self);\n    }\n\n    self._decipher._onPayload = onKEXPayload.bind(self, {\n      firstPacket: false\n    });\n  }\n\n  self._kex = createKeyExchange(init, self, payload);\n\n  self._kex.start();\n}\n\nconst createKeyExchange = (() => {\n  function convertToMpint(buf) {\n    let idx = 0;\n    let length = buf.length;\n\n    while (buf[idx] === 0x00) {\n      ++idx;\n      --length;\n    }\n\n    let newBuf;\n\n    if (buf[idx] & 0x80) {\n      newBuf = Buffer.allocUnsafe(1 + length);\n      newBuf[0] = 0;\n      buf.copy(newBuf, 1, idx);\n      buf = newBuf;\n    } else if (length !== buf.length) {\n      newBuf = Buffer.allocUnsafe(length);\n      buf.copy(newBuf, 0, idx);\n      buf = newBuf;\n    }\n\n    return buf;\n  }\n\n  class KeyExchange {\n    constructor(negotiated, protocol, remoteKexinit) {\n      this._protocol = protocol;\n      this.sessionID = protocol._kex ? protocol._kex.sessionID : undefined;\n      this.negotiated = negotiated;\n      this._step = 1;\n      this._public = null;\n      this._dh = null;\n      this._sentNEWKEYS = false;\n      this._receivedNEWKEYS = false;\n      this._finished = false;\n      this._hostVerified = false; // Data needed for initializing cipher/decipher/etc.\n\n      this._kexinit = protocol._kexinit;\n      this._remoteKexinit = remoteKexinit;\n      this._identRaw = protocol._identRaw;\n      this._remoteIdentRaw = protocol._remoteIdentRaw;\n      this._hostKey = undefined;\n      this._dhData = undefined;\n      this._sig = undefined;\n    }\n\n    finish() {\n      if (this._finished) return false;\n      this._finished = true;\n      const isServer = this._protocol._server;\n      const negotiated = this.negotiated;\n      const pubKey = this.convertPublicKey(this._dhData);\n      let secret = this.computeSecret(this._dhData);\n\n      if (secret instanceof Error) {\n        secret.message = `Error while computing DH secret (${this.type}): ${secret.message}`;\n        secret.level = 'handshake';\n        return doFatalError(this._protocol, secret, DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      }\n\n      const hash = createHash(this.hashName); // V_C\n\n      hashString(hash, isServer ? this._remoteIdentRaw : this._identRaw); // \"V_S\"\n\n      hashString(hash, isServer ? this._identRaw : this._remoteIdentRaw); // \"I_C\"\n\n      hashString(hash, isServer ? this._remoteKexinit : this._kexinit); // \"I_S\"\n\n      hashString(hash, isServer ? this._kexinit : this._remoteKexinit); // \"K_S\"\n\n      const serverPublicHostKey = isServer ? this._hostKey.getPublicSSH() : this._hostKey;\n      hashString(hash, serverPublicHostKey);\n\n      if (this.type === 'groupex') {\n        // Group exchange-specific\n        const params = this.getDHParams();\n        const num = Buffer.allocUnsafe(4); // min (uint32)\n\n        writeUInt32BE(num, this._minBits, 0);\n        hash.update(num); // preferred (uint32)\n\n        writeUInt32BE(num, this._prefBits, 0);\n        hash.update(num); // max (uint32)\n\n        writeUInt32BE(num, this._maxBits, 0);\n        hash.update(num); // prime\n\n        hashString(hash, params.prime); // generator\n\n        hashString(hash, params.generator);\n      } // method-specific data sent by client\n\n\n      hashString(hash, isServer ? pubKey : this.getPublicKey()); // method-specific data sent by server\n\n      const serverPublicKey = isServer ? this.getPublicKey() : pubKey;\n      hashString(hash, serverPublicKey); // shared secret (\"K\")\n\n      hashString(hash, secret); // \"H\"\n\n      const exchangeHash = hash.digest();\n\n      if (!isServer) {\n        bufferParser.init(this._sig, 0);\n        const sigType = bufferParser.readString(true);\n\n        if (!sigType) {\n          return doFatalError(this._protocol, 'Malformed packet while reading signature', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n\n        if (sigType !== negotiated.serverHostKey) {\n          return doFatalError(this._protocol, `Wrong signature type: ${sigType}, ` + `expected: ${negotiated.serverHostKey}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        } // \"s\"\n\n\n        let sigValue = bufferParser.readString();\n        bufferParser.clear();\n\n        if (sigValue === undefined) {\n          return doFatalError(this._protocol, 'Malformed packet while reading signature', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n\n        if (!(sigValue = sigSSHToASN1(sigValue, sigType))) {\n          return doFatalError(this._protocol, 'Malformed signature', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n\n        let parsedHostKey;\n        {\n          bufferParser.init(this._hostKey, 0);\n          const name = bufferParser.readString(true);\n\n          const hostKey = this._hostKey.slice(bufferParser.pos());\n\n          bufferParser.clear();\n          parsedHostKey = parseDERKey(hostKey, name);\n\n          if (parsedHostKey instanceof Error) {\n            parsedHostKey.level = 'handshake';\n            return doFatalError(this._protocol, parsedHostKey, DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n          }\n        }\n        let hashAlgo; // Check if we need to override the default hash algorithm\n\n        switch (this.negotiated.serverHostKey) {\n          case 'rsa-sha2-256':\n            hashAlgo = 'sha256';\n            break;\n\n          case 'rsa-sha2-512':\n            hashAlgo = 'sha512';\n            break;\n        }\n\n        this._protocol._debug && this._protocol._debug('Verifying signature ...');\n        const verified = parsedHostKey.verify(exchangeHash, sigValue, hashAlgo);\n\n        if (verified !== true) {\n          if (verified instanceof Error) {\n            this._protocol._debug && this._protocol._debug(`Signature verification failed: ${verified.stack}`);\n          } else {\n            this._protocol._debug && this._protocol._debug('Signature verification failed');\n          }\n\n          return doFatalError(this._protocol, 'Handshake failed: signature verification failed', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n\n        this._protocol._debug && this._protocol._debug('Verified signature');\n      } else {\n        // Server\n        let hashAlgo; // Check if we need to override the default hash algorithm\n\n        switch (this.negotiated.serverHostKey) {\n          case 'rsa-sha2-256':\n            hashAlgo = 'sha256';\n            break;\n\n          case 'rsa-sha2-512':\n            hashAlgo = 'sha512';\n            break;\n        }\n\n        this._protocol._debug && this._protocol._debug('Generating signature ...');\n\n        let signature = this._hostKey.sign(exchangeHash, hashAlgo);\n\n        if (signature instanceof Error) {\n          return doFatalError(this._protocol, 'Handshake failed: signature generation failed for ' + `${this._hostKey.type} host key: ${signature.message}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n\n        signature = convertSignature(signature, this._hostKey.type);\n\n        if (signature === false) {\n          return doFatalError(this._protocol, 'Handshake failed: signature conversion failed for ' + `${this._hostKey.type} host key`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        } // Send KEX reply\n\n        /*\n          byte      SSH_MSG_KEXDH_REPLY\n                      / SSH_MSG_KEX_DH_GEX_REPLY\n                      / SSH_MSG_KEX_ECDH_REPLY\n          string    server public host key and certificates (K_S)\n          string    <method-specific data>\n          string    signature of H\n        */\n\n\n        const sigType = this.negotiated.serverHostKey;\n        const sigTypeLen = Buffer.byteLength(sigType);\n        const sigLen = 4 + sigTypeLen + 4 + signature.length;\n        let p = this._protocol._packetRW.write.allocStartKEX;\n\n        const packet = this._protocol._packetRW.write.alloc(1 + 4 + serverPublicHostKey.length + 4 + serverPublicKey.length + 4 + sigLen, true);\n\n        packet[p] = MESSAGE.KEXDH_REPLY;\n        writeUInt32BE(packet, serverPublicHostKey.length, ++p);\n        packet.set(serverPublicHostKey, p += 4);\n        writeUInt32BE(packet, serverPublicKey.length, p += serverPublicHostKey.length);\n        packet.set(serverPublicKey, p += 4);\n        writeUInt32BE(packet, sigLen, p += serverPublicKey.length);\n        writeUInt32BE(packet, sigTypeLen, p += 4);\n        packet.utf8Write(sigType, p += 4, sigTypeLen);\n        writeUInt32BE(packet, signature.length, p += sigTypeLen);\n        packet.set(signature, p += 4);\n\n        if (this._protocol._debug) {\n          let type;\n\n          switch (this.type) {\n            case 'group':\n              type = 'KEXDH_REPLY';\n              break;\n\n            case 'groupex':\n              type = 'KEXDH_GEX_REPLY';\n              break;\n\n            default:\n              type = 'KEXECDH_REPLY';\n          }\n\n          this._protocol._debug(`Outbound: Sending ${type}`);\n        }\n\n        this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));\n      }\n\n      trySendNEWKEYS(this);\n\n      const completeHandshake = () => {\n        if (!this.sessionID) this.sessionID = exchangeHash;\n        {\n          const newSecret = Buffer.allocUnsafe(4 + secret.length);\n          writeUInt32BE(newSecret, secret.length, 0);\n          newSecret.set(secret, 4);\n          secret = newSecret;\n        } // Initialize new ciphers, deciphers, etc.\n\n        const csCipherInfo = CIPHER_INFO[negotiated.cs.cipher];\n        const scCipherInfo = CIPHER_INFO[negotiated.sc.cipher];\n        const csIV = generateKEXVal(csCipherInfo.ivLen, this.hashName, secret, exchangeHash, this.sessionID, 'A');\n        const scIV = generateKEXVal(scCipherInfo.ivLen, this.hashName, secret, exchangeHash, this.sessionID, 'B');\n        const csKey = generateKEXVal(csCipherInfo.keyLen, this.hashName, secret, exchangeHash, this.sessionID, 'C');\n        const scKey = generateKEXVal(scCipherInfo.keyLen, this.hashName, secret, exchangeHash, this.sessionID, 'D');\n        let csMacInfo;\n        let csMacKey;\n\n        if (!csCipherInfo.authLen) {\n          csMacInfo = MAC_INFO[negotiated.cs.mac];\n          csMacKey = generateKEXVal(csMacInfo.len, this.hashName, secret, exchangeHash, this.sessionID, 'E');\n        }\n\n        let scMacInfo;\n        let scMacKey;\n\n        if (!scCipherInfo.authLen) {\n          scMacInfo = MAC_INFO[negotiated.sc.mac];\n          scMacKey = generateKEXVal(scMacInfo.len, this.hashName, secret, exchangeHash, this.sessionID, 'F');\n        }\n\n        const config = {\n          inbound: {\n            onPayload: this._protocol._onPayload,\n            seqno: this._protocol._decipher.inSeqno,\n            decipherInfo: !isServer ? scCipherInfo : csCipherInfo,\n            decipherIV: !isServer ? scIV : csIV,\n            decipherKey: !isServer ? scKey : csKey,\n            macInfo: !isServer ? scMacInfo : csMacInfo,\n            macKey: !isServer ? scMacKey : csMacKey\n          },\n          outbound: {\n            onWrite: this._protocol._onWrite,\n            seqno: this._protocol._cipher.outSeqno,\n            cipherInfo: isServer ? scCipherInfo : csCipherInfo,\n            cipherIV: isServer ? scIV : csIV,\n            cipherKey: isServer ? scKey : csKey,\n            macInfo: isServer ? scMacInfo : csMacInfo,\n            macKey: isServer ? scMacKey : csMacKey\n          }\n        };\n        this._protocol._cipher && this._protocol._cipher.free();\n        this._protocol._decipher && this._protocol._decipher.free();\n        this._protocol._cipher = createCipher(config);\n        this._protocol._decipher = createDecipher(config);\n        const rw = {\n          read: undefined,\n          write: undefined\n        };\n\n        switch (negotiated.cs.compress) {\n          case 'zlib':\n            // starts immediately\n            if (isServer) rw.read = new ZlibPacketReader();else rw.write = new ZlibPacketWriter(this._protocol);\n            break;\n\n          case 'zlib@openssh.com':\n            // Starts after successful user authentication\n            if (this._protocol._authenticated) {\n              // If a rekey happens and this compression method is selected and\n              // we already authenticated successfully, we need to start\n              // immediately instead\n              if (isServer) rw.read = new ZlibPacketReader();else rw.write = new ZlibPacketWriter(this._protocol);\n              break;\n            }\n\n          // FALLTHROUGH\n\n          default:\n            // none -- never any compression/decompression\n            if (isServer) rw.read = new PacketReader();else rw.write = new PacketWriter(this._protocol);\n        }\n\n        switch (negotiated.sc.compress) {\n          case 'zlib':\n            // starts immediately\n            if (isServer) rw.write = new ZlibPacketWriter(this._protocol);else rw.read = new ZlibPacketReader();\n            break;\n\n          case 'zlib@openssh.com':\n            // Starts after successful user authentication\n            if (this._protocol._authenticated) {\n              // If a rekey happens and this compression method is selected and\n              // we already authenticated successfully, we need to start\n              // immediately instead\n              if (isServer) rw.write = new ZlibPacketWriter(this._protocol);else rw.read = new ZlibPacketReader();\n              break;\n            }\n\n          // FALLTHROUGH\n\n          default:\n            // none -- never any compression/decompression\n            if (isServer) rw.write = new PacketWriter(this._protocol);else rw.read = new PacketReader();\n        }\n\n        this._protocol._packetRW.read.cleanup();\n\n        this._protocol._packetRW.write.cleanup();\n\n        this._protocol._packetRW = rw; // Cleanup/reset various state\n\n        this._public = null;\n        this._dh = null;\n        this._kexinit = this._protocol._kexinit = undefined;\n        this._remoteKexinit = undefined;\n        this._identRaw = undefined;\n        this._remoteIdentRaw = undefined;\n        this._hostKey = undefined;\n        this._dhData = undefined;\n        this._sig = undefined;\n\n        this._protocol._onHandshakeComplete(negotiated);\n\n        return false;\n      };\n\n      if (!isServer) return completeHandshake();\n      this.finish = completeHandshake;\n    }\n\n    start() {\n      if (!this._protocol._server) {\n        if (this._protocol._debug) {\n          let type;\n\n          switch (this.type) {\n            case 'group':\n              type = 'KEXDH_INIT';\n              break;\n\n            default:\n              type = 'KEXECDH_INIT';\n          }\n\n          this._protocol._debug(`Outbound: Sending ${type}`);\n        }\n\n        const pubKey = this.getPublicKey();\n        let p = this._protocol._packetRW.write.allocStartKEX;\n\n        const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubKey.length, true);\n\n        packet[p] = MESSAGE.KEXDH_INIT;\n        writeUInt32BE(packet, pubKey.length, ++p);\n        packet.set(pubKey, p += 4);\n\n        this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));\n      }\n    }\n\n    getPublicKey() {\n      this.generateKeys();\n      const key = this._public;\n      if (key) return this.convertPublicKey(key);\n    }\n\n    convertPublicKey(key) {\n      let newKey;\n      let idx = 0;\n      let len = key.length;\n\n      while (key[idx] === 0x00) {\n        ++idx;\n        --len;\n      }\n\n      if (key[idx] & 0x80) {\n        newKey = Buffer.allocUnsafe(1 + len);\n        newKey[0] = 0;\n        key.copy(newKey, 1, idx);\n        return newKey;\n      }\n\n      if (len !== key.length) {\n        newKey = Buffer.allocUnsafe(len);\n        key.copy(newKey, 0, idx);\n        key = newKey;\n      }\n\n      return key;\n    }\n\n    computeSecret(otherPublicKey) {\n      this.generateKeys();\n\n      try {\n        return convertToMpint(this._dh.computeSecret(otherPublicKey));\n      } catch (ex) {\n        return ex;\n      }\n    }\n\n    parse(payload) {\n      const type = payload[0];\n\n      switch (this._step) {\n        case 1:\n          if (this._protocol._server) {\n            // Server\n            if (type !== MESSAGE.KEXDH_INIT) {\n              return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_INIT}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n\n            this._protocol._debug && this._protocol._debug('Received DH Init');\n            /*\n              byte     SSH_MSG_KEXDH_INIT\n                         / SSH_MSG_KEX_ECDH_INIT\n              string   <method-specific data>\n            */\n\n            bufferParser.init(payload, 1);\n            const dhData = bufferParser.readString();\n            bufferParser.clear();\n\n            if (dhData === undefined) {\n              return doFatalError(this._protocol, 'Received malformed KEX*_INIT', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            } // Client public key\n\n\n            this._dhData = dhData;\n            let hostKey = this._protocol._hostKeys[this.negotiated.serverHostKey];\n            if (Array.isArray(hostKey)) hostKey = hostKey[0];\n            this._hostKey = hostKey;\n            this.finish();\n          } else {\n            // Client\n            if (type !== MESSAGE.KEXDH_REPLY) {\n              return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_REPLY}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n\n            this._protocol._debug && this._protocol._debug('Received DH Reply');\n            /*\n              byte      SSH_MSG_KEXDH_REPLY\n                          / SSH_MSG_KEX_DH_GEX_REPLY\n                          / SSH_MSG_KEX_ECDH_REPLY\n              string    server public host key and certificates (K_S)\n              string    <method-specific data>\n              string    signature of H\n            */\n\n            bufferParser.init(payload, 1);\n            let hostPubKey;\n            let dhData;\n            let sig;\n\n            if ((hostPubKey = bufferParser.readString()) === undefined || (dhData = bufferParser.readString()) === undefined || (sig = bufferParser.readString()) === undefined) {\n              bufferParser.clear();\n              return doFatalError(this._protocol, 'Received malformed KEX*_REPLY', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n\n            bufferParser.clear(); // Check that the host public key type matches what was negotiated\n            // during KEXINIT swap\n\n            bufferParser.init(hostPubKey, 0);\n            const hostPubKeyType = bufferParser.readString(true);\n            bufferParser.clear();\n\n            if (hostPubKeyType === undefined) {\n              return doFatalError(this._protocol, 'Received malformed host public key', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n\n            if (hostPubKeyType !== this.negotiated.serverHostKey) {\n              // Check if we need to make an exception\n              switch (this.negotiated.serverHostKey) {\n                case 'rsa-sha2-256':\n                case 'rsa-sha2-512':\n                  if (hostPubKeyType === 'ssh-rsa') break;\n                // FALLTHROUGH\n\n                default:\n                  return doFatalError(this._protocol, 'Host key does not match negotiated type', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n              }\n            }\n\n            this._hostKey = hostPubKey;\n            this._dhData = dhData;\n            this._sig = sig;\n            let checked = false;\n            let ret;\n\n            if (this._protocol._hostVerifier === undefined) {\n              ret = true;\n              this._protocol._debug && this._protocol._debug('Host accepted by default (no verification)');\n            } else {\n              ret = this._protocol._hostVerifier(hostPubKey, permitted => {\n                if (checked) return;\n                checked = true;\n\n                if (permitted === false) {\n                  this._protocol._debug && this._protocol._debug('Host denied (verification failed)');\n                  return doFatalError(this._protocol, 'Host denied (verification failed)', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n                }\n\n                this._protocol._debug && this._protocol._debug('Host accepted (verified)');\n                this._hostVerified = true;\n                if (this._receivedNEWKEYS) this.finish();else trySendNEWKEYS(this);\n              });\n            }\n\n            if (ret === undefined) {\n              // Async host verification\n              ++this._step;\n              return;\n            }\n\n            checked = true;\n\n            if (ret === false) {\n              this._protocol._debug && this._protocol._debug('Host denied (verification failed)');\n              return doFatalError(this._protocol, 'Host denied (verification failed)', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n\n            this._protocol._debug && this._protocol._debug('Host accepted (verified)');\n            this._hostVerified = true;\n            trySendNEWKEYS(this);\n          }\n\n          ++this._step;\n          break;\n\n        case 2:\n          if (type !== MESSAGE.NEWKEYS) {\n            return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.NEWKEYS}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n          }\n\n          this._protocol._debug && this._protocol._debug('Inbound: NEWKEYS');\n          this._receivedNEWKEYS = true;\n          ++this._step;\n          if (this._protocol._server || this._hostVerified) return this.finish(); // Signal to current decipher that we need to change to a new decipher\n          // for the next packet\n\n          return false;\n\n        default:\n          return doFatalError(this._protocol, `Received unexpected packet ${type} after NEWKEYS`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      }\n    }\n\n  }\n\n  class Curve25519Exchange extends KeyExchange {\n    constructor(hashName) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      super(...args);\n      this.type = '25519';\n      this.hashName = hashName;\n      this._keys = null;\n    }\n\n    generateKeys() {\n      if (!this._keys) this._keys = generateKeyPairSync('x25519');\n    }\n\n    getPublicKey() {\n      this.generateKeys();\n\n      const key = this._keys.publicKey.export({\n        type: 'spki',\n        format: 'der'\n      });\n\n      return key.slice(-32); // HACK: avoids parsing DER/BER header\n    }\n\n    convertPublicKey(key) {\n      let newKey;\n      let idx = 0;\n      let len = key.length;\n\n      while (key[idx] === 0x00) {\n        ++idx;\n        --len;\n      }\n\n      if (key.length === 32) return key;\n\n      if (len !== key.length) {\n        newKey = Buffer.allocUnsafe(len);\n        key.copy(newKey, 0, idx);\n        key = newKey;\n      }\n\n      return key;\n    }\n\n    computeSecret(otherPublicKey) {\n      this.generateKeys();\n\n      try {\n        const asnWriter = new Ber.Writer();\n        asnWriter.startSequence(); // algorithm\n\n        asnWriter.startSequence();\n        asnWriter.writeOID('1.3.101.110'); // id-X25519\n\n        asnWriter.endSequence(); // PublicKey\n\n        asnWriter.startSequence(Ber.BitString);\n        asnWriter.writeByte(0x00); // XXX: hack to write a raw buffer without a tag -- yuck\n\n        asnWriter._ensure(otherPublicKey.length);\n\n        otherPublicKey.copy(asnWriter._buf, asnWriter._offset, 0, otherPublicKey.length);\n        asnWriter._offset += otherPublicKey.length;\n        asnWriter.endSequence();\n        asnWriter.endSequence();\n        return convertToMpint(diffieHellman({\n          privateKey: this._keys.privateKey,\n          publicKey: createPublicKey({\n            key: asnWriter.buffer,\n            type: 'spki',\n            format: 'der'\n          })\n        }));\n      } catch (ex) {\n        return ex;\n      }\n    }\n\n  }\n\n  class ECDHExchange extends KeyExchange {\n    constructor(curveName, hashName) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      super(...args);\n      this.type = 'ecdh';\n      this.curveName = curveName;\n      this.hashName = hashName;\n    }\n\n    generateKeys() {\n      if (!this._dh) {\n        this._dh = createECDH(this.curveName);\n        this._public = this._dh.generateKeys();\n      }\n    }\n\n  }\n\n  class DHGroupExchange extends KeyExchange {\n    constructor(hashName) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      super(...args);\n      this.type = 'groupex';\n      this.hashName = hashName;\n      this._prime = null;\n      this._generator = null;\n      this._minBits = GEX_MIN_BITS;\n      this._prefBits = dhEstimate(this.negotiated);\n      if (this._protocol._compatFlags & COMPAT.BUG_DHGEX_LARGE) this._prefBits = Math.min(this._prefBits, 4096);\n      this._maxBits = GEX_MAX_BITS;\n    }\n\n    start() {\n      if (this._protocol._server) return;\n      this._protocol._debug && this._protocol._debug('Outbound: Sending KEXDH_GEX_REQUEST');\n      let p = this._protocol._packetRW.write.allocStartKEX;\n\n      const packet = this._protocol._packetRW.write.alloc(1 + 4 + 4 + 4, true);\n\n      packet[p] = MESSAGE.KEXDH_GEX_REQUEST;\n      writeUInt32BE(packet, this._minBits, ++p);\n      writeUInt32BE(packet, this._prefBits, p += 4);\n      writeUInt32BE(packet, this._maxBits, p += 4);\n\n      this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));\n    }\n\n    generateKeys() {\n      if (!this._dh && this._prime && this._generator) {\n        this._dh = createDiffieHellman(this._prime, this._generator);\n        this._public = this._dh.generateKeys();\n      }\n    }\n\n    setDHParams(prime, generator) {\n      if (!Buffer.isBuffer(prime)) throw new Error('Invalid prime value');\n      if (!Buffer.isBuffer(generator)) throw new Error('Invalid generator value');\n      this._prime = prime;\n      this._generator = generator;\n    }\n\n    getDHParams() {\n      if (this._dh) {\n        return {\n          prime: convertToMpint(this._dh.getPrime()),\n          generator: convertToMpint(this._dh.getGenerator())\n        };\n      }\n    }\n\n    parse(payload) {\n      const type = payload[0];\n\n      switch (this._step) {\n        case 1:\n          if (this._protocol._server) {\n            if (type !== MESSAGE.KEXDH_GEX_REQUEST) {\n              return doFatalError(this._protocol, `Received packet ${type} instead of ` + MESSAGE.KEXDH_GEX_REQUEST, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            } // TODO: allow user implementation to provide safe prime and\n            // generator on demand to support group exchange on server side\n\n\n            return doFatalError(this._protocol, 'Group exchange not implemented for server', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n          }\n\n          if (type !== MESSAGE.KEXDH_GEX_GROUP) {\n            return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_GROUP}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n          }\n\n          this._protocol._debug && this._protocol._debug('Received DH GEX Group');\n          /*\n            byte    SSH_MSG_KEX_DH_GEX_GROUP\n            mpint   p, safe prime\n            mpint   g, generator for subgroup in GF(p)\n          */\n\n          bufferParser.init(payload, 1);\n          let prime;\n          let gen;\n\n          if ((prime = bufferParser.readString()) === undefined || (gen = bufferParser.readString()) === undefined) {\n            bufferParser.clear();\n            return doFatalError(this._protocol, 'Received malformed KEXDH_GEX_GROUP', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n          }\n\n          bufferParser.clear(); // TODO: validate prime\n\n          this.setDHParams(prime, gen);\n          this.generateKeys();\n          const pubkey = this.getPublicKey();\n          this._protocol._debug && this._protocol._debug('Outbound: Sending KEXDH_GEX_INIT');\n          let p = this._protocol._packetRW.write.allocStartKEX;\n\n          const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubkey.length, true);\n\n          packet[p] = MESSAGE.KEXDH_GEX_INIT;\n          writeUInt32BE(packet, pubkey.length, ++p);\n          packet.set(pubkey, p += 4);\n\n          this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));\n\n          ++this._step;\n          break;\n\n        case 2:\n          if (this._protocol._server) {\n            if (type !== MESSAGE.KEXDH_GEX_INIT) {\n              return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_INIT}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n\n            this._protocol._debug && this._protocol._debug('Received DH GEX Init');\n            return doFatalError(this._protocol, 'Group exchange not implemented for server', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n          } else if (type !== MESSAGE.KEXDH_GEX_REPLY) {\n            return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_REPLY}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n          }\n\n          this._protocol._debug && this._protocol._debug('Received DH GEX Reply');\n          this._step = 1;\n          payload[0] = MESSAGE.KEXDH_REPLY;\n          this.parse = KeyExchange.prototype.parse;\n          this.parse(payload);\n      }\n    }\n\n  }\n\n  class DHExchange extends KeyExchange {\n    constructor(groupName, hashName) {\n      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n        args[_key4 - 2] = arguments[_key4];\n      }\n\n      super(...args);\n      this.type = 'group';\n      this.groupName = groupName;\n      this.hashName = hashName;\n    }\n\n    start() {\n      if (!this._protocol._server) {\n        this._protocol._debug && this._protocol._debug('Outbound: Sending KEXDH_INIT');\n        const pubKey = this.getPublicKey();\n        let p = this._protocol._packetRW.write.allocStartKEX;\n\n        const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubKey.length, true);\n\n        packet[p] = MESSAGE.KEXDH_INIT;\n        writeUInt32BE(packet, pubKey.length, ++p);\n        packet.set(pubKey, p += 4);\n\n        this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));\n      }\n    }\n\n    generateKeys() {\n      if (!this._dh) {\n        this._dh = createDiffieHellmanGroup(this.groupName);\n        this._public = this._dh.generateKeys();\n      }\n    }\n\n    getDHParams() {\n      if (this._dh) {\n        return {\n          prime: convertToMpint(this._dh.getPrime()),\n          generator: convertToMpint(this._dh.getGenerator())\n        };\n      }\n    }\n\n  }\n\n  return function (negotiated) {\n    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      args[_key5 - 1] = arguments[_key5];\n    }\n\n    if (typeof negotiated !== 'object' || negotiated === null) throw new Error('Invalid negotiated argument');\n    const kexType = negotiated.kex;\n\n    if (typeof kexType === 'string') {\n      args = [negotiated, ...args];\n\n      switch (kexType) {\n        case 'curve25519-sha256':\n        case 'curve25519-sha256@libssh.org':\n          if (!curve25519Supported) break;\n          return new Curve25519Exchange('sha256', ...args);\n\n        case 'ecdh-sha2-nistp256':\n          return new ECDHExchange('prime256v1', 'sha256', ...args);\n\n        case 'ecdh-sha2-nistp384':\n          return new ECDHExchange('secp384r1', 'sha384', ...args);\n\n        case 'ecdh-sha2-nistp521':\n          return new ECDHExchange('secp521r1', 'sha512', ...args);\n\n        case 'diffie-hellman-group1-sha1':\n          return new DHExchange('modp2', 'sha1', ...args);\n\n        case 'diffie-hellman-group14-sha1':\n          return new DHExchange('modp14', 'sha1', ...args);\n\n        case 'diffie-hellman-group14-sha256':\n          return new DHExchange('modp14', 'sha256', ...args);\n\n        case 'diffie-hellman-group15-sha512':\n          return new DHExchange('modp15', 'sha512', ...args);\n\n        case 'diffie-hellman-group16-sha512':\n          return new DHExchange('modp16', 'sha512', ...args);\n\n        case 'diffie-hellman-group17-sha512':\n          return new DHExchange('modp17', 'sha512', ...args);\n\n        case 'diffie-hellman-group18-sha512':\n          return new DHExchange('modp18', 'sha512', ...args);\n\n        case 'diffie-hellman-group-exchange-sha1':\n          return new DHGroupExchange('sha1', ...args);\n\n        case 'diffie-hellman-group-exchange-sha256':\n          return new DHGroupExchange('sha256', ...args);\n      }\n\n      throw new Error(`Unsupported key exchange algorithm: ${kexType}`);\n    }\n\n    throw new Error(`Invalid key exchange type: ${kexType}`);\n  };\n})();\n\nconst KexInit = (() => {\n  const KEX_PROPERTY_NAMES = ['kex', 'serverHostKey', ['cs', 'cipher'], ['sc', 'cipher'], ['cs', 'mac'], ['sc', 'mac'], ['cs', 'compress'], ['sc', 'compress'], ['cs', 'lang'], ['sc', 'lang']];\n  return class KexInit {\n    constructor(obj) {\n      if (typeof obj !== 'object' || obj === null) throw new TypeError('Argument must be an object');\n      const lists = {\n        kex: undefined,\n        serverHostKey: undefined,\n        cs: {\n          cipher: undefined,\n          mac: undefined,\n          compress: undefined,\n          lang: undefined\n        },\n        sc: {\n          cipher: undefined,\n          mac: undefined,\n          compress: undefined,\n          lang: undefined\n        },\n        all: undefined\n      };\n      let totalSize = 0;\n\n      for (const prop of KEX_PROPERTY_NAMES) {\n        let base;\n        let val;\n        let desc;\n        let key;\n\n        if (typeof prop === 'string') {\n          base = lists;\n          val = obj[prop];\n          desc = key = prop;\n        } else {\n          const parent = prop[0];\n          base = lists[parent];\n          key = prop[1];\n          val = obj[parent][key];\n          desc = `${parent}.${key}`;\n        }\n\n        const entry = {\n          array: undefined,\n          buffer: undefined\n        };\n\n        if (Buffer.isBuffer(val)) {\n          entry.array = ('' + val).split(',');\n          entry.buffer = val;\n          totalSize += 4 + val.length;\n        } else {\n          if (typeof val === 'string') val = val.split(',');\n\n          if (Array.isArray(val)) {\n            entry.array = val;\n            entry.buffer = Buffer.from(val.join(','));\n          } else {\n            throw new TypeError(`Invalid \\`${desc}\\` type: ${typeof val}`);\n          }\n\n          totalSize += 4 + entry.buffer.length;\n        }\n\n        base[key] = entry;\n      }\n\n      const all = Buffer.allocUnsafe(totalSize);\n      lists.all = all;\n      let allPos = 0;\n\n      for (const prop of KEX_PROPERTY_NAMES) {\n        let data;\n        if (typeof prop === 'string') data = lists[prop].buffer;else data = lists[prop[0]][prop[1]].buffer;\n        allPos = writeUInt32BE(all, data.length, allPos);\n        all.set(data, allPos);\n        allPos += data.length;\n      }\n\n      this.totalSize = totalSize;\n      this.lists = lists;\n    }\n\n    copyAllTo(buf, offset) {\n      const src = this.lists.all;\n      if (typeof offset !== 'number') throw new TypeError(`Invalid offset value: ${typeof offset}`);\n      if (buf.length - offset < src.length) throw new Error('Insufficient space to copy list');\n      buf.set(src, offset);\n      return src.length;\n    }\n\n  };\n})();\n\nconst hashString = (() => {\n  const LEN = Buffer.allocUnsafe(4);\n  return (hash, buf) => {\n    writeUInt32BE(LEN, buf.length, 0);\n    hash.update(LEN);\n    hash.update(buf);\n  };\n})();\n\nfunction generateKEXVal(len, hashName, secret, exchangeHash, sessionID, char) {\n  let ret;\n\n  if (len) {\n    let digest = createHash(hashName).update(secret).update(exchangeHash).update(char).update(sessionID).digest();\n\n    while (digest.length < len) {\n      const chunk = createHash(hashName).update(secret).update(exchangeHash).update(digest).digest();\n      const extended = Buffer.allocUnsafe(digest.length + chunk.length);\n      extended.set(digest, 0);\n      extended.set(chunk, digest.length);\n      digest = extended;\n    }\n\n    if (digest.length === len) ret = digest;else ret = new FastBuffer(digest.buffer, digest.byteOffset, len);\n  } else {\n    ret = EMPTY_BUFFER;\n  }\n\n  return ret;\n}\n\nfunction onKEXPayload(state, payload) {\n  // XXX: move this to the Decipher implementations?\n  if (payload.length === 0) {\n    this._debug && this._debug('Inbound: Skipping empty packet payload');\n    return;\n  }\n\n  if (this._skipNextInboundPacket) {\n    this._skipNextInboundPacket = false;\n    return;\n  }\n\n  payload = this._packetRW.read.read(payload);\n  const type = payload[0];\n\n  switch (type) {\n    case MESSAGE.DISCONNECT:\n    case MESSAGE.IGNORE:\n    case MESSAGE.UNIMPLEMENTED:\n    case MESSAGE.DEBUG:\n      if (!MESSAGE_HANDLERS) MESSAGE_HANDLERS = require('./handlers.js');\n      return MESSAGE_HANDLERS[type](this, payload);\n\n    case MESSAGE.KEXINIT:\n      if (!state.firstPacket) {\n        return doFatalError(this, 'Received extra KEXINIT during handshake', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      }\n\n      state.firstPacket = false;\n      return handleKexInit(this, payload);\n\n    default:\n      if (type < 20 || type > 49) {\n        return doFatalError(this, `Received unexpected packet type ${type}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      }\n\n  }\n\n  return this._kex.parse(payload);\n}\n\nfunction dhEstimate(neg) {\n  const csCipher = CIPHER_INFO[neg.cs.cipher];\n  const scCipher = CIPHER_INFO[neg.sc.cipher]; // XXX: if OpenSSH's `umac-*` MACs are ever supported, their key lengths will\n  // also need to be considered when calculating `bits`\n\n  const bits = Math.max(0, csCipher.sslName === 'des-ede3-cbc' ? 14 : csCipher.keyLen, csCipher.blockLen, csCipher.ivLen, scCipher.sslName === 'des-ede3-cbc' ? 14 : scCipher.keyLen, scCipher.blockLen, scCipher.ivLen) * 8;\n  if (bits <= 112) return 2048;\n  if (bits <= 128) return 3072;\n  if (bits <= 192) return 7680;\n  return 8192;\n}\n\nfunction trySendNEWKEYS(kex) {\n  if (!kex._sentNEWKEYS) {\n    kex._protocol._debug && kex._protocol._debug('Outbound: Sending NEWKEYS');\n    const p = kex._protocol._packetRW.write.allocStartKEX;\n\n    const packet = kex._protocol._packetRW.write.alloc(1, true);\n\n    packet[p] = MESSAGE.NEWKEYS;\n\n    kex._protocol._cipher.encrypt(kex._protocol._packetRW.write.finalize(packet, true));\n\n    kex._sentNEWKEYS = true;\n  }\n}\n\nmodule.exports = {\n  KexInit,\n  kexinit,\n  onKEXPayload,\n  DEFAULT_KEXINIT: new KexInit({\n    kex: DEFAULT_KEX,\n    serverHostKey: DEFAULT_SERVER_HOST_KEY,\n    cs: {\n      cipher: DEFAULT_CIPHER,\n      mac: DEFAULT_MAC,\n      compress: DEFAULT_COMPRESSION,\n      lang: []\n    },\n    sc: {\n      cipher: DEFAULT_CIPHER,\n      mac: DEFAULT_MAC,\n      compress: DEFAULT_COMPRESSION,\n      lang: []\n    }\n  }),\n  HANDLERS: {\n    [MESSAGE.KEXINIT]: handleKexInit\n  }\n};","map":{"version":3,"names":["createDiffieHellman","createDiffieHellmanGroup","createECDH","createHash","createPublicKey","diffieHellman","generateKeyPairSync","randomFillSync","require","Ber","COMPAT","curve25519Supported","DEFAULT_KEX","DEFAULT_SERVER_HOST_KEY","DEFAULT_CIPHER","DEFAULT_MAC","DEFAULT_COMPRESSION","DISCONNECT_REASON","MESSAGE","CIPHER_INFO","createCipher","createDecipher","MAC_INFO","parseDERKey","bufferFill","bufferParser","convertSignature","doFatalError","FastBuffer","sigSSHToASN1","writeUInt32BE","PacketReader","PacketWriter","ZlibPacketReader","ZlibPacketWriter","MESSAGE_HANDLERS","GEX_MIN_BITS","GEX_MAX_BITS","EMPTY_BUFFER","Buffer","alloc","kexinit","self","payload","_compatFlags","BAD_DHGEX","entry","_offer","lists","kex","array","found","i","length","includes","slice","splice","len","totalSize","newKexBuf","from","join","buffer","all","rest","Uint8Array","byteOffset","allocUnsafe","set","undefined","copyAllTo","_debug","KEXINIT","_kexinit","_packetRW","write","allocStart","p","allocStartKEX","packet","_cipher","encrypt","finalize","handleKexInit","init","serverHostKey","cs","cipher","mac","compress","lang","sc","readList","clear","KEY_EXCHANGE_FAILED","pos","firstFollows","local","remote","localKex","indexOf","clientList","serverList","debug","_server","_skipNextInboundPacket","localSrvHostKey","localCSCipher","localSCCipher","localCSMAC","authLen","localSCMAC","localCSCompress","localSCCompress","_kex","_decipher","_onPayload","onKEXPayload","bind","firstPacket","createKeyExchange","start","convertToMpint","buf","idx","newBuf","copy","KeyExchange","constructor","negotiated","protocol","remoteKexinit","_protocol","sessionID","_step","_public","_dh","_sentNEWKEYS","_receivedNEWKEYS","_finished","_hostVerified","_remoteKexinit","_identRaw","_remoteIdentRaw","_hostKey","_dhData","_sig","finish","isServer","pubKey","convertPublicKey","secret","computeSecret","Error","message","type","level","hash","hashName","hashString","serverPublicHostKey","getPublicSSH","params","getDHParams","num","_minBits","update","_prefBits","_maxBits","prime","generator","getPublicKey","serverPublicKey","exchangeHash","digest","sigType","readString","sigValue","parsedHostKey","name","hostKey","hashAlgo","verified","verify","stack","signature","sign","sigTypeLen","byteLength","sigLen","KEXDH_REPLY","utf8Write","trySendNEWKEYS","completeHandshake","newSecret","csCipherInfo","scCipherInfo","csIV","generateKEXVal","ivLen","scIV","csKey","keyLen","scKey","csMacInfo","csMacKey","scMacInfo","scMacKey","config","inbound","onPayload","seqno","inSeqno","decipherInfo","decipherIV","decipherKey","macInfo","macKey","outbound","onWrite","_onWrite","outSeqno","cipherInfo","cipherIV","cipherKey","free","rw","read","_authenticated","cleanup","_onHandshakeComplete","KEXDH_INIT","generateKeys","key","newKey","otherPublicKey","ex","parse","dhData","_hostKeys","Array","isArray","hostPubKey","sig","hostPubKeyType","checked","ret","_hostVerifier","permitted","NEWKEYS","Curve25519Exchange","args","_keys","publicKey","export","format","asnWriter","Writer","startSequence","writeOID","endSequence","BitString","writeByte","_ensure","_buf","_offset","privateKey","ECDHExchange","curveName","DHGroupExchange","_prime","_generator","dhEstimate","BUG_DHGEX_LARGE","Math","min","KEXDH_GEX_REQUEST","setDHParams","isBuffer","getPrime","getGenerator","KEXDH_GEX_GROUP","gen","pubkey","KEXDH_GEX_INIT","KEXDH_GEX_REPLY","prototype","DHExchange","groupName","kexType","KexInit","KEX_PROPERTY_NAMES","obj","TypeError","prop","base","val","desc","parent","split","allPos","data","offset","src","LEN","char","chunk","extended","state","DISCONNECT","IGNORE","UNIMPLEMENTED","DEBUG","neg","csCipher","scCipher","bits","max","sslName","blockLen","module","exports","DEFAULT_KEXINIT","HANDLERS"],"sources":["/home/micqdf/AlpacaPunchTests/maintest/test1/client/node_modules/ssh2/lib/protocol/kex.js"],"sourcesContent":["'use strict';\n\nconst {\n  createDiffieHellman,\n  createDiffieHellmanGroup,\n  createECDH,\n  createHash,\n  createPublicKey,\n  diffieHellman,\n  generateKeyPairSync,\n  randomFillSync,\n} = require('crypto');\n\nconst { Ber } = require('asn1');\n\nconst {\n  COMPAT,\n  curve25519Supported,\n  DEFAULT_KEX,\n  DEFAULT_SERVER_HOST_KEY,\n  DEFAULT_CIPHER,\n  DEFAULT_MAC,\n  DEFAULT_COMPRESSION,\n  DISCONNECT_REASON,\n  MESSAGE,\n} = require('./constants.js');\nconst {\n  CIPHER_INFO,\n  createCipher,\n  createDecipher,\n  MAC_INFO,\n} = require('./crypto.js');\nconst { parseDERKey } = require('./keyParser.js');\nconst {\n  bufferFill,\n  bufferParser,\n  convertSignature,\n  doFatalError,\n  FastBuffer,\n  sigSSHToASN1,\n  writeUInt32BE,\n} = require('./utils.js');\nconst {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter,\n} = require('./zlib.js');\n\nlet MESSAGE_HANDLERS;\n\nconst GEX_MIN_BITS = 2048; // RFC 8270\nconst GEX_MAX_BITS = 8192; // RFC 8270\n\nconst EMPTY_BUFFER = Buffer.alloc(0);\n\n// Client/Server\nfunction kexinit(self) {\n  /*\n    byte         SSH_MSG_KEXINIT\n    byte[16]     cookie (random bytes)\n    name-list    kex_algorithms\n    name-list    server_host_key_algorithms\n    name-list    encryption_algorithms_client_to_server\n    name-list    encryption_algorithms_server_to_client\n    name-list    mac_algorithms_client_to_server\n    name-list    mac_algorithms_server_to_client\n    name-list    compression_algorithms_client_to_server\n    name-list    compression_algorithms_server_to_client\n    name-list    languages_client_to_server\n    name-list    languages_server_to_client\n    boolean      first_kex_packet_follows\n    uint32       0 (reserved for future extension)\n  */\n\n  let payload;\n  if (self._compatFlags & COMPAT.BAD_DHGEX) {\n    const entry = self._offer.lists.kex;\n    let kex = entry.array;\n    let found = false;\n    for (let i = 0; i < kex.length; ++i) {\n      if (kex[i].includes('group-exchange')) {\n        if (!found) {\n          found = true;\n          // Copy array lazily\n          kex = kex.slice();\n        }\n        kex.splice(i--, 1);\n      }\n    }\n    if (found) {\n      let len = 1 + 16 + self._offer.totalSize + 1 + 4;\n      const newKexBuf = Buffer.from(kex.join(','));\n      len -= (entry.buffer.length - newKexBuf.length);\n\n      const all = self._offer.lists.all;\n      const rest = new Uint8Array(\n        all.buffer,\n        all.byteOffset + 4 + entry.buffer.length,\n        all.length - (4 + entry.buffer.length)\n      );\n\n      payload = Buffer.allocUnsafe(len);\n      writeUInt32BE(payload, newKexBuf.length, 17);\n      payload.set(newKexBuf, 17 + 4);\n      payload.set(rest, 17 + 4 + newKexBuf.length);\n    }\n  }\n\n  if (payload === undefined) {\n    payload = Buffer.allocUnsafe(1 + 16 + self._offer.totalSize + 1 + 4);\n    self._offer.copyAllTo(payload, 17);\n  }\n\n  self._debug && self._debug('Outbound: Sending KEXINIT');\n\n  payload[0] = MESSAGE.KEXINIT;\n  randomFillSync(payload, 1, 16);\n\n  // Zero-fill first_kex_packet_follows and reserved bytes\n  bufferFill(payload, 0, payload.length - 5);\n\n  self._kexinit = payload;\n\n  // Needed to correct the starting position in allocated \"packets\" when packets\n  // will be buffered due to active key exchange\n  self._packetRW.write.allocStart = 0;\n\n  // TODO: only create single buffer and set _kexinit as slice of packet instead\n  {\n    const p = self._packetRW.write.allocStartKEX;\n    const packet = self._packetRW.write.alloc(payload.length, true);\n    packet.set(payload, p);\n    self._cipher.encrypt(self._packetRW.write.finalize(packet, true));\n  }\n}\n\nfunction handleKexInit(self, payload) {\n  /*\n    byte         SSH_MSG_KEXINIT\n    byte[16]     cookie (random bytes)\n    name-list    kex_algorithms\n    name-list    server_host_key_algorithms\n    name-list    encryption_algorithms_client_to_server\n    name-list    encryption_algorithms_server_to_client\n    name-list    mac_algorithms_client_to_server\n    name-list    mac_algorithms_server_to_client\n    name-list    compression_algorithms_client_to_server\n    name-list    compression_algorithms_server_to_client\n    name-list    languages_client_to_server\n    name-list    languages_server_to_client\n    boolean      first_kex_packet_follows\n    uint32       0 (reserved for future extension)\n  */\n  const init = {\n    kex: undefined,\n    serverHostKey: undefined,\n    cs: {\n      cipher: undefined,\n      mac: undefined,\n      compress: undefined,\n      lang: undefined,\n    },\n    sc: {\n      cipher: undefined,\n      mac: undefined,\n      compress: undefined,\n      lang: undefined,\n    },\n  };\n\n  bufferParser.init(payload, 17);\n\n  if ((init.kex = bufferParser.readList()) === undefined\n      || (init.serverHostKey = bufferParser.readList()) === undefined\n      || (init.cs.cipher = bufferParser.readList()) === undefined\n      || (init.sc.cipher = bufferParser.readList()) === undefined\n      || (init.cs.mac = bufferParser.readList()) === undefined\n      || (init.sc.mac = bufferParser.readList()) === undefined\n      || (init.cs.compress = bufferParser.readList()) === undefined\n      || (init.sc.compress = bufferParser.readList()) === undefined\n      || (init.cs.lang = bufferParser.readList()) === undefined\n      || (init.sc.lang = bufferParser.readList()) === undefined) {\n    bufferParser.clear();\n    return doFatalError(\n      self,\n      'Received malformed KEXINIT',\n      'handshake',\n      DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n    );\n  }\n\n  const pos = bufferParser.pos();\n  const firstFollows = (pos < payload.length && payload[pos] === 1);\n  bufferParser.clear();\n\n  const local = self._offer;\n  const remote = init;\n\n  let localKex = local.lists.kex.array;\n  if (self._compatFlags & COMPAT.BAD_DHGEX) {\n    let found = false;\n    for (let i = 0; i < localKex.length; ++i) {\n      if (localKex[i].indexOf('group-exchange') !== -1) {\n        if (!found) {\n          found = true;\n          // Copy array lazily\n          localKex = localKex.slice();\n        }\n        localKex.splice(i--, 1);\n      }\n    }\n  }\n\n  let clientList;\n  let serverList;\n  let i;\n  const debug = self._debug;\n\n  debug && debug('Inbound: Handshake in progress');\n\n  // Key exchange method =======================================================\n  debug && debug(`Handshake: (local) KEX method: ${localKex}`);\n  debug && debug(`Handshake: (remote) KEX method: ${remote.kex}`);\n  if (self._server) {\n    serverList = localKex;\n    clientList = remote.kex;\n  } else {\n    serverList = remote.kex;\n    clientList = localKex;\n  }\n  // Check for agreeable key exchange algorithm\n  for (i = 0;\n       i < clientList.length && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching key exchange algorithm');\n    return doFatalError(\n      self,\n      'Handshake failed: no matching key exchange algorithm',\n      'handshake',\n      DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n    );\n  }\n  init.kex = clientList[i];\n  debug && debug(`Handshake: KEX algorithm: ${clientList[i]}`);\n  if (firstFollows && (!remote.kex.length || clientList[i] !== remote.kex[0])) {\n    // Ignore next inbound packet, it was a wrong first guess at KEX algorithm\n    self._skipNextInboundPacket = true;\n  }\n\n\n  // Server host key format ====================================================\n  const localSrvHostKey = local.lists.serverHostKey.array;\n  debug && debug(`Handshake: (local) Host key format: ${localSrvHostKey}`);\n  debug && debug(\n    `Handshake: (remote) Host key format: ${remote.serverHostKey}`\n  );\n  if (self._server) {\n    serverList = localSrvHostKey;\n    clientList = remote.serverHostKey;\n  } else {\n    serverList = remote.serverHostKey;\n    clientList = localSrvHostKey;\n  }\n  // Check for agreeable server host key format\n  for (i = 0;\n       i < clientList.length && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching host key format');\n    return doFatalError(\n      self,\n      'Handshake failed: no matching host key format',\n      'handshake',\n      DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n    );\n  }\n  init.serverHostKey = clientList[i];\n  debug && debug(`Handshake: Host key format: ${clientList[i]}`);\n\n\n  // Client->Server cipher =====================================================\n  const localCSCipher = local.lists.cs.cipher.array;\n  debug && debug(`Handshake: (local) C->S cipher: ${localCSCipher}`);\n  debug && debug(`Handshake: (remote) C->S cipher: ${remote.cs.cipher}`);\n  if (self._server) {\n    serverList = localCSCipher;\n    clientList = remote.cs.cipher;\n  } else {\n    serverList = remote.cs.cipher;\n    clientList = localCSCipher;\n  }\n  // Check for agreeable client->server cipher\n  for (i = 0;\n       i < clientList.length && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching C->S cipher');\n    return doFatalError(\n      self,\n      'Handshake failed: no matching C->S cipher',\n      'handshake',\n      DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n    );\n  }\n  init.cs.cipher = clientList[i];\n  debug && debug(`Handshake: C->S Cipher: ${clientList[i]}`);\n\n\n  // Server->Client cipher =====================================================\n  const localSCCipher = local.lists.sc.cipher.array;\n  debug && debug(`Handshake: (local) S->C cipher: ${localSCCipher}`);\n  debug && debug(`Handshake: (remote) S->C cipher: ${remote.sc.cipher}`);\n  if (self._server) {\n    serverList = localSCCipher;\n    clientList = remote.sc.cipher;\n  } else {\n    serverList = remote.sc.cipher;\n    clientList = localSCCipher;\n  }\n  // Check for agreeable server->client cipher\n  for (i = 0;\n       i < clientList.length && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching S->C cipher');\n    return doFatalError(\n      self,\n      'Handshake failed: no matching S->C cipher',\n      'handshake',\n      DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n    );\n  }\n  init.sc.cipher = clientList[i];\n  debug && debug(`Handshake: S->C cipher: ${clientList[i]}`);\n\n\n  // Client->Server MAC ========================================================\n  const localCSMAC = local.lists.cs.mac.array;\n  debug && debug(`Handshake: (local) C->S MAC: ${localCSMAC}`);\n  debug && debug(`Handshake: (remote) C->S MAC: ${remote.cs.mac}`);\n  if (CIPHER_INFO[init.cs.cipher].authLen > 0) {\n    init.cs.mac = '';\n    debug && debug('Handshake: C->S MAC: <implicit>');\n  } else {\n    if (self._server) {\n      serverList = localCSMAC;\n      clientList = remote.cs.mac;\n    } else {\n      serverList = remote.cs.mac;\n      clientList = localCSMAC;\n    }\n    // Check for agreeable client->server hmac algorithm\n    for (i = 0;\n         i < clientList.length && serverList.indexOf(clientList[i]) === -1;\n         ++i);\n    if (i === clientList.length) {\n      // No suitable match found!\n      debug && debug('Handshake: No matching C->S MAC');\n      return doFatalError(\n        self,\n        'Handshake failed: no matching C->S MAC',\n        'handshake',\n        DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n      );\n    }\n    init.cs.mac = clientList[i];\n    debug && debug(`Handshake: C->S MAC: ${clientList[i]}`);\n  }\n\n\n  // Server->Client MAC ========================================================\n  const localSCMAC = local.lists.sc.mac.array;\n  debug && debug(`Handshake: (local) S->C MAC: ${localSCMAC}`);\n  debug && debug(`Handshake: (remote) S->C MAC: ${remote.sc.mac}`);\n  if (CIPHER_INFO[init.sc.cipher].authLen > 0) {\n    init.sc.mac = '';\n    debug && debug('Handshake: S->C MAC: <implicit>');\n  } else {\n    if (self._server) {\n      serverList = localSCMAC;\n      clientList = remote.sc.mac;\n    } else {\n      serverList = remote.sc.mac;\n      clientList = localSCMAC;\n    }\n    // Check for agreeable server->client hmac algorithm\n    for (i = 0;\n         i < clientList.length && serverList.indexOf(clientList[i]) === -1;\n         ++i);\n    if (i === clientList.length) {\n      // No suitable match found!\n      debug && debug('Handshake: No matching S->C MAC');\n      return doFatalError(\n        self,\n        'Handshake failed: no matching S->C MAC',\n        'handshake',\n        DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n      );\n    }\n    init.sc.mac = clientList[i];\n    debug && debug(`Handshake: S->C MAC: ${clientList[i]}`);\n  }\n\n\n  // Client->Server compression ================================================\n  const localCSCompress = local.lists.cs.compress.array;\n  debug && debug(`Handshake: (local) C->S compression: ${localCSCompress}`);\n  debug && debug(`Handshake: (remote) C->S compression: ${remote.cs.compress}`);\n  if (self._server) {\n    serverList = localCSCompress;\n    clientList = remote.cs.compress;\n  } else {\n    serverList = remote.cs.compress;\n    clientList = localCSCompress;\n  }\n  // Check for agreeable client->server compression algorithm\n  for (i = 0;\n       i < clientList.length && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching C->S compression');\n    return doFatalError(\n      self,\n      'Handshake failed: no matching C->S compression',\n      'handshake',\n      DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n    );\n  }\n  init.cs.compress = clientList[i];\n  debug && debug(`Handshake: C->S compression: ${clientList[i]}`);\n\n\n  // Server->Client compression ================================================\n  const localSCCompress = local.lists.sc.compress.array;\n  debug && debug(`Handshake: (local) S->C compression: ${localSCCompress}`);\n  debug && debug(`Handshake: (remote) S->C compression: ${remote.sc.compress}`);\n  if (self._server) {\n    serverList = localSCCompress;\n    clientList = remote.sc.compress;\n  } else {\n    serverList = remote.sc.compress;\n    clientList = localSCCompress;\n  }\n  // Check for agreeable server->client compression algorithm\n  for (i = 0;\n       i < clientList.length && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching S->C compression');\n    return doFatalError(\n      self,\n      'Handshake failed: no matching S->C compression',\n      'handshake',\n      DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n    );\n  }\n  init.sc.compress = clientList[i];\n  debug && debug(`Handshake: S->C compression: ${clientList[i]}`);\n\n  init.cs.lang = '';\n  init.sc.lang = '';\n\n  // XXX: hack -- find a better way to do this\n  if (self._kex) {\n    if (!self._kexinit) {\n      // We received a rekey request, but we haven't sent a KEXINIT in response\n      // yet\n      kexinit(self);\n    }\n    self._decipher._onPayload = onKEXPayload.bind(self, { firstPacket: false });\n  }\n\n  self._kex = createKeyExchange(init, self, payload);\n  self._kex.start();\n}\n\nconst createKeyExchange = (() => {\n  function convertToMpint(buf) {\n    let idx = 0;\n    let length = buf.length;\n    while (buf[idx] === 0x00) {\n      ++idx;\n      --length;\n    }\n    let newBuf;\n    if (buf[idx] & 0x80) {\n      newBuf = Buffer.allocUnsafe(1 + length);\n      newBuf[0] = 0;\n      buf.copy(newBuf, 1, idx);\n      buf = newBuf;\n    } else if (length !== buf.length) {\n      newBuf = Buffer.allocUnsafe(length);\n      buf.copy(newBuf, 0, idx);\n      buf = newBuf;\n    }\n    return buf;\n  }\n\n  class KeyExchange {\n    constructor(negotiated, protocol, remoteKexinit) {\n      this._protocol = protocol;\n\n      this.sessionID = (protocol._kex ? protocol._kex.sessionID : undefined);\n      this.negotiated = negotiated;\n      this._step = 1;\n      this._public = null;\n      this._dh = null;\n      this._sentNEWKEYS = false;\n      this._receivedNEWKEYS = false;\n      this._finished = false;\n      this._hostVerified = false;\n\n      // Data needed for initializing cipher/decipher/etc.\n      this._kexinit = protocol._kexinit;\n      this._remoteKexinit = remoteKexinit;\n      this._identRaw = protocol._identRaw;\n      this._remoteIdentRaw = protocol._remoteIdentRaw;\n      this._hostKey = undefined;\n      this._dhData = undefined;\n      this._sig = undefined;\n    }\n    finish() {\n      if (this._finished)\n        return false;\n      this._finished = true;\n\n      const isServer = this._protocol._server;\n      const negotiated = this.negotiated;\n\n      const pubKey = this.convertPublicKey(this._dhData);\n      let secret = this.computeSecret(this._dhData);\n      if (secret instanceof Error) {\n        secret.message =\n          `Error while computing DH secret (${this.type}): ${secret.message}`;\n        secret.level = 'handshake';\n        return doFatalError(\n          this._protocol,\n          secret,\n          DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n        );\n      }\n\n      const hash = createHash(this.hashName);\n      // V_C\n      hashString(hash, (isServer ? this._remoteIdentRaw : this._identRaw));\n      // \"V_S\"\n      hashString(hash, (isServer ? this._identRaw : this._remoteIdentRaw));\n      // \"I_C\"\n      hashString(hash, (isServer ? this._remoteKexinit : this._kexinit));\n      // \"I_S\"\n      hashString(hash, (isServer ? this._kexinit : this._remoteKexinit));\n      // \"K_S\"\n      const serverPublicHostKey = (isServer\n                                   ? this._hostKey.getPublicSSH()\n                                   : this._hostKey);\n      hashString(hash, serverPublicHostKey);\n\n      if (this.type === 'groupex') {\n        // Group exchange-specific\n        const params = this.getDHParams();\n        const num = Buffer.allocUnsafe(4);\n        // min (uint32)\n        writeUInt32BE(num, this._minBits, 0);\n        hash.update(num);\n        // preferred (uint32)\n        writeUInt32BE(num, this._prefBits, 0);\n        hash.update(num);\n        // max (uint32)\n        writeUInt32BE(num, this._maxBits, 0);\n        hash.update(num);\n        // prime\n        hashString(hash, params.prime);\n        // generator\n        hashString(hash, params.generator);\n      }\n\n      // method-specific data sent by client\n      hashString(hash, (isServer ? pubKey : this.getPublicKey()));\n      // method-specific data sent by server\n      const serverPublicKey = (isServer ? this.getPublicKey() : pubKey);\n      hashString(hash, serverPublicKey);\n      // shared secret (\"K\")\n      hashString(hash, secret);\n\n      // \"H\"\n      const exchangeHash = hash.digest();\n\n      if (!isServer) {\n        bufferParser.init(this._sig, 0);\n        const sigType = bufferParser.readString(true);\n\n        if (!sigType) {\n          return doFatalError(\n            this._protocol,\n            'Malformed packet while reading signature',\n            'handshake',\n            DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n          );\n        }\n\n        if (sigType !== negotiated.serverHostKey) {\n          return doFatalError(\n            this._protocol,\n            `Wrong signature type: ${sigType}, `\n              + `expected: ${negotiated.serverHostKey}`,\n            'handshake',\n            DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n          );\n        }\n\n        // \"s\"\n        let sigValue = bufferParser.readString();\n\n        bufferParser.clear();\n\n        if (sigValue === undefined) {\n          return doFatalError(\n            this._protocol,\n            'Malformed packet while reading signature',\n            'handshake',\n            DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n          );\n        }\n\n        if (!(sigValue = sigSSHToASN1(sigValue, sigType))) {\n          return doFatalError(\n            this._protocol,\n            'Malformed signature',\n            'handshake',\n            DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n          );\n        }\n\n        let parsedHostKey;\n        {\n          bufferParser.init(this._hostKey, 0);\n          const name = bufferParser.readString(true);\n          const hostKey = this._hostKey.slice(bufferParser.pos());\n          bufferParser.clear();\n          parsedHostKey = parseDERKey(hostKey, name);\n          if (parsedHostKey instanceof Error) {\n            parsedHostKey.level = 'handshake';\n            return doFatalError(\n              this._protocol,\n              parsedHostKey,\n              DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n            );\n          }\n        }\n\n        let hashAlgo;\n        // Check if we need to override the default hash algorithm\n        switch (this.negotiated.serverHostKey) {\n          case 'rsa-sha2-256': hashAlgo = 'sha256'; break;\n          case 'rsa-sha2-512': hashAlgo = 'sha512'; break;\n        }\n\n        this._protocol._debug\n          && this._protocol._debug('Verifying signature ...');\n\n        const verified = parsedHostKey.verify(exchangeHash, sigValue, hashAlgo);\n        if (verified !== true) {\n          if (verified instanceof Error) {\n            this._protocol._debug && this._protocol._debug(\n              `Signature verification failed: ${verified.stack}`\n            );\n          } else {\n            this._protocol._debug && this._protocol._debug(\n              'Signature verification failed'\n            );\n          }\n          return doFatalError(\n            this._protocol,\n            'Handshake failed: signature verification failed',\n            'handshake',\n            DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n          );\n        }\n        this._protocol._debug && this._protocol._debug('Verified signature');\n      } else {\n        // Server\n\n        let hashAlgo;\n        // Check if we need to override the default hash algorithm\n        switch (this.negotiated.serverHostKey) {\n          case 'rsa-sha2-256': hashAlgo = 'sha256'; break;\n          case 'rsa-sha2-512': hashAlgo = 'sha512'; break;\n        }\n\n        this._protocol._debug && this._protocol._debug(\n          'Generating signature ...'\n        );\n\n        let signature = this._hostKey.sign(exchangeHash, hashAlgo);\n        if (signature instanceof Error) {\n          return doFatalError(\n            this._protocol,\n            'Handshake failed: signature generation failed for '\n              + `${this._hostKey.type} host key: ${signature.message}`,\n            'handshake',\n            DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n          );\n        }\n\n        signature = convertSignature(signature, this._hostKey.type);\n        if (signature === false) {\n          return doFatalError(\n            this._protocol,\n            'Handshake failed: signature conversion failed for '\n              + `${this._hostKey.type} host key`,\n            'handshake',\n            DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n          );\n        }\n\n        // Send KEX reply\n        /*\n          byte      SSH_MSG_KEXDH_REPLY\n                      / SSH_MSG_KEX_DH_GEX_REPLY\n                      / SSH_MSG_KEX_ECDH_REPLY\n          string    server public host key and certificates (K_S)\n          string    <method-specific data>\n          string    signature of H\n        */\n        const sigType = this.negotiated.serverHostKey;\n        const sigTypeLen = Buffer.byteLength(sigType);\n        const sigLen = 4 + sigTypeLen + 4 + signature.length;\n        let p = this._protocol._packetRW.write.allocStartKEX;\n        const packet = this._protocol._packetRW.write.alloc(\n          1\n            + 4 + serverPublicHostKey.length\n            + 4 + serverPublicKey.length\n            + 4 + sigLen,\n          true\n        );\n\n        packet[p] = MESSAGE.KEXDH_REPLY;\n\n        writeUInt32BE(packet, serverPublicHostKey.length, ++p);\n        packet.set(serverPublicHostKey, p += 4);\n\n        writeUInt32BE(packet,\n                      serverPublicKey.length,\n                      p += serverPublicHostKey.length);\n        packet.set(serverPublicKey, p += 4);\n\n        writeUInt32BE(packet, sigLen, p += serverPublicKey.length);\n\n        writeUInt32BE(packet, sigTypeLen, p += 4);\n        packet.utf8Write(sigType, p += 4, sigTypeLen);\n\n        writeUInt32BE(packet, signature.length, p += sigTypeLen);\n        packet.set(signature, p += 4);\n\n        if (this._protocol._debug) {\n          let type;\n          switch (this.type) {\n            case 'group':\n              type = 'KEXDH_REPLY';\n              break;\n            case 'groupex':\n              type = 'KEXDH_GEX_REPLY';\n              break;\n            default:\n              type = 'KEXECDH_REPLY';\n          }\n          this._protocol._debug(`Outbound: Sending ${type}`);\n        }\n        this._protocol._cipher.encrypt(\n          this._protocol._packetRW.write.finalize(packet, true)\n        );\n      }\n      trySendNEWKEYS(this);\n\n      const completeHandshake = () => {\n        if (!this.sessionID)\n          this.sessionID = exchangeHash;\n\n        {\n          const newSecret = Buffer.allocUnsafe(4 + secret.length);\n          writeUInt32BE(newSecret, secret.length, 0);\n          newSecret.set(secret, 4);\n          secret = newSecret;\n        }\n\n        // Initialize new ciphers, deciphers, etc.\n\n        const csCipherInfo = CIPHER_INFO[negotiated.cs.cipher];\n        const scCipherInfo = CIPHER_INFO[negotiated.sc.cipher];\n\n        const csIV = generateKEXVal(csCipherInfo.ivLen,\n                                    this.hashName,\n                                    secret,\n                                    exchangeHash,\n                                    this.sessionID,\n                                    'A');\n        const scIV = generateKEXVal(scCipherInfo.ivLen,\n                                    this.hashName,\n                                    secret,\n                                    exchangeHash,\n                                    this.sessionID,\n                                    'B');\n        const csKey = generateKEXVal(csCipherInfo.keyLen,\n                                     this.hashName,\n                                     secret,\n                                     exchangeHash,\n                                     this.sessionID,\n                                     'C');\n        const scKey = generateKEXVal(scCipherInfo.keyLen,\n                                     this.hashName,\n                                     secret,\n                                     exchangeHash,\n                                     this.sessionID,\n                                     'D');\n        let csMacInfo;\n        let csMacKey;\n        if (!csCipherInfo.authLen) {\n          csMacInfo = MAC_INFO[negotiated.cs.mac];\n          csMacKey = generateKEXVal(csMacInfo.len,\n                                    this.hashName,\n                                    secret,\n                                    exchangeHash,\n                                    this.sessionID,\n                                    'E');\n        }\n        let scMacInfo;\n        let scMacKey;\n        if (!scCipherInfo.authLen) {\n          scMacInfo = MAC_INFO[negotiated.sc.mac];\n          scMacKey = generateKEXVal(scMacInfo.len,\n                                    this.hashName,\n                                    secret,\n                                    exchangeHash,\n                                    this.sessionID,\n                                    'F');\n        }\n\n        const config = {\n          inbound: {\n            onPayload: this._protocol._onPayload,\n            seqno: this._protocol._decipher.inSeqno,\n            decipherInfo: (!isServer ? scCipherInfo : csCipherInfo),\n            decipherIV: (!isServer ? scIV : csIV),\n            decipherKey: (!isServer ? scKey : csKey),\n            macInfo: (!isServer ? scMacInfo : csMacInfo),\n            macKey: (!isServer ? scMacKey : csMacKey),\n          },\n          outbound: {\n            onWrite: this._protocol._onWrite,\n            seqno: this._protocol._cipher.outSeqno,\n            cipherInfo: (isServer ? scCipherInfo : csCipherInfo),\n            cipherIV: (isServer ? scIV : csIV),\n            cipherKey: (isServer ? scKey : csKey),\n            macInfo: (isServer ? scMacInfo : csMacInfo),\n            macKey: (isServer ? scMacKey : csMacKey),\n          },\n        };\n        this._protocol._cipher && this._protocol._cipher.free();\n        this._protocol._decipher && this._protocol._decipher.free();\n        this._protocol._cipher = createCipher(config);\n        this._protocol._decipher = createDecipher(config);\n\n        const rw = {\n          read: undefined,\n          write: undefined,\n        };\n        switch (negotiated.cs.compress) {\n          case 'zlib': // starts immediately\n            if (isServer)\n              rw.read = new ZlibPacketReader();\n            else\n              rw.write = new ZlibPacketWriter(this._protocol);\n            break;\n          case 'zlib@openssh.com':\n            // Starts after successful user authentication\n\n            if (this._protocol._authenticated) {\n              // If a rekey happens and this compression method is selected and\n              // we already authenticated successfully, we need to start\n              // immediately instead\n              if (isServer)\n                rw.read = new ZlibPacketReader();\n              else\n                rw.write = new ZlibPacketWriter(this._protocol);\n              break;\n            }\n          // FALLTHROUGH\n          default:\n            // none -- never any compression/decompression\n\n            if (isServer)\n              rw.read = new PacketReader();\n            else\n              rw.write = new PacketWriter(this._protocol);\n        }\n        switch (negotiated.sc.compress) {\n          case 'zlib': // starts immediately\n            if (isServer)\n              rw.write = new ZlibPacketWriter(this._protocol);\n            else\n              rw.read = new ZlibPacketReader();\n            break;\n          case 'zlib@openssh.com':\n            // Starts after successful user authentication\n\n            if (this._protocol._authenticated) {\n              // If a rekey happens and this compression method is selected and\n              // we already authenticated successfully, we need to start\n              // immediately instead\n              if (isServer)\n                rw.write = new ZlibPacketWriter(this._protocol);\n              else\n                rw.read = new ZlibPacketReader();\n              break;\n            }\n          // FALLTHROUGH\n          default:\n            // none -- never any compression/decompression\n\n            if (isServer)\n              rw.write = new PacketWriter(this._protocol);\n            else\n              rw.read = new PacketReader();\n        }\n        this._protocol._packetRW.read.cleanup();\n        this._protocol._packetRW.write.cleanup();\n        this._protocol._packetRW = rw;\n\n        // Cleanup/reset various state\n        this._public = null;\n        this._dh = null;\n        this._kexinit = this._protocol._kexinit = undefined;\n        this._remoteKexinit = undefined;\n        this._identRaw = undefined;\n        this._remoteIdentRaw = undefined;\n        this._hostKey = undefined;\n        this._dhData = undefined;\n        this._sig = undefined;\n\n        this._protocol._onHandshakeComplete(negotiated);\n\n        return false;\n      };\n      if (!isServer)\n        return completeHandshake();\n      this.finish = completeHandshake;\n    }\n\n    start() {\n      if (!this._protocol._server) {\n        if (this._protocol._debug) {\n          let type;\n          switch (this.type) {\n            case 'group':\n              type = 'KEXDH_INIT';\n              break;\n            default:\n              type = 'KEXECDH_INIT';\n          }\n          this._protocol._debug(`Outbound: Sending ${type}`);\n        }\n\n        const pubKey = this.getPublicKey();\n\n        let p = this._protocol._packetRW.write.allocStartKEX;\n        const packet = this._protocol._packetRW.write.alloc(\n          1 + 4 + pubKey.length,\n          true\n        );\n        packet[p] = MESSAGE.KEXDH_INIT;\n        writeUInt32BE(packet, pubKey.length, ++p);\n        packet.set(pubKey, p += 4);\n        this._protocol._cipher.encrypt(\n          this._protocol._packetRW.write.finalize(packet, true)\n        );\n      }\n    }\n    getPublicKey() {\n      this.generateKeys();\n\n      const key = this._public;\n\n      if (key)\n        return this.convertPublicKey(key);\n    }\n    convertPublicKey(key) {\n      let newKey;\n      let idx = 0;\n      let len = key.length;\n      while (key[idx] === 0x00) {\n        ++idx;\n        --len;\n      }\n\n      if (key[idx] & 0x80) {\n        newKey = Buffer.allocUnsafe(1 + len);\n        newKey[0] = 0;\n        key.copy(newKey, 1, idx);\n        return newKey;\n      }\n\n      if (len !== key.length) {\n        newKey = Buffer.allocUnsafe(len);\n        key.copy(newKey, 0, idx);\n        key = newKey;\n      }\n      return key;\n    }\n    computeSecret(otherPublicKey) {\n      this.generateKeys();\n\n      try {\n        return convertToMpint(this._dh.computeSecret(otherPublicKey));\n      } catch (ex) {\n        return ex;\n      }\n    }\n    parse(payload) {\n      const type = payload[0];\n      switch (this._step) {\n        case 1:\n          if (this._protocol._server) {\n            // Server\n            if (type !== MESSAGE.KEXDH_INIT) {\n              return doFatalError(\n                this._protocol,\n                `Received packet ${type} instead of ${MESSAGE.KEXDH_INIT}`,\n                'handshake',\n                DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n              );\n            }\n            this._protocol._debug && this._protocol._debug(\n              'Received DH Init'\n            );\n            /*\n              byte     SSH_MSG_KEXDH_INIT\n                         / SSH_MSG_KEX_ECDH_INIT\n              string   <method-specific data>\n            */\n            bufferParser.init(payload, 1);\n            const dhData = bufferParser.readString();\n            bufferParser.clear();\n            if (dhData === undefined) {\n              return doFatalError(\n                this._protocol,\n                'Received malformed KEX*_INIT',\n                'handshake',\n                DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n              );\n            }\n\n            // Client public key\n            this._dhData = dhData;\n\n            let hostKey =\n              this._protocol._hostKeys[this.negotiated.serverHostKey];\n            if (Array.isArray(hostKey))\n              hostKey = hostKey[0];\n            this._hostKey = hostKey;\n\n            this.finish();\n          } else {\n            // Client\n            if (type !== MESSAGE.KEXDH_REPLY) {\n              return doFatalError(\n                this._protocol,\n                `Received packet ${type} instead of ${MESSAGE.KEXDH_REPLY}`,\n                'handshake',\n                DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n              );\n            }\n            this._protocol._debug && this._protocol._debug(\n              'Received DH Reply'\n            );\n            /*\n              byte      SSH_MSG_KEXDH_REPLY\n                          / SSH_MSG_KEX_DH_GEX_REPLY\n                          / SSH_MSG_KEX_ECDH_REPLY\n              string    server public host key and certificates (K_S)\n              string    <method-specific data>\n              string    signature of H\n            */\n            bufferParser.init(payload, 1);\n            let hostPubKey;\n            let dhData;\n            let sig;\n            if ((hostPubKey = bufferParser.readString()) === undefined\n                || (dhData = bufferParser.readString()) === undefined\n                || (sig = bufferParser.readString()) === undefined) {\n              bufferParser.clear();\n              return doFatalError(\n                this._protocol,\n                'Received malformed KEX*_REPLY',\n                'handshake',\n                DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n              );\n            }\n            bufferParser.clear();\n\n            // Check that the host public key type matches what was negotiated\n            // during KEXINIT swap\n            bufferParser.init(hostPubKey, 0);\n            const hostPubKeyType = bufferParser.readString(true);\n            bufferParser.clear();\n            if (hostPubKeyType === undefined) {\n              return doFatalError(\n                this._protocol,\n                'Received malformed host public key',\n                'handshake',\n                DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n              );\n            }\n            if (hostPubKeyType !== this.negotiated.serverHostKey) {\n              // Check if we need to make an exception\n              switch (this.negotiated.serverHostKey) {\n                case 'rsa-sha2-256':\n                case 'rsa-sha2-512':\n                  if (hostPubKeyType === 'ssh-rsa')\n                    break;\n                // FALLTHROUGH\n                default:\n                  return doFatalError(\n                    this._protocol,\n                    'Host key does not match negotiated type',\n                    'handshake',\n                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n                  );\n              }\n            }\n\n            this._hostKey = hostPubKey;\n            this._dhData = dhData;\n            this._sig = sig;\n\n            let checked = false;\n            let ret;\n            if (this._protocol._hostVerifier === undefined) {\n              ret = true;\n              this._protocol._debug && this._protocol._debug(\n                'Host accepted by default (no verification)'\n              );\n            } else {\n              ret = this._protocol._hostVerifier(hostPubKey, (permitted) => {\n                if (checked)\n                  return;\n                checked = true;\n                if (permitted === false) {\n                  this._protocol._debug && this._protocol._debug(\n                    'Host denied (verification failed)'\n                  );\n                  return doFatalError(\n                    this._protocol,\n                    'Host denied (verification failed)',\n                    'handshake',\n                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n                  );\n                }\n                this._protocol._debug && this._protocol._debug(\n                  'Host accepted (verified)'\n                );\n                this._hostVerified = true;\n                if (this._receivedNEWKEYS)\n                  this.finish();\n                else\n                  trySendNEWKEYS(this);\n              });\n            }\n            if (ret === undefined) {\n              // Async host verification\n              ++this._step;\n              return;\n            }\n            checked = true;\n            if (ret === false) {\n              this._protocol._debug && this._protocol._debug(\n                'Host denied (verification failed)'\n              );\n              return doFatalError(\n                this._protocol,\n                'Host denied (verification failed)',\n                'handshake',\n                DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n              );\n            }\n            this._protocol._debug && this._protocol._debug(\n              'Host accepted (verified)'\n            );\n            this._hostVerified = true;\n            trySendNEWKEYS(this);\n          }\n          ++this._step;\n          break;\n        case 2:\n          if (type !== MESSAGE.NEWKEYS) {\n            return doFatalError(\n              this._protocol,\n              `Received packet ${type} instead of ${MESSAGE.NEWKEYS}`,\n              'handshake',\n              DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n            );\n          }\n          this._protocol._debug && this._protocol._debug(\n            'Inbound: NEWKEYS'\n          );\n          this._receivedNEWKEYS = true;\n          ++this._step;\n          if (this._protocol._server || this._hostVerified)\n            return this.finish();\n\n          // Signal to current decipher that we need to change to a new decipher\n          // for the next packet\n          return false;\n        default:\n          return doFatalError(\n            this._protocol,\n            `Received unexpected packet ${type} after NEWKEYS`,\n            'handshake',\n            DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n          );\n      }\n    }\n  }\n\n  class Curve25519Exchange extends KeyExchange {\n    constructor(hashName, ...args) {\n      super(...args);\n\n      this.type = '25519';\n      this.hashName = hashName;\n      this._keys = null;\n    }\n    generateKeys() {\n      if (!this._keys)\n        this._keys = generateKeyPairSync('x25519');\n    }\n    getPublicKey() {\n      this.generateKeys();\n\n      const key = this._keys.publicKey.export({ type: 'spki', format: 'der' });\n      return key.slice(-32); // HACK: avoids parsing DER/BER header\n    }\n    convertPublicKey(key) {\n      let newKey;\n      let idx = 0;\n      let len = key.length;\n      while (key[idx] === 0x00) {\n        ++idx;\n        --len;\n      }\n\n      if (key.length === 32)\n        return key;\n\n      if (len !== key.length) {\n        newKey = Buffer.allocUnsafe(len);\n        key.copy(newKey, 0, idx);\n        key = newKey;\n      }\n      return key;\n    }\n    computeSecret(otherPublicKey) {\n      this.generateKeys();\n\n      try {\n        const asnWriter = new Ber.Writer();\n        asnWriter.startSequence();\n          // algorithm\n          asnWriter.startSequence();\n            asnWriter.writeOID('1.3.101.110'); // id-X25519\n          asnWriter.endSequence();\n\n          // PublicKey\n          asnWriter.startSequence(Ber.BitString);\n            asnWriter.writeByte(0x00);\n            // XXX: hack to write a raw buffer without a tag -- yuck\n            asnWriter._ensure(otherPublicKey.length);\n            otherPublicKey.copy(asnWriter._buf,\n                                asnWriter._offset,\n                                0,\n                                otherPublicKey.length);\n            asnWriter._offset += otherPublicKey.length;\n          asnWriter.endSequence();\n        asnWriter.endSequence();\n\n        return convertToMpint(diffieHellman({\n          privateKey: this._keys.privateKey,\n          publicKey: createPublicKey({\n            key: asnWriter.buffer,\n            type: 'spki',\n            format: 'der',\n          }),\n        }));\n      } catch (ex) {\n        return ex;\n      }\n    }\n  }\n\n  class ECDHExchange extends KeyExchange {\n    constructor(curveName, hashName, ...args) {\n      super(...args);\n\n      this.type = 'ecdh';\n      this.curveName = curveName;\n      this.hashName = hashName;\n    }\n    generateKeys() {\n      if (!this._dh) {\n        this._dh = createECDH(this.curveName);\n        this._public = this._dh.generateKeys();\n      }\n    }\n  }\n\n  class DHGroupExchange extends KeyExchange {\n    constructor(hashName, ...args) {\n      super(...args);\n\n      this.type = 'groupex';\n      this.hashName = hashName;\n      this._prime = null;\n      this._generator = null;\n      this._minBits = GEX_MIN_BITS;\n      this._prefBits = dhEstimate(this.negotiated);\n      if (this._protocol._compatFlags & COMPAT.BUG_DHGEX_LARGE)\n        this._prefBits = Math.min(this._prefBits, 4096);\n      this._maxBits = GEX_MAX_BITS;\n    }\n    start() {\n      if (this._protocol._server)\n        return;\n      this._protocol._debug && this._protocol._debug(\n        'Outbound: Sending KEXDH_GEX_REQUEST'\n      );\n      let p = this._protocol._packetRW.write.allocStartKEX;\n      const packet = this._protocol._packetRW.write.alloc(\n        1 + 4 + 4 + 4,\n        true\n      );\n      packet[p] = MESSAGE.KEXDH_GEX_REQUEST;\n      writeUInt32BE(packet, this._minBits, ++p);\n      writeUInt32BE(packet, this._prefBits, p += 4);\n      writeUInt32BE(packet, this._maxBits, p += 4);\n      this._protocol._cipher.encrypt(\n        this._protocol._packetRW.write.finalize(packet, true)\n      );\n    }\n    generateKeys() {\n      if (!this._dh && this._prime && this._generator) {\n        this._dh = createDiffieHellman(this._prime, this._generator);\n        this._public = this._dh.generateKeys();\n      }\n    }\n    setDHParams(prime, generator) {\n      if (!Buffer.isBuffer(prime))\n        throw new Error('Invalid prime value');\n      if (!Buffer.isBuffer(generator))\n        throw new Error('Invalid generator value');\n      this._prime = prime;\n      this._generator = generator;\n    }\n    getDHParams() {\n      if (this._dh) {\n        return {\n          prime: convertToMpint(this._dh.getPrime()),\n          generator: convertToMpint(this._dh.getGenerator()),\n        };\n      }\n    }\n    parse(payload) {\n      const type = payload[0];\n      switch (this._step) {\n        case 1:\n          if (this._protocol._server) {\n            if (type !== MESSAGE.KEXDH_GEX_REQUEST) {\n              return doFatalError(\n                this._protocol,\n                `Received packet ${type} instead of `\n                  + MESSAGE.KEXDH_GEX_REQUEST,\n                'handshake',\n                DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n              );\n            }\n            // TODO: allow user implementation to provide safe prime and\n            // generator on demand to support group exchange on server side\n            return doFatalError(\n              this._protocol,\n              'Group exchange not implemented for server',\n              'handshake',\n              DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n            );\n          }\n\n          if (type !== MESSAGE.KEXDH_GEX_GROUP) {\n            return doFatalError(\n              this._protocol,\n              `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_GROUP}`,\n              'handshake',\n              DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n            );\n          }\n\n          this._protocol._debug && this._protocol._debug(\n            'Received DH GEX Group'\n          );\n\n          /*\n            byte    SSH_MSG_KEX_DH_GEX_GROUP\n            mpint   p, safe prime\n            mpint   g, generator for subgroup in GF(p)\n          */\n          bufferParser.init(payload, 1);\n          let prime;\n          let gen;\n          if ((prime = bufferParser.readString()) === undefined\n              || (gen = bufferParser.readString()) === undefined) {\n            bufferParser.clear();\n            return doFatalError(\n              this._protocol,\n              'Received malformed KEXDH_GEX_GROUP',\n              'handshake',\n              DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n            );\n          }\n          bufferParser.clear();\n\n          // TODO: validate prime\n          this.setDHParams(prime, gen);\n          this.generateKeys();\n          const pubkey = this.getPublicKey();\n\n          this._protocol._debug && this._protocol._debug(\n            'Outbound: Sending KEXDH_GEX_INIT'\n          );\n\n          let p = this._protocol._packetRW.write.allocStartKEX;\n          const packet =\n            this._protocol._packetRW.write.alloc(1 + 4 + pubkey.length, true);\n          packet[p] = MESSAGE.KEXDH_GEX_INIT;\n          writeUInt32BE(packet, pubkey.length, ++p);\n          packet.set(pubkey, p += 4);\n          this._protocol._cipher.encrypt(\n            this._protocol._packetRW.write.finalize(packet, true)\n          );\n\n          ++this._step;\n          break;\n        case 2:\n          if (this._protocol._server) {\n            if (type !== MESSAGE.KEXDH_GEX_INIT) {\n              return doFatalError(\n                this._protocol,\n                `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_INIT}`,\n                'handshake',\n                DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n              );\n            }\n            this._protocol._debug && this._protocol._debug(\n              'Received DH GEX Init'\n            );\n            return doFatalError(\n              this._protocol,\n              'Group exchange not implemented for server',\n              'handshake',\n              DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n            );\n          } else if (type !== MESSAGE.KEXDH_GEX_REPLY) {\n            return doFatalError(\n              this._protocol,\n              `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_REPLY}`,\n              'handshake',\n              DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n            );\n          }\n          this._protocol._debug && this._protocol._debug(\n            'Received DH GEX Reply'\n          );\n          this._step = 1;\n          payload[0] = MESSAGE.KEXDH_REPLY;\n          this.parse = KeyExchange.prototype.parse;\n          this.parse(payload);\n      }\n    }\n  }\n\n  class DHExchange extends KeyExchange {\n    constructor(groupName, hashName, ...args) {\n      super(...args);\n\n      this.type = 'group';\n      this.groupName = groupName;\n      this.hashName = hashName;\n    }\n    start() {\n      if (!this._protocol._server) {\n        this._protocol._debug && this._protocol._debug(\n          'Outbound: Sending KEXDH_INIT'\n        );\n        const pubKey = this.getPublicKey();\n        let p = this._protocol._packetRW.write.allocStartKEX;\n        const packet =\n          this._protocol._packetRW.write.alloc(1 + 4 + pubKey.length, true);\n        packet[p] = MESSAGE.KEXDH_INIT;\n        writeUInt32BE(packet, pubKey.length, ++p);\n        packet.set(pubKey, p += 4);\n        this._protocol._cipher.encrypt(\n          this._protocol._packetRW.write.finalize(packet, true)\n        );\n      }\n    }\n    generateKeys() {\n      if (!this._dh) {\n        this._dh = createDiffieHellmanGroup(this.groupName);\n        this._public = this._dh.generateKeys();\n      }\n    }\n    getDHParams() {\n      if (this._dh) {\n        return {\n          prime: convertToMpint(this._dh.getPrime()),\n          generator: convertToMpint(this._dh.getGenerator()),\n        };\n      }\n    }\n  }\n\n  return (negotiated, ...args) => {\n    if (typeof negotiated !== 'object' || negotiated === null)\n      throw new Error('Invalid negotiated argument');\n    const kexType = negotiated.kex;\n    if (typeof kexType === 'string') {\n      args = [negotiated, ...args];\n      switch (kexType) {\n        case 'curve25519-sha256':\n        case 'curve25519-sha256@libssh.org':\n          if (!curve25519Supported)\n            break;\n          return new Curve25519Exchange('sha256', ...args);\n\n        case 'ecdh-sha2-nistp256':\n          return new ECDHExchange('prime256v1', 'sha256', ...args);\n        case 'ecdh-sha2-nistp384':\n          return new ECDHExchange('secp384r1', 'sha384', ...args);\n        case 'ecdh-sha2-nistp521':\n          return new ECDHExchange('secp521r1', 'sha512', ...args);\n\n        case 'diffie-hellman-group1-sha1':\n          return new DHExchange('modp2', 'sha1', ...args);\n        case 'diffie-hellman-group14-sha1':\n          return new DHExchange('modp14', 'sha1', ...args);\n        case 'diffie-hellman-group14-sha256':\n          return new DHExchange('modp14', 'sha256', ...args);\n        case 'diffie-hellman-group15-sha512':\n          return new DHExchange('modp15', 'sha512', ...args);\n        case 'diffie-hellman-group16-sha512':\n          return new DHExchange('modp16', 'sha512', ...args);\n        case 'diffie-hellman-group17-sha512':\n          return new DHExchange('modp17', 'sha512', ...args);\n        case 'diffie-hellman-group18-sha512':\n          return new DHExchange('modp18', 'sha512', ...args);\n\n        case 'diffie-hellman-group-exchange-sha1':\n          return new DHGroupExchange('sha1', ...args);\n        case 'diffie-hellman-group-exchange-sha256':\n          return new DHGroupExchange('sha256', ...args);\n      }\n      throw new Error(`Unsupported key exchange algorithm: ${kexType}`);\n    }\n    throw new Error(`Invalid key exchange type: ${kexType}`);\n  };\n})();\n\nconst KexInit = (() => {\n  const KEX_PROPERTY_NAMES = [\n    'kex',\n    'serverHostKey',\n    ['cs', 'cipher' ],\n    ['sc', 'cipher' ],\n    ['cs', 'mac' ],\n    ['sc', 'mac' ],\n    ['cs', 'compress' ],\n    ['sc', 'compress' ],\n    ['cs', 'lang' ],\n    ['sc', 'lang' ],\n  ];\n  return class KexInit {\n    constructor(obj) {\n      if (typeof obj !== 'object' || obj === null)\n        throw new TypeError('Argument must be an object');\n\n      const lists = {\n        kex: undefined,\n        serverHostKey: undefined,\n        cs: {\n          cipher: undefined,\n          mac: undefined,\n          compress: undefined,\n          lang: undefined,\n        },\n        sc: {\n          cipher: undefined,\n          mac: undefined,\n          compress: undefined,\n          lang: undefined,\n        },\n\n        all: undefined,\n      };\n      let totalSize = 0;\n      for (const prop of KEX_PROPERTY_NAMES) {\n        let base;\n        let val;\n        let desc;\n        let key;\n        if (typeof prop === 'string') {\n          base = lists;\n          val = obj[prop];\n          desc = key = prop;\n        } else {\n          const parent = prop[0];\n          base = lists[parent];\n          key = prop[1];\n          val = obj[parent][key];\n          desc = `${parent}.${key}`;\n        }\n        const entry = { array: undefined, buffer: undefined };\n        if (Buffer.isBuffer(val)) {\n          entry.array = ('' + val).split(',');\n          entry.buffer = val;\n          totalSize += 4 + val.length;\n        } else {\n          if (typeof val === 'string')\n            val = val.split(',');\n          if (Array.isArray(val)) {\n            entry.array = val;\n            entry.buffer = Buffer.from(val.join(','));\n          } else {\n            throw new TypeError(`Invalid \\`${desc}\\` type: ${typeof val}`);\n          }\n          totalSize += 4 + entry.buffer.length;\n        }\n        base[key] = entry;\n      }\n\n      const all = Buffer.allocUnsafe(totalSize);\n      lists.all = all;\n\n      let allPos = 0;\n      for (const prop of KEX_PROPERTY_NAMES) {\n        let data;\n        if (typeof prop === 'string')\n          data = lists[prop].buffer;\n        else\n          data = lists[prop[0]][prop[1]].buffer;\n        allPos = writeUInt32BE(all, data.length, allPos);\n        all.set(data, allPos);\n        allPos += data.length;\n      }\n\n      this.totalSize = totalSize;\n      this.lists = lists;\n    }\n    copyAllTo(buf, offset) {\n      const src = this.lists.all;\n      if (typeof offset !== 'number')\n        throw new TypeError(`Invalid offset value: ${typeof offset}`);\n      if (buf.length - offset < src.length)\n        throw new Error('Insufficient space to copy list');\n      buf.set(src, offset);\n      return src.length;\n    }\n  };\n})();\n\nconst hashString = (() => {\n  const LEN = Buffer.allocUnsafe(4);\n  return (hash, buf) => {\n    writeUInt32BE(LEN, buf.length, 0);\n    hash.update(LEN);\n    hash.update(buf);\n  };\n})();\n\nfunction generateKEXVal(len, hashName, secret, exchangeHash, sessionID, char) {\n  let ret;\n  if (len) {\n    let digest = createHash(hashName)\n                   .update(secret)\n                   .update(exchangeHash)\n                   .update(char)\n                   .update(sessionID)\n                   .digest();\n    while (digest.length < len) {\n      const chunk = createHash(hashName)\n                      .update(secret)\n                      .update(exchangeHash)\n                      .update(digest)\n                      .digest();\n      const extended = Buffer.allocUnsafe(digest.length + chunk.length);\n      extended.set(digest, 0);\n      extended.set(chunk, digest.length);\n      digest = extended;\n    }\n    if (digest.length === len)\n      ret = digest;\n    else\n      ret = new FastBuffer(digest.buffer, digest.byteOffset, len);\n  } else {\n    ret = EMPTY_BUFFER;\n  }\n  return ret;\n}\n\nfunction onKEXPayload(state, payload) {\n  // XXX: move this to the Decipher implementations?\n  if (payload.length === 0) {\n    this._debug && this._debug('Inbound: Skipping empty packet payload');\n    return;\n  }\n\n  if (this._skipNextInboundPacket) {\n    this._skipNextInboundPacket = false;\n    return;\n  }\n\n  payload = this._packetRW.read.read(payload);\n\n  const type = payload[0];\n  switch (type) {\n    case MESSAGE.DISCONNECT:\n    case MESSAGE.IGNORE:\n    case MESSAGE.UNIMPLEMENTED:\n    case MESSAGE.DEBUG:\n      if (!MESSAGE_HANDLERS)\n        MESSAGE_HANDLERS = require('./handlers.js');\n      return MESSAGE_HANDLERS[type](this, payload);\n    case MESSAGE.KEXINIT:\n      if (!state.firstPacket) {\n        return doFatalError(\n          this,\n          'Received extra KEXINIT during handshake',\n          'handshake',\n          DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n        );\n      }\n      state.firstPacket = false;\n      return handleKexInit(this, payload);\n    default:\n      if (type < 20 || type > 49) {\n        return doFatalError(\n          this,\n          `Received unexpected packet type ${type}`,\n          'handshake',\n          DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n        );\n      }\n  }\n\n  return this._kex.parse(payload);\n}\n\nfunction dhEstimate(neg) {\n  const csCipher = CIPHER_INFO[neg.cs.cipher];\n  const scCipher = CIPHER_INFO[neg.sc.cipher];\n  // XXX: if OpenSSH's `umac-*` MACs are ever supported, their key lengths will\n  // also need to be considered when calculating `bits`\n  const bits = Math.max(\n    0,\n    (csCipher.sslName === 'des-ede3-cbc' ? 14 : csCipher.keyLen),\n    csCipher.blockLen,\n    csCipher.ivLen,\n    (scCipher.sslName === 'des-ede3-cbc' ? 14 : scCipher.keyLen),\n    scCipher.blockLen,\n    scCipher.ivLen\n  ) * 8;\n  if (bits <= 112)\n    return 2048;\n  if (bits <= 128)\n    return 3072;\n  if (bits <= 192)\n    return 7680;\n  return 8192;\n}\n\nfunction trySendNEWKEYS(kex) {\n  if (!kex._sentNEWKEYS) {\n    kex._protocol._debug && kex._protocol._debug(\n      'Outbound: Sending NEWKEYS'\n    );\n    const p = kex._protocol._packetRW.write.allocStartKEX;\n    const packet = kex._protocol._packetRW.write.alloc(1, true);\n    packet[p] = MESSAGE.NEWKEYS;\n    kex._protocol._cipher.encrypt(\n      kex._protocol._packetRW.write.finalize(packet, true)\n    );\n    kex._sentNEWKEYS = true;\n  }\n}\n\nmodule.exports = {\n  KexInit,\n  kexinit,\n  onKEXPayload,\n  DEFAULT_KEXINIT: new KexInit({\n    kex: DEFAULT_KEX,\n    serverHostKey: DEFAULT_SERVER_HOST_KEY,\n    cs: {\n      cipher: DEFAULT_CIPHER,\n      mac: DEFAULT_MAC,\n      compress: DEFAULT_COMPRESSION,\n      lang: [],\n    },\n    sc: {\n      cipher: DEFAULT_CIPHER,\n      mac: DEFAULT_MAC,\n      compress: DEFAULT_COMPRESSION,\n      lang: [],\n    },\n  }),\n  HANDLERS: {\n    [MESSAGE.KEXINIT]: handleKexInit,\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}