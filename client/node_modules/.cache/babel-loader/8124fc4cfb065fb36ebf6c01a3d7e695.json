{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport { useRef, useCallback } from \"react\";\nimport { mergeValidators } from \"../utils/utilValidators\";\nexport function useValidators(context, nameProp, isMounted, isAsync) {\n  if (isAsync === void 0) {\n    isAsync = false;\n  }\n\n  var validators = useRef({});\n  var validatorsMaps = useRef({});\n  var updateValidatorsMap = useCallback(function (path, isValid, counter) {\n    // It propagates up to the form context\n    if (context !== undefined) {\n      context.updateValidatorsMap(nameProp.current + \"/\" + path, isValid, counter);\n    } else {\n      validatorsMaps.current[path] = _extends({}, validatorsMaps.current[path], {\n        isValid: isValid,\n        counter: counter\n      });\n    }\n  }, []); // resetValidatorsMap only used in useForm\n\n  var resetValidatorsMap = useCallback(function () {\n    Object.keys(validatorsMaps.current).forEach(function (key) {\n      var type = validatorsMaps.current[key].type;\n      validatorsMaps.current[key].counter = 0;\n      validatorsMaps.current[key].isValid = type === \"collection\" ? null : false;\n    });\n    return validatorsMaps.current;\n  }, []); // syncValidatorsValue type depends on its context - can be function or object\n  // asyncValidatorsValue type depends on its context - can be boolean, null or object\n\n  var _useRef = useRef(function (path, syncValidatorsValue, asyncValidatorsValue) {\n    validators.current = _extends({}, validators.current, mergeValidators(path, syncValidatorsValue));\n\n    if (isAsync) {\n      validatorsMaps.current = _extends({}, validatorsMaps.current, mergeValidators(path, asyncValidatorsValue));\n    }\n\n    if (nameProp !== undefined && isMounted.current && context !== undefined) {\n      var addFN = isAsync ? context.addValidatorsAsync : context.addValidators;\n      addFN(nameProp.current, validators.current, validatorsMaps.current);\n    }\n  }),\n      addValidators = _useRef.current;\n\n  var _useRef2 = useRef(function (path, validatorsToRemove, validatorsMapsToRemove) {\n    if (validatorsMapsToRemove === void 0) {\n      validatorsMapsToRemove = false;\n    }\n\n    var newValidators = _extends({}, validators.current, mergeValidators(path, validatorsToRemove, true));\n\n    var newValidatorsMaps = !isAsync ? {} : _extends({}, validatorsMaps.current, mergeValidators(path, validatorsMapsToRemove, true));\n\n    if (context !== undefined) {\n      validators.current = newValidators;\n      validatorsMaps.current = newValidatorsMaps;\n      var removeFN = isAsync ? context.removeValidatorsAsync : context.removeValidators;\n      removeFN(nameProp.current, validators.current, validatorsMaps.current);\n    } else {\n      // if context is undefined it is the form context and then\n      // we must clean the undefined prop from it\n      validators.current = cleanValidators(newValidators);\n      validatorsMaps.current = cleanValidators(newValidatorsMaps);\n    }\n  }),\n      removeValidators = _useRef2.current;\n\n  return [validators, addValidators, removeValidators, validatorsMaps, updateValidatorsMap, resetValidatorsMap];\n}\n\nfunction cleanValidators(validatorObj) {\n  Object.keys(validatorObj).forEach(function (key) {\n    if (validatorObj[key] === undefined) {\n      delete validatorObj[key];\n    }\n  });\n  return validatorObj;\n}","map":{"version":3,"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","useRef","useCallback","mergeValidators","useValidators","context","nameProp","isMounted","isAsync","validators","validatorsMaps","updateValidatorsMap","path","isValid","counter","undefined","current","resetValidatorsMap","keys","forEach","type","_useRef","syncValidatorsValue","asyncValidatorsValue","addFN","addValidatorsAsync","addValidators","_useRef2","validatorsToRemove","validatorsMapsToRemove","newValidators","newValidatorsMaps","removeFN","removeValidatorsAsync","removeValidators","cleanValidators","validatorObj"],"sources":["/home/micqdf/AlpacaPunchTests/maintest/test1/client/node_modules/usetheform/build/es/hooks/useValidators.js"],"sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport { useRef, useCallback } from \"react\";\nimport { mergeValidators } from \"../utils/utilValidators\";\nexport function useValidators(context, nameProp, isMounted, isAsync) {\n  if (isAsync === void 0) {\n    isAsync = false;\n  }\n\n  var validators = useRef({});\n  var validatorsMaps = useRef({});\n  var updateValidatorsMap = useCallback(function (path, isValid, counter) {\n    // It propagates up to the form context\n    if (context !== undefined) {\n      context.updateValidatorsMap(nameProp.current + \"/\" + path, isValid, counter);\n    } else {\n      validatorsMaps.current[path] = _extends({}, validatorsMaps.current[path], {\n        isValid: isValid,\n        counter: counter\n      });\n    }\n  }, []); // resetValidatorsMap only used in useForm\n\n  var resetValidatorsMap = useCallback(function () {\n    Object.keys(validatorsMaps.current).forEach(function (key) {\n      var type = validatorsMaps.current[key].type;\n      validatorsMaps.current[key].counter = 0;\n      validatorsMaps.current[key].isValid = type === \"collection\" ? null : false;\n    });\n    return validatorsMaps.current;\n  }, []); // syncValidatorsValue type depends on its context - can be function or object\n  // asyncValidatorsValue type depends on its context - can be boolean, null or object\n\n  var _useRef = useRef(function (path, syncValidatorsValue, asyncValidatorsValue) {\n    validators.current = _extends({}, validators.current, mergeValidators(path, syncValidatorsValue));\n\n    if (isAsync) {\n      validatorsMaps.current = _extends({}, validatorsMaps.current, mergeValidators(path, asyncValidatorsValue));\n    }\n\n    if (nameProp !== undefined && isMounted.current && context !== undefined) {\n      var addFN = isAsync ? context.addValidatorsAsync : context.addValidators;\n      addFN(nameProp.current, validators.current, validatorsMaps.current);\n    }\n  }),\n      addValidators = _useRef.current;\n\n  var _useRef2 = useRef(function (path, validatorsToRemove, validatorsMapsToRemove) {\n    if (validatorsMapsToRemove === void 0) {\n      validatorsMapsToRemove = false;\n    }\n\n    var newValidators = _extends({}, validators.current, mergeValidators(path, validatorsToRemove, true));\n\n    var newValidatorsMaps = !isAsync ? {} : _extends({}, validatorsMaps.current, mergeValidators(path, validatorsMapsToRemove, true));\n\n    if (context !== undefined) {\n      validators.current = newValidators;\n      validatorsMaps.current = newValidatorsMaps;\n      var removeFN = isAsync ? context.removeValidatorsAsync : context.removeValidators;\n      removeFN(nameProp.current, validators.current, validatorsMaps.current);\n    } else {\n      // if context is undefined it is the form context and then\n      // we must clean the undefined prop from it\n      validators.current = cleanValidators(newValidators);\n      validatorsMaps.current = cleanValidators(newValidatorsMaps);\n    }\n  }),\n      removeValidators = _useRef2.current;\n\n  return [validators, addValidators, removeValidators, validatorsMaps, updateValidatorsMap, resetValidatorsMap];\n}\n\nfunction cleanValidators(validatorObj) {\n  Object.keys(validatorObj).forEach(function (key) {\n    if (validatorObj[key] === undefined) {\n      delete validatorObj[key];\n    }\n  });\n  return validatorObj;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}