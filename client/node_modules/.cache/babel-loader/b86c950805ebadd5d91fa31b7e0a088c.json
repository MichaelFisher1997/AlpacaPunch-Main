{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@zilliqa-js/core'), require('@zilliqa-js/util'), require('@zilliqa-js/proto'), require('@zilliqa-js/crypto'), require('bip39'), require('hdkey')) : typeof define === 'function' && define.amd ? define(['exports', 'tslib', '@zilliqa-js/core', '@zilliqa-js/util', '@zilliqa-js/proto', '@zilliqa-js/crypto', 'bip39', 'hdkey'], factory) : factory(global.zjsAccount = {}, global.tslib, global['@zilliqa-js/core'], global['@zilliqa-js/util'], global['@zilliqa-js/proto'], global['@zilliqa-js/crypto'], global.bip39, global.hdkey);\n})(this, function (exports, tslib, core, util, proto, zcrypto, bip39, hdkey) {\n  'use strict';\n\n  bip39 = bip39 && bip39.hasOwnProperty('default') ? bip39['default'] : bip39;\n  hdkey = hdkey && hdkey.hasOwnProperty('default') ? hdkey['default'] : hdkey; //  Copyright (C) 2018 Zilliqa\n\n  var encodeTransactionProto = function (tx) {\n    var msg = {\n      version: tx.version,\n      nonce: tx.nonce || 0,\n      // core protocol Schnorr expects lowercase, non-prefixed address.\n      toaddr: util.bytes.hexToByteArray(tx.toAddr.replace('0x', '').toLowerCase()),\n      senderpubkey: proto.ZilliqaMessage.ByteArray.create({\n        data: util.bytes.hexToByteArray(tx.pubKey || '00')\n      }),\n      amount: proto.ZilliqaMessage.ByteArray.create({\n        data: Uint8Array.from(tx.amount.toArrayLike(Buffer, undefined, 16))\n      }),\n      gasprice: proto.ZilliqaMessage.ByteArray.create({\n        data: Uint8Array.from(tx.gasPrice.toArrayLike(Buffer, undefined, 16))\n      }),\n      gaslimit: tx.gasLimit,\n      code: tx.code && tx.code.length ? Uint8Array.from(tslib.__spreadArray([], tslib.__read(tx.code), false).map(function (c) {\n        return c.charCodeAt(0);\n      })) : null,\n      data: tx.data && tx.data.length ? Uint8Array.from(tslib.__spreadArray([], tslib.__read(tx.data), false).map(function (c) {\n        return c.charCodeAt(0);\n      })) : null\n    };\n    var serialised = proto.ZilliqaMessage.ProtoTransactionCoreInfo.create(msg);\n    return Buffer.from(proto.ZilliqaMessage.ProtoTransactionCoreInfo.encode(serialised).finish());\n  };\n\n  var isTxReceipt = function (x) {\n    return util.validation.isPlainObject(x) && util.validation.matchesObject(x, {});\n  };\n\n  var isTxParams = function (obj) {\n    var validator = {\n      version: [util.validation.required(util.validation.isNumber)],\n      toAddr: [util.validation.required(util.validation.isAddress)],\n      amount: [util.validation.required(util.validation.isBN)],\n      gasPrice: [util.validation.required(util.validation.isBN)],\n      gasLimit: [util.validation.required(util.validation.isLong)],\n      code: [util.validation.isString],\n      data: [util.validation.isString],\n      receipt: [isTxReceipt],\n      nonce: [util.validation.required(util.validation.isNumber)],\n      signature: [util.validation.required(util.validation.isSignature)]\n    };\n    return util.validation.matchesObject(obj, validator);\n  };\n\n  var formatOutgoingTx = function (req) {\n    var e_1, _a; // if batch create transaction, payload is array\n\n\n    if (Array.isArray(req.payload) && req.payload[0].method === core.RPCMethod.CreateTransaction && isTxParams(req.payload[0].params[0])) {\n      // loop thru batch payloads and format the params\n      var payloads = [];\n\n      try {\n        for (var _b = tslib.__values(req.payload), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var txPayload = _c.value;\n          var txConfig = txPayload.params[0];\n          payloads.push(tslib.__assign(tslib.__assign({}, txPayload), {\n            params: [tslib.__assign(tslib.__assign({}, txConfig), {\n              amount: txConfig.amount.toString(),\n              gasLimit: txConfig.gasLimit.toString(),\n              gasPrice: txConfig.gasPrice.toString()\n            })]\n          }));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      var ret = tslib.__assign(tslib.__assign({}, req), {\n        payload: payloads\n      });\n\n      return ret;\n    } // non-batch create transactions\n\n\n    if (!Array.isArray(req.payload) && req.payload.method === core.RPCMethod.CreateTransaction && isTxParams(req.payload.params[0])) {\n      var txConfig = req.payload.params[0];\n\n      var ret = tslib.__assign(tslib.__assign({}, req), {\n        payload: tslib.__assign(tslib.__assign({}, req.payload), {\n          params: [tslib.__assign(tslib.__assign({}, txConfig), {\n            amount: txConfig.amount.toString(),\n            gasLimit: txConfig.gasLimit.toString(),\n            gasPrice: txConfig.gasPrice.toString()\n          })]\n        })\n      });\n\n      return ret;\n    }\n\n    return req;\n  };\n\n  function sleep(ms) {\n    return tslib.__awaiter(this, void 0, void 0, function () {\n      return tslib.__generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve) {\n          setTimeout(function () {\n            return resolve(undefined);\n          }, ms);\n        })];\n      });\n    });\n  }\n\n  var util$1 = /*#__PURE__*/Object.freeze({\n    encodeTransactionProto: encodeTransactionProto,\n    isTxReceipt: isTxReceipt,\n    isTxParams: isTxParams,\n    formatOutgoingTx: formatOutgoingTx,\n    sleep: sleep\n  }); //  Copyright (C) 2018 Zilliqa\n\n  var Account =\n  /** @class */\n  function () {\n    function Account(privateKey) {\n      this.privateKey = this.normalizePrivateKey(privateKey);\n      this.publicKey = zcrypto.getPubKeyFromPrivateKey(this.privateKey);\n      this.address = zcrypto.getAddressFromPublicKey(this.publicKey);\n      this.bech32Address = zcrypto.toBech32Address(this.address);\n    }\n    /**\r\n     * fromFile\r\n     *\r\n     * Takes a JSON-encoded keystore and passphrase, returning a fully\r\n     * instantiated Account instance.\r\n     *\r\n     * @param {string} file\r\n     * @param {string} passphrase\r\n     * @returns {Promise<Account>}\r\n     */\n\n\n    Account.fromFile = function (file, passphrase) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var keystore, privateKey, err_1;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              keystore = JSON.parse(file);\n              return [4\n              /*yield*/\n              , zcrypto.decryptPrivateKey(passphrase, keystore)];\n\n            case 1:\n              privateKey = _a.sent();\n              return [2\n              /*return*/\n              , new Account(privateKey)];\n\n            case 2:\n              err_1 = _a.sent();\n              throw new Error(\"Could not decrypt keystore file.\");\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\r\n     * toFile\r\n     *\r\n     * @param {string} passphrase\r\n     * @param {kdf} 'pbkdf2' | 'scrypt'\r\n     * @returns {Promise<string>}\r\n     */\n\n\n    Account.prototype.toFile = function (passphrase, kdf) {\n      if (kdf === void 0) {\n        kdf = 'scrypt';\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var keystore;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!passphrase || !passphrase.length) {\n                throw new Error('Passphrase cannot have a length of 0');\n              }\n\n              return [4\n              /*yield*/\n              , zcrypto.encryptPrivateKey(kdf, this.privateKey, passphrase)];\n\n            case 1:\n              keystore = _a.sent();\n              return [2\n              /*return*/\n              , keystore];\n          }\n        });\n      });\n    };\n    /**\r\n     * signTransaction\r\n     *\r\n     * @param {Buffer} bytes - the data to be signed\r\n     *\r\n     * @returns {string} - the hex encoded signature. it is a concatenation of\r\n     * the r and s values in hex, each padded to a length of 64.\r\n     */\n\n\n    Account.prototype.signTransaction = function (bytes) {\n      return zcrypto.sign(bytes, this.privateKey, this.publicKey);\n    };\n\n    Account.prototype.normalizePrivateKey = function (privateKey) {\n      return zcrypto.normalizePrivateKey(privateKey);\n    };\n\n    return Account;\n  }(); //  Copyright (C) 2018 Zilliqa\n\n\n  var Wallet =\n  /** @class */\n  function (_super) {\n    tslib.__extends(Wallet, _super);\n    /**\r\n     * constructor\r\n     *\r\n     * Takes an array of Account objects and instantiates a Wallet instance.\r\n     *\r\n     * @param {Account[]} accounts\r\n     */\n\n\n    function Wallet(provider, accounts) {\n      if (accounts === void 0) {\n        accounts = [];\n      }\n\n      var _this = _super.call(this) || this;\n\n      _this.accounts = {};\n\n      if (accounts.length) {\n        _this.accounts = accounts.reduce(function (acc, account) {\n          var _a;\n\n          return tslib.__assign(tslib.__assign({}, acc), (_a = {}, _a[account.address] = account, _a));\n        }, {});\n      }\n\n      _this.provider = provider;\n      _this.defaultAccount = accounts[0];\n      return _this;\n    }\n    /**\r\n     * create\r\n     *\r\n     * Creates a new keypair with a randomly-generated private key. The new\r\n     * account is accessible by address.\r\n     *\r\n     * @returns {string} - address of the new account\r\n     */\n\n\n    Wallet.prototype.create = function () {\n      var _a;\n\n      var privateKey = zcrypto.schnorr.generatePrivateKey();\n      var newAccount = new Account(privateKey);\n      this.accounts = tslib.__assign(tslib.__assign({}, this.accounts), (_a = {}, _a[newAccount.address] = newAccount, _a));\n\n      if (!this.defaultAccount) {\n        this.defaultAccount = newAccount;\n      }\n\n      return newAccount.address;\n    };\n    /**\r\n     * addByPrivateKey\r\n     *\r\n     * Adds an account to the wallet by private key.\r\n     *\r\n     * @param {string} privateKey - hex-encoded private key\r\n     * @returns {string} - the corresponing address, computer from the private\r\n     * key.\r\n     */\n\n\n    Wallet.prototype.addByPrivateKey = function (privateKey) {\n      var _a;\n\n      var newAccount = new Account(privateKey);\n      this.accounts = tslib.__assign(tslib.__assign({}, this.accounts), (_a = {}, _a[newAccount.address] = newAccount, _a));\n\n      if (!this.defaultAccount) {\n        this.defaultAccount = newAccount;\n      }\n\n      return newAccount.address;\n    };\n    /**\r\n     * addByKeystore\r\n     *\r\n     * Adds an account by keystore. This method is asynchronous and returns\r\n     * a Promise<string>, in order not to block on the underlying decryption\r\n     * operation.\r\n     *\r\n     * @param {string} keystore\r\n     * @param {string} passphrase\r\n     * @returns {Promise<string>}\r\n     */\n\n\n    Wallet.prototype.addByKeystore = function (keystore, passphrase) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var newAccount;\n\n        var _a;\n\n        return tslib.__generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , Account.fromFile(keystore, passphrase)];\n\n            case 1:\n              newAccount = _b.sent();\n              this.accounts = tslib.__assign(tslib.__assign({}, this.accounts), (_a = {}, _a[newAccount.address] = newAccount, _a));\n\n              if (!this.defaultAccount) {\n                this.defaultAccount = newAccount;\n              }\n\n              return [2\n              /*return*/\n              , newAccount.address];\n          }\n        });\n      });\n    };\n    /**\r\n     * addByMnemonic\r\n     *\r\n     * Adds an `Account` by use of a mnemonic as specified in BIP-32 and BIP-39\r\n     *\r\n     * @param {string} phrase - 12-word mnemonic phrase\r\n     * @param {number} index=0 - the number of the child key to add\r\n     * @returns {string} - the corresponding address\r\n     */\n\n\n    Wallet.prototype.addByMnemonic = function (phrase, index) {\n      if (index === void 0) {\n        index = 0;\n      }\n\n      if (!this.isValidMnemonic(phrase)) {\n        throw new Error(\"Invalid mnemonic phrase: \" + phrase);\n      }\n\n      var seed = bip39.mnemonicToSeed(phrase);\n      var hdKey = hdkey.fromMasterSeed(seed);\n      var childKey = hdKey.derive(\"m/44'/313'/0'/0/\" + index);\n      var privateKey = childKey.privateKey.toString('hex');\n      return this.addByPrivateKey(privateKey);\n    };\n    /**\r\n     * addByMnemonicLedger\r\n     *\r\n     * Adds an `Account` by use of a mnemonic as specified in BIP-32 and BIP-39\r\n     * The key derivation path used in Ledger is different from that of\r\n     * addByMnemonic.\r\n     *\r\n     * @param {string} phrase - 12-word mnemonic phrase\r\n     * @param {number} index=0 - the number of the child key to add\r\n     * @returns {string} - the corresponding address\r\n     */\n\n\n    Wallet.prototype.addByMnemonicLedger = function (phrase, index) {\n      if (index === void 0) {\n        index = 0;\n      }\n\n      if (!this.isValidMnemonic(phrase)) {\n        throw new Error(\"Invalid mnemonic phrase: \" + phrase);\n      }\n\n      var seed = bip39.mnemonicToSeed(phrase);\n      var hdKey = hdkey.fromMasterSeed(seed);\n      var childKey = hdKey.derive(\"m/44'/313'/\" + index + \"'/0'/0'\");\n      var privateKey = childKey.privateKey.toString('hex');\n      return this.addByPrivateKey(privateKey);\n    };\n    /**\r\n     * export\r\n     *\r\n     * Exports the specified account as a keystore file.\r\n     *\r\n     * @param {string} address\r\n     * @param {string} passphrase\r\n     * @param {KDF} kdf='scrypt'\r\n     * @returns {Promise<string>}\r\n     */\n\n\n    Wallet.prototype.export = function (address, passphrase, kdf) {\n      if (kdf === void 0) {\n        kdf = 'scrypt';\n      }\n\n      if (!this.accounts[address]) {\n        throw new Error(\"No account with address \" + address + \" exists\");\n      }\n\n      return this.accounts[address].toFile(passphrase, kdf);\n    };\n    /**\r\n     * remove\r\n     *\r\n     * Removes an account from the wallet and returns boolean to indicate\r\n     * failure or success.\r\n     *\r\n     * @param {string} address\r\n     * @returns {boolean}\r\n     */\n\n\n    Wallet.prototype.remove = function (address) {\n      if (this.accounts[address]) {\n        var _a = this.accounts,\n            _b = address,\n            toRemove = _a[_b],\n            rest = tslib.__rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n        this.accounts = rest;\n        return true;\n      }\n\n      return false;\n    };\n    /**\r\n     * setDefault\r\n     *\r\n     * Sets the default account of the wallet.\r\n     *\r\n     * @param {string} address\r\n     */\n\n\n    Wallet.prototype.setDefault = function (address) {\n      this.defaultAccount = this.accounts[address];\n    };\n    /**\r\n     * sign\r\n     *\r\n     * signs an unsigned transaction with the default account.\r\n     *\r\n     * @param {Transaction} tx\r\n     * @param {boolean} offlineSign\r\n     * @returns {Transaction}\r\n     */\n\n\n    Wallet.prototype.sign = function (tx, offlineSign) {\n      if (tx.txParams && tx.txParams.pubKey) {\n        // attempt to find the address\n        var senderAddress = zcrypto.getAddressFromPublicKey(tx.txParams.pubKey);\n\n        if (!this.accounts[senderAddress]) {\n          throw new Error(\"Could not sign the transaction with \" + senderAddress + \" as it does not exist\");\n        }\n\n        return this.signWith(tx, senderAddress, offlineSign);\n      }\n\n      if (!this.defaultAccount) {\n        throw new Error('This wallet has no default account.');\n      }\n\n      return this.signWith(tx, this.defaultAccount.address, offlineSign);\n    };\n\n    Wallet.prototype.signBatch = function (txList) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var batchResults, signer_1, balance, nextNonce, _loop_1, this_1, index, err_1;\n\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              batchResults = [];\n\n              if (!this.defaultAccount) {\n                throw new Error('This wallet has no default account.');\n              }\n\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 7,, 8]);\n\n              signer_1 = this.accounts[this.defaultAccount.address];\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.GetBalance, signer_1.address.replace('0x', '').toLowerCase())];\n\n            case 2:\n              balance = _a.sent();\n\n              if (balance.result === undefined) {\n                throw new Error('Could not get balance');\n              }\n\n              if (typeof balance.result.nonce !== 'number') {\n                throw new Error('Could not get nonce');\n              }\n\n              nextNonce = balance.result.nonce + 1;\n\n              _loop_1 = function (index) {\n                var currentNonce, withNonceTx, signedTx;\n                return tslib.__generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      currentNonce = index + nextNonce;\n                      withNonceTx = txList[index].map(function (txObj) {\n                        return tslib.__assign(tslib.__assign({}, txObj), {\n                          nonce: currentNonce,\n                          pubKey: signer_1.publicKey\n                        });\n                      });\n                      return [4\n                      /*yield*/\n                      , this_1.sign(withNonceTx)];\n\n                    case 1:\n                      signedTx = _b.sent();\n                      batchResults.push(signedTx);\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              };\n\n              this_1 = this;\n              index = 0;\n              _a.label = 3;\n\n            case 3:\n              if (!(index < txList.length)) return [3\n              /*break*/\n              , 6];\n              return [5\n              /*yield**/\n              , _loop_1(index)];\n\n            case 4:\n              _a.sent();\n\n              _a.label = 5;\n\n            case 5:\n              index++;\n              return [3\n              /*break*/\n              , 3];\n\n            case 6:\n              return [3\n              /*break*/\n              , 8];\n\n            case 7:\n              err_1 = _a.sent();\n              throw err_1;\n\n            case 8:\n              return [2\n              /*return*/\n              , batchResults];\n          }\n        });\n      });\n    };\n    /**\r\n     * signWith\r\n     *\r\n     * @param {Transaction} tx\r\n     * @param {string} account\r\n     * @param {boolean} offlineSign\r\n     * @returns {Transaction}\r\n     */\n\n\n    Wallet.prototype.signWith = function (tx, account, offlineSign) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var signer, gasPrice, gasLimit, debt, currNonce, balance, bal, withNonce_1, withPublicKey, err_2;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!this.accounts[account]) {\n                throw new Error('The selected account does not exist on this Wallet instance.');\n              }\n\n              signer = this.accounts[account];\n              gasPrice = tx.txParams.gasPrice;\n              gasLimit = new util.BN(tx.txParams.gasLimit.toString());\n              debt = gasPrice.mul(gasLimit).add(tx.txParams.amount);\n              currNonce = 0;\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 5,, 6]);\n\n              if (!!tx.txParams.nonce) return [3\n              /*break*/\n              , 4];\n\n              if (offlineSign) {\n                throw new Error('No nonce detected in tx params when signing in offline mode');\n              }\n\n              if (!(typeof offlineSign === 'undefined' || !offlineSign)) return [3\n              /*break*/\n              , 3];\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.GetBalance, signer.address.replace('0x', '').toLowerCase())];\n\n            case 2:\n              balance = _a.sent();\n\n              if (balance.result === undefined) {\n                throw new Error('Could not get balance');\n              }\n\n              bal = new util.BN(balance.result.balance);\n\n              if (debt.gt(bal)) {\n                throw new Error('You do not have enough funds, need ' + debt.toString() + ' but only have ' + bal.toString());\n              }\n\n              if (typeof balance.result.nonce !== 'number') {\n                throw new Error('Could not get nonce');\n              }\n\n              currNonce = balance.result.nonce;\n              _a.label = 3;\n\n            case 3:\n              withNonce_1 = tx.map(function (txObj) {\n                return tslib.__assign(tslib.__assign({}, txObj), {\n                  nonce: txObj.nonce || currNonce + 1,\n                  pubKey: signer.publicKey\n                });\n              });\n              return [2\n              /*return*/\n              , withNonce_1.map(function (txObj) {\n                // @ts-ignore\n                return tslib.__assign(tslib.__assign({}, txObj), {\n                  signature: signer.signTransaction(withNonce_1.bytes)\n                });\n              })];\n\n            case 4:\n              withPublicKey = tx.map(function (txObj) {\n                return tslib.__assign(tslib.__assign({}, txObj), {\n                  pubKey: signer.publicKey\n                });\n              });\n              return [2\n              /*return*/\n              , withPublicKey.map(function (txObj) {\n                return tslib.__assign(tslib.__assign({}, txObj), {\n                  signature: signer.signTransaction(tx.bytes)\n                });\n              })];\n\n            case 5:\n              err_2 = _a.sent();\n              throw err_2;\n\n            case 6:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    Wallet.prototype.isValidMnemonic = function (phrase) {\n      if (phrase.trim().split(/\\s+/g).length < 12) {\n        return false;\n      }\n\n      return bip39.validateMnemonic(phrase);\n    };\n\n    return Wallet;\n  }(core.Signer); //  Copyright (C) 2018 Zilliqa\n\n\n  (function (TxStatus) {\n    TxStatus[TxStatus[\"Initialised\"] = 0] = \"Initialised\";\n    TxStatus[TxStatus[\"Pending\"] = 1] = \"Pending\";\n    TxStatus[TxStatus[\"Confirmed\"] = 2] = \"Confirmed\";\n    TxStatus[TxStatus[\"Rejected\"] = 3] = \"Rejected\";\n  })(exports.TxStatus || (exports.TxStatus = {}));\n\n  (function (TxEventName) {\n    TxEventName[\"Error\"] = \"error\";\n    TxEventName[\"Receipt\"] = \"receipt\";\n    TxEventName[\"Track\"] = \"track\";\n  })(exports.TxEventName || (exports.TxEventName = {}));\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  var minimalisticAssert = assert;\n\n  function assert(val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  assert.equal = function assertEqual(l, r, msg) {\n    if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);\n  };\n\n  var inherits_browser = createCommonjsModule(function (module) {\n    if (typeof Object.create === 'function') {\n      // implementation from standard node.js 'util' module\n      module.exports = function inherits(ctor, superCtor) {\n        if (superCtor) {\n          ctor.super_ = superCtor;\n          ctor.prototype = Object.create(superCtor.prototype, {\n            constructor: {\n              value: ctor,\n              enumerable: false,\n              writable: true,\n              configurable: true\n            }\n          });\n        }\n      };\n    } else {\n      // old school shim for old browsers\n      module.exports = function inherits(ctor, superCtor) {\n        if (superCtor) {\n          ctor.super_ = superCtor;\n\n          var TempCtor = function () {};\n\n          TempCtor.prototype = superCtor.prototype;\n          ctor.prototype = new TempCtor();\n          ctor.prototype.constructor = ctor;\n        }\n      };\n    }\n  });\n  var inherits_1 = inherits_browser;\n\n  function isSurrogatePair(msg, i) {\n    if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {\n      return false;\n    }\n\n    if (i < 0 || i + 1 >= msg.length) {\n      return false;\n    }\n\n    return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;\n  }\n\n  function toArray(msg, enc) {\n    if (Array.isArray(msg)) return msg.slice();\n    if (!msg) return [];\n    var res = [];\n\n    if (typeof msg === 'string') {\n      if (!enc) {\n        // Inspired by stringToUtf8ByteArray() in closure-library by Google\n        // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n        // Apache License 2.0\n        // https://github.com/google/closure-library/blob/master/LICENSE\n        var p = 0;\n\n        for (var i = 0; i < msg.length; i++) {\n          var c = msg.charCodeAt(i);\n\n          if (c < 128) {\n            res[p++] = c;\n          } else if (c < 2048) {\n            res[p++] = c >> 6 | 192;\n            res[p++] = c & 63 | 128;\n          } else if (isSurrogatePair(msg, i)) {\n            c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);\n            res[p++] = c >> 18 | 240;\n            res[p++] = c >> 12 & 63 | 128;\n            res[p++] = c >> 6 & 63 | 128;\n            res[p++] = c & 63 | 128;\n          } else {\n            res[p++] = c >> 12 | 224;\n            res[p++] = c >> 6 & 63 | 128;\n            res[p++] = c & 63 | 128;\n          }\n        }\n      } else if (enc === 'hex') {\n        msg = msg.replace(/[^a-z0-9]+/ig, '');\n        if (msg.length % 2 !== 0) msg = '0' + msg;\n\n        for (i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));\n      }\n    } else {\n      for (i = 0; i < msg.length; i++) res[i] = msg[i] | 0;\n    }\n\n    return res;\n  }\n\n  var toArray_1 = toArray;\n\n  function toHex(msg) {\n    var res = '';\n\n    for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));\n\n    return res;\n  }\n\n  var toHex_1 = toHex;\n\n  function htonl(w) {\n    var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;\n    return res >>> 0;\n  }\n\n  var htonl_1 = htonl;\n\n  function toHex32(msg, endian) {\n    var res = '';\n\n    for (var i = 0; i < msg.length; i++) {\n      var w = msg[i];\n      if (endian === 'little') w = htonl(w);\n      res += zero8(w.toString(16));\n    }\n\n    return res;\n  }\n\n  var toHex32_1 = toHex32;\n\n  function zero2(word) {\n    if (word.length === 1) return '0' + word;else return word;\n  }\n\n  var zero2_1 = zero2;\n\n  function zero8(word) {\n    if (word.length === 7) return '0' + word;else if (word.length === 6) return '00' + word;else if (word.length === 5) return '000' + word;else if (word.length === 4) return '0000' + word;else if (word.length === 3) return '00000' + word;else if (word.length === 2) return '000000' + word;else if (word.length === 1) return '0000000' + word;else return word;\n  }\n\n  var zero8_1 = zero8;\n\n  function join32(msg, start, end, endian) {\n    var len = end - start;\n    minimalisticAssert(len % 4 === 0);\n    var res = new Array(len / 4);\n\n    for (var i = 0, k = start; i < res.length; i++, k += 4) {\n      var w;\n      if (endian === 'big') w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];\n      res[i] = w >>> 0;\n    }\n\n    return res;\n  }\n\n  var join32_1 = join32;\n\n  function split32(msg, endian) {\n    var res = new Array(msg.length * 4);\n\n    for (var i = 0, k = 0; i < msg.length; i++, k += 4) {\n      var m = msg[i];\n\n      if (endian === 'big') {\n        res[k] = m >>> 24;\n        res[k + 1] = m >>> 16 & 0xff;\n        res[k + 2] = m >>> 8 & 0xff;\n        res[k + 3] = m & 0xff;\n      } else {\n        res[k + 3] = m >>> 24;\n        res[k + 2] = m >>> 16 & 0xff;\n        res[k + 1] = m >>> 8 & 0xff;\n        res[k] = m & 0xff;\n      }\n    }\n\n    return res;\n  }\n\n  var split32_1 = split32;\n\n  function rotr32(w, b) {\n    return w >>> b | w << 32 - b;\n  }\n\n  var rotr32_1 = rotr32;\n\n  function rotl32(w, b) {\n    return w << b | w >>> 32 - b;\n  }\n\n  var rotl32_1 = rotl32;\n\n  function sum32(a, b) {\n    return a + b >>> 0;\n  }\n\n  var sum32_1 = sum32;\n\n  function sum32_3(a, b, c) {\n    return a + b + c >>> 0;\n  }\n\n  var sum32_3_1 = sum32_3;\n\n  function sum32_4(a, b, c, d) {\n    return a + b + c + d >>> 0;\n  }\n\n  var sum32_4_1 = sum32_4;\n\n  function sum32_5(a, b, c, d, e) {\n    return a + b + c + d + e >>> 0;\n  }\n\n  var sum32_5_1 = sum32_5;\n\n  function sum64(buf, pos, ah, al) {\n    var bh = buf[pos];\n    var bl = buf[pos + 1];\n    var lo = al + bl >>> 0;\n    var hi = (lo < al ? 1 : 0) + ah + bh;\n    buf[pos] = hi >>> 0;\n    buf[pos + 1] = lo;\n  }\n\n  var sum64_1 = sum64;\n\n  function sum64_hi(ah, al, bh, bl) {\n    var lo = al + bl >>> 0;\n    var hi = (lo < al ? 1 : 0) + ah + bh;\n    return hi >>> 0;\n  }\n\n  var sum64_hi_1 = sum64_hi;\n\n  function sum64_lo(ah, al, bh, bl) {\n    var lo = al + bl;\n    return lo >>> 0;\n  }\n\n  var sum64_lo_1 = sum64_lo;\n\n  function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n    var carry = 0;\n    var lo = al;\n    lo = lo + bl >>> 0;\n    carry += lo < al ? 1 : 0;\n    lo = lo + cl >>> 0;\n    carry += lo < cl ? 1 : 0;\n    lo = lo + dl >>> 0;\n    carry += lo < dl ? 1 : 0;\n    var hi = ah + bh + ch + dh + carry;\n    return hi >>> 0;\n  }\n\n  var sum64_4_hi_1 = sum64_4_hi;\n\n  function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n    var lo = al + bl + cl + dl;\n    return lo >>> 0;\n  }\n\n  var sum64_4_lo_1 = sum64_4_lo;\n\n  function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n    var carry = 0;\n    var lo = al;\n    lo = lo + bl >>> 0;\n    carry += lo < al ? 1 : 0;\n    lo = lo + cl >>> 0;\n    carry += lo < cl ? 1 : 0;\n    lo = lo + dl >>> 0;\n    carry += lo < dl ? 1 : 0;\n    lo = lo + el >>> 0;\n    carry += lo < el ? 1 : 0;\n    var hi = ah + bh + ch + dh + eh + carry;\n    return hi >>> 0;\n  }\n\n  var sum64_5_hi_1 = sum64_5_hi;\n\n  function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n    var lo = al + bl + cl + dl + el;\n    return lo >>> 0;\n  }\n\n  var sum64_5_lo_1 = sum64_5_lo;\n\n  function rotr64_hi(ah, al, num) {\n    var r = al << 32 - num | ah >>> num;\n    return r >>> 0;\n  }\n\n  var rotr64_hi_1 = rotr64_hi;\n\n  function rotr64_lo(ah, al, num) {\n    var r = ah << 32 - num | al >>> num;\n    return r >>> 0;\n  }\n\n  var rotr64_lo_1 = rotr64_lo;\n\n  function shr64_hi(ah, al, num) {\n    return ah >>> num;\n  }\n\n  var shr64_hi_1 = shr64_hi;\n\n  function shr64_lo(ah, al, num) {\n    var r = ah << 32 - num | al >>> num;\n    return r >>> 0;\n  }\n\n  var shr64_lo_1 = shr64_lo;\n  var utils = {\n    inherits: inherits_1,\n    toArray: toArray_1,\n    toHex: toHex_1,\n    htonl: htonl_1,\n    toHex32: toHex32_1,\n    zero2: zero2_1,\n    zero8: zero8_1,\n    join32: join32_1,\n    split32: split32_1,\n    rotr32: rotr32_1,\n    rotl32: rotl32_1,\n    sum32: sum32_1,\n    sum32_3: sum32_3_1,\n    sum32_4: sum32_4_1,\n    sum32_5: sum32_5_1,\n    sum64: sum64_1,\n    sum64_hi: sum64_hi_1,\n    sum64_lo: sum64_lo_1,\n    sum64_4_hi: sum64_4_hi_1,\n    sum64_4_lo: sum64_4_lo_1,\n    sum64_5_hi: sum64_5_hi_1,\n    sum64_5_lo: sum64_5_lo_1,\n    rotr64_hi: rotr64_hi_1,\n    rotr64_lo: rotr64_lo_1,\n    shr64_hi: shr64_hi_1,\n    shr64_lo: shr64_lo_1\n  };\n\n  function BlockHash() {\n    this.pending = null;\n    this.pendingTotal = 0;\n    this.blockSize = this.constructor.blockSize;\n    this.outSize = this.constructor.outSize;\n    this.hmacStrength = this.constructor.hmacStrength;\n    this.padLength = this.constructor.padLength / 8;\n    this.endian = 'big';\n    this._delta8 = this.blockSize / 8;\n    this._delta32 = this.blockSize / 32;\n  }\n\n  var BlockHash_1 = BlockHash;\n\n  BlockHash.prototype.update = function update(msg, enc) {\n    // Convert message to array, pad it, and join into 32bit blocks\n    msg = utils.toArray(msg, enc);\n    if (!this.pending) this.pending = msg;else this.pending = this.pending.concat(msg);\n    this.pendingTotal += msg.length; // Enough data, try updating\n\n    if (this.pending.length >= this._delta8) {\n      msg = this.pending; // Process pending data in blocks\n\n      var r = msg.length % this._delta8;\n      this.pending = msg.slice(msg.length - r, msg.length);\n      if (this.pending.length === 0) this.pending = null;\n      msg = utils.join32(msg, 0, msg.length - r, this.endian);\n\n      for (var i = 0; i < msg.length; i += this._delta32) this._update(msg, i, i + this._delta32);\n    }\n\n    return this;\n  };\n\n  BlockHash.prototype.digest = function digest(enc) {\n    this.update(this._pad());\n    minimalisticAssert(this.pending === null);\n    return this._digest(enc);\n  };\n\n  BlockHash.prototype._pad = function pad() {\n    var len = this.pendingTotal;\n    var bytes = this._delta8;\n    var k = bytes - (len + this.padLength) % bytes;\n    var res = new Array(k + this.padLength);\n    res[0] = 0x80;\n\n    for (var i = 1; i < k; i++) res[i] = 0; // Append length\n\n\n    len <<= 3;\n\n    if (this.endian === 'big') {\n      for (var t = 8; t < this.padLength; t++) res[i++] = 0;\n\n      res[i++] = 0;\n      res[i++] = 0;\n      res[i++] = 0;\n      res[i++] = 0;\n      res[i++] = len >>> 24 & 0xff;\n      res[i++] = len >>> 16 & 0xff;\n      res[i++] = len >>> 8 & 0xff;\n      res[i++] = len & 0xff;\n    } else {\n      res[i++] = len & 0xff;\n      res[i++] = len >>> 8 & 0xff;\n      res[i++] = len >>> 16 & 0xff;\n      res[i++] = len >>> 24 & 0xff;\n      res[i++] = 0;\n      res[i++] = 0;\n      res[i++] = 0;\n      res[i++] = 0;\n\n      for (t = 8; t < this.padLength; t++) res[i++] = 0;\n    }\n\n    return res;\n  };\n\n  var common = {\n    BlockHash: BlockHash_1\n  };\n  var rotr32$1 = utils.rotr32;\n\n  function ft_1(s, x, y, z) {\n    if (s === 0) return ch32(x, y, z);\n    if (s === 1 || s === 3) return p32(x, y, z);\n    if (s === 2) return maj32(x, y, z);\n  }\n\n  var ft_1_1 = ft_1;\n\n  function ch32(x, y, z) {\n    return x & y ^ ~x & z;\n  }\n\n  var ch32_1 = ch32;\n\n  function maj32(x, y, z) {\n    return x & y ^ x & z ^ y & z;\n  }\n\n  var maj32_1 = maj32;\n\n  function p32(x, y, z) {\n    return x ^ y ^ z;\n  }\n\n  var p32_1 = p32;\n\n  function s0_256(x) {\n    return rotr32$1(x, 2) ^ rotr32$1(x, 13) ^ rotr32$1(x, 22);\n  }\n\n  var s0_256_1 = s0_256;\n\n  function s1_256(x) {\n    return rotr32$1(x, 6) ^ rotr32$1(x, 11) ^ rotr32$1(x, 25);\n  }\n\n  var s1_256_1 = s1_256;\n\n  function g0_256(x) {\n    return rotr32$1(x, 7) ^ rotr32$1(x, 18) ^ x >>> 3;\n  }\n\n  var g0_256_1 = g0_256;\n\n  function g1_256(x) {\n    return rotr32$1(x, 17) ^ rotr32$1(x, 19) ^ x >>> 10;\n  }\n\n  var g1_256_1 = g1_256;\n  var common$1 = {\n    ft_1: ft_1_1,\n    ch32: ch32_1,\n    maj32: maj32_1,\n    p32: p32_1,\n    s0_256: s0_256_1,\n    s1_256: s1_256_1,\n    g0_256: g0_256_1,\n    g1_256: g1_256_1\n  };\n  var rotl32$1 = utils.rotl32;\n  var sum32$1 = utils.sum32;\n  var sum32_5$1 = utils.sum32_5;\n  var ft_1$1 = common$1.ft_1;\n  var BlockHash$1 = common.BlockHash;\n  var sha1_K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];\n\n  function SHA1() {\n    if (!(this instanceof SHA1)) return new SHA1();\n    BlockHash$1.call(this);\n    this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n    this.W = new Array(80);\n  }\n\n  utils.inherits(SHA1, BlockHash$1);\n  var _1 = SHA1;\n  SHA1.blockSize = 512;\n  SHA1.outSize = 160;\n  SHA1.hmacStrength = 80;\n  SHA1.padLength = 64;\n\n  SHA1.prototype._update = function _update(msg, start) {\n    var W = this.W;\n\n    for (var i = 0; i < 16; i++) W[i] = msg[start + i];\n\n    for (; i < W.length; i++) W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n\n    var a = this.h[0];\n    var b = this.h[1];\n    var c = this.h[2];\n    var d = this.h[3];\n    var e = this.h[4];\n\n    for (i = 0; i < W.length; i++) {\n      var s = ~~(i / 20);\n      var t = sum32_5$1(rotl32$1(a, 5), ft_1$1(s, b, c, d), e, W[i], sha1_K[s]);\n      e = d;\n      d = c;\n      c = rotl32$1(b, 30);\n      b = a;\n      a = t;\n    }\n\n    this.h[0] = sum32$1(this.h[0], a);\n    this.h[1] = sum32$1(this.h[1], b);\n    this.h[2] = sum32$1(this.h[2], c);\n    this.h[3] = sum32$1(this.h[3], d);\n    this.h[4] = sum32$1(this.h[4], e);\n  };\n\n  SHA1.prototype._digest = function digest(enc) {\n    if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');\n  };\n\n  var sum32$2 = utils.sum32;\n  var sum32_4$1 = utils.sum32_4;\n  var sum32_5$2 = utils.sum32_5;\n  var ch32$1 = common$1.ch32;\n  var maj32$1 = common$1.maj32;\n  var s0_256$1 = common$1.s0_256;\n  var s1_256$1 = common$1.s1_256;\n  var g0_256$1 = common$1.g0_256;\n  var g1_256$1 = common$1.g1_256;\n  var BlockHash$2 = common.BlockHash;\n  var sha256_K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n\n  function SHA256() {\n    if (!(this instanceof SHA256)) return new SHA256();\n    BlockHash$2.call(this);\n    this.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n    this.k = sha256_K;\n    this.W = new Array(64);\n  }\n\n  utils.inherits(SHA256, BlockHash$2);\n  var _256 = SHA256;\n  SHA256.blockSize = 512;\n  SHA256.outSize = 256;\n  SHA256.hmacStrength = 192;\n  SHA256.padLength = 64;\n\n  SHA256.prototype._update = function _update(msg, start) {\n    var W = this.W;\n\n    for (var i = 0; i < 16; i++) W[i] = msg[start + i];\n\n    for (; i < W.length; i++) W[i] = sum32_4$1(g1_256$1(W[i - 2]), W[i - 7], g0_256$1(W[i - 15]), W[i - 16]);\n\n    var a = this.h[0];\n    var b = this.h[1];\n    var c = this.h[2];\n    var d = this.h[3];\n    var e = this.h[4];\n    var f = this.h[5];\n    var g = this.h[6];\n    var h = this.h[7];\n    minimalisticAssert(this.k.length === W.length);\n\n    for (i = 0; i < W.length; i++) {\n      var T1 = sum32_5$2(h, s1_256$1(e), ch32$1(e, f, g), this.k[i], W[i]);\n      var T2 = sum32$2(s0_256$1(a), maj32$1(a, b, c));\n      h = g;\n      g = f;\n      f = e;\n      e = sum32$2(d, T1);\n      d = c;\n      c = b;\n      b = a;\n      a = sum32$2(T1, T2);\n    }\n\n    this.h[0] = sum32$2(this.h[0], a);\n    this.h[1] = sum32$2(this.h[1], b);\n    this.h[2] = sum32$2(this.h[2], c);\n    this.h[3] = sum32$2(this.h[3], d);\n    this.h[4] = sum32$2(this.h[4], e);\n    this.h[5] = sum32$2(this.h[5], f);\n    this.h[6] = sum32$2(this.h[6], g);\n    this.h[7] = sum32$2(this.h[7], h);\n  };\n\n  SHA256.prototype._digest = function digest(enc) {\n    if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');\n  };\n\n  function SHA224() {\n    if (!(this instanceof SHA224)) return new SHA224();\n\n    _256.call(this);\n\n    this.h = [0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];\n  }\n\n  utils.inherits(SHA224, _256);\n  var _224 = SHA224;\n  SHA224.blockSize = 512;\n  SHA224.outSize = 224;\n  SHA224.hmacStrength = 192;\n  SHA224.padLength = 64;\n\n  SHA224.prototype._digest = function digest(enc) {\n    // Just truncate output\n    if (enc === 'hex') return utils.toHex32(this.h.slice(0, 7), 'big');else return utils.split32(this.h.slice(0, 7), 'big');\n  };\n\n  var rotr64_hi$1 = utils.rotr64_hi;\n  var rotr64_lo$1 = utils.rotr64_lo;\n  var shr64_hi$1 = utils.shr64_hi;\n  var shr64_lo$1 = utils.shr64_lo;\n  var sum64$1 = utils.sum64;\n  var sum64_hi$1 = utils.sum64_hi;\n  var sum64_lo$1 = utils.sum64_lo;\n  var sum64_4_hi$1 = utils.sum64_4_hi;\n  var sum64_4_lo$1 = utils.sum64_4_lo;\n  var sum64_5_hi$1 = utils.sum64_5_hi;\n  var sum64_5_lo$1 = utils.sum64_5_lo;\n  var BlockHash$3 = common.BlockHash;\n  var sha512_K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];\n\n  function SHA512() {\n    if (!(this instanceof SHA512)) return new SHA512();\n    BlockHash$3.call(this);\n    this.h = [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179];\n    this.k = sha512_K;\n    this.W = new Array(160);\n  }\n\n  utils.inherits(SHA512, BlockHash$3);\n  var _512 = SHA512;\n  SHA512.blockSize = 1024;\n  SHA512.outSize = 512;\n  SHA512.hmacStrength = 192;\n  SHA512.padLength = 128;\n\n  SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {\n    var W = this.W; // 32 x 32bit words\n\n    for (var i = 0; i < 32; i++) W[i] = msg[start + i];\n\n    for (; i < W.length; i += 2) {\n      var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2\n\n      var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);\n      var c1_hi = W[i - 14]; // i - 7\n\n      var c1_lo = W[i - 13];\n      var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15\n\n      var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);\n      var c3_hi = W[i - 32]; // i - 16\n\n      var c3_lo = W[i - 31];\n      W[i] = sum64_4_hi$1(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);\n      W[i + 1] = sum64_4_lo$1(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);\n    }\n  };\n\n  SHA512.prototype._update = function _update(msg, start) {\n    this._prepareBlock(msg, start);\n\n    var W = this.W;\n    var ah = this.h[0];\n    var al = this.h[1];\n    var bh = this.h[2];\n    var bl = this.h[3];\n    var ch = this.h[4];\n    var cl = this.h[5];\n    var dh = this.h[6];\n    var dl = this.h[7];\n    var eh = this.h[8];\n    var el = this.h[9];\n    var fh = this.h[10];\n    var fl = this.h[11];\n    var gh = this.h[12];\n    var gl = this.h[13];\n    var hh = this.h[14];\n    var hl = this.h[15];\n    minimalisticAssert(this.k.length === W.length);\n\n    for (var i = 0; i < W.length; i += 2) {\n      var c0_hi = hh;\n      var c0_lo = hl;\n      var c1_hi = s1_512_hi(eh, el);\n      var c1_lo = s1_512_lo(eh, el);\n      var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);\n      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);\n      var c3_hi = this.k[i];\n      var c3_lo = this.k[i + 1];\n      var c4_hi = W[i];\n      var c4_lo = W[i + 1];\n      var T1_hi = sum64_5_hi$1(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);\n      var T1_lo = sum64_5_lo$1(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);\n      c0_hi = s0_512_hi(ah, al);\n      c0_lo = s0_512_lo(ah, al);\n      c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);\n      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\n      var T2_hi = sum64_hi$1(c0_hi, c0_lo, c1_hi, c1_lo);\n      var T2_lo = sum64_lo$1(c0_hi, c0_lo, c1_hi, c1_lo);\n      hh = gh;\n      hl = gl;\n      gh = fh;\n      gl = fl;\n      fh = eh;\n      fl = el;\n      eh = sum64_hi$1(dh, dl, T1_hi, T1_lo);\n      el = sum64_lo$1(dl, dl, T1_hi, T1_lo);\n      dh = ch;\n      dl = cl;\n      ch = bh;\n      cl = bl;\n      bh = ah;\n      bl = al;\n      ah = sum64_hi$1(T1_hi, T1_lo, T2_hi, T2_lo);\n      al = sum64_lo$1(T1_hi, T1_lo, T2_hi, T2_lo);\n    }\n\n    sum64$1(this.h, 0, ah, al);\n    sum64$1(this.h, 2, bh, bl);\n    sum64$1(this.h, 4, ch, cl);\n    sum64$1(this.h, 6, dh, dl);\n    sum64$1(this.h, 8, eh, el);\n    sum64$1(this.h, 10, fh, fl);\n    sum64$1(this.h, 12, gh, gl);\n    sum64$1(this.h, 14, hh, hl);\n  };\n\n  SHA512.prototype._digest = function digest(enc) {\n    if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');\n  };\n\n  function ch64_hi(xh, xl, yh, yl, zh) {\n    var r = xh & yh ^ ~xh & zh;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function ch64_lo(xh, xl, yh, yl, zh, zl) {\n    var r = xl & yl ^ ~xl & zl;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function maj64_hi(xh, xl, yh, yl, zh) {\n    var r = xh & yh ^ xh & zh ^ yh & zh;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function maj64_lo(xh, xl, yh, yl, zh, zl) {\n    var r = xl & yl ^ xl & zl ^ yl & zl;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function s0_512_hi(xh, xl) {\n    var c0_hi = rotr64_hi$1(xh, xl, 28);\n    var c1_hi = rotr64_hi$1(xl, xh, 2); // 34\n\n    var c2_hi = rotr64_hi$1(xl, xh, 7); // 39\n\n    var r = c0_hi ^ c1_hi ^ c2_hi;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function s0_512_lo(xh, xl) {\n    var c0_lo = rotr64_lo$1(xh, xl, 28);\n    var c1_lo = rotr64_lo$1(xl, xh, 2); // 34\n\n    var c2_lo = rotr64_lo$1(xl, xh, 7); // 39\n\n    var r = c0_lo ^ c1_lo ^ c2_lo;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function s1_512_hi(xh, xl) {\n    var c0_hi = rotr64_hi$1(xh, xl, 14);\n    var c1_hi = rotr64_hi$1(xh, xl, 18);\n    var c2_hi = rotr64_hi$1(xl, xh, 9); // 41\n\n    var r = c0_hi ^ c1_hi ^ c2_hi;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function s1_512_lo(xh, xl) {\n    var c0_lo = rotr64_lo$1(xh, xl, 14);\n    var c1_lo = rotr64_lo$1(xh, xl, 18);\n    var c2_lo = rotr64_lo$1(xl, xh, 9); // 41\n\n    var r = c0_lo ^ c1_lo ^ c2_lo;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function g0_512_hi(xh, xl) {\n    var c0_hi = rotr64_hi$1(xh, xl, 1);\n    var c1_hi = rotr64_hi$1(xh, xl, 8);\n    var c2_hi = shr64_hi$1(xh, xl, 7);\n    var r = c0_hi ^ c1_hi ^ c2_hi;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function g0_512_lo(xh, xl) {\n    var c0_lo = rotr64_lo$1(xh, xl, 1);\n    var c1_lo = rotr64_lo$1(xh, xl, 8);\n    var c2_lo = shr64_lo$1(xh, xl, 7);\n    var r = c0_lo ^ c1_lo ^ c2_lo;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function g1_512_hi(xh, xl) {\n    var c0_hi = rotr64_hi$1(xh, xl, 19);\n    var c1_hi = rotr64_hi$1(xl, xh, 29); // 61\n\n    var c2_hi = shr64_hi$1(xh, xl, 6);\n    var r = c0_hi ^ c1_hi ^ c2_hi;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function g1_512_lo(xh, xl) {\n    var c0_lo = rotr64_lo$1(xh, xl, 19);\n    var c1_lo = rotr64_lo$1(xl, xh, 29); // 61\n\n    var c2_lo = shr64_lo$1(xh, xl, 6);\n    var r = c0_lo ^ c1_lo ^ c2_lo;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function SHA384() {\n    if (!(this instanceof SHA384)) return new SHA384();\n\n    _512.call(this);\n\n    this.h = [0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4];\n  }\n\n  utils.inherits(SHA384, _512);\n  var _384 = SHA384;\n  SHA384.blockSize = 1024;\n  SHA384.outSize = 384;\n  SHA384.hmacStrength = 192;\n  SHA384.padLength = 128;\n\n  SHA384.prototype._digest = function digest(enc) {\n    if (enc === 'hex') return utils.toHex32(this.h.slice(0, 12), 'big');else return utils.split32(this.h.slice(0, 12), 'big');\n  };\n\n  var sha1 = _1;\n  var sha224 = _224;\n  var sha256 = _256;\n  var sha384 = _384;\n  var sha512 = _512;\n  var sha = {\n    sha1: sha1,\n    sha224: sha224,\n    sha256: sha256,\n    sha384: sha384,\n    sha512: sha512\n  };\n  var rotl32$2 = utils.rotl32;\n  var sum32$3 = utils.sum32;\n  var sum32_3$1 = utils.sum32_3;\n  var sum32_4$2 = utils.sum32_4;\n  var BlockHash$4 = common.BlockHash;\n\n  function RIPEMD160() {\n    if (!(this instanceof RIPEMD160)) return new RIPEMD160();\n    BlockHash$4.call(this);\n    this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n    this.endian = 'little';\n  }\n\n  utils.inherits(RIPEMD160, BlockHash$4);\n  var ripemd160 = RIPEMD160;\n  RIPEMD160.blockSize = 512;\n  RIPEMD160.outSize = 160;\n  RIPEMD160.hmacStrength = 192;\n  RIPEMD160.padLength = 64;\n\n  RIPEMD160.prototype._update = function update(msg, start) {\n    var A = this.h[0];\n    var B = this.h[1];\n    var C = this.h[2];\n    var D = this.h[3];\n    var E = this.h[4];\n    var Ah = A;\n    var Bh = B;\n    var Ch = C;\n    var Dh = D;\n    var Eh = E;\n\n    for (var j = 0; j < 80; j++) {\n      var T = sum32$3(rotl32$2(sum32_4$2(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);\n      A = E;\n      E = D;\n      D = rotl32$2(C, 10);\n      C = B;\n      B = T;\n      T = sum32$3(rotl32$2(sum32_4$2(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);\n      Ah = Eh;\n      Eh = Dh;\n      Dh = rotl32$2(Ch, 10);\n      Ch = Bh;\n      Bh = T;\n    }\n\n    T = sum32_3$1(this.h[1], C, Dh);\n    this.h[1] = sum32_3$1(this.h[2], D, Eh);\n    this.h[2] = sum32_3$1(this.h[3], E, Ah);\n    this.h[3] = sum32_3$1(this.h[4], A, Bh);\n    this.h[4] = sum32_3$1(this.h[0], B, Ch);\n    this.h[0] = T;\n  };\n\n  RIPEMD160.prototype._digest = function digest(enc) {\n    if (enc === 'hex') return utils.toHex32(this.h, 'little');else return utils.split32(this.h, 'little');\n  };\n\n  function f(j, x, y, z) {\n    if (j <= 15) return x ^ y ^ z;else if (j <= 31) return x & y | ~x & z;else if (j <= 47) return (x | ~y) ^ z;else if (j <= 63) return x & z | y & ~z;else return x ^ (y | ~z);\n  }\n\n  function K(j) {\n    if (j <= 15) return 0x00000000;else if (j <= 31) return 0x5a827999;else if (j <= 47) return 0x6ed9eba1;else if (j <= 63) return 0x8f1bbcdc;else return 0xa953fd4e;\n  }\n\n  function Kh(j) {\n    if (j <= 15) return 0x50a28be6;else if (j <= 31) return 0x5c4dd124;else if (j <= 47) return 0x6d703ef3;else if (j <= 63) return 0x7a6d76e9;else return 0x00000000;\n  }\n\n  var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];\n  var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];\n  var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];\n  var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];\n  var ripemd = {\n    ripemd160: ripemd160\n  };\n\n  function Hmac(hash, key, enc) {\n    if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);\n    this.Hash = hash;\n    this.blockSize = hash.blockSize / 8;\n    this.outSize = hash.outSize / 8;\n    this.inner = null;\n    this.outer = null;\n\n    this._init(utils.toArray(key, enc));\n  }\n\n  var hmac = Hmac;\n\n  Hmac.prototype._init = function init(key) {\n    // Shorten key, if needed\n    if (key.length > this.blockSize) key = new this.Hash().update(key).digest();\n    minimalisticAssert(key.length <= this.blockSize); // Add padding to key\n\n    for (var i = key.length; i < this.blockSize; i++) key.push(0);\n\n    for (i = 0; i < key.length; i++) key[i] ^= 0x36;\n\n    this.inner = new this.Hash().update(key); // 0x36 ^ 0x5c = 0x6a\n\n    for (i = 0; i < key.length; i++) key[i] ^= 0x6a;\n\n    this.outer = new this.Hash().update(key);\n  };\n\n  Hmac.prototype.update = function update(msg, enc) {\n    this.inner.update(msg, enc);\n    return this;\n  };\n\n  Hmac.prototype.digest = function digest(enc) {\n    this.outer.update(this.inner.digest());\n    return this.outer.digest(enc);\n  };\n\n  var hash_1 = createCommonjsModule(function (module, exports) {\n    var hash = exports;\n    hash.utils = utils;\n    hash.common = common;\n    hash.sha = sha;\n    hash.ripemd = ripemd;\n    hash.hmac = hmac; // Proxy hash functions to the main object\n\n    hash.sha1 = hash.sha.sha1;\n    hash.sha256 = hash.sha.sha256;\n    hash.sha224 = hash.sha.sha224;\n    hash.sha384 = hash.sha.sha384;\n    hash.sha512 = hash.sha.sha512;\n    hash.ripemd160 = hash.ripemd.ripemd160;\n  }); //  Copyright (C) 2018 Zilliqa\n\n  /**\r\n   * Transaction\r\n   *\r\n   * Transaction is a functor. Its purpose is to encode the possible states a\r\n   * Transaction can be in:  Confirmed, Rejected, Pending, or Initialised (i.e., not broadcasted).\r\n   */\n\n  var Transaction =\n  /** @class */\n  function () {\n    function Transaction(params, provider, status, toDS, enableSecureToAddress) {\n      if (status === void 0) {\n        status = exports.TxStatus.Initialised;\n      }\n\n      if (toDS === void 0) {\n        toDS = false;\n      }\n\n      if (enableSecureToAddress === void 0) {\n        enableSecureToAddress = true;\n      }\n\n      this.code = '';\n      this.data = ''; // private members\n\n      this.version = params.version;\n      this.toAddr = enableSecureToAddress ? zcrypto.normaliseAddress(params.toAddr) : zcrypto.toChecksumAddress(params.toAddr);\n      this.nonce = params.nonce;\n      this.pubKey = params.pubKey;\n      this.amount = params.amount;\n      this.code = params.code || '';\n      this.data = params.data || '';\n      this.signature = params.signature;\n      this.gasPrice = params.gasPrice;\n      this.gasLimit = params.gasLimit;\n      this.receipt = params.receipt; // public members\n\n      this.provider = provider;\n      this.status = status;\n      this.toDS = toDS;\n      this.blockConfirmation = 0;\n      this.eventEmitter = new core.EventEmitter();\n    }\n    /**\r\n     * confirm\r\n     *\r\n     * constructs an already-confirmed transaction.\r\n     *\r\n     * @static\r\n     * @param {BaseTx} params\r\n     */\n\n\n    Transaction.confirm = function (params, provider) {\n      return new Transaction(params, provider, exports.TxStatus.Confirmed);\n    };\n    /**\r\n     * reject\r\n     *\r\n     * constructs an already-rejected transaction.\r\n     *\r\n     * @static\r\n     * @param {BaseTx} params\r\n     */\n\n\n    Transaction.reject = function (params, provider) {\n      return new Transaction(params, provider, exports.TxStatus.Rejected);\n    };\n\n    Object.defineProperty(Transaction.prototype, \"hash\", {\n      /**\r\n       * to get hash or transaction id of this transaction\r\n       * this can be identical returned by zilliqa network while calling CreateTransaction\r\n       */\n      get: function () {\n        var payload = this.bytes.toString('hex');\n        return hash_1.sha256().update(payload, 'hex').digest('hex');\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(Transaction.prototype, \"bytes\", {\n      get: function () {\n        return encodeTransactionProto(this.txParams);\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(Transaction.prototype, \"senderAddress\", {\n      get: function () {\n        if (!this.pubKey) {\n          return '0'.repeat(40);\n        }\n\n        return zcrypto.getAddressFromPublicKey(this.pubKey);\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(Transaction.prototype, \"txParams\", {\n      get: function () {\n        return {\n          version: this.version,\n          toAddr: zcrypto.normaliseAddress(this.toAddr),\n          nonce: this.nonce,\n          pubKey: this.pubKey,\n          amount: this.amount,\n          gasPrice: this.gasPrice,\n          gasLimit: this.gasLimit,\n          code: this.code,\n          data: this.data,\n          signature: this.signature,\n          receipt: this.receipt\n        };\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(Transaction.prototype, \"payload\", {\n      get: function () {\n        return {\n          version: this.version,\n          toAddr: this.toAddr,\n          nonce: this.nonce,\n          pubKey: this.pubKey,\n          amount: this.amount.toString(),\n          gasPrice: this.gasPrice.toString(),\n          gasLimit: this.gasLimit.toString(),\n          code: this.code,\n          data: this.data,\n          signature: this.signature,\n          receipt: this.receipt\n        };\n      },\n      enumerable: false,\n      configurable: true\n    });\n    /**\r\n     * isPending\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n    Transaction.prototype.isPending = function () {\n      return this.status === exports.TxStatus.Pending;\n    };\n    /**\r\n     * isInitialised\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n\n    Transaction.prototype.isInitialised = function () {\n      return this.status === exports.TxStatus.Initialised;\n    };\n\n    Transaction.prototype.getReceipt = function () {\n      return this.receipt;\n    };\n    /**\r\n     * isConfirmed\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n\n    Transaction.prototype.isConfirmed = function () {\n      return this.status === exports.TxStatus.Confirmed;\n    };\n    /**\r\n     * isRejected\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n\n    Transaction.prototype.isRejected = function () {\n      return this.status === exports.TxStatus.Rejected;\n    };\n    /**\r\n     * setProvider\r\n     *\r\n     * Sets the provider on this instance.\r\n     *\r\n     * @param {Provider} provider\r\n     */\n\n\n    Transaction.prototype.setProvider = function (provider) {\n      this.provider = provider;\n    };\n    /**\r\n     * setStatus\r\n     *\r\n     * Escape hatch to imperatively set the state of the transaction.\r\n     *\r\n     * @param {TxStatus} status\r\n     * @returns {undefined}\r\n     */\n\n\n    Transaction.prototype.setStatus = function (status) {\n      this.status = status;\n      return this;\n    };\n\n    Transaction.prototype.observed = function () {\n      return this.eventEmitter;\n    };\n    /**\r\n     * blockConfirm\r\n     *\r\n     * Use `RPCMethod.GetLatestBlock` to get latest blockNumber\r\n     * Use interval to get the latestBlockNumber\r\n     * After BlockNumber change, then we use `RPCMethod.GetTransaction` to get the receipt\r\n     *\r\n     * @param {string} txHash\r\n     * @param {number} maxblockCount\r\n     * @param {number} interval interval in milliseconds\r\n     * @returns {Promise<Transaction>}\r\n     */\n\n\n    Transaction.prototype.blockConfirm = function (txHash, maxblockCount, interval) {\n      if (maxblockCount === void 0) {\n        maxblockCount = 4;\n      }\n\n      if (interval === void 0) {\n        interval = 1000;\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var blockStart, blockChecked, attempt, blockLatest, blockNext, err_1, blockFailed, errorMessage;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              this.status = exports.TxStatus.Pending;\n              return [4\n              /*yield*/\n              , this.getBlockNumber()];\n\n            case 1:\n              blockStart = _a.sent();\n              blockChecked = blockStart;\n              attempt = 0;\n              _a.label = 2;\n\n            case 2:\n              if (!(attempt < maxblockCount)) return [3\n              /*break*/\n              , 12];\n              _a.label = 3;\n\n            case 3:\n              _a.trys.push([3, 8,, 9]);\n\n              return [4\n              /*yield*/\n              , this.getBlockNumber()];\n\n            case 4:\n              blockLatest = _a.sent();\n              blockNext = blockChecked.add(new util.BN(attempt === 0 ? attempt : 1));\n              if (!blockLatest.gte(blockNext)) return [3\n              /*break*/\n              , 6];\n              blockChecked = blockLatest;\n              this.emit(exports.TxEventName.Track, {\n                txHash: txHash,\n                attempt: attempt,\n                currentBlock: blockChecked.toString()\n              });\n              return [4\n              /*yield*/\n              , this.trackTx(txHash)];\n\n            case 5:\n              if (_a.sent()) {\n                this.blockConfirmation = blockLatest.sub(blockStart).toNumber();\n                return [2\n                /*return*/\n                , this];\n              }\n\n              return [3\n              /*break*/\n              , 7];\n\n            case 6:\n              attempt = attempt - 1 >= 0 ? attempt - 1 : 0;\n              _a.label = 7;\n\n            case 7:\n              return [3\n              /*break*/\n              , 9];\n\n            case 8:\n              err_1 = _a.sent();\n              this.status = exports.TxStatus.Rejected;\n              throw err_1;\n\n            case 9:\n              if (!(attempt + 1 < maxblockCount)) return [3\n              /*break*/\n              , 11];\n              return [4\n              /*yield*/\n              , sleep(interval)];\n\n            case 10:\n              _a.sent();\n\n              _a.label = 11;\n\n            case 11:\n              attempt += 1;\n              return [3\n              /*break*/\n              , 2];\n\n            case 12:\n              return [4\n              /*yield*/\n              , this.getBlockNumber()];\n\n            case 13:\n              blockFailed = _a.sent();\n              this.blockConfirmation = blockFailed.sub(blockStart).toNumber();\n              this.status = exports.TxStatus.Rejected;\n              errorMessage = \"The transaction is still not confirmed after \" + maxblockCount + \" blocks.\";\n              throw new Error(errorMessage);\n          }\n        });\n      });\n    };\n    /**\r\n     * confirmReceipt\r\n     *\r\n     * Similar to the Promise API. This sets the Transaction instance to a state\r\n     * of pending. Calling this function kicks off a passive loop that polls the\r\n     * lookup node for confirmation on the txHash.\r\n     *\r\n     * The polls are performed with a linear backoff:\r\n     *\r\n     * `const delay = interval * attempt`\r\n     *\r\n     * This is a low-level method that you should generally not have to use\r\n     * directly.\r\n     *\r\n     * @param {string} txHash\r\n     * @param {number} maxAttempts\r\n     * @param {number} initial interval in milliseconds\r\n     * @returns {Promise<Transaction>}\r\n     */\n\n\n    Transaction.prototype.confirm = function (txHash, maxAttempts, interval) {\n      if (maxAttempts === void 0) {\n        maxAttempts = core.GET_TX_ATTEMPTS;\n      }\n\n      if (interval === void 0) {\n        interval = 1000;\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var attempt, err_2, errorMessage;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              this.status = exports.TxStatus.Pending;\n              attempt = 0;\n              _a.label = 1;\n\n            case 1:\n              if (!(attempt < maxAttempts)) return [3\n              /*break*/\n              , 8];\n              this.emit(exports.TxEventName.Track, {\n                txHash: txHash,\n                attempt: attempt\n              });\n              _a.label = 2;\n\n            case 2:\n              _a.trys.push([2, 4,, 5]);\n\n              return [4\n              /*yield*/\n              , this.trackTx(txHash)];\n\n            case 3:\n              if (_a.sent()) {\n                return [2\n                /*return*/\n                , this];\n              }\n\n              return [3\n              /*break*/\n              , 5];\n\n            case 4:\n              err_2 = _a.sent();\n              this.status = exports.TxStatus.Rejected;\n              throw err_2;\n\n            case 5:\n              if (!(attempt + 1 < maxAttempts)) return [3\n              /*break*/\n              , 7];\n              return [4\n              /*yield*/\n              , sleep(interval * attempt)];\n\n            case 6:\n              _a.sent();\n\n              _a.label = 7;\n\n            case 7:\n              attempt++;\n              return [3\n              /*break*/\n              , 1];\n\n            case 8:\n              this.status = exports.TxStatus.Rejected;\n              errorMessage = \"The transaction is still not confirmed after \" + maxAttempts + \" attempts.\";\n              throw new Error(errorMessage);\n          }\n        });\n      });\n    };\n    /**\r\n     * map\r\n     *\r\n     * maps over the transaction, allowing for manipulation.\r\n     *\r\n     * @param {(prev: TxParams) => TxParams} fn - mapper\r\n     * @returns {Transaction}\r\n     */\n\n\n    Transaction.prototype.map = function (fn) {\n      var newParams = fn(this.txParams);\n      this.setParams(newParams);\n      return this;\n    };\n\n    Transaction.prototype.setParams = function (params) {\n      this.version = params.version;\n      this.toAddr = zcrypto.normaliseAddress(params.toAddr);\n      this.nonce = params.nonce;\n      this.pubKey = params.pubKey;\n      this.amount = params.amount;\n      this.code = params.code || '';\n      this.data = params.data || '';\n      this.signature = params.signature;\n      this.gasPrice = params.gasPrice;\n      this.gasLimit = params.gasLimit;\n      this.receipt = params.receipt;\n    };\n\n    Transaction.prototype.trackTx = function (txHash) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var res;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.GetTransaction, txHash)];\n\n            case 1:\n              res = _a.sent();\n\n              if (res.error) {\n                this.emit(exports.TxEventName.Error, res.error);\n                return [2\n                /*return*/\n                , false];\n              }\n\n              this.id = res.result.ID;\n              this.receipt = tslib.__assign(tslib.__assign({}, res.result.receipt), {\n                cumulative_gas: parseInt(res.result.receipt.cumulative_gas, 10)\n              });\n              this.emit(exports.TxEventName.Receipt, this.receipt);\n              this.status = this.receipt && this.receipt.success ? exports.TxStatus.Confirmed : exports.TxStatus.Rejected;\n              return [2\n              /*return*/\n              , true];\n          }\n        });\n      });\n    };\n\n    Transaction.prototype.getBlockNumber = function () {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var res, error_1;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.GetLatestTxBlock)];\n\n            case 1:\n              res = _a.sent();\n\n              if (res.error === undefined && res.result.header.BlockNum) {\n                // if blockNumber is too high, we use BN to be safer\n                return [2\n                /*return*/\n                , new util.BN(res.result.header.BlockNum)];\n              } else {\n                throw new Error('Can not get latest BlockNumber');\n              }\n\n              return [3\n              /*break*/\n              , 3];\n\n            case 2:\n              error_1 = _a.sent();\n              throw error_1;\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    Transaction.prototype.emit = function (event, txEvent) {\n      this.eventEmitter.emit(event, tslib.__assign(tslib.__assign({}, txEvent), {\n        event: event\n      }));\n    };\n\n    return Transaction;\n  }(); //  Copyright (C) 2018 Zilliqa\n\n\n  var TransactionFactory =\n  /** @class */\n  function () {\n    function TransactionFactory(provider, signer) {\n      this.provider = provider;\n      this.provider.middleware.request.use(formatOutgoingTx, core.RPCMethod.CreateTransaction);\n      this.signer = signer;\n    }\n\n    TransactionFactory.prototype.new = function (txParams, toDs, enableSecureAddress) {\n      if (toDs === void 0) {\n        toDs = false;\n      }\n\n      if (enableSecureAddress === void 0) {\n        enableSecureAddress = true;\n      }\n\n      return new Transaction(txParams, this.provider, exports.TxStatus.Initialised, toDs, enableSecureAddress);\n    };\n    /**\r\n     * This constructor could help you to check if there is a default account to be used, and further more, if it has\r\n     * sufficient fund to do the transfer.\r\n     * @param txParams\r\n     */\n\n\n    TransactionFactory.prototype.payment = function (txParams) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var defaultAccount, addr, response, fund;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              defaultAccount = this.signer.defaultAccount;\n              if (!(defaultAccount !== undefined)) return [3\n              /*break*/\n              , 2];\n              addr = defaultAccount.address;\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.GetBalance, addr.replace('0x', '').toLowerCase())];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error) {\n                throw response.error;\n              }\n\n              fund = new util.BN(response.result.balance);\n\n              if (txParams.amount.cmp(fund) === 1) {\n                throw new Error('No sufficient fund');\n              }\n\n              return [3\n              /*break*/\n              , 3];\n\n            case 2:\n              throw new Error('No default wallet');\n\n            case 3:\n              return [2\n              /*return*/\n              , this.new(txParams, true)];\n          }\n        });\n      });\n    };\n\n    return TransactionFactory;\n  }(); //  Copyright (C) 2018 Zilliqa\n\n\n  exports.util = util$1;\n  exports.Account = Account;\n  exports.Wallet = Wallet;\n  exports.Transaction = Transaction;\n  exports.TransactionFactory = TransactionFactory;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n}); //# sourceMappingURL=index.umd.js.map","map":null,"metadata":{},"sourceType":"script"}