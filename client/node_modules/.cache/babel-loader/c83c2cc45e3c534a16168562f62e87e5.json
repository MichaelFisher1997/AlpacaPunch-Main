{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@zilliqa-js/account'), require('@zilliqa-js/core'), require('@zilliqa-js/crypto'), require('@zilliqa-js/util'), require('@zilliqa-js/blockchain'), require('hash.js')) : typeof define === 'function' && define.amd ? define(['exports', 'tslib', '@zilliqa-js/account', '@zilliqa-js/core', '@zilliqa-js/crypto', '@zilliqa-js/util', '@zilliqa-js/blockchain', 'hash.js'], factory) : factory(global.zjsContract = {}, global.tslib, global['@zilliqa-js/account'], global['@zilliqa-js/core'], global['@zilliqa-js/crypto'], global['@zilliqa-js/util'], global['@zilliqa-js/blockchain'], global.hash.js);\n})(this, function (exports, tslib, account, core, crypto, util, blockchain, hash) {\n  'use strict';\n\n  hash = hash && hash.hasOwnProperty('default') ? hash['default'] : hash; //  Copyright (C) 2018 Zilliqa\n\n  (function (ContractStatus) {\n    ContractStatus[ContractStatus[\"Deployed\"] = 0] = \"Deployed\";\n    ContractStatus[ContractStatus[\"Rejected\"] = 1] = \"Rejected\";\n    ContractStatus[ContractStatus[\"Initialised\"] = 2] = \"Initialised\";\n  })(exports.ContractStatus || (exports.ContractStatus = {})); //  Copyright (C) 2018 Zilliqa\n\n\n  var NIL_ADDRESS = '0x0000000000000000000000000000000000000000';\n\n  var Contract =\n  /** @class */\n  function () {\n    function Contract(factory, code, abi, address, init, state, checkAddr) {\n      if (checkAddr === void 0) {\n        checkAddr = false;\n      }\n\n      this.factory = factory;\n      this.provider = factory.provider;\n      this.signer = factory.signer;\n      this.blockchain = new blockchain.Blockchain(factory.provider, factory.signer); // assume that we are accessing an existing contract\n\n      if (address) {\n        this.abi = abi;\n\n        if (checkAddr) {\n          this.address = crypto.normaliseAddress(address);\n        } else {\n          if (util.validation.isBech32(address)) {\n            this.address = crypto.fromBech32Address(address);\n          } else if (crypto.isValidChecksumAddress(address)) {\n            this.address = address;\n          } else {\n            this.address = crypto.toChecksumAddress(address);\n          }\n        }\n\n        this.init = init;\n        this.state = state;\n        this.status = exports.ContractStatus.Deployed;\n      } else {\n        // assume we're deploying\n        this.abi = abi;\n        this.code = code;\n        this.init = init;\n        this.status = exports.ContractStatus.Initialised;\n      }\n    }\n    /**\r\n     * isInitialised\r\n     *\r\n     * Returns true if the contract has not been deployed\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n\n    Contract.prototype.isInitialised = function () {\n      return this.status === exports.ContractStatus.Initialised;\n    };\n    /**\r\n     * isDeployed\r\n     *\r\n     * Returns true if the contract is deployed\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n\n    Contract.prototype.isDeployed = function () {\n      return this.status === exports.ContractStatus.Deployed;\n    };\n    /**\r\n     * isRejected\r\n     *\r\n     * Returns true if an attempt to deploy the contract was made, but the\r\n     * underlying transaction was unsuccessful.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n\n    Contract.prototype.isRejected = function () {\n      return this.status === exports.ContractStatus.Rejected;\n    };\n\n    Contract.prototype.prepareTx = function (tx, attempts, interval, isDeploy) {\n      if (attempts === void 0) {\n        attempts = core.GET_TX_ATTEMPTS;\n      }\n\n      if (interval === void 0) {\n        interval = 1000;\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.CreateTransaction, tslib.__assign(tslib.__assign({}, tx.txParams), {\n                priority: tx.toDS\n              }))];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error) {\n                this.address = undefined;\n                this.error = response.error;\n                return [2\n                /*return*/\n                , tx.setStatus(account.TxStatus.Rejected)];\n              }\n\n              if (isDeploy) {\n                this.address = response.result.ContractAddress ? crypto.toChecksumAddress(response.result.ContractAddress) : undefined;\n              }\n\n              return [2\n              /*return*/\n              , tx.confirm(response.result.TranID, attempts, interval)];\n          }\n        });\n      });\n    };\n\n    Contract.prototype.prepare = function (tx) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.CreateTransaction, tslib.__assign(tslib.__assign({}, tx.txParams), {\n                priority: tx.toDS\n              }))];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error || !response.result) {\n                this.address = undefined;\n                this.error = response.error;\n                tx.setStatus(account.TxStatus.Rejected);\n              } else {\n                tx.id = response.result.TranID;\n                tx.setStatus(account.TxStatus.Pending);\n                return [2\n                /*return*/\n                , response.result.ContractAddress];\n              }\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\r\n     * deploy smart contract with no confirm\r\n     * @param params\r\n     * @param toDs\r\n     */\n\n\n    Contract.prototype.deployWithoutConfirm = function (params, toDs) {\n      if (toDs === void 0) {\n        toDs = false;\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var tx, _a, err_1;\n\n        return tslib.__generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              if (!this.code || !this.init) {\n                throw new Error('Cannot deploy without code or initialisation parameters.');\n              }\n\n              tx = new account.Transaction(tslib.__assign(tslib.__assign({}, params), {\n                toAddr: NIL_ADDRESS,\n                amount: new util.BN(0),\n                code: this.code,\n                data: JSON.stringify(this.init).replace(/\\\\\"/g, '\"')\n              }), this.provider, account.TxStatus.Initialised, toDs);\n              _b.label = 1;\n\n            case 1:\n              _b.trys.push([1, 3,, 4]);\n\n              _a = this;\n              return [4\n              /*yield*/\n              , this.prepare(tx)];\n\n            case 2:\n              _a.address = _b.sent();\n              this.status = this.address === undefined ? exports.ContractStatus.Rejected : exports.ContractStatus.Initialised;\n              return [2\n              /*return*/\n              , [tx, this]];\n\n            case 3:\n              err_1 = _b.sent();\n              throw err_1;\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\r\n     * deploy\r\n     *\r\n     * @param {DeployParams} params\r\n     * @returns {Promise<Contract>}\r\n     */\n\n\n    Contract.prototype.deploy = function (params, attempts, interval, toDs) {\n      if (attempts === void 0) {\n        attempts = 33;\n      }\n\n      if (interval === void 0) {\n        interval = 1000;\n      }\n\n      if (toDs === void 0) {\n        toDs = false;\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var tx, err_2;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!this.code || !this.init) {\n                throw new Error('Cannot deploy without code or initialisation parameters.');\n              }\n\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 3,, 4]);\n\n              return [4\n              /*yield*/\n              , this.prepareTx(new account.Transaction(tslib.__assign(tslib.__assign({}, params), {\n                toAddr: NIL_ADDRESS,\n                amount: new util.BN(0),\n                code: this.code,\n                data: JSON.stringify(this.init).replace(/\\\\\"/g, '\"')\n              }), this.provider, account.TxStatus.Initialised, toDs), attempts, interval, true)];\n\n            case 2:\n              tx = _a.sent();\n\n              if (tx.isRejected()) {\n                this.status = exports.ContractStatus.Rejected;\n                this.address = undefined;\n                return [2\n                /*return*/\n                , [tx, this]];\n              }\n\n              this.status = exports.ContractStatus.Deployed;\n              this.address = this.address && crypto.isValidChecksumAddress(this.address) ? this.address : Contracts.getAddressForContract(tx);\n              return [2\n              /*return*/\n              , [tx, this]];\n\n            case 3:\n              err_2 = _a.sent();\n              throw err_2;\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    Contract.prototype.callWithoutConfirm = function (transition, args, params, toDs) {\n      if (toDs === void 0) {\n        toDs = false;\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var data, tx, err_3;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              data = {\n                _tag: transition,\n                params: args\n              };\n\n              if (this.error) {\n                return [2\n                /*return*/\n                , Promise.reject(this.error)];\n              }\n\n              if (!this.address) {\n                return [2\n                /*return*/\n                , Promise.reject('Contract has not been deployed!')];\n              }\n\n              tx = new account.Transaction(tslib.__assign(tslib.__assign({}, params), {\n                toAddr: this.address,\n                data: JSON.stringify(data)\n              }), this.provider, account.TxStatus.Initialised, toDs);\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 3,, 4]);\n\n              return [4\n              /*yield*/\n              , this.prepare(tx)];\n\n            case 2:\n              _a.sent();\n\n              return [2\n              /*return*/\n              , tx];\n\n            case 3:\n              err_3 = _a.sent();\n              throw err_3;\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\r\n     * call\r\n     *\r\n     * @param {string} transition\r\n     * @param {any} params\r\n     * @returns {Promise<Transaction>}\r\n     */\n\n\n    Contract.prototype.call = function (transition, args, params, attempts, interval, toDs) {\n      if (attempts === void 0) {\n        attempts = 33;\n      }\n\n      if (interval === void 0) {\n        interval = 1000;\n      }\n\n      if (toDs === void 0) {\n        toDs = false;\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var data, err_4;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              data = {\n                _tag: transition,\n                params: args\n              };\n\n              if (this.error) {\n                return [2\n                /*return*/\n                , Promise.reject(this.error)];\n              }\n\n              if (!this.address) {\n                return [2\n                /*return*/\n                , Promise.reject('Contract has not been deployed!')];\n              }\n\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 3,, 4]);\n\n              return [4\n              /*yield*/\n              , this.prepareTx(new account.Transaction(tslib.__assign(tslib.__assign({}, params), {\n                toAddr: this.address,\n                data: JSON.stringify(data)\n              }), this.provider, account.TxStatus.Initialised, toDs), attempts, interval, false)];\n\n            case 2:\n              return [2\n              /*return*/\n              , _a.sent()];\n\n            case 3:\n              err_4 = _a.sent();\n              throw err_4;\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    Contract.prototype.getState = function () {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (this.status !== exports.ContractStatus.Deployed) {\n                return [2\n                /*return*/\n                , Promise.resolve([])];\n              }\n\n              if (!this.address) {\n                throw new Error('Cannot get state of uninitialised contract');\n              }\n\n              return [4\n              /*yield*/\n              , this.blockchain.getSmartContractState(this.address)];\n\n            case 1:\n              response = _a.sent();\n              return [2\n              /*return*/\n              , response.result];\n          }\n        });\n      });\n    };\n\n    Contract.prototype.getSubState = function (variableName, indices) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (this.status !== exports.ContractStatus.Deployed) {\n                return [2\n                /*return*/\n                , Promise.resolve([])];\n              }\n\n              if (!this.address) {\n                throw new Error('Cannot get state of uninitialised contract');\n              }\n\n              if (!variableName) {\n                throw new Error('Variable name required');\n              }\n\n              return [4\n              /*yield*/\n              , this.blockchain.getSmartContractSubState(this.address, variableName, indices)];\n\n            case 1:\n              response = _a.sent();\n              return [2\n              /*return*/\n              , response.result];\n          }\n        });\n      });\n    };\n\n    Contract.prototype.getInit = function () {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (this.status !== exports.ContractStatus.Deployed) {\n                return [2\n                /*return*/\n                , Promise.resolve([])];\n              }\n\n              if (!this.address) {\n                throw new Error('Cannot get state of uninitialised contract');\n              }\n\n              return [4\n              /*yield*/\n              , this.blockchain.getSmartContractInit(this.address)];\n\n            case 1:\n              response = _a.sent();\n              return [2\n              /*return*/\n              , response.result];\n          }\n        });\n      });\n    };\n\n    tslib.__decorate([core.sign, tslib.__metadata(\"design:type\", Function), tslib.__metadata(\"design:paramtypes\", [account.Transaction, Number, Number, Boolean]), tslib.__metadata(\"design:returntype\", Promise)], Contract.prototype, \"prepareTx\", null);\n\n    tslib.__decorate([core.sign, tslib.__metadata(\"design:type\", Function), tslib.__metadata(\"design:paramtypes\", [account.Transaction]), tslib.__metadata(\"design:returntype\", Promise)], Contract.prototype, \"prepare\", null);\n\n    return Contract;\n  }(); //  Copyright (C) 2018 Zilliqa\n\n  /**\r\n   * Contracts\r\n   *\r\n   * Unlike most zilliqa-js modules, `Contracts` is a factory class.\r\n   * As a result, individual `Contract` instances are instead obtained by\r\n   * calling `Contracts.at` (for an already-deployed contract) and\r\n   * `Contracts.new` (to deploy a new contract).\r\n   */\n\n\n  var Contracts =\n  /** @class */\n  function () {\n    function Contracts(provider, signer) {\n      this.provider = provider;\n      this.provider.middleware.request.use(account.util.formatOutgoingTx, core.RPCMethod.CreateTransaction);\n      this.signer = signer;\n    }\n    /**\r\n     * getAddressForContract\r\n     *\r\n     * @static\r\n     * @param {Transaction} tx - transaction used to create the contract\r\n     * @returns {string} - the contract address\r\n     */\n\n\n    Contracts.getAddressForContract = function (tx) {\n      // always subtract 1 from the tx nonce, as contract addresses are computed\n      // based on the nonce in the global state.\n      var nonce = tx.txParams.nonce ? tx.txParams.nonce - 1 : 0;\n      return crypto.toChecksumAddress(hash.sha256().update(tx.senderAddress.replace('0x', '').toLowerCase(), 'hex').update(util.bytes.intToHexArray(nonce, 16).join(''), 'hex').digest('hex').slice(24));\n    };\n\n    Contracts.prototype.at = function (address, abi, code, init, state) {\n      return new Contract(this, code, abi, address, init, state);\n    };\n\n    Contracts.prototype.atBech32 = function (address, abi, code, init, state) {\n      return new Contract(this, code, abi, address, init, state, true);\n    };\n\n    Contracts.prototype.new = function (code, init, abi) {\n      return new Contract(this, code, abi, undefined, init);\n    };\n\n    return Contracts;\n  }(); //  Copyright (C) 2018 Zilliqa\n\n\n  exports.Contracts = Contracts;\n  exports.Contract = Contract;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"mappings":"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","names":["ContractStatus","NIL_ADDRESS","factory","code","abi","address","init","state","checkAddr","provider","signer","blockchain","Blockchain","normaliseAddress","validation","isBech32","fromBech32Address","isValidChecksumAddress","toChecksumAddress","status","Deployed","Initialised","Contract","Rejected","tx","attempts","interval","isDeploy","send","RPCMethod","CreateTransaction","tslib","txParams","priority","toDS","response","_a","error","undefined","setStatus","TxStatus","result","ContractAddress","confirm","TranID","id","Pending","params","toDs","Error","Transaction","toAddr","amount","BN","data","JSON","stringify","replace","prepare","_b","err_1","prepareTx","isRejected","Contracts","getAddressForContract","err_2","transition","args","_tag","Promise","reject","err_3","err_4","resolve","getSmartContractState","variableName","indices","getSmartContractSubState","getSmartContractInit","__decorate","sign","Number","middleware","request","use","util","formatOutgoingTx","nonce","hash","sha256","update","senderAddress","toLowerCase","bytes","intToHexArray","join","digest","slice"],"sources":["/home/micqdf/Documents/this/test1/client/node_modules/@zilliqa-js/contract/src/types.ts","/home/micqdf/Documents/this/test1/client/node_modules/@zilliqa-js/contract/src/contract.ts","/home/micqdf/Documents/this/test1/client/node_modules/@zilliqa-js/contract/src/factory.ts","/home/micqdf/Documents/this/test1/client/node_modules/@zilliqa-js/contract/src/index.ts"],"sourcesContent":["//  Copyright (C) 2018 Zilliqa\n//\n//  This file is part of zilliqa-js\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  This program is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport { Omit } from 'utility-types';\nimport { TxParams } from '@zilliqa-js/account';\n\nexport enum ContractStatus {\n  Deployed,\n  Rejected,\n  Initialised,\n}\n\nexport type DeployParams = Omit<\n  TxParams,\n  'toAddr' | 'amount' | 'code' | 'data' | 'receipt' | 'signature'\n>;\n\nexport type CallParams = Omit<\n  TxParams,\n  'toAddr' | 'data' | 'code' | 'receipt' | 'signature'\n>;\n\nexport interface ContractObj {\n  address: string;\n  abi: ABI;\n  init: any;\n  state: any;\n}\n\nexport interface Transition {\n  vname: string;\n  params: Field[];\n}\n\n/**\n * Interface for ABI returned by scilla-checker\n */\nexport interface ABI {\n  scilla_major_version: number;\n  vname: string;\n  fields: Field[];\n  params: Field[];\n  transitions: Transition[];\n}\n\nexport interface Field {\n  vname: string;\n  type: string;\n  depth?: number;\n}\n\nexport interface Value {\n  vname: string;\n  type: string;\n  value: string | ADTValue;\n}\n\ninterface ADTValue {\n  constructor: string;\n  argtypes: string[];\n  arguments: Value[];\n}\n\nexport type Param = Value;\nexport type TransitionParam = Value;\n\nexport type Init = Value[];\n\n// Post v5.0.0 upgrade\nexport type State = any;\n\nexport interface TransitionPayload {\n  // the name of the transtion to be called\n  _tag: string;\n  // amount to send to the contract, if any\n  _amount: string;\n  params: Value[];\n}\n\n// RPC Error Responses\nexport type DeployError =\n  | 'Code is empty and To addr is null'\n  | 'To Addr is null'\n  | 'Non - contract address called'\n  | 'Could not create Transaction'\n  | 'Unable to process';\n\nexport interface DeploySuccess {\n  TranID: string;\n  Info: string;\n  ContractAddress?: string;\n}\n","//  Copyright (C) 2018 Zilliqa\n//\n//  This file is part of zilliqa-js\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  This program is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport { Transaction, TxStatus, Wallet } from '@zilliqa-js/account';\nimport { GET_TX_ATTEMPTS, Provider, RPCMethod, sign } from '@zilliqa-js/core';\nimport {\n  fromBech32Address,\n  isValidChecksumAddress,\n  normaliseAddress,\n  toChecksumAddress,\n} from '@zilliqa-js/crypto';\nimport { BN, validation } from '@zilliqa-js/util';\nimport { Blockchain } from '@zilliqa-js/blockchain';\n\nimport { Contracts } from './factory';\nimport {\n  ABI,\n  CallParams,\n  ContractStatus,\n  DeployError,\n  DeployParams,\n  DeploySuccess,\n  Init,\n  State,\n  Value,\n} from './types';\n\nconst NIL_ADDRESS = '0x0000000000000000000000000000000000000000';\n\nexport class Contract {\n  factory: Contracts;\n  provider: Provider;\n  signer: Wallet;\n  blockchain: Blockchain;\n\n  init: Init;\n  abi?: ABI;\n  state?: State;\n  address?: string;\n  code?: string;\n  status: ContractStatus;\n  error?: any;\n\n  constructor(\n    factory: Contracts,\n    code?: string,\n    abi?: ABI,\n    address?: string,\n    init?: any,\n    state?: any,\n    checkAddr: boolean = false,\n  ) {\n    this.factory = factory;\n    this.provider = factory.provider;\n    this.signer = factory.signer;\n    this.blockchain = new Blockchain(factory.provider, factory.signer);\n\n    // assume that we are accessing an existing contract\n    if (address) {\n      this.abi = abi;\n      if (checkAddr) {\n        this.address = normaliseAddress(address);\n      } else {\n        if (validation.isBech32(address)) {\n          this.address = fromBech32Address(address);\n        } else if (isValidChecksumAddress(address)) {\n          this.address = address;\n        } else {\n          this.address = toChecksumAddress(address);\n        }\n      }\n      this.init = init;\n      this.state = state;\n      this.status = ContractStatus.Deployed;\n    } else {\n      // assume we're deploying\n      this.abi = abi;\n      this.code = code;\n      this.init = init;\n      this.status = ContractStatus.Initialised;\n    }\n  }\n\n  /**\n   * isInitialised\n   *\n   * Returns true if the contract has not been deployed\n   *\n   * @returns {boolean}\n   */\n  isInitialised(): boolean {\n    return this.status === ContractStatus.Initialised;\n  }\n\n  /**\n   * isDeployed\n   *\n   * Returns true if the contract is deployed\n   *\n   * @returns {boolean}\n   */\n  isDeployed(): boolean {\n    return this.status === ContractStatus.Deployed;\n  }\n\n  /**\n   * isRejected\n   *\n   * Returns true if an attempt to deploy the contract was made, but the\n   * underlying transaction was unsuccessful.\n   *\n   * @returns {boolean}\n   */\n  isRejected(): boolean {\n    return this.status === ContractStatus.Rejected;\n  }\n\n  @sign\n  async prepareTx(\n    tx: Transaction,\n    attempts: number = GET_TX_ATTEMPTS,\n    interval: number = 1000,\n    isDeploy: boolean,\n  ): Promise<Transaction> {\n    const response = await this.provider.send<DeploySuccess, DeployError>(\n      RPCMethod.CreateTransaction,\n      { ...tx.txParams, priority: tx.toDS },\n    );\n\n    if (response.error) {\n      this.address = undefined;\n      this.error = response.error;\n      return tx.setStatus(TxStatus.Rejected);\n    }\n\n    if (isDeploy) {\n      this.address = response.result.ContractAddress\n        ? toChecksumAddress(response.result.ContractAddress)\n        : undefined;\n    }\n\n    return tx.confirm(response.result.TranID, attempts, interval);\n  }\n\n  @sign\n  async prepare(tx: Transaction): Promise<string | undefined> {\n    const response = await this.provider.send<DeploySuccess, DeployError>(\n      RPCMethod.CreateTransaction,\n      { ...tx.txParams, priority: tx.toDS },\n    );\n\n    if (response.error || !response.result) {\n      this.address = undefined;\n      this.error = response.error;\n      tx.setStatus(TxStatus.Rejected);\n    } else {\n      tx.id = response.result.TranID;\n      tx.setStatus(TxStatus.Pending);\n      return response.result.ContractAddress;\n    }\n  }\n\n  /**\n   * deploy smart contract with no confirm\n   * @param params\n   * @param toDs\n   */\n  async deployWithoutConfirm(\n    params: DeployParams,\n    toDs: boolean = false,\n  ): Promise<[Transaction, Contract]> {\n    if (!this.code || !this.init) {\n      throw new Error(\n        'Cannot deploy without code or initialisation parameters.',\n      );\n    }\n    const tx = new Transaction(\n      {\n        ...params,\n        toAddr: NIL_ADDRESS,\n        amount: new BN(0),\n        code: this.code,\n        data: JSON.stringify(this.init).replace(/\\\\\"/g, '\"'),\n      },\n      this.provider,\n      TxStatus.Initialised,\n      toDs,\n    );\n\n    try {\n      this.address = await this.prepare(tx);\n      this.status =\n        this.address === undefined\n          ? ContractStatus.Rejected\n          : ContractStatus.Initialised;\n      return [tx, this];\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  /**\n   * deploy\n   *\n   * @param {DeployParams} params\n   * @returns {Promise<Contract>}\n   */\n  async deploy(\n    params: DeployParams,\n    attempts: number = 33,\n    interval: number = 1000,\n    toDs: boolean = false,\n  ): Promise<[Transaction, Contract]> {\n    if (!this.code || !this.init) {\n      throw new Error(\n        'Cannot deploy without code or initialisation parameters.',\n      );\n    }\n\n    try {\n      const tx = await this.prepareTx(\n        new Transaction(\n          {\n            ...params,\n            toAddr: NIL_ADDRESS,\n            amount: new BN(0),\n            code: this.code,\n            data: JSON.stringify(this.init).replace(/\\\\\"/g, '\"'),\n          },\n          this.provider,\n          TxStatus.Initialised,\n          toDs,\n        ),\n        attempts,\n        interval,\n        true,\n      );\n\n      if (tx.isRejected()) {\n        this.status = ContractStatus.Rejected;\n        this.address = undefined;\n        return [tx, this];\n      }\n\n      this.status = ContractStatus.Deployed;\n      this.address =\n        this.address && isValidChecksumAddress(this.address)\n          ? this.address\n          : Contracts.getAddressForContract(tx);\n\n      return [tx, this];\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  async callWithoutConfirm(\n    transition: string,\n    args: Value[],\n    params: CallParams,\n    toDs: boolean = false,\n  ): Promise<Transaction> {\n    const data = {\n      _tag: transition,\n      params: args,\n    };\n\n    if (this.error) {\n      return Promise.reject(this.error);\n    }\n\n    if (!this.address) {\n      return Promise.reject('Contract has not been deployed!');\n    }\n\n    const tx = new Transaction(\n      {\n        ...params,\n        toAddr: this.address,\n        data: JSON.stringify(data),\n      },\n      this.provider,\n      TxStatus.Initialised,\n      toDs,\n    );\n\n    try {\n      await this.prepare(tx);\n      return tx;\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  /**\n   * call\n   *\n   * @param {string} transition\n   * @param {any} params\n   * @returns {Promise<Transaction>}\n   */\n  async call(\n    transition: string,\n    args: Value[],\n    params: CallParams,\n    attempts: number = 33,\n    interval: number = 1000,\n    toDs: boolean = false,\n  ): Promise<Transaction> {\n    const data = {\n      _tag: transition,\n      params: args,\n    };\n\n    if (this.error) {\n      return Promise.reject(this.error);\n    }\n\n    if (!this.address) {\n      return Promise.reject('Contract has not been deployed!');\n    }\n\n    try {\n      return await this.prepareTx(\n        new Transaction(\n          {\n            ...params,\n            toAddr: this.address,\n            data: JSON.stringify(data),\n          },\n          this.provider,\n          TxStatus.Initialised,\n          toDs,\n        ),\n        attempts,\n        interval,\n        false,\n      );\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  async getState(): Promise<State> {\n    if (this.status !== ContractStatus.Deployed) {\n      return Promise.resolve([]);\n    }\n\n    if (!this.address) {\n      throw new Error('Cannot get state of uninitialised contract');\n    }\n\n    const response = await this.blockchain.getSmartContractState(this.address);\n\n    return response.result;\n  }\n\n  async getSubState(variableName: string, indices?: string[]): Promise<State> {\n    if (this.status !== ContractStatus.Deployed) {\n      return Promise.resolve([]);\n    }\n\n    if (!this.address) {\n      throw new Error('Cannot get state of uninitialised contract');\n    }\n\n    if (!variableName) {\n      throw new Error('Variable name required');\n    }\n\n    const response = await this.blockchain.getSmartContractSubState(\n      this.address,\n      variableName,\n      indices,\n    );\n\n    return response.result;\n  }\n\n  async getInit(): Promise<State> {\n    if (this.status !== ContractStatus.Deployed) {\n      return Promise.resolve([]);\n    }\n\n    if (!this.address) {\n      throw new Error('Cannot get state of uninitialised contract');\n    }\n\n    const response = await this.blockchain.getSmartContractInit(this.address);\n\n    return response.result;\n  }\n}\n","//  Copyright (C) 2018 Zilliqa\n//\n//  This file is part of zilliqa-js\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  This program is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport hash from 'hash.js';\n\nimport { Wallet, Transaction, util } from '@zilliqa-js/account';\nimport { toChecksumAddress } from '@zilliqa-js/crypto';\nimport { Provider, RPCMethod, ZilliqaModule } from '@zilliqa-js/core';\nimport { bytes } from '@zilliqa-js/util';\n\nimport { Contract } from './contract';\nimport { ABI, Init, State } from './types';\n\n/**\n * Contracts\n *\n * Unlike most zilliqa-js modules, `Contracts` is a factory class.\n * As a result, individual `Contract` instances are instead obtained by\n * calling `Contracts.at` (for an already-deployed contract) and\n * `Contracts.new` (to deploy a new contract).\n */\nexport class Contracts implements ZilliqaModule {\n  /**\n   * getAddressForContract\n   *\n   * @static\n   * @param {Transaction} tx - transaction used to create the contract\n   * @returns {string} - the contract address\n   */\n  static getAddressForContract(tx: Transaction): string {\n    // always subtract 1 from the tx nonce, as contract addresses are computed\n    // based on the nonce in the global state.\n    const nonce = tx.txParams.nonce ? tx.txParams.nonce - 1 : 0;\n\n    return toChecksumAddress(\n      hash\n        .sha256()\n        .update(tx.senderAddress.replace('0x', '').toLowerCase(), 'hex')\n        .update(bytes.intToHexArray(nonce, 16).join(''), 'hex')\n        .digest('hex')\n        .slice(24),\n    );\n  }\n\n  provider: Provider;\n  signer: Wallet;\n\n  constructor(provider: Provider, signer: Wallet) {\n    this.provider = provider;\n    this.provider.middleware.request.use(\n      util.formatOutgoingTx,\n      RPCMethod.CreateTransaction,\n    );\n    this.signer = signer;\n  }\n\n  at(\n    address: string,\n    abi?: ABI,\n    code?: string,\n    init?: Init,\n    state?: State,\n  ): Contract {\n    return new Contract(this, code, abi, address, init, state);\n  }\n\n  atBech32(\n    address: string,\n    abi?: ABI,\n    code?: string,\n    init?: Init,\n    state?: State,\n  ): Contract {\n    return new Contract(this, code, abi, address, init, state, true);\n  }\n\n  new(code: string, init: Init, abi?: ABI): Contract {\n    return new Contract(this, code, abi, undefined, init);\n  }\n}\n","//  Copyright (C) 2018 Zilliqa\n//\n//  This file is part of zilliqa-js\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  This program is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nexport * from './factory';\nexport * from './contract';\nexport * from './types';\n"]},"metadata":{},"sourceType":"script"}