{"ast":null,"code":"/*\n  TODO:\n    * Replace `buffer._pos` usage in keyParser.js and elsewhere\n    * Utilize optional \"writev\" support when writing packets from\n      cipher.encrypt()\n    * Built-in support for automatic re-keying, on by default\n    * Revisit receiving unexpected/unknown packets\n      * Error (fatal or otherwise) or ignore or pass on to user (in some or all\n        cases)?\n      * Including server/client check for single directional packet types?\n      * Check packets for validity or bail as early as possible?\n    * Automatic re-key every 2**31 packets after the last key exchange (sent or\n      received), as suggested by RFC4344. OpenSSH currently does this.\n    * Automatic re-key every so many blocks depending on cipher. RFC4344:\n         Because of a birthday property of block ciphers and some modes of\n         operation, implementations must be careful not to encrypt too many\n         blocks with the same encryption key.\n\n         Let L be the block length (in bits) of an SSH encryption method's\n         block cipher (e.g., 128 for AES).  If L is at least 128, then, after\n         rekeying, an SSH implementation SHOULD NOT encrypt more than 2**(L/4)\n         blocks before rekeying again.  If L is at least 128, then SSH\n         implementations should also attempt to force a rekey before receiving\n         more than 2**(L/4) blocks.  If L is less than 128 (which is the case\n         for older ciphers such as 3DES, Blowfish, CAST-128, and IDEA), then,\n         although it may be too expensive to rekey every 2**(L/4) blocks, it\n         is still advisable for SSH implementations to follow the original\n         recommendation in [RFC4253]: rekey at least once for every gigabyte\n         of transmitted data.\n\n         Note that if L is less than or equal to 128, then the recommendation\n         in this subsection supersedes the recommendation in Section 3.1.  If\n         an SSH implementation uses a block cipher with a larger block size\n         (e.g., Rijndael with 256-bit blocks), then the recommendations in\n         Section 3.1 may supersede the recommendations in this subsection\n         (depending on the lengths of the packets).\n*/\n'use strict';\n\nconst {\n  inspect\n} = require('util');\n\nconst {\n  bindingAvailable,\n  NullCipher,\n  NullDecipher\n} = require('./crypto.js');\n\nconst {\n  COMPAT_CHECKS,\n  DISCONNECT_REASON,\n  MESSAGE,\n  SIGNALS,\n  TERMINAL_MODE\n} = require('./constants.js');\n\nconst {\n  DEFAULT_KEXINIT,\n  KexInit,\n  kexinit,\n  onKEXPayload\n} = require('./kex.js');\n\nconst {\n  parseKey\n} = require('./keyParser.js');\n\nconst MESSAGE_HANDLERS = require('./handlers.js');\n\nconst {\n  bufferCopy,\n  bufferFill,\n  bufferSlice,\n  convertSignature,\n  sendPacket,\n  writeUInt32BE\n} = require('./utils.js');\n\nconst {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter\n} = require('./zlib.js');\n\nconst MODULE_VER = require('../../package.json').version;\n\nconst VALID_DISCONNECT_REASONS = new Map(Object.values(DISCONNECT_REASON).map(n => [n, 1]));\nconst IDENT_RAW = Buffer.from(`SSH-2.0-ssh2js${MODULE_VER}`);\nconst IDENT = Buffer.from(`${IDENT_RAW}\\r\\n`);\nconst MAX_LINE_LEN = 8192;\nconst MAX_LINES = 1024;\nconst PING_PAYLOAD = Buffer.from([MESSAGE.GLOBAL_REQUEST, // \"keepalive@openssh.com\"\n0, 0, 0, 21, 107, 101, 101, 112, 97, 108, 105, 118, 101, 64, 111, 112, 101, 110, 115, 115, 104, 46, 99, 111, 109, // Request a reply\n1]);\nconst NO_TERMINAL_MODES_BUFFER = Buffer.from([TERMINAL_MODE.TTY_OP_END]);\n\nfunction noop() {}\n/*\n  Inbound:\n    * kexinit payload (needed only until exchange hash is generated)\n    * raw ident\n    * rekey packet queue\n    * expected packet (implemented as separate _parse() function?)\n  Outbound:\n    * kexinit payload (needed only until exchange hash is generated)\n    * rekey packet queue\n    * kex secret (needed only until NEWKEYS)\n    * exchange hash (needed only until NEWKEYS)\n    * session ID (set to exchange hash from initial handshake)\n*/\n\n\nclass Protocol {\n  constructor(config) {\n    var _this = this;\n\n    const onWrite = config.onWrite;\n    if (typeof onWrite !== 'function') throw new Error('Missing onWrite function');\n\n    this._onWrite = data => {\n      onWrite(data);\n    };\n\n    const onError = config.onError;\n    if (typeof onError !== 'function') throw new Error('Missing onError function');\n\n    this._onError = err => {\n      onError(err);\n    };\n\n    const debug = config.debug;\n    this._debug = typeof debug === 'function' ? msg => {\n      debug(msg);\n    } : undefined;\n    const onHeader = config.onHeader;\n    this._onHeader = typeof onHeader === 'function' ? function () {\n      onHeader(...arguments);\n    } : noop;\n    const onPacket = config.onPacket;\n    this._onPacket = typeof onPacket === 'function' ? () => {\n      onPacket();\n    } : noop;\n    let onHandshakeComplete = config.onHandshakeComplete;\n    if (typeof onHandshakeComplete !== 'function') onHandshakeComplete = noop;\n\n    this._onHandshakeComplete = function () {\n      _this._debug && _this._debug('Handshake completed'); // Process packets queued during a rekey where necessary\n\n      const oldQueue = _this._queue;\n\n      if (oldQueue) {\n        _this._queue = undefined;\n        _this._debug && _this._debug(`Draining outbound queue (${oldQueue.length}) ...`);\n\n        for (let i = 0; i < oldQueue.length; ++i) {\n          const data = oldQueue[i]; // data === payload only\n          // XXX: hacky\n\n          let finalized = _this._packetRW.write.finalize(data);\n\n          if (finalized === data) {\n            const packet = _this._cipher.allocPacket(data.length);\n\n            packet.set(data, 5);\n            finalized = packet;\n          }\n\n          sendPacket(_this, finalized);\n        }\n\n        _this._debug && _this._debug('... finished draining outbound queue');\n      }\n\n      onHandshakeComplete(...arguments);\n    };\n\n    this._queue = undefined;\n    const messageHandlers = config.messageHandlers;\n    if (typeof messageHandlers === 'object' && messageHandlers !== null) this._handlers = messageHandlers;else this._handlers = {};\n    this._onPayload = onPayload.bind(this);\n    this._server = !!config.server;\n    this._banner = undefined;\n    let greeting;\n\n    if (this._server) {\n      if (typeof config.hostKeys !== 'object' || config.hostKeys === null) throw new Error('Missing server host key(s)');\n      this._hostKeys = config.hostKeys; // Greeting displayed before the ssh identification string is sent, this\n      // is usually ignored by most clients\n\n      if (typeof config.greeting === 'string' && config.greeting.length) {\n        greeting = config.greeting.slice(-2) === '\\r\\n' ? config.greeting : `${config.greeting}\\r\\n`;\n      } // Banner shown after the handshake completes, but before user\n      // authentication begins\n\n\n      if (typeof config.banner === 'string' && config.banner.length) {\n        this._banner = config.banner.slice(-2) === '\\r\\n' ? config.banner : `${config.banner}\\r\\n`;\n      }\n    } else {\n      this._hostKeys = undefined;\n    }\n\n    let offer = config.offer;\n    if (typeof offer !== 'object' || offer === null) offer = DEFAULT_KEXINIT;else if (offer.constructor !== KexInit) offer = new KexInit(offer);\n    this._kex = undefined;\n    this._kexinit = undefined;\n    this._offer = offer;\n    this._cipher = new NullCipher(0, this._onWrite);\n    this._decipher = undefined;\n    this._skipNextInboundPacket = false;\n    this._packetRW = {\n      read: new PacketReader(),\n      write: new PacketWriter(this)\n    };\n    this._hostVerifier = !this._server && typeof config.hostVerifier === 'function' ? config.hostVerifier : undefined;\n    this._parse = parseHeader;\n    this._buffer = undefined;\n    this._authsQueue = [];\n    this._authenticated = false;\n    this._remoteIdentRaw = undefined;\n    let sentIdent;\n\n    if (typeof config.ident === 'string') {\n      this._identRaw = Buffer.from(`SSH-2.0-${config.ident}`);\n      sentIdent = Buffer.allocUnsafe(this._identRaw.length + 2);\n      sentIdent.set(this._identRaw, 0);\n      sentIdent[sentIdent.length - 2] = 13; // '\\r'\n\n      sentIdent[sentIdent.length - 1] = 10; // '\\n'\n    } else if (Buffer.isBuffer(config.ident)) {\n      const fullIdent = Buffer.allocUnsafe(8 + config.ident.length);\n      fullIdent.latin1Write('SSH-2.0-', 0, 8);\n      fullIdent.set(config.ident, 8);\n      this._identRaw = fullIdent;\n      sentIdent = Buffer.allocUnsafe(fullIdent.length + 2);\n      sentIdent.set(fullIdent, 0);\n      sentIdent[sentIdent.length - 2] = 13; // '\\r'\n\n      sentIdent[sentIdent.length - 1] = 10; // '\\n'\n    } else {\n      this._identRaw = IDENT_RAW;\n      sentIdent = IDENT;\n    }\n\n    this._compatFlags = 0;\n\n    if (this._debug) {\n      if (bindingAvailable) this._debug('Custom crypto binding available');else this._debug('Custom crypto binding not available');\n    }\n\n    this._debug && this._debug(`Local ident: ${inspect(this._identRaw.toString())}`);\n\n    this.start = () => {\n      this.start = undefined;\n      if (greeting) this._onWrite(greeting);\n\n      this._onWrite(sentIdent);\n    };\n  }\n\n  _destruct(reason) {\n    this._packetRW.read.cleanup();\n\n    this._packetRW.write.cleanup();\n\n    this._cipher && this._cipher.free();\n    this._decipher && this._decipher.free();\n    if (typeof reason !== 'string' || reason.length === 0) reason = 'fatal error';\n\n    this.parse = () => {\n      throw new Error(`Instance unusable after ${reason}`);\n    };\n\n    this._onWrite = () => {\n      throw new Error(`Instance unusable after ${reason}`);\n    };\n\n    this._destruct = undefined;\n  }\n\n  cleanup() {\n    this._destruct && this._destruct();\n  }\n\n  parse(chunk, i, len) {\n    while (i < len) i = this._parse(chunk, i, len);\n  } // Protocol message API\n  // ===========================================================================\n  // Common/Shared =============================================================\n  // ===========================================================================\n  // Global\n  // ------\n\n\n  disconnect(reason) {\n    const pktLen = 1 + 4 + 4 + 4; // We don't use _packetRW.write.* here because we need to make sure that\n    // we always get a full packet allocated because this message can be sent\n    // at any time -- even during a key exchange\n\n    let p = this._packetRW.write.allocStartKEX;\n\n    const packet = this._packetRW.write.alloc(pktLen, true);\n\n    const end = p + pktLen;\n    if (!VALID_DISCONNECT_REASONS.has(reason)) reason = DISCONNECT_REASON.PROTOCOL_ERROR;\n    packet[p] = MESSAGE.DISCONNECT;\n    writeUInt32BE(packet, reason, ++p);\n    packet.fill(0, p += 4, end);\n    this._debug && this._debug(`Outbound: Sending DISCONNECT (${reason})`);\n    sendPacket(this, this._packetRW.write.finalize(packet, true), true);\n  }\n\n  ping() {\n    const p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(PING_PAYLOAD.length);\n\n    packet.set(PING_PAYLOAD, p);\n    this._debug && this._debug('Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  rekey() {\n    if (this._kexinit === undefined) {\n      this._debug && this._debug('Outbound: Initiated explicit rekey');\n      this._queue = [];\n      kexinit(this);\n    } else {\n      this._debug && this._debug('Outbound: Ignoring rekey during handshake');\n    }\n  } // 'ssh-connection' service-specific\n  // ---------------------------------\n\n\n  requestSuccess(data) {\n    let p = this._packetRW.write.allocStart;\n    let packet;\n\n    if (Buffer.isBuffer(data)) {\n      packet = this._packetRW.write.alloc(1 + data.length);\n      packet[p] = MESSAGE.REQUEST_SUCCESS;\n      packet.set(data, ++p);\n    } else {\n      packet = this._packetRW.write.alloc(1);\n      packet[p] = MESSAGE.REQUEST_SUCCESS;\n    }\n\n    this._debug && this._debug('Outbound: Sending REQUEST_SUCCESS');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  requestFailure() {\n    const p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1);\n\n    packet[p] = MESSAGE.REQUEST_FAILURE;\n    this._debug && this._debug('Outbound: Sending REQUEST_FAILURE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  channelSuccess(chan) {\n    // Does not consume window space\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_SUCCESS;\n    writeUInt32BE(packet, chan, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  channelFailure(chan) {\n    // Does not consume window space\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_FAILURE;\n    writeUInt32BE(packet, chan, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  channelEOF(chan) {\n    // Does not consume window space\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_EOF;\n    writeUInt32BE(packet, chan, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_EOF (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  channelClose(chan) {\n    // Does not consume window space\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_CLOSE;\n    writeUInt32BE(packet, chan, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  channelWindowAdjust(chan, amount) {\n    // Does not consume window space\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_WINDOW_ADJUST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, amount, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${chan}, ${amount})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  channelData(chan, data) {\n    const isBuffer = Buffer.isBuffer(data);\n    const dataLen = isBuffer ? data.length : Buffer.byteLength(data);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + dataLen);\n\n    packet[p] = MESSAGE.CHANNEL_DATA;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, dataLen, p += 4);\n    if (isBuffer) packet.set(data, p += 4);else packet.utf8Write(data, p += 4, dataLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_DATA (r:${chan}, ${dataLen})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  channelExtData(chan, data, type) {\n    const isBuffer = Buffer.isBuffer(data);\n    const dataLen = isBuffer ? data.length : Buffer.byteLength(data);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + dataLen);\n\n    packet[p] = MESSAGE.CHANNEL_EXTENDED_DATA;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, type, p += 4);\n    writeUInt32BE(packet, dataLen, p += 4);\n    if (isBuffer) packet.set(data, p += 4);else packet.utf8Write(data, p += 4, dataLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  channelOpenConfirm(remote, local, initWindow, maxPacket) {\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;\n    writeUInt32BE(packet, remote, ++p);\n    writeUInt32BE(packet, local, p += 4);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${remote}, l:${local})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  channelOpenFail(remote, reason, desc) {\n    if (typeof desc !== 'string') desc = '';\n    const descLen = Buffer.byteLength(desc);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + descLen + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN_FAILURE;\n    writeUInt32BE(packet, remote, ++p);\n    writeUInt32BE(packet, reason, p += 4);\n    writeUInt32BE(packet, descLen, p += 4);\n    p += 4;\n\n    if (descLen) {\n      packet.utf8Write(desc, p, descLen);\n      p += descLen;\n    }\n\n    writeUInt32BE(packet, 0, p); // Empty language tag\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${remote})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  } // ===========================================================================\n  // Client-specific ===========================================================\n  // ===========================================================================\n  // Global\n  // ------\n\n\n  service(name) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const nameLen = Buffer.byteLength(name);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + nameLen);\n\n    packet[p] = MESSAGE.SERVICE_REQUEST;\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(name, p += 4, nameLen);\n    this._debug && this._debug(`Outbound: Sending SERVICE_REQUEST (${name})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  } // 'ssh-userauth' service-specific\n  // -------------------------------\n\n\n  authPassword(username, password, newPassword) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const userLen = Buffer.byteLength(username);\n    const passLen = Buffer.byteLength(password);\n    const newPassLen = newPassword ? Buffer.byteLength(newPassword) : 0;\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 8 + 1 + 4 + passLen + (newPassword ? 4 + newPassLen : 0));\n\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(packet, 8, p += 14);\n    packet.utf8Write('password', p += 4, 8);\n    packet[p += 8] = newPassword ? 1 : 0;\n    writeUInt32BE(packet, passLen, ++p);\n    if (Buffer.isBuffer(password)) bufferCopy(password, packet, 0, passLen, p += 4);else packet.utf8Write(password, p += 4, passLen);\n\n    if (newPassword) {\n      writeUInt32BE(packet, newPassLen, p += passLen);\n      if (Buffer.isBuffer(newPassword)) bufferCopy(newPassword, packet, 0, newPassLen, p += 4);else packet.utf8Write(newPassword, p += 4, newPassLen);\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (changed password)');\n    } else {\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (password)');\n    }\n\n    this._authsQueue.push('password');\n\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  authPK(username, pubKey, cbSign) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    pubKey = parseKey(pubKey);\n    if (pubKey instanceof Error) throw new Error('Invalid key');\n    const keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n    const userLen = Buffer.byteLength(username);\n    const algoLen = Buffer.byteLength(keyType);\n    const pubKeyLen = pubKey.length;\n    const sessionID = this._kex.sessionID;\n    const sesLen = sessionID.length;\n    const payloadLen = (cbSign ? 4 + sesLen : 0) + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen;\n    let packet;\n    let p;\n\n    if (cbSign) {\n      packet = Buffer.allocUnsafe(payloadLen);\n      p = 0;\n      writeUInt32BE(packet, sesLen, p);\n      packet.set(sessionID, p += 4);\n      p += sesLen;\n    } else {\n      packet = this._packetRW.write.alloc(payloadLen);\n      p = this._packetRW.write.allocStart;\n    }\n\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(packet, 9, p += 14);\n    packet.utf8Write('publickey', p += 4, 9);\n    packet[p += 9] = cbSign ? 1 : 0;\n    writeUInt32BE(packet, algoLen, ++p);\n    packet.utf8Write(keyType, p += 4, algoLen);\n    writeUInt32BE(packet, pubKeyLen, p += algoLen);\n    packet.set(pubKey, p += 4);\n\n    if (!cbSign) {\n      this._authsQueue.push('publickey');\n\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (publickey -- check)');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n      return;\n    }\n\n    cbSign(packet, signature => {\n      signature = convertSignature(signature, keyType);\n      if (signature === false) throw new Error('Error while converting handshake signature');\n      const sigLen = signature.length;\n      p = this._packetRW.write.allocStart;\n      packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen + 4 + 4 + algoLen + 4 + sigLen); // TODO: simply copy from original \"packet\" to new `packet` to avoid\n      // having to write each individual field a second time?\n\n      packet[p] = MESSAGE.USERAUTH_REQUEST;\n      writeUInt32BE(packet, userLen, ++p);\n      packet.utf8Write(username, p += 4, userLen);\n      writeUInt32BE(packet, 14, p += userLen);\n      packet.utf8Write('ssh-connection', p += 4, 14);\n      writeUInt32BE(packet, 9, p += 14);\n      packet.utf8Write('publickey', p += 4, 9);\n      packet[p += 9] = 1;\n      writeUInt32BE(packet, algoLen, ++p);\n      packet.utf8Write(keyType, p += 4, algoLen);\n      writeUInt32BE(packet, pubKeyLen, p += algoLen);\n      packet.set(pubKey, p += 4);\n      writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += pubKeyLen);\n      writeUInt32BE(packet, algoLen, p += 4);\n      packet.utf8Write(keyType, p += 4, algoLen);\n      writeUInt32BE(packet, sigLen, p += algoLen);\n      packet.set(signature, p += 4); // Servers shouldn't send packet type 60 in response to signed publickey\n      // attempts, but if they do, interpret as type 60.\n\n      this._authsQueue.push('publickey');\n\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (publickey)');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    });\n  }\n\n  authHostbased(username, pubKey, hostname, userlocal, cbSign) {\n    // TODO: Make DRY by sharing similar code with authPK()\n    if (this._server) throw new Error('Client-only method called in server mode');\n    pubKey = parseKey(pubKey);\n    if (pubKey instanceof Error) throw new Error('Invalid key');\n    const keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n    const userLen = Buffer.byteLength(username);\n    const algoLen = Buffer.byteLength(keyType);\n    const pubKeyLen = pubKey.length;\n    const sessionID = this._kex.sessionID;\n    const sesLen = sessionID.length;\n    const hostnameLen = Buffer.byteLength(hostname);\n    const userlocalLen = Buffer.byteLength(userlocal);\n    const data = Buffer.allocUnsafe(4 + sesLen + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 4 + algoLen + 4 + pubKeyLen + 4 + hostnameLen + 4 + userlocalLen);\n    let p = 0;\n    writeUInt32BE(data, sesLen, p);\n    data.set(sessionID, p += 4);\n    data[p += sesLen] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(data, userLen, ++p);\n    data.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(data, 14, p += userLen);\n    data.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(data, 9, p += 14);\n    data.utf8Write('hostbased', p += 4, 9);\n    writeUInt32BE(data, algoLen, p += 9);\n    data.utf8Write(keyType, p += 4, algoLen);\n    writeUInt32BE(data, pubKeyLen, p += algoLen);\n    data.set(pubKey, p += 4);\n    writeUInt32BE(data, hostnameLen, p += pubKeyLen);\n    data.utf8Write(hostname, p += 4, hostnameLen);\n    writeUInt32BE(data, userlocalLen, p += hostnameLen);\n    data.utf8Write(userlocal, p += 4, userlocalLen);\n    cbSign(data, signature => {\n      signature = convertSignature(signature, keyType);\n      if (!signature) throw new Error('Error while converting handshake signature');\n      const sigLen = signature.length;\n      const reqDataLen = data.length - sesLen - 4;\n      p = this._packetRW.write.allocStart;\n\n      const packet = this._packetRW.write.alloc(reqDataLen + 4 + 4 + algoLen + 4 + sigLen);\n\n      bufferCopy(data, packet, 4 + sesLen, data.length, p);\n      writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += reqDataLen);\n      writeUInt32BE(packet, algoLen, p += 4);\n      packet.utf8Write(keyType, p += 4, algoLen);\n      writeUInt32BE(packet, sigLen, p += algoLen);\n      packet.set(signature, p += 4);\n\n      this._authsQueue.push('hostbased');\n\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (hostbased)');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    });\n  }\n\n  authKeyboard(username) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const userLen = Buffer.byteLength(username);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 20 + 4 + 4);\n\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(packet, 20, p += 14);\n    packet.utf8Write('keyboard-interactive', p += 4, 20);\n    writeUInt32BE(packet, 0, p += 20);\n    writeUInt32BE(packet, 0, p += 4);\n\n    this._authsQueue.push('keyboard-interactive');\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  authNone(username) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const userLen = Buffer.byteLength(username);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 4);\n\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(packet, 4, p += 14);\n    packet.utf8Write('none', p += 4, 4);\n\n    this._authsQueue.push('none');\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (none)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  authInfoRes(responses) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    let responsesTotalLen = 0;\n    let responseLens;\n\n    if (responses) {\n      responseLens = new Array(responses.length);\n\n      for (let i = 0; i < responses.length; ++i) {\n        const len = Buffer.byteLength(responses[i]);\n        responseLens[i] = len;\n        responsesTotalLen += 4 + len;\n      }\n    }\n\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + responsesTotalLen);\n\n    packet[p] = MESSAGE.USERAUTH_INFO_RESPONSE;\n\n    if (responses) {\n      writeUInt32BE(packet, responses.length, ++p);\n      p += 4;\n\n      for (let i = 0; i < responses.length; ++i) {\n        const len = responseLens[i];\n        writeUInt32BE(packet, len, p);\n        p += 4;\n\n        if (len) {\n          packet.utf8Write(responses[i], p, len);\n          p += len;\n        }\n      }\n    } else {\n      writeUInt32BE(packet, 0, ++p);\n    }\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_INFO_RESPONSE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  } // 'ssh-connection' service-specific\n  // ---------------------------------\n\n\n  tcpipForward(bindAddr, bindPort, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const addrLen = Buffer.byteLength(bindAddr);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 13 + 1 + 4 + addrLen + 4);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 13, ++p);\n    packet.utf8Write('tcpip-forward', p += 4, 13);\n    packet[p += 13] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, addrLen, ++p);\n    packet.utf8Write(bindAddr, p += 4, addrLen);\n    writeUInt32BE(packet, bindPort, p += addrLen);\n    this._debug && this._debug('Outbound: Sending GLOBAL_REQUEST (tcpip-forward)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  cancelTcpipForward(bindAddr, bindPort, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const addrLen = Buffer.byteLength(bindAddr);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 20 + 1 + 4 + addrLen + 4);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 20, ++p);\n    packet.utf8Write('cancel-tcpip-forward', p += 4, 20);\n    packet[p += 20] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, addrLen, ++p);\n    packet.utf8Write(bindAddr, p += 4, addrLen);\n    writeUInt32BE(packet, bindPort, p += addrLen);\n    this._debug && this._debug('Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  openssh_streamLocalForward(socketPath, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const socketPathLen = Buffer.byteLength(socketPath);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 31 + 1 + 4 + socketPathLen);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 31, ++p);\n    packet.utf8Write('streamlocal-forward@openssh.com', p += 4, 31);\n    packet[p += 31] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, socketPathLen, ++p);\n    packet.utf8Write(socketPath, p += 4, socketPathLen);\n    this._debug && this._debug('Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  openssh_cancelStreamLocalForward(socketPath, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const socketPathLen = Buffer.byteLength(socketPath);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 38 + 1 + 4 + socketPathLen);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 38, ++p);\n    packet.utf8Write('cancel-streamlocal-forward@openssh.com', p += 4, 38);\n    packet[p += 38] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, socketPathLen, ++p);\n    packet.utf8Write(socketPath, p += 4, socketPathLen);\n\n    if (this._debug) {\n      this._debug('Outbound: Sending GLOBAL_REQUEST ' + '(cancel-streamlocal-forward@openssh.com)');\n    }\n\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  directTcpip(chan, initWindow, maxPacket, cfg) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const srcLen = Buffer.byteLength(cfg.srcIP);\n    const dstLen = Buffer.byteLength(cfg.dstIP);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 12 + 4 + 4 + 4 + 4 + srcLen + 4 + 4 + dstLen + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 12, ++p);\n    packet.utf8Write('direct-tcpip', p += 4, 12);\n    writeUInt32BE(packet, chan, p += 12);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, dstLen, p += 4);\n    packet.utf8Write(cfg.dstIP, p += 4, dstLen);\n    writeUInt32BE(packet, cfg.dstPort, p += dstLen);\n    writeUInt32BE(packet, srcLen, p += 4);\n    packet.utf8Write(cfg.srcIP, p += 4, srcLen);\n    writeUInt32BE(packet, cfg.srcPort, p += srcLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-tcpip)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  openssh_directStreamLocal(chan, initWindow, maxPacket, cfg) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const pathLen = Buffer.byteLength(cfg.socketPath);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 30 + 4 + 4 + 4 + 4 + pathLen + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 30, ++p);\n    packet.utf8Write('direct-streamlocal@openssh.com', p += 4, 30);\n    writeUInt32BE(packet, chan, p += 30);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, pathLen, p += 4);\n    packet.utf8Write(cfg.socketPath, p += 4, pathLen); // zero-fill reserved fields (string and uint32)\n\n    bufferFill(packet, 0, p += pathLen, p + 8);\n\n    if (this._debug) {\n      this._debug('Outbound: Sending CHANNEL_OPEN ' + `(r:${chan}, direct-streamlocal@openssh.com)`);\n    }\n\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  openssh_noMoreSessions(wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 28 + 1);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 28, ++p);\n    packet.utf8Write('no-more-sessions@openssh.com', p += 4, 28);\n    packet[p += 28] = wantReply === undefined || wantReply === true ? 1 : 0;\n    this._debug && this._debug('Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  session(chan, initWindow, maxPacket) {\n    if (this._server) throw new Error('Client-only method called in server mode'); // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 7 + 4 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 7, ++p);\n    packet.utf8Write('session', p += 4, 7);\n    writeUInt32BE(packet, chan, p += 7);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, session)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  windowChange(chan, rows, cols, height, width) {\n    if (this._server) throw new Error('Client-only method called in server mode'); // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 13, p += 4);\n    packet.utf8Write('window-change', p += 4, 13);\n    packet[p += 13] = 0;\n    writeUInt32BE(packet, cols, ++p);\n    writeUInt32BE(packet, rows, p += 4);\n    writeUInt32BE(packet, width, p += 4);\n    writeUInt32BE(packet, height, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, window-change)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  pty(chan, rows, cols, height, width, term, modes, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode'); // Does not consume window space\n\n    if (!term || !term.length) term = 'vt100';\n\n    if (modes && !Buffer.isBuffer(modes) && !Array.isArray(modes) && typeof modes === 'object' && modes !== null) {\n      modes = modesToBytes(modes);\n    }\n\n    if (!modes || !modes.length) modes = NO_TERMINAL_MODES_BUFFER;\n    const termLen = term.length;\n    const modesLen = modes.length;\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4 + 4 + modesLen);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 7, p += 4);\n    packet.utf8Write('pty-req', p += 4, 7);\n    packet[p += 7] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, termLen, ++p);\n    packet.utf8Write(term, p += 4, termLen);\n    writeUInt32BE(packet, cols, p += termLen);\n    writeUInt32BE(packet, rows, p += 4);\n    writeUInt32BE(packet, width, p += 4);\n    writeUInt32BE(packet, height, p += 4);\n    writeUInt32BE(packet, modesLen, p += 4);\n    p += 4;\n\n    if (Array.isArray(modes)) {\n      for (let i = 0; i < modesLen; ++i) packet[p++] = modes[i];\n    } else if (Buffer.isBuffer(modes)) {\n      packet.set(modes, p);\n    }\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, pty-req)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  shell(chan, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode'); // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 5 + 1);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 5, p += 4);\n    packet.utf8Write('shell', p += 4, 5);\n    packet[p += 5] = wantReply === undefined || wantReply === true ? 1 : 0;\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, shell)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  exec(chan, cmd, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode'); // Does not consume window space\n\n    const isBuf = Buffer.isBuffer(cmd);\n    const cmdLen = isBuf ? cmd.length : Buffer.byteLength(cmd);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 1 + 4 + cmdLen);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 4, p += 4);\n    packet.utf8Write('exec', p += 4, 4);\n    packet[p += 4] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, cmdLen, ++p);\n    if (isBuf) packet.set(cmd, p += 4);else packet.utf8Write(cmd, p += 4, cmdLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, exec: ${cmd})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  signal(chan, signal) {\n    if (this._server) throw new Error('Client-only method called in server mode'); // Does not consume window space\n\n    const origSignal = signal;\n    signal = signal.toUpperCase();\n    if (signal.slice(0, 3) === 'SIG') signal = signal.slice(3);\n    if (SIGNALS[signal] !== 1) throw new Error(`Invalid signal: ${origSignal}`);\n    const signalLen = signal.length;\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 6 + 1 + 4 + signalLen);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 6, p += 4);\n    packet.utf8Write('signal', p += 4, 6);\n    packet[p += 6] = 0;\n    writeUInt32BE(packet, signalLen, ++p);\n    packet.utf8Write(signal, p += 4, signalLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, signal: ${signal})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  env(chan, key, val, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode'); // Does not consume window space\n\n    const keyLen = Buffer.byteLength(key);\n    const isBuf = Buffer.isBuffer(val);\n    const valLen = isBuf ? val.length : Buffer.byteLength(val);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 3, p += 4);\n    packet.utf8Write('env', p += 4, 3);\n    packet[p += 3] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, keyLen, ++p);\n    packet.utf8Write(key, p += 4, keyLen);\n    writeUInt32BE(packet, valLen, p += keyLen);\n    if (isBuf) packet.set(val, p += 4);else packet.utf8Write(val, p += 4, valLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, env: ${key}=${val})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  x11Forward(chan, cfg, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode'); // Does not consume window space\n\n    const protocol = cfg.protocol;\n    const cookie = cfg.cookie;\n    const isBufProto = Buffer.isBuffer(protocol);\n    const protoLen = isBufProto ? protocol.length : Buffer.byteLength(protocol);\n    const isBufCookie = Buffer.isBuffer(cookie);\n    const cookieLen = isBufCookie ? cookie.length : Buffer.byteLength(cookie);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 7 + 1 + 1 + 4 + protoLen + 4 + cookieLen + 4);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 7, p += 4);\n    packet.utf8Write('x11-req', p += 4, 7);\n    packet[p += 7] = wantReply === undefined || wantReply === true ? 1 : 0;\n    packet[++p] = cfg.single ? 1 : 0;\n    writeUInt32BE(packet, protoLen, ++p);\n    if (isBufProto) packet.set(protocol, p += 4);else packet.utf8Write(protocol, p += 4, protoLen);\n    writeUInt32BE(packet, cookieLen, p += protoLen);\n    if (isBufCookie) packet.set(cookie, p += 4);else packet.latin1Write(cookie, p += 4, cookieLen);\n    writeUInt32BE(packet, cfg.screen || 0, p += cookieLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, x11-req)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  subsystem(chan, name, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode'); // Does not consume window space\n\n    const nameLen = Buffer.byteLength(name);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 9 + 1 + 4 + nameLen);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 9, p += 4);\n    packet.utf8Write('subsystem', p += 4, 9);\n    packet[p += 9] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(name, p += 4, nameLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, subsystem: ${name})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  openssh_agentForward(chan, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode'); // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 26 + 1);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 26, p += 4);\n    packet.utf8Write('auth-agent-req@openssh.com', p += 4, 26);\n    packet[p += 26] = wantReply === undefined || wantReply === true ? 1 : 0;\n\n    if (this._debug) {\n      this._debug('Outbound: Sending CHANNEL_REQUEST ' + `(r:${chan}, auth-agent-req@openssh.com)`);\n    }\n\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  openssh_hostKeysProve(keys) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    let keysTotal = 0;\n    const publicKeys = [];\n\n    for (const key of keys) {\n      const publicKey = key.getPublicSSH();\n      keysTotal += 4 + publicKey.length;\n      publicKeys.push(publicKey);\n    }\n\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 29 + 1 + keysTotal);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 29, ++p);\n    packet.utf8Write('hostkeys-prove-00@openssh.com', p += 4, 29);\n    packet[p += 29] = 1; // want reply\n\n    ++p;\n\n    for (const buf of publicKeys) {\n      writeUInt32BE(packet, buf.length, p);\n      bufferCopy(buf, packet, 0, buf.length, p += 4);\n      p += buf.length;\n    }\n\n    if (this._debug) {\n      this._debug('Outbound: Sending GLOBAL_REQUEST (hostkeys-prove-00@openssh.com)');\n    }\n\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  } // ===========================================================================\n  // Server-specific ===========================================================\n  // ===========================================================================\n  // Global\n  // ------\n\n\n  serviceAccept(svcName) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const svcNameLen = Buffer.byteLength(svcName);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + svcNameLen);\n\n    packet[p] = MESSAGE.SERVICE_ACCEPT;\n    writeUInt32BE(packet, svcNameLen, ++p);\n    packet.utf8Write(svcName, p += 4, svcNameLen);\n    this._debug && this._debug(`Outbound: Sending SERVICE_ACCEPT (${svcName})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n\n    if (this._server && this._banner && svcName === 'ssh-userauth') {\n      const banner = this._banner;\n      this._banner = undefined; // Prevent banner from being displayed again\n\n      const bannerLen = Buffer.byteLength(banner);\n      p = this._packetRW.write.allocStart;\n\n      const packet = this._packetRW.write.alloc(1 + 4 + bannerLen + 4);\n\n      packet[p] = MESSAGE.USERAUTH_BANNER;\n      writeUInt32BE(packet, bannerLen, ++p);\n      packet.utf8Write(banner, p += 4, bannerLen);\n      writeUInt32BE(packet, 0, p += bannerLen); // Empty language tag\n\n      this._debug && this._debug('Outbound: Sending USERAUTH_BANNER');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    }\n  } // 'ssh-connection' service-specific\n\n\n  forwardedTcpip(chan, initWindow, maxPacket, cfg) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const boundAddrLen = Buffer.byteLength(cfg.boundAddr);\n    const remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4 + remoteAddrLen + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 15, ++p);\n    packet.utf8Write('forwarded-tcpip', p += 4, 15);\n    writeUInt32BE(packet, chan, p += 15);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, boundAddrLen, p += 4);\n    packet.utf8Write(cfg.boundAddr, p += 4, boundAddrLen);\n    writeUInt32BE(packet, cfg.boundPort, p += boundAddrLen);\n    writeUInt32BE(packet, remoteAddrLen, p += 4);\n    packet.utf8Write(cfg.remoteAddr, p += 4, remoteAddrLen);\n    writeUInt32BE(packet, cfg.remotePort, p += remoteAddrLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-tcpip)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  x11(chan, initWindow, maxPacket, cfg) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const addrLen = Buffer.byteLength(cfg.originAddr);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 3, ++p);\n    packet.utf8Write('x11', p += 4, 3);\n    writeUInt32BE(packet, chan, p += 3);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, addrLen, p += 4);\n    packet.utf8Write(cfg.originAddr, p += 4, addrLen);\n    writeUInt32BE(packet, cfg.originPort, p += addrLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, x11)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  openssh_authAgent(chan, initWindow, maxPacket) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 22 + 4 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 22, ++p);\n    packet.utf8Write('auth-agent@openssh.com', p += 4, 22);\n    writeUInt32BE(packet, chan, p += 22);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, auth-agent@openssh.com)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  openssh_forwardedStreamLocal(chan, initWindow, maxPacket, cfg) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const pathLen = Buffer.byteLength(cfg.socketPath);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 33 + 4 + 4 + 4 + 4 + pathLen + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 33, ++p);\n    packet.utf8Write('forwarded-streamlocal@openssh.com', p += 4, 33);\n    writeUInt32BE(packet, chan, p += 33);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, pathLen, p += 4);\n    packet.utf8Write(cfg.socketPath, p += 4, pathLen);\n    writeUInt32BE(packet, 0, p += pathLen);\n\n    if (this._debug) {\n      this._debug('Outbound: Sending CHANNEL_OPEN ' + `(r:${chan}, forwarded-streamlocal@openssh.com)`);\n    }\n\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  exitStatus(chan, status) {\n    if (!this._server) throw new Error('Server-only method called in client mode'); // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 11, p += 4);\n    packet.utf8Write('exit-status', p += 4, 11);\n    packet[p += 11] = 0;\n    writeUInt32BE(packet, status, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-status: ${status})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  exitSignal(chan, name, coreDumped, msg) {\n    if (!this._server) throw new Error('Server-only method called in client mode'); // Does not consume window space\n\n    const origSignal = name;\n    if (typeof origSignal !== 'string' || !origSignal) throw new Error(`Invalid signal: ${origSignal}`);\n    let signal = name.toUpperCase();\n    if (signal.slice(0, 3) === 'SIG') signal = signal.slice(3);\n    if (SIGNALS[signal] !== 1) throw new Error(`Invalid signal: ${origSignal}`);\n    const nameLen = Buffer.byteLength(signal);\n    const msgLen = msg ? Buffer.byteLength(msg) : 0;\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen + 4);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 11, p += 4);\n    packet.utf8Write('exit-signal', p += 4, 11);\n    packet[p += 11] = 0;\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(signal, p += 4, nameLen);\n    packet[p += nameLen] = coreDumped ? 1 : 0;\n    writeUInt32BE(packet, msgLen, ++p);\n    p += 4;\n\n    if (msgLen) {\n      packet.utf8Write(msg, p, msgLen);\n      p += msgLen;\n    }\n\n    writeUInt32BE(packet, 0, p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-signal: ${name})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  } // 'ssh-userauth' service-specific\n\n\n  authFailure(authMethods, isPartial) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    if (this._authsQueue.length === 0) throw new Error('No auth in progress');\n    let methods;\n\n    if (typeof authMethods === 'boolean') {\n      isPartial = authMethods;\n      authMethods = undefined;\n    }\n\n    if (authMethods) {\n      methods = [];\n\n      for (let i = 0; i < authMethods.length; ++i) {\n        if (authMethods[i].toLowerCase() === 'none') continue;\n        methods.push(authMethods[i]);\n      }\n\n      methods = methods.join(',');\n    } else {\n      methods = '';\n    }\n\n    const methodsLen = methods.length;\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + methodsLen + 1);\n\n    packet[p] = MESSAGE.USERAUTH_FAILURE;\n    writeUInt32BE(packet, methodsLen, ++p);\n    packet.utf8Write(methods, p += 4, methodsLen);\n    packet[p += methodsLen] = isPartial === true ? 1 : 0;\n\n    this._authsQueue.shift();\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_FAILURE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  authSuccess() {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    if (this._authsQueue.length === 0) throw new Error('No auth in progress');\n    const p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1);\n\n    packet[p] = MESSAGE.USERAUTH_SUCCESS;\n\n    this._authsQueue.shift();\n\n    this._authenticated = true;\n    this._debug && this._debug('Outbound: Sending USERAUTH_SUCCESS');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n    if (this._kex.negotiated.cs.compress === 'zlib@openssh.com') this._packetRW.read = new ZlibPacketReader();\n    if (this._kex.negotiated.sc.compress === 'zlib@openssh.com') this._packetRW.write = new ZlibPacketWriter(this);\n  }\n\n  authPKOK(keyAlgo, key) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    if (this._authsQueue.length === 0 || this._authsQueue[0] !== 'publickey') throw new Error('\"publickey\" auth not in progress'); // TODO: support parsed key for `key`\n\n    const keyAlgoLen = Buffer.byteLength(keyAlgo);\n    const keyLen = key.length;\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + keyAlgoLen + 4 + keyLen);\n\n    packet[p] = MESSAGE.USERAUTH_PK_OK;\n    writeUInt32BE(packet, keyAlgoLen, ++p);\n    packet.utf8Write(keyAlgo, p += 4, keyAlgoLen);\n    writeUInt32BE(packet, keyLen, p += keyAlgoLen);\n    packet.set(key, p += 4);\n\n    this._authsQueue.shift();\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_PK_OK');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  authPasswdChg(prompt) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const promptLen = Buffer.byteLength(prompt);\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + promptLen + 4);\n\n    packet[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;\n    writeUInt32BE(packet, promptLen, ++p);\n    packet.utf8Write(prompt, p += 4, promptLen);\n    writeUInt32BE(packet, 0, p += promptLen); // Empty language tag\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_PASSWD_CHANGEREQ');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  authInfoReq(name, instructions, prompts) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    let promptsLen = 0;\n    const nameLen = name ? Buffer.byteLength(name) : 0;\n    const instrLen = instructions ? Buffer.byteLength(instructions) : 0;\n\n    for (let i = 0; i < prompts.length; ++i) promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;\n\n    let p = this._packetRW.write.allocStart;\n\n    const packet = this._packetRW.write.alloc(1 + 4 + nameLen + 4 + instrLen + 4 + 4 + promptsLen);\n\n    packet[p] = MESSAGE.USERAUTH_INFO_REQUEST;\n    writeUInt32BE(packet, nameLen, ++p);\n    p += 4;\n\n    if (name) {\n      packet.utf8Write(name, p, nameLen);\n      p += nameLen;\n    }\n\n    writeUInt32BE(packet, instrLen, p);\n    p += 4;\n\n    if (instructions) {\n      packet.utf8Write(instructions, p, instrLen);\n      p += instrLen;\n    }\n\n    writeUInt32BE(packet, 0, p);\n    writeUInt32BE(packet, prompts.length, p += 4);\n    p += 4;\n\n    for (let i = 0; i < prompts.length; ++i) {\n      const prompt = prompts[i];\n      const promptLen = Buffer.byteLength(prompt.prompt);\n      writeUInt32BE(packet, promptLen, p);\n      p += 4;\n\n      if (promptLen) {\n        packet.utf8Write(prompt.prompt, p, promptLen);\n        p += promptLen;\n      }\n\n      packet[p++] = prompt.echo ? 1 : 0;\n    }\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_INFO_REQUEST');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n} // SSH-protoversion-softwareversion (SP comments) CR LF\n\n\nconst RE_IDENT = /^SSH-(2\\.0|1\\.99)-([^ ]+)(?: (.*))?$/; // TODO: optimize this by starting n bytes from the end of this._buffer instead\n// of the beginning\n\nfunction parseHeader(chunk, p, len) {\n  let data;\n  let chunkOffset;\n\n  if (this._buffer) {\n    data = Buffer.allocUnsafe(this._buffer.length + (len - p));\n    data.set(this._buffer, 0);\n\n    if (p === 0) {\n      data.set(chunk, this._buffer.length);\n    } else {\n      data.set(new Uint8Array(chunk.buffer, chunk.byteOffset + p, len - p), this._buffer.length);\n    }\n\n    chunkOffset = this._buffer.length;\n    p = 0;\n  } else {\n    data = chunk;\n    chunkOffset = 0;\n  }\n\n  const op = p;\n  let start = p;\n  let end = p;\n  let needNL = false;\n  let lineLen = 0;\n  let lines = 0;\n\n  for (; p < data.length; ++p) {\n    const ch = data[p];\n\n    if (ch === 13\n    /* '\\r' */\n    ) {\n      needNL = true;\n      continue;\n    }\n\n    if (ch === 10\n    /* '\\n' */\n    ) {\n      if (end > start && end - start > 4 && data[start] === 83\n      /* 'S' */\n      && data[start + 1] === 83\n      /* 'S' */\n      && data[start + 2] === 72\n      /* 'H' */\n      && data[start + 3] === 45\n      /* '-' */\n      ) {\n        const full = data.latin1Slice(op, end + 1);\n        const identRaw = start === op ? full : full.slice(start - op);\n        const m = RE_IDENT.exec(identRaw);\n        if (!m) throw new Error('Invalid identification string');\n        const header = {\n          greeting: start === op ? '' : full.slice(0, start - op),\n          identRaw,\n          versions: {\n            protocol: m[1],\n            software: m[2]\n          },\n          comments: m[3]\n        }; // Needed during handshake\n\n        this._remoteIdentRaw = Buffer.from(identRaw);\n        this._debug && this._debug(`Remote ident: ${inspect(identRaw)}`);\n        this._compatFlags = getCompatFlags(header);\n        this._buffer = undefined;\n        this._decipher = new NullDecipher(0, onKEXPayload.bind(this, {\n          firstPacket: true\n        }));\n        this._parse = parsePacket;\n\n        this._onHeader(header);\n\n        if (!this._destruct) {\n          // We disconnected inside _onHeader\n          return len;\n        }\n\n        kexinit(this);\n        return p + 1 - chunkOffset;\n      } // Only allow pre-ident greetings when we're a client\n\n\n      if (this._server) throw new Error('Greetings from clients not permitted');\n      if (++lines > MAX_LINES) throw new Error('Max greeting lines exceeded');\n      needNL = false;\n      start = p + 1;\n      lineLen = 0;\n    } else if (needNL) {\n      throw new Error('Invalid header: expected newline');\n    } else if (++lineLen >= MAX_LINE_LEN) {\n      throw new Error('Header line too long');\n    }\n\n    end = p;\n  }\n\n  if (!this._buffer) this._buffer = bufferSlice(data, op);\n  return p - chunkOffset;\n}\n\nfunction parsePacket(chunk, p, len) {\n  return this._decipher.decrypt(chunk, p, len);\n}\n\nfunction onPayload(payload) {\n  // XXX: move this to the Decipher implementations?\n  this._onPacket();\n\n  if (payload.length === 0) {\n    this._debug && this._debug('Inbound: Skipping empty packet payload');\n    return;\n  }\n\n  payload = this._packetRW.read.read(payload);\n  const type = payload[0];\n\n  if (type === MESSAGE.USERAUTH_SUCCESS && !this._server && !this._authenticated) {\n    this._authenticated = true;\n    if (this._kex.negotiated.cs.compress === 'zlib@openssh.com') this._packetRW.write = new ZlibPacketWriter(this);\n    if (this._kex.negotiated.sc.compress === 'zlib@openssh.com') this._packetRW.read = new ZlibPacketReader();\n  }\n\n  const handler = MESSAGE_HANDLERS[type];\n\n  if (handler === undefined) {\n    this._debug && this._debug(`Inbound: Unsupported message type: ${type}`);\n    return;\n  }\n\n  return handler(this, payload);\n}\n\nfunction getCompatFlags(header) {\n  const software = header.versions.software;\n  let flags = 0;\n\n  for (const rule of COMPAT_CHECKS) {\n    if (typeof rule[0] === 'string') {\n      if (software === rule[0]) flags |= rule[1];\n    } else if (rule[0].test(software)) {\n      flags |= rule[1];\n    }\n  }\n\n  return flags;\n}\n\nfunction modesToBytes(modes) {\n  const keys = Object.keys(modes);\n  const bytes = Buffer.allocUnsafe(5 * keys.length + 1);\n  let b = 0;\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (key === 'TTY_OP_END') continue;\n    const opcode = TERMINAL_MODE[key];\n    if (opcode === undefined) continue;\n    const val = modes[key];\n\n    if (typeof val === 'number' && isFinite(val)) {\n      bytes[b++] = opcode;\n      bytes[b++] = val >>> 24;\n      bytes[b++] = val >>> 16;\n      bytes[b++] = val >>> 8;\n      bytes[b++] = val;\n    }\n  }\n\n  bytes[b++] = TERMINAL_MODE.TTY_OP_END;\n  if (b < bytes.length) return bufferSlice(bytes, 0, b);\n  return bytes;\n}\n\nmodule.exports = Protocol;","map":{"version":3,"names":["inspect","require","bindingAvailable","NullCipher","NullDecipher","COMPAT_CHECKS","DISCONNECT_REASON","MESSAGE","SIGNALS","TERMINAL_MODE","DEFAULT_KEXINIT","KexInit","kexinit","onKEXPayload","parseKey","MESSAGE_HANDLERS","bufferCopy","bufferFill","bufferSlice","convertSignature","sendPacket","writeUInt32BE","PacketReader","PacketWriter","ZlibPacketReader","ZlibPacketWriter","MODULE_VER","version","VALID_DISCONNECT_REASONS","Map","Object","values","map","n","IDENT_RAW","Buffer","from","IDENT","MAX_LINE_LEN","MAX_LINES","PING_PAYLOAD","GLOBAL_REQUEST","NO_TERMINAL_MODES_BUFFER","TTY_OP_END","noop","Protocol","constructor","config","onWrite","Error","_onWrite","data","onError","_onError","err","debug","_debug","msg","undefined","onHeader","_onHeader","onPacket","_onPacket","onHandshakeComplete","_onHandshakeComplete","oldQueue","_queue","length","i","finalized","_packetRW","write","finalize","packet","_cipher","allocPacket","set","messageHandlers","_handlers","_onPayload","onPayload","bind","_server","server","_banner","greeting","hostKeys","_hostKeys","slice","banner","offer","_kex","_kexinit","_offer","_decipher","_skipNextInboundPacket","read","_hostVerifier","hostVerifier","_parse","parseHeader","_buffer","_authsQueue","_authenticated","_remoteIdentRaw","sentIdent","ident","_identRaw","allocUnsafe","isBuffer","fullIdent","latin1Write","_compatFlags","toString","start","_destruct","reason","cleanup","free","parse","chunk","len","disconnect","pktLen","p","allocStartKEX","alloc","end","has","PROTOCOL_ERROR","DISCONNECT","fill","ping","allocStart","rekey","requestSuccess","REQUEST_SUCCESS","requestFailure","REQUEST_FAILURE","channelSuccess","chan","CHANNEL_SUCCESS","channelFailure","CHANNEL_FAILURE","channelEOF","CHANNEL_EOF","channelClose","CHANNEL_CLOSE","channelWindowAdjust","amount","CHANNEL_WINDOW_ADJUST","channelData","dataLen","byteLength","CHANNEL_DATA","utf8Write","channelExtData","type","CHANNEL_EXTENDED_DATA","channelOpenConfirm","remote","local","initWindow","maxPacket","CHANNEL_OPEN_CONFIRMATION","channelOpenFail","desc","descLen","CHANNEL_OPEN_FAILURE","service","name","nameLen","SERVICE_REQUEST","authPassword","username","password","newPassword","userLen","passLen","newPassLen","USERAUTH_REQUEST","push","authPK","pubKey","cbSign","keyType","getPublicSSH","algoLen","pubKeyLen","sessionID","sesLen","payloadLen","signature","sigLen","authHostbased","hostname","userlocal","hostnameLen","userlocalLen","reqDataLen","authKeyboard","authNone","authInfoRes","responses","responsesTotalLen","responseLens","Array","USERAUTH_INFO_RESPONSE","tcpipForward","bindAddr","bindPort","wantReply","addrLen","cancelTcpipForward","openssh_streamLocalForward","socketPath","socketPathLen","openssh_cancelStreamLocalForward","directTcpip","cfg","srcLen","srcIP","dstLen","dstIP","CHANNEL_OPEN","dstPort","srcPort","openssh_directStreamLocal","pathLen","openssh_noMoreSessions","session","windowChange","rows","cols","height","width","CHANNEL_REQUEST","pty","term","modes","isArray","modesToBytes","termLen","modesLen","shell","exec","cmd","isBuf","cmdLen","signal","origSignal","toUpperCase","signalLen","env","key","val","keyLen","valLen","x11Forward","protocol","cookie","isBufProto","protoLen","isBufCookie","cookieLen","single","screen","subsystem","openssh_agentForward","openssh_hostKeysProve","keys","keysTotal","publicKeys","publicKey","buf","serviceAccept","svcName","svcNameLen","SERVICE_ACCEPT","bannerLen","USERAUTH_BANNER","forwardedTcpip","boundAddrLen","boundAddr","remoteAddrLen","remoteAddr","boundPort","remotePort","x11","originAddr","originPort","openssh_authAgent","openssh_forwardedStreamLocal","exitStatus","status","exitSignal","coreDumped","msgLen","authFailure","authMethods","isPartial","methods","toLowerCase","join","methodsLen","USERAUTH_FAILURE","shift","authSuccess","USERAUTH_SUCCESS","negotiated","cs","compress","sc","authPKOK","keyAlgo","keyAlgoLen","USERAUTH_PK_OK","authPasswdChg","prompt","promptLen","USERAUTH_PASSWD_CHANGEREQ","authInfoReq","instructions","prompts","promptsLen","instrLen","USERAUTH_INFO_REQUEST","echo","RE_IDENT","chunkOffset","Uint8Array","buffer","byteOffset","op","needNL","lineLen","lines","ch","full","latin1Slice","identRaw","m","header","versions","software","comments","getCompatFlags","firstPacket","parsePacket","decrypt","payload","handler","flags","rule","test","bytes","b","opcode","isFinite","module","exports"],"sources":["/home/micqdf/AlpacaPunchTests/maintest/test1/client/node_modules/ssh2/lib/protocol/Protocol.js"],"sourcesContent":["/*\n  TODO:\n    * Replace `buffer._pos` usage in keyParser.js and elsewhere\n    * Utilize optional \"writev\" support when writing packets from\n      cipher.encrypt()\n    * Built-in support for automatic re-keying, on by default\n    * Revisit receiving unexpected/unknown packets\n      * Error (fatal or otherwise) or ignore or pass on to user (in some or all\n        cases)?\n      * Including server/client check for single directional packet types?\n      * Check packets for validity or bail as early as possible?\n    * Automatic re-key every 2**31 packets after the last key exchange (sent or\n      received), as suggested by RFC4344. OpenSSH currently does this.\n    * Automatic re-key every so many blocks depending on cipher. RFC4344:\n         Because of a birthday property of block ciphers and some modes of\n         operation, implementations must be careful not to encrypt too many\n         blocks with the same encryption key.\n\n         Let L be the block length (in bits) of an SSH encryption method's\n         block cipher (e.g., 128 for AES).  If L is at least 128, then, after\n         rekeying, an SSH implementation SHOULD NOT encrypt more than 2**(L/4)\n         blocks before rekeying again.  If L is at least 128, then SSH\n         implementations should also attempt to force a rekey before receiving\n         more than 2**(L/4) blocks.  If L is less than 128 (which is the case\n         for older ciphers such as 3DES, Blowfish, CAST-128, and IDEA), then,\n         although it may be too expensive to rekey every 2**(L/4) blocks, it\n         is still advisable for SSH implementations to follow the original\n         recommendation in [RFC4253]: rekey at least once for every gigabyte\n         of transmitted data.\n\n         Note that if L is less than or equal to 128, then the recommendation\n         in this subsection supersedes the recommendation in Section 3.1.  If\n         an SSH implementation uses a block cipher with a larger block size\n         (e.g., Rijndael with 256-bit blocks), then the recommendations in\n         Section 3.1 may supersede the recommendations in this subsection\n         (depending on the lengths of the packets).\n*/\n\n'use strict';\n\nconst { inspect } = require('util');\n\nconst { bindingAvailable, NullCipher, NullDecipher } = require('./crypto.js');\nconst {\n  COMPAT_CHECKS,\n  DISCONNECT_REASON,\n  MESSAGE,\n  SIGNALS,\n  TERMINAL_MODE,\n} = require('./constants.js');\nconst {\n  DEFAULT_KEXINIT,\n  KexInit,\n  kexinit,\n  onKEXPayload,\n} = require('./kex.js');\nconst {\n  parseKey,\n} = require('./keyParser.js');\nconst MESSAGE_HANDLERS = require('./handlers.js');\nconst {\n  bufferCopy,\n  bufferFill,\n  bufferSlice,\n  convertSignature,\n  sendPacket,\n  writeUInt32BE,\n} = require('./utils.js');\nconst {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter,\n} = require('./zlib.js');\n\nconst MODULE_VER = require('../../package.json').version;\n\nconst VALID_DISCONNECT_REASONS = new Map(\n  Object.values(DISCONNECT_REASON).map((n) => [n, 1])\n);\nconst IDENT_RAW = Buffer.from(`SSH-2.0-ssh2js${MODULE_VER}`);\nconst IDENT = Buffer.from(`${IDENT_RAW}\\r\\n`);\nconst MAX_LINE_LEN = 8192;\nconst MAX_LINES = 1024;\nconst PING_PAYLOAD = Buffer.from([\n  MESSAGE.GLOBAL_REQUEST,\n  // \"keepalive@openssh.com\"\n  0, 0, 0, 21,\n    107, 101, 101, 112, 97, 108, 105, 118, 101, 64, 111, 112, 101, 110, 115,\n    115, 104, 46, 99, 111, 109,\n  // Request a reply\n  1,\n]);\nconst NO_TERMINAL_MODES_BUFFER = Buffer.from([ TERMINAL_MODE.TTY_OP_END ]);\n\nfunction noop() {}\n\n/*\n  Inbound:\n    * kexinit payload (needed only until exchange hash is generated)\n    * raw ident\n    * rekey packet queue\n    * expected packet (implemented as separate _parse() function?)\n  Outbound:\n    * kexinit payload (needed only until exchange hash is generated)\n    * rekey packet queue\n    * kex secret (needed only until NEWKEYS)\n    * exchange hash (needed only until NEWKEYS)\n    * session ID (set to exchange hash from initial handshake)\n*/\nclass Protocol {\n  constructor(config) {\n    const onWrite = config.onWrite;\n    if (typeof onWrite !== 'function')\n      throw new Error('Missing onWrite function');\n    this._onWrite = (data) => { onWrite(data); };\n\n    const onError = config.onError;\n    if (typeof onError !== 'function')\n      throw new Error('Missing onError function');\n    this._onError = (err) => { onError(err); };\n\n    const debug = config.debug;\n    this._debug = (typeof debug === 'function'\n                   ? (msg) => { debug(msg); }\n                   : undefined);\n\n    const onHeader = config.onHeader;\n    this._onHeader = (typeof onHeader === 'function'\n                      ? (...args) => { onHeader(...args); }\n                      : noop);\n\n    const onPacket = config.onPacket;\n    this._onPacket = (typeof onPacket === 'function'\n                      ? () => { onPacket(); }\n                      : noop);\n\n    let onHandshakeComplete = config.onHandshakeComplete;\n    if (typeof onHandshakeComplete !== 'function')\n      onHandshakeComplete = noop;\n    this._onHandshakeComplete = (...args) => {\n      this._debug && this._debug('Handshake completed');\n\n      // Process packets queued during a rekey where necessary\n      const oldQueue = this._queue;\n      if (oldQueue) {\n        this._queue = undefined;\n        this._debug && this._debug(\n          `Draining outbound queue (${oldQueue.length}) ...`\n        );\n        for (let i = 0; i < oldQueue.length; ++i) {\n          const data = oldQueue[i];\n          // data === payload only\n\n          // XXX: hacky\n          let finalized = this._packetRW.write.finalize(data);\n          if (finalized === data) {\n            const packet = this._cipher.allocPacket(data.length);\n            packet.set(data, 5);\n            finalized = packet;\n          }\n\n          sendPacket(this, finalized);\n        }\n        this._debug && this._debug('... finished draining outbound queue');\n      }\n\n      onHandshakeComplete(...args);\n    };\n    this._queue = undefined;\n\n    const messageHandlers = config.messageHandlers;\n    if (typeof messageHandlers === 'object' && messageHandlers !== null)\n      this._handlers = messageHandlers;\n    else\n      this._handlers = {};\n\n    this._onPayload = onPayload.bind(this);\n\n    this._server = !!config.server;\n    this._banner = undefined;\n    let greeting;\n    if (this._server) {\n      if (typeof config.hostKeys !== 'object' || config.hostKeys === null)\n        throw new Error('Missing server host key(s)');\n      this._hostKeys = config.hostKeys;\n\n      // Greeting displayed before the ssh identification string is sent, this\n      // is usually ignored by most clients\n      if (typeof config.greeting === 'string' && config.greeting.length) {\n        greeting = (config.greeting.slice(-2) === '\\r\\n'\n                    ? config.greeting\n                    : `${config.greeting}\\r\\n`);\n      }\n\n      // Banner shown after the handshake completes, but before user\n      // authentication begins\n      if (typeof config.banner === 'string' && config.banner.length) {\n        this._banner = (config.banner.slice(-2) === '\\r\\n'\n                        ? config.banner\n                        : `${config.banner}\\r\\n`);\n      }\n    } else {\n      this._hostKeys = undefined;\n    }\n\n    let offer = config.offer;\n    if (typeof offer !== 'object' || offer === null)\n      offer = DEFAULT_KEXINIT;\n    else if (offer.constructor !== KexInit)\n      offer = new KexInit(offer);\n    this._kex = undefined;\n    this._kexinit = undefined;\n    this._offer = offer;\n    this._cipher = new NullCipher(0, this._onWrite);\n    this._decipher = undefined;\n    this._skipNextInboundPacket = false;\n    this._packetRW = {\n      read: new PacketReader(),\n      write: new PacketWriter(this),\n    };\n    this._hostVerifier = (!this._server\n                           && typeof config.hostVerifier === 'function'\n                          ? config.hostVerifier\n                          : undefined);\n\n    this._parse = parseHeader;\n    this._buffer = undefined;\n    this._authsQueue = [];\n    this._authenticated = false;\n    this._remoteIdentRaw = undefined;\n    let sentIdent;\n    if (typeof config.ident === 'string') {\n      this._identRaw = Buffer.from(`SSH-2.0-${config.ident}`);\n\n      sentIdent = Buffer.allocUnsafe(this._identRaw.length + 2);\n      sentIdent.set(this._identRaw, 0);\n      sentIdent[sentIdent.length - 2] = 13; // '\\r'\n      sentIdent[sentIdent.length - 1] = 10; // '\\n'\n    } else if (Buffer.isBuffer(config.ident)) {\n      const fullIdent = Buffer.allocUnsafe(8 + config.ident.length);\n      fullIdent.latin1Write('SSH-2.0-', 0, 8);\n      fullIdent.set(config.ident, 8);\n      this._identRaw = fullIdent;\n\n      sentIdent = Buffer.allocUnsafe(fullIdent.length + 2);\n      sentIdent.set(fullIdent, 0);\n      sentIdent[sentIdent.length - 2] = 13; // '\\r'\n      sentIdent[sentIdent.length - 1] = 10; // '\\n'\n    } else {\n      this._identRaw = IDENT_RAW;\n      sentIdent = IDENT;\n    }\n    this._compatFlags = 0;\n\n    if (this._debug) {\n      if (bindingAvailable)\n        this._debug('Custom crypto binding available');\n      else\n        this._debug('Custom crypto binding not available');\n    }\n\n    this._debug && this._debug(\n      `Local ident: ${inspect(this._identRaw.toString())}`\n    );\n    this.start = () => {\n      this.start = undefined;\n      if (greeting)\n        this._onWrite(greeting);\n      this._onWrite(sentIdent);\n    };\n  }\n  _destruct(reason) {\n    this._packetRW.read.cleanup();\n    this._packetRW.write.cleanup();\n    this._cipher && this._cipher.free();\n    this._decipher && this._decipher.free();\n    if (typeof reason !== 'string' || reason.length === 0)\n      reason = 'fatal error';\n    this.parse = () => {\n      throw new Error(`Instance unusable after ${reason}`);\n    };\n    this._onWrite = () => {\n      throw new Error(`Instance unusable after ${reason}`);\n    };\n    this._destruct = undefined;\n  }\n  cleanup() {\n    this._destruct && this._destruct();\n  }\n  parse(chunk, i, len) {\n    while (i < len)\n      i = this._parse(chunk, i, len);\n  }\n\n  // Protocol message API\n\n  // ===========================================================================\n  // Common/Shared =============================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  disconnect(reason) {\n    const pktLen = 1 + 4 + 4 + 4;\n    // We don't use _packetRW.write.* here because we need to make sure that\n    // we always get a full packet allocated because this message can be sent\n    // at any time -- even during a key exchange\n    let p = this._packetRW.write.allocStartKEX;\n    const packet = this._packetRW.write.alloc(pktLen, true);\n    const end = p + pktLen;\n\n    if (!VALID_DISCONNECT_REASONS.has(reason))\n      reason = DISCONNECT_REASON.PROTOCOL_ERROR;\n\n    packet[p] = MESSAGE.DISCONNECT;\n    writeUInt32BE(packet, reason, ++p);\n    packet.fill(0, p += 4, end);\n\n    this._debug && this._debug(`Outbound: Sending DISCONNECT (${reason})`);\n    sendPacket(this, this._packetRW.write.finalize(packet, true), true);\n  }\n  ping() {\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(PING_PAYLOAD.length);\n\n    packet.set(PING_PAYLOAD, p);\n\n    this._debug && this._debug(\n      'Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)'\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  rekey() {\n    if (this._kexinit === undefined) {\n      this._debug && this._debug('Outbound: Initiated explicit rekey');\n      this._queue = [];\n      kexinit(this);\n    } else {\n      this._debug && this._debug('Outbound: Ignoring rekey during handshake');\n    }\n  }\n\n  // 'ssh-connection' service-specific\n  // ---------------------------------\n  requestSuccess(data) {\n    let p = this._packetRW.write.allocStart;\n    let packet;\n    if (Buffer.isBuffer(data)) {\n      packet = this._packetRW.write.alloc(1 + data.length);\n\n      packet[p] = MESSAGE.REQUEST_SUCCESS;\n\n      packet.set(data, ++p);\n    } else {\n      packet = this._packetRW.write.alloc(1);\n\n      packet[p] = MESSAGE.REQUEST_SUCCESS;\n    }\n\n    this._debug && this._debug('Outbound: Sending REQUEST_SUCCESS');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  requestFailure() {\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1);\n\n    packet[p] = MESSAGE.REQUEST_FAILURE;\n\n    this._debug && this._debug('Outbound: Sending REQUEST_FAILURE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelSuccess(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_SUCCESS;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelFailure(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_FAILURE;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelEOF(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_EOF;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_EOF (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelClose(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_CLOSE;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelWindowAdjust(chan, amount) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_WINDOW_ADJUST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, amount, p += 4);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${chan}, ${amount})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelData(chan, data) {\n    const isBuffer = Buffer.isBuffer(data);\n    const dataLen = (isBuffer ? data.length : Buffer.byteLength(data));\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + dataLen);\n\n    packet[p] = MESSAGE.CHANNEL_DATA;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, dataLen, p += 4);\n\n    if (isBuffer)\n      packet.set(data, p += 4);\n    else\n      packet.utf8Write(data, p += 4, dataLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_DATA (r:${chan}, ${dataLen})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelExtData(chan, data, type) {\n    const isBuffer = Buffer.isBuffer(data);\n    const dataLen = (isBuffer ? data.length : Buffer.byteLength(data));\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + dataLen);\n\n    packet[p] = MESSAGE.CHANNEL_EXTENDED_DATA;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, type, p += 4);\n\n    writeUInt32BE(packet, dataLen, p += 4);\n\n    if (isBuffer)\n      packet.set(data, p += 4);\n    else\n      packet.utf8Write(data, p += 4, dataLen);\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelOpenConfirm(remote, local, initWindow, maxPacket) {\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;\n\n    writeUInt32BE(packet, remote, ++p);\n\n    writeUInt32BE(packet, local, p += 4);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${remote}, l:${local})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelOpenFail(remote, reason, desc) {\n    if (typeof desc !== 'string')\n      desc = '';\n\n    const descLen = Buffer.byteLength(desc);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + descLen + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN_FAILURE;\n\n    writeUInt32BE(packet, remote, ++p);\n\n    writeUInt32BE(packet, reason, p += 4);\n\n    writeUInt32BE(packet, descLen, p += 4);\n\n    p += 4;\n    if (descLen) {\n      packet.utf8Write(desc, p, descLen);\n      p += descLen;\n    }\n\n    writeUInt32BE(packet, 0, p); // Empty language tag\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${remote})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // ===========================================================================\n  // Client-specific ===========================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  service(name) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const nameLen = Buffer.byteLength(name);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + nameLen);\n\n    packet[p] = MESSAGE.SERVICE_REQUEST;\n\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(name, p += 4, nameLen);\n\n    this._debug && this._debug(`Outbound: Sending SERVICE_REQUEST (${name})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // 'ssh-userauth' service-specific\n  // -------------------------------\n  authPassword(username, password, newPassword) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const userLen = Buffer.byteLength(username);\n    const passLen = Buffer.byteLength(password);\n    const newPassLen = (newPassword ? Buffer.byteLength(newPassword) : 0);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + userLen + 4 + 14 + 4 + 8 + 1 + 4 + passLen\n        + (newPassword ? 4 + newPassLen : 0)\n    );\n\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n\n    writeUInt32BE(packet, 8, p += 14);\n    packet.utf8Write('password', p += 4, 8);\n\n    packet[p += 8] = (newPassword ? 1 : 0);\n\n    writeUInt32BE(packet, passLen, ++p);\n    if (Buffer.isBuffer(password))\n      bufferCopy(password, packet, 0, passLen, p += 4);\n    else\n      packet.utf8Write(password, p += 4, passLen);\n\n    if (newPassword) {\n      writeUInt32BE(packet, newPassLen, p += passLen);\n      if (Buffer.isBuffer(newPassword))\n        bufferCopy(newPassword, packet, 0, newPassLen, p += 4);\n      else\n        packet.utf8Write(newPassword, p += 4, newPassLen);\n      this._debug && this._debug(\n        'Outbound: Sending USERAUTH_REQUEST (changed password)'\n      );\n    } else {\n      this._debug && this._debug(\n        'Outbound: Sending USERAUTH_REQUEST (password)'\n      );\n    }\n\n    this._authsQueue.push('password');\n\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authPK(username, pubKey, cbSign) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    pubKey = parseKey(pubKey);\n    if (pubKey instanceof Error)\n      throw new Error('Invalid key');\n\n    const keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n\n    const userLen = Buffer.byteLength(username);\n    const algoLen = Buffer.byteLength(keyType);\n    const pubKeyLen = pubKey.length;\n    const sessionID = this._kex.sessionID;\n    const sesLen = sessionID.length;\n    const payloadLen =\n      (cbSign ? 4 + sesLen : 0)\n        + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen;\n    let packet;\n    let p;\n    if (cbSign) {\n      packet = Buffer.allocUnsafe(payloadLen);\n      p = 0;\n      writeUInt32BE(packet, sesLen, p);\n      packet.set(sessionID, p += 4);\n      p += sesLen;\n    } else {\n      packet = this._packetRW.write.alloc(payloadLen);\n      p = this._packetRW.write.allocStart;\n    }\n\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n\n    writeUInt32BE(packet, 9, p += 14);\n    packet.utf8Write('publickey', p += 4, 9);\n\n    packet[p += 9] = (cbSign ? 1 : 0);\n\n    writeUInt32BE(packet, algoLen, ++p);\n    packet.utf8Write(keyType, p += 4, algoLen);\n\n    writeUInt32BE(packet, pubKeyLen, p += algoLen);\n    packet.set(pubKey, p += 4);\n\n    if (!cbSign) {\n      this._authsQueue.push('publickey');\n\n      this._debug && this._debug(\n        'Outbound: Sending USERAUTH_REQUEST (publickey -- check)'\n      );\n      sendPacket(this, this._packetRW.write.finalize(packet));\n      return;\n    }\n\n    cbSign(packet, (signature) => {\n      signature = convertSignature(signature, keyType);\n      if (signature === false)\n        throw new Error('Error while converting handshake signature');\n\n      const sigLen = signature.length;\n      p = this._packetRW.write.allocStart;\n      packet = this._packetRW.write.alloc(\n        1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen + 4\n          + 4 + algoLen + 4 + sigLen\n      );\n\n      // TODO: simply copy from original \"packet\" to new `packet` to avoid\n      // having to write each individual field a second time?\n      packet[p] = MESSAGE.USERAUTH_REQUEST;\n\n      writeUInt32BE(packet, userLen, ++p);\n      packet.utf8Write(username, p += 4, userLen);\n\n      writeUInt32BE(packet, 14, p += userLen);\n      packet.utf8Write('ssh-connection', p += 4, 14);\n\n      writeUInt32BE(packet, 9, p += 14);\n      packet.utf8Write('publickey', p += 4, 9);\n\n      packet[p += 9] = 1;\n\n      writeUInt32BE(packet, algoLen, ++p);\n      packet.utf8Write(keyType, p += 4, algoLen);\n\n      writeUInt32BE(packet, pubKeyLen, p += algoLen);\n      packet.set(pubKey, p += 4);\n\n      writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += pubKeyLen);\n\n      writeUInt32BE(packet, algoLen, p += 4);\n      packet.utf8Write(keyType, p += 4, algoLen);\n\n      writeUInt32BE(packet, sigLen, p += algoLen);\n      packet.set(signature, p += 4);\n\n      // Servers shouldn't send packet type 60 in response to signed publickey\n      // attempts, but if they do, interpret as type 60.\n      this._authsQueue.push('publickey');\n\n      this._debug && this._debug(\n        'Outbound: Sending USERAUTH_REQUEST (publickey)'\n      );\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    });\n  }\n  authHostbased(username, pubKey, hostname, userlocal, cbSign) {\n    // TODO: Make DRY by sharing similar code with authPK()\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    pubKey = parseKey(pubKey);\n    if (pubKey instanceof Error)\n      throw new Error('Invalid key');\n\n    const keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n\n    const userLen = Buffer.byteLength(username);\n    const algoLen = Buffer.byteLength(keyType);\n    const pubKeyLen = pubKey.length;\n    const sessionID = this._kex.sessionID;\n    const sesLen = sessionID.length;\n    const hostnameLen = Buffer.byteLength(hostname);\n    const userlocalLen = Buffer.byteLength(userlocal);\n    const data = Buffer.allocUnsafe(\n      4 + sesLen + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 4 + algoLen\n        + 4 + pubKeyLen + 4 + hostnameLen + 4 + userlocalLen\n    );\n    let p = 0;\n\n    writeUInt32BE(data, sesLen, p);\n    data.set(sessionID, p += 4);\n\n    data[p += sesLen] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(data, userLen, ++p);\n    data.utf8Write(username, p += 4, userLen);\n\n    writeUInt32BE(data, 14, p += userLen);\n    data.utf8Write('ssh-connection', p += 4, 14);\n\n    writeUInt32BE(data, 9, p += 14);\n    data.utf8Write('hostbased', p += 4, 9);\n\n    writeUInt32BE(data, algoLen, p += 9);\n    data.utf8Write(keyType, p += 4, algoLen);\n\n    writeUInt32BE(data, pubKeyLen, p += algoLen);\n    data.set(pubKey, p += 4);\n\n    writeUInt32BE(data, hostnameLen, p += pubKeyLen);\n    data.utf8Write(hostname, p += 4, hostnameLen);\n\n    writeUInt32BE(data, userlocalLen, p += hostnameLen);\n    data.utf8Write(userlocal, p += 4, userlocalLen);\n\n    cbSign(data, (signature) => {\n      signature = convertSignature(signature, keyType);\n      if (!signature)\n        throw new Error('Error while converting handshake signature');\n\n      const sigLen = signature.length;\n      const reqDataLen = (data.length - sesLen - 4);\n      p = this._packetRW.write.allocStart;\n      const packet = this._packetRW.write.alloc(\n        reqDataLen + 4 + 4 + algoLen + 4 + sigLen\n      );\n\n      bufferCopy(data, packet, 4 + sesLen, data.length, p);\n\n      writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += reqDataLen);\n      writeUInt32BE(packet, algoLen, p += 4);\n      packet.utf8Write(keyType, p += 4, algoLen);\n      writeUInt32BE(packet, sigLen, p += algoLen);\n      packet.set(signature, p += 4);\n\n      this._authsQueue.push('hostbased');\n\n      this._debug && this._debug(\n        'Outbound: Sending USERAUTH_REQUEST (hostbased)'\n      );\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    });\n  }\n  authKeyboard(username) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const userLen = Buffer.byteLength(username);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + userLen + 4 + 14 + 4 + 20 + 4 + 4\n    );\n\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n\n    writeUInt32BE(packet, 20, p += 14);\n    packet.utf8Write('keyboard-interactive', p += 4, 20);\n\n    writeUInt32BE(packet, 0, p += 20);\n\n    writeUInt32BE(packet, 0, p += 4);\n\n    this._authsQueue.push('keyboard-interactive');\n\n    this._debug && this._debug(\n      'Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)'\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authNone(username) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const userLen = Buffer.byteLength(username);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 4);\n\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n\n    writeUInt32BE(packet, 4, p += 14);\n    packet.utf8Write('none', p += 4, 4);\n\n    this._authsQueue.push('none');\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (none)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authInfoRes(responses) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    let responsesTotalLen = 0;\n    let responseLens;\n\n    if (responses) {\n      responseLens = new Array(responses.length);\n      for (let i = 0; i < responses.length; ++i) {\n        const len = Buffer.byteLength(responses[i]);\n        responseLens[i] = len;\n        responsesTotalLen += 4 + len;\n      }\n    }\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + responsesTotalLen);\n\n    packet[p] = MESSAGE.USERAUTH_INFO_RESPONSE;\n\n    if (responses) {\n      writeUInt32BE(packet, responses.length, ++p);\n      p += 4;\n      for (let i = 0; i < responses.length; ++i) {\n        const len = responseLens[i];\n        writeUInt32BE(packet, len, p);\n        p += 4;\n        if (len) {\n          packet.utf8Write(responses[i], p, len);\n          p += len;\n        }\n      }\n    } else {\n      writeUInt32BE(packet, 0, ++p);\n    }\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_INFO_RESPONSE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // 'ssh-connection' service-specific\n  // ---------------------------------\n  tcpipForward(bindAddr, bindPort, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const addrLen = Buffer.byteLength(bindAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 13 + 1 + 4 + addrLen + 4);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 13, ++p);\n    packet.utf8Write('tcpip-forward', p += 4, 13);\n\n    packet[p += 13] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, addrLen, ++p);\n    packet.utf8Write(bindAddr, p += 4, addrLen);\n\n    writeUInt32BE(packet, bindPort, p += addrLen);\n\n    this._debug\n      && this._debug('Outbound: Sending GLOBAL_REQUEST (tcpip-forward)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  cancelTcpipForward(bindAddr, bindPort, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const addrLen = Buffer.byteLength(bindAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 20 + 1 + 4 + addrLen + 4);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 20, ++p);\n    packet.utf8Write('cancel-tcpip-forward', p += 4, 20);\n\n    packet[p += 20] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, addrLen, ++p);\n    packet.utf8Write(bindAddr, p += 4, addrLen);\n\n    writeUInt32BE(packet, bindPort, p += addrLen);\n\n    this._debug\n      && this._debug('Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_streamLocalForward(socketPath, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const socketPathLen = Buffer.byteLength(socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 31 + 1 + 4 + socketPathLen\n    );\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 31, ++p);\n    packet.utf8Write('streamlocal-forward@openssh.com', p += 4, 31);\n\n    packet[p += 31] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, socketPathLen, ++p);\n    packet.utf8Write(socketPath, p += 4, socketPathLen);\n\n    this._debug && this._debug(\n      'Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)'\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_cancelStreamLocalForward(socketPath, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const socketPathLen = Buffer.byteLength(socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 38 + 1 + 4 + socketPathLen\n    );\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 38, ++p);\n    packet.utf8Write('cancel-streamlocal-forward@openssh.com', p += 4, 38);\n\n    packet[p += 38] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, socketPathLen, ++p);\n    packet.utf8Write(socketPath, p += 4, socketPathLen);\n\n    if (this._debug) {\n      this._debug(\n        'Outbound: Sending GLOBAL_REQUEST '\n          + '(cancel-streamlocal-forward@openssh.com)'\n      );\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  directTcpip(chan, initWindow, maxPacket, cfg) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const srcLen = Buffer.byteLength(cfg.srcIP);\n    const dstLen = Buffer.byteLength(cfg.dstIP);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 12 + 4 + 4 + 4 + 4 + srcLen + 4 + 4 + dstLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 12, ++p);\n    packet.utf8Write('direct-tcpip', p += 4, 12);\n\n    writeUInt32BE(packet, chan, p += 12);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    writeUInt32BE(packet, dstLen, p += 4);\n    packet.utf8Write(cfg.dstIP, p += 4, dstLen);\n\n    writeUInt32BE(packet, cfg.dstPort, p += dstLen);\n\n    writeUInt32BE(packet, srcLen, p += 4);\n    packet.utf8Write(cfg.srcIP, p += 4, srcLen);\n\n    writeUInt32BE(packet, cfg.srcPort, p += srcLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-tcpip)`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_directStreamLocal(chan, initWindow, maxPacket, cfg) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const pathLen = Buffer.byteLength(cfg.socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 30 + 4 + 4 + 4 + 4 + pathLen + 4 + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 30, ++p);\n    packet.utf8Write('direct-streamlocal@openssh.com', p += 4, 30);\n\n    writeUInt32BE(packet, chan, p += 30);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    writeUInt32BE(packet, pathLen, p += 4);\n    packet.utf8Write(cfg.socketPath, p += 4, pathLen);\n\n    // zero-fill reserved fields (string and uint32)\n    bufferFill(packet, 0, p += pathLen, p + 8);\n\n    if (this._debug) {\n      this._debug(\n        'Outbound: Sending CHANNEL_OPEN '\n          + `(r:${chan}, direct-streamlocal@openssh.com)`\n      );\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_noMoreSessions(wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 28 + 1);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 28, ++p);\n    packet.utf8Write('no-more-sessions@openssh.com', p += 4, 28);\n\n    packet[p += 28] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    this._debug && this._debug(\n      'Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)'\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  session(chan, initWindow, maxPacket) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 7 + 4 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 7, ++p);\n    packet.utf8Write('session', p += 4, 7);\n\n    writeUInt32BE(packet, chan, p += 7);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, session)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  windowChange(chan, rows, cols, height, width) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 13, p += 4);\n    packet.utf8Write('window-change', p += 4, 13);\n\n    packet[p += 13] = 0;\n\n    writeUInt32BE(packet, cols, ++p);\n\n    writeUInt32BE(packet, rows, p += 4);\n\n    writeUInt32BE(packet, width, p += 4);\n\n    writeUInt32BE(packet, height, p += 4);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, window-change)`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  pty(chan, rows, cols, height, width, term, modes, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    if (!term || !term.length)\n      term = 'vt100';\n    if (modes\n        && !Buffer.isBuffer(modes)\n        && !Array.isArray(modes)\n        && typeof modes === 'object'\n        && modes !== null) {\n      modes = modesToBytes(modes);\n    }\n    if (!modes || !modes.length)\n      modes = NO_TERMINAL_MODES_BUFFER;\n\n    const termLen = term.length;\n    const modesLen = modes.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4 + 4 + modesLen\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 7, p += 4);\n    packet.utf8Write('pty-req', p += 4, 7);\n\n    packet[p += 7] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, termLen, ++p);\n    packet.utf8Write(term, p += 4, termLen);\n\n    writeUInt32BE(packet, cols, p += termLen);\n\n    writeUInt32BE(packet, rows, p += 4);\n\n    writeUInt32BE(packet, width, p += 4);\n\n    writeUInt32BE(packet, height, p += 4);\n\n    writeUInt32BE(packet, modesLen, p += 4);\n    p += 4;\n    if (Array.isArray(modes)) {\n      for (let i = 0; i < modesLen; ++i)\n        packet[p++] = modes[i];\n    } else if (Buffer.isBuffer(modes)) {\n      packet.set(modes, p);\n    }\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, pty-req)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  shell(chan, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 5 + 1);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 5, p += 4);\n    packet.utf8Write('shell', p += 4, 5);\n\n    packet[p += 5] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, shell)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exec(chan, cmd, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const isBuf = Buffer.isBuffer(cmd);\n    const cmdLen = (isBuf ? cmd.length : Buffer.byteLength(cmd));\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 1 + 4 + cmdLen);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 4, p += 4);\n    packet.utf8Write('exec', p += 4, 4);\n\n    packet[p += 4] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, cmdLen, ++p);\n    if (isBuf)\n      packet.set(cmd, p += 4);\n    else\n      packet.utf8Write(cmd, p += 4, cmdLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exec: ${cmd})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  signal(chan, signal) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const origSignal = signal;\n\n    signal = signal.toUpperCase();\n    if (signal.slice(0, 3) === 'SIG')\n      signal = signal.slice(3);\n\n    if (SIGNALS[signal] !== 1)\n      throw new Error(`Invalid signal: ${origSignal}`);\n\n    const signalLen = signal.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 6 + 1 + 4 + signalLen\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 6, p += 4);\n    packet.utf8Write('signal', p += 4, 6);\n\n    packet[p += 6] = 0;\n\n    writeUInt32BE(packet, signalLen, ++p);\n    packet.utf8Write(signal, p += 4, signalLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, signal: ${signal})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  env(chan, key, val, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const keyLen = Buffer.byteLength(key);\n    const isBuf = Buffer.isBuffer(val);\n    const valLen = (isBuf ? val.length : Buffer.byteLength(val));\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 3, p += 4);\n    packet.utf8Write('env', p += 4, 3);\n\n    packet[p += 3] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, keyLen, ++p);\n    packet.utf8Write(key, p += 4, keyLen);\n\n    writeUInt32BE(packet, valLen, p += keyLen);\n    if (isBuf)\n      packet.set(val, p += 4);\n    else\n      packet.utf8Write(val, p += 4, valLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, env: ${key}=${val})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  x11Forward(chan, cfg, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const protocol = cfg.protocol;\n    const cookie = cfg.cookie;\n    const isBufProto = Buffer.isBuffer(protocol);\n    const protoLen = (isBufProto\n                      ? protocol.length\n                      : Buffer.byteLength(protocol));\n    const isBufCookie = Buffer.isBuffer(cookie);\n    const cookieLen = (isBufCookie\n                       ? cookie.length\n                       : Buffer.byteLength(cookie));\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 7 + 1 + 1 + 4 + protoLen + 4 + cookieLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 7, p += 4);\n    packet.utf8Write('x11-req', p += 4, 7);\n\n    packet[p += 7] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    packet[++p] = (cfg.single ? 1 : 0);\n\n    writeUInt32BE(packet, protoLen, ++p);\n    if (isBufProto)\n      packet.set(protocol, p += 4);\n    else\n      packet.utf8Write(protocol, p += 4, protoLen);\n\n    writeUInt32BE(packet, cookieLen, p += protoLen);\n    if (isBufCookie)\n      packet.set(cookie, p += 4);\n    else\n      packet.latin1Write(cookie, p += 4, cookieLen);\n\n    writeUInt32BE(packet, (cfg.screen || 0), p += cookieLen);\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, x11-req)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  subsystem(chan, name, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n    const nameLen = Buffer.byteLength(name);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 9 + 1 + 4 + nameLen);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 9, p += 4);\n    packet.utf8Write('subsystem', p += 4, 9);\n\n    packet[p += 9] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(name, p += 4, nameLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, subsystem: ${name})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_agentForward(chan, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 26 + 1);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 26, p += 4);\n    packet.utf8Write('auth-agent-req@openssh.com', p += 4, 26);\n\n    packet[p += 26] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    if (this._debug) {\n      this._debug(\n        'Outbound: Sending CHANNEL_REQUEST '\n          + `(r:${chan}, auth-agent-req@openssh.com)`\n      );\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_hostKeysProve(keys) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    let keysTotal = 0;\n    const publicKeys = [];\n    for (const key of keys) {\n      const publicKey = key.getPublicSSH();\n      keysTotal += 4 + publicKey.length;\n      publicKeys.push(publicKey);\n    }\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 29 + 1 + keysTotal);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 29, ++p);\n    packet.utf8Write('hostkeys-prove-00@openssh.com', p += 4, 29);\n\n    packet[p += 29] = 1; // want reply\n\n    ++p;\n    for (const buf of publicKeys) {\n      writeUInt32BE(packet, buf.length, p);\n      bufferCopy(buf, packet, 0, buf.length, p += 4);\n      p += buf.length;\n    }\n\n    if (this._debug) {\n      this._debug(\n        'Outbound: Sending GLOBAL_REQUEST (hostkeys-prove-00@openssh.com)'\n      );\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // ===========================================================================\n  // Server-specific ===========================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  serviceAccept(svcName) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    const svcNameLen = Buffer.byteLength(svcName);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + svcNameLen);\n\n    packet[p] = MESSAGE.SERVICE_ACCEPT;\n\n    writeUInt32BE(packet, svcNameLen, ++p);\n    packet.utf8Write(svcName, p += 4, svcNameLen);\n\n    this._debug && this._debug(`Outbound: Sending SERVICE_ACCEPT (${svcName})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n\n    if (this._server && this._banner && svcName === 'ssh-userauth') {\n      const banner = this._banner;\n      this._banner = undefined; // Prevent banner from being displayed again\n      const bannerLen = Buffer.byteLength(banner);\n      p = this._packetRW.write.allocStart;\n      const packet = this._packetRW.write.alloc(1 + 4 + bannerLen + 4);\n\n      packet[p] = MESSAGE.USERAUTH_BANNER;\n\n      writeUInt32BE(packet, bannerLen, ++p);\n      packet.utf8Write(banner, p += 4, bannerLen);\n\n      writeUInt32BE(packet, 0, p += bannerLen); // Empty language tag\n\n      this._debug && this._debug('Outbound: Sending USERAUTH_BANNER');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    }\n  }\n  // 'ssh-connection' service-specific\n  forwardedTcpip(chan, initWindow, maxPacket, cfg) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    const boundAddrLen = Buffer.byteLength(cfg.boundAddr);\n    const remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4 + remoteAddrLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 15, ++p);\n    packet.utf8Write('forwarded-tcpip', p += 4, 15);\n\n    writeUInt32BE(packet, chan, p += 15);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    writeUInt32BE(packet, boundAddrLen, p += 4);\n    packet.utf8Write(cfg.boundAddr, p += 4, boundAddrLen);\n\n    writeUInt32BE(packet, cfg.boundPort, p += boundAddrLen);\n\n    writeUInt32BE(packet, remoteAddrLen, p += 4);\n    packet.utf8Write(cfg.remoteAddr, p += 4, remoteAddrLen);\n\n    writeUInt32BE(packet, cfg.remotePort, p += remoteAddrLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-tcpip)`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  x11(chan, initWindow, maxPacket, cfg) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    const addrLen = Buffer.byteLength(cfg.originAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 3, ++p);\n    packet.utf8Write('x11', p += 4, 3);\n\n    writeUInt32BE(packet, chan, p += 3);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    writeUInt32BE(packet, addrLen, p += 4);\n    packet.utf8Write(cfg.originAddr, p += 4, addrLen);\n\n    writeUInt32BE(packet, cfg.originPort, p += addrLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_OPEN (r:${chan}, x11)`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_authAgent(chan, initWindow, maxPacket) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 22 + 4 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 22, ++p);\n    packet.utf8Write('auth-agent@openssh.com', p += 4, 22);\n\n    writeUInt32BE(packet, chan, p += 22);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_OPEN (r:${chan}, auth-agent@openssh.com)`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_forwardedStreamLocal(chan, initWindow, maxPacket, cfg) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    const pathLen = Buffer.byteLength(cfg.socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 33 + 4 + 4 + 4 + 4 + pathLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 33, ++p);\n    packet.utf8Write('forwarded-streamlocal@openssh.com', p += 4, 33);\n\n    writeUInt32BE(packet, chan, p += 33);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    writeUInt32BE(packet, pathLen, p += 4);\n    packet.utf8Write(cfg.socketPath, p += 4, pathLen);\n\n    writeUInt32BE(packet, 0, p += pathLen);\n\n    if (this._debug) {\n      this._debug(\n        'Outbound: Sending CHANNEL_OPEN '\n          + `(r:${chan}, forwarded-streamlocal@openssh.com)`\n      );\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exitStatus(chan, status) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    // Does not consume window space\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 11, p += 4);\n    packet.utf8Write('exit-status', p += 4, 11);\n\n    packet[p += 11] = 0;\n\n    writeUInt32BE(packet, status, ++p);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-status: ${status})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exitSignal(chan, name, coreDumped, msg) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    // Does not consume window space\n\n    const origSignal = name;\n\n    if (typeof origSignal !== 'string' || !origSignal)\n      throw new Error(`Invalid signal: ${origSignal}`);\n\n    let signal = name.toUpperCase();\n    if (signal.slice(0, 3) === 'SIG')\n      signal = signal.slice(3);\n\n    if (SIGNALS[signal] !== 1)\n      throw new Error(`Invalid signal: ${origSignal}`);\n\n    const nameLen = Buffer.byteLength(signal);\n    const msgLen = (msg ? Buffer.byteLength(msg) : 0);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 11, p += 4);\n    packet.utf8Write('exit-signal', p += 4, 11);\n\n    packet[p += 11] = 0;\n\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(signal, p += 4, nameLen);\n\n    packet[p += nameLen] = (coreDumped ? 1 : 0);\n\n    writeUInt32BE(packet, msgLen, ++p);\n\n    p += 4;\n    if (msgLen) {\n      packet.utf8Write(msg, p, msgLen);\n      p += msgLen;\n    }\n\n    writeUInt32BE(packet, 0, p);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-signal: ${name})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  // 'ssh-userauth' service-specific\n  authFailure(authMethods, isPartial) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    if (this._authsQueue.length === 0)\n      throw new Error('No auth in progress');\n\n    let methods;\n\n    if (typeof authMethods === 'boolean') {\n      isPartial = authMethods;\n      authMethods = undefined;\n    }\n\n    if (authMethods) {\n      methods = [];\n      for (let i = 0; i < authMethods.length; ++i) {\n        if (authMethods[i].toLowerCase() === 'none')\n          continue;\n        methods.push(authMethods[i]);\n      }\n      methods = methods.join(',');\n    } else {\n      methods = '';\n    }\n\n    const methodsLen = methods.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + methodsLen + 1);\n\n    packet[p] = MESSAGE.USERAUTH_FAILURE;\n\n    writeUInt32BE(packet, methodsLen, ++p);\n    packet.utf8Write(methods, p += 4, methodsLen);\n\n    packet[p += methodsLen] = (isPartial === true ? 1 : 0);\n\n    this._authsQueue.shift();\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_FAILURE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authSuccess() {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    if (this._authsQueue.length === 0)\n      throw new Error('No auth in progress');\n\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1);\n\n    packet[p] = MESSAGE.USERAUTH_SUCCESS;\n\n    this._authsQueue.shift();\n    this._authenticated = true;\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_SUCCESS');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n\n    if (this._kex.negotiated.cs.compress === 'zlib@openssh.com')\n      this._packetRW.read = new ZlibPacketReader();\n    if (this._kex.negotiated.sc.compress === 'zlib@openssh.com')\n      this._packetRW.write = new ZlibPacketWriter(this);\n  }\n  authPKOK(keyAlgo, key) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    if (this._authsQueue.length === 0 || this._authsQueue[0] !== 'publickey')\n      throw new Error('\"publickey\" auth not in progress');\n\n    // TODO: support parsed key for `key`\n\n    const keyAlgoLen = Buffer.byteLength(keyAlgo);\n    const keyLen = key.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + keyAlgoLen + 4 + keyLen);\n\n    packet[p] = MESSAGE.USERAUTH_PK_OK;\n\n    writeUInt32BE(packet, keyAlgoLen, ++p);\n    packet.utf8Write(keyAlgo, p += 4, keyAlgoLen);\n\n    writeUInt32BE(packet, keyLen, p += keyAlgoLen);\n    packet.set(key, p += 4);\n\n    this._authsQueue.shift();\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_PK_OK');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authPasswdChg(prompt) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    const promptLen = Buffer.byteLength(prompt);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + promptLen + 4);\n\n    packet[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;\n\n    writeUInt32BE(packet, promptLen, ++p);\n    packet.utf8Write(prompt, p += 4, promptLen);\n\n    writeUInt32BE(packet, 0, p += promptLen); // Empty language tag\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_PASSWD_CHANGEREQ');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authInfoReq(name, instructions, prompts) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    let promptsLen = 0;\n    const nameLen = name ? Buffer.byteLength(name) : 0;\n    const instrLen = instructions ? Buffer.byteLength(instructions) : 0;\n\n    for (let i = 0; i < prompts.length; ++i)\n      promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + nameLen + 4 + instrLen + 4 + 4 + promptsLen\n    );\n\n    packet[p] = MESSAGE.USERAUTH_INFO_REQUEST;\n\n    writeUInt32BE(packet, nameLen, ++p);\n    p += 4;\n    if (name) {\n      packet.utf8Write(name, p, nameLen);\n      p += nameLen;\n    }\n\n    writeUInt32BE(packet, instrLen, p);\n    p += 4;\n    if (instructions) {\n      packet.utf8Write(instructions, p, instrLen);\n      p += instrLen;\n    }\n\n    writeUInt32BE(packet, 0, p);\n\n    writeUInt32BE(packet, prompts.length, p += 4);\n    p += 4;\n    for (let i = 0; i < prompts.length; ++i) {\n      const prompt = prompts[i];\n      const promptLen = Buffer.byteLength(prompt.prompt);\n\n      writeUInt32BE(packet, promptLen, p);\n      p += 4;\n      if (promptLen) {\n        packet.utf8Write(prompt.prompt, p, promptLen);\n        p += promptLen;\n      }\n      packet[p++] = (prompt.echo ? 1 : 0);\n    }\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_INFO_REQUEST');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n}\n\n// SSH-protoversion-softwareversion (SP comments) CR LF\nconst RE_IDENT = /^SSH-(2\\.0|1\\.99)-([^ ]+)(?: (.*))?$/;\n\n// TODO: optimize this by starting n bytes from the end of this._buffer instead\n// of the beginning\nfunction parseHeader(chunk, p, len) {\n  let data;\n  let chunkOffset;\n  if (this._buffer) {\n    data = Buffer.allocUnsafe(this._buffer.length + (len - p));\n    data.set(this._buffer, 0);\n    if (p === 0) {\n      data.set(chunk, this._buffer.length);\n    } else {\n      data.set(new Uint8Array(chunk.buffer,\n                              chunk.byteOffset + p,\n                              (len - p)),\n               this._buffer.length);\n    }\n    chunkOffset = this._buffer.length;\n    p = 0;\n  } else {\n    data = chunk;\n    chunkOffset = 0;\n  }\n  const op = p;\n  let start = p;\n  let end = p;\n  let needNL = false;\n  let lineLen = 0;\n  let lines = 0;\n  for (; p < data.length; ++p) {\n    const ch = data[p];\n\n    if (ch === 13 /* '\\r' */) {\n      needNL = true;\n      continue;\n    }\n\n    if (ch === 10 /* '\\n' */) {\n      if (end > start\n          && end - start > 4\n          && data[start] === 83 /* 'S' */\n          && data[start + 1] === 83 /* 'S' */\n          && data[start + 2] === 72 /* 'H' */\n          && data[start + 3] === 45 /* '-' */) {\n\n        const full = data.latin1Slice(op, end + 1);\n        const identRaw = (start === op ? full : full.slice(start - op));\n        const m = RE_IDENT.exec(identRaw);\n        if (!m)\n          throw new Error('Invalid identification string');\n\n        const header = {\n          greeting: (start === op ? '' : full.slice(0, start - op)),\n          identRaw,\n          versions: {\n            protocol: m[1],\n            software: m[2],\n          },\n          comments: m[3]\n        };\n\n        // Needed during handshake\n        this._remoteIdentRaw = Buffer.from(identRaw);\n\n        this._debug && this._debug(`Remote ident: ${inspect(identRaw)}`);\n        this._compatFlags = getCompatFlags(header);\n\n        this._buffer = undefined;\n        this._decipher =\n          new NullDecipher(0, onKEXPayload.bind(this, { firstPacket: true }));\n        this._parse = parsePacket;\n\n        this._onHeader(header);\n        if (!this._destruct) {\n          // We disconnected inside _onHeader\n          return len;\n        }\n\n        kexinit(this);\n\n        return p + 1 - chunkOffset;\n      }\n\n      // Only allow pre-ident greetings when we're a client\n      if (this._server)\n        throw new Error('Greetings from clients not permitted');\n\n      if (++lines > MAX_LINES)\n        throw new Error('Max greeting lines exceeded');\n\n      needNL = false;\n      start = p + 1;\n      lineLen = 0;\n    } else if (needNL) {\n      throw new Error('Invalid header: expected newline');\n    } else if (++lineLen >= MAX_LINE_LEN) {\n      throw new Error('Header line too long');\n    }\n\n    end = p;\n  }\n  if (!this._buffer)\n    this._buffer = bufferSlice(data, op);\n\n  return p - chunkOffset;\n}\n\nfunction parsePacket(chunk, p, len) {\n  return this._decipher.decrypt(chunk, p, len);\n}\n\nfunction onPayload(payload) {\n  // XXX: move this to the Decipher implementations?\n\n  this._onPacket();\n\n  if (payload.length === 0) {\n    this._debug && this._debug('Inbound: Skipping empty packet payload');\n    return;\n  }\n\n  payload = this._packetRW.read.read(payload);\n\n  const type = payload[0];\n  if (type === MESSAGE.USERAUTH_SUCCESS\n      && !this._server\n      && !this._authenticated) {\n    this._authenticated = true;\n    if (this._kex.negotiated.cs.compress === 'zlib@openssh.com')\n      this._packetRW.write = new ZlibPacketWriter(this);\n    if (this._kex.negotiated.sc.compress === 'zlib@openssh.com')\n      this._packetRW.read = new ZlibPacketReader();\n  }\n  const handler = MESSAGE_HANDLERS[type];\n  if (handler === undefined) {\n    this._debug && this._debug(`Inbound: Unsupported message type: ${type}`);\n    return;\n  }\n\n  return handler(this, payload);\n}\n\nfunction getCompatFlags(header) {\n  const software = header.versions.software;\n\n  let flags = 0;\n\n  for (const rule of COMPAT_CHECKS) {\n    if (typeof rule[0] === 'string') {\n      if (software === rule[0])\n        flags |= rule[1];\n    } else if (rule[0].test(software)) {\n      flags |= rule[1];\n    }\n  }\n\n  return flags;\n}\n\nfunction modesToBytes(modes) {\n  const keys = Object.keys(modes);\n  const bytes = Buffer.allocUnsafe((5 * keys.length) + 1);\n  let b = 0;\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (key === 'TTY_OP_END')\n      continue;\n\n    const opcode = TERMINAL_MODE[key];\n    if (opcode === undefined)\n      continue;\n\n    const val = modes[key];\n    if (typeof val === 'number' && isFinite(val)) {\n      bytes[b++] = opcode;\n      bytes[b++] = val >>> 24;\n      bytes[b++] = val >>> 16;\n      bytes[b++] = val >>> 8;\n      bytes[b++] = val;\n    }\n  }\n\n  bytes[b++] = TERMINAL_MODE.TTY_OP_END;\n\n  if (b < bytes.length)\n    return bufferSlice(bytes, 0, b);\n\n  return bytes;\n}\n\nmodule.exports = Protocol;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}