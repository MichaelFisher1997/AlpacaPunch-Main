{"ast":null,"code":"'use strict';\n\nconst {\n  SFTP\n} = require('./protocol/SFTP.js');\n\nconst MAX_CHANNEL = 2 ** 32 - 1;\n\nfunction onChannelOpenFailure(self, recipient, info, cb) {\n  self._chanMgr.remove(recipient);\n\n  if (typeof cb !== 'function') return;\n  let err;\n\n  if (info instanceof Error) {\n    err = info;\n  } else if (typeof info === 'object' && info !== null) {\n    err = new Error(`(SSH) Channel open failure: ${info.description}`);\n    err.reason = info.reason;\n  } else {\n    err = new Error('(SSH) Channel open failure: server closed channel unexpectedly');\n    err.reason = '';\n  }\n\n  cb(err);\n}\n\nfunction onCHANNEL_CLOSE(self, recipient, channel, err, dead) {\n  if (typeof channel === 'function') {\n    // We got CHANNEL_CLOSE instead of CHANNEL_OPEN_FAILURE when\n    // requesting to open a channel\n    onChannelOpenFailure(self, recipient, err, channel);\n    return;\n  }\n\n  if (typeof channel !== 'object' || channel === null) return;\n  if (channel.incoming && channel.incoming.state === 'closed') return;\n\n  self._chanMgr.remove(recipient);\n\n  if (channel.server && channel.constructor.name === 'Session') return;\n  channel.incoming.state = 'closed';\n  if (channel.readable) channel.push(null);\n\n  if (channel.server) {\n    if (channel.stderr.writable) channel.stderr.end();\n  } else if (channel.stderr.readable) {\n    channel.stderr.push(null);\n  }\n\n  if (channel.constructor !== SFTP && (channel.outgoing.state === 'open' || channel.outgoing.state === 'eof') && !dead) {\n    channel.close();\n  }\n\n  if (channel.outgoing.state === 'closing') channel.outgoing.state = 'closed';\n  const readState = channel._readableState;\n  const writeState = channel._writableState;\n  if (writeState && !writeState.ending && !writeState.finished && !dead) channel.end(); // Take care of any outstanding channel requests\n\n  const chanCallbacks = channel._callbacks;\n  channel._callbacks = [];\n\n  for (let i = 0; i < chanCallbacks.length; ++i) chanCallbacks[i](true);\n\n  if (channel.server) {\n    if (!channel.readable || channel.destroyed || readState && readState.endEmitted) {\n      channel.emit('close');\n    } else {\n      channel.once('end', () => channel.emit('close'));\n    }\n  } else {\n    let doClose;\n\n    switch (channel.type) {\n      case 'direct-streamlocal@openssh.com':\n      case 'direct-tcpip':\n        doClose = () => channel.emit('close');\n\n        break;\n\n      default:\n        {\n          // Align more with node child processes, where the close event gets\n          // the same arguments as the exit event\n          const exit = channel._exit;\n\n          doClose = () => {\n            if (exit.code === null) channel.emit('close', exit.code, exit.signal, exit.dump, exit.desc);else channel.emit('close', exit.code);\n          };\n        }\n    }\n\n    if (!channel.readable || channel.destroyed || readState && readState.endEmitted) {\n      doClose();\n    } else {\n      channel.once('end', doClose);\n    }\n\n    const errReadState = channel.stderr._readableState;\n\n    if (!channel.stderr.readable || channel.stderr.destroyed || errReadState && errReadState.endEmitted) {\n      channel.stderr.emit('close');\n    } else {\n      channel.stderr.once('end', () => channel.stderr.emit('close'));\n    }\n  }\n}\n\nclass ChannelManager {\n  constructor(client) {\n    this._client = client;\n    this._channels = {};\n    this._cur = -1;\n    this._count = 0;\n  }\n\n  add(val) {\n    // Attempt to reserve an id\n    let id; // Optimized paths\n\n    if (this._cur < MAX_CHANNEL) {\n      id = ++this._cur;\n    } else if (this._count === 0) {\n      // Revert and reset back to fast path once we no longer have any channels\n      // open\n      this._cur = 0;\n      id = 0;\n    } else {\n      // Slower lookup path\n      // This path is triggered we have opened at least MAX_CHANNEL channels\n      // while having at least one channel open at any given time, so we have\n      // to search for a free id.\n      const channels = this._channels;\n\n      for (let i = 0; i < MAX_CHANNEL; ++i) {\n        if (channels[i] === undefined) {\n          id = i;\n          break;\n        }\n      }\n    }\n\n    if (id === undefined) return -1;\n    this._channels[id] = val || true;\n    ++this._count;\n    return id;\n  }\n\n  update(id, val) {\n    if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id)) throw new Error(`Invalid channel id: ${id}`);\n    if (val && this._channels[id]) this._channels[id] = val;\n  }\n\n  get(id) {\n    if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id)) throw new Error(`Invalid channel id: ${id}`);\n    return this._channels[id];\n  }\n\n  remove(id) {\n    if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id)) throw new Error(`Invalid channel id: ${id}`);\n\n    if (this._channels[id]) {\n      delete this._channels[id];\n      if (this._count) --this._count;\n    }\n  }\n\n  cleanup(err) {\n    const channels = this._channels;\n    this._channels = {};\n    this._cur = -1;\n    this._count = 0;\n    const chanIDs = Object.keys(channels);\n    const client = this._client;\n\n    for (let i = 0; i < chanIDs.length; ++i) {\n      const id = +chanIDs[i];\n      const channel = channels[id];\n      onCHANNEL_CLOSE(client, id, channel._channel || channel, err, true);\n    }\n  }\n\n}\n\nconst isRegExp = (() => {\n  const toString = Object.prototype.toString;\n  return val => toString.call(val) === '[object RegExp]';\n})();\n\nfunction generateAlgorithmList(algoList, defaultList, supportedList) {\n  if (Array.isArray(algoList) && algoList.length > 0) {\n    // Exact list\n    for (let i = 0; i < algoList.length; ++i) {\n      if (supportedList.indexOf(algoList[i]) === -1) throw new Error(`Unsupported algorithm: ${algoList[i]}`);\n    }\n\n    return algoList;\n  }\n\n  if (typeof algoList === 'object' && algoList !== null) {\n    // Operations based on the default list\n    const keys = Object.keys(algoList);\n    let list = defaultList;\n\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      let val = algoList[key];\n\n      switch (key) {\n        case 'append':\n          if (!Array.isArray(val)) val = [val];\n\n          if (Array.isArray(val)) {\n            for (let j = 0; j < val.length; ++j) {\n              const append = val[j];\n\n              if (typeof append === 'string') {\n                if (!append || list.indexOf(append) !== -1) continue;\n                if (supportedList.indexOf(append) === -1) throw new Error(`Unsupported algorithm: ${append}`);\n                if (list === defaultList) list = list.slice();\n                list.push(append);\n              } else if (isRegExp(append)) {\n                for (let k = 0; k < supportedList.length; ++k) {\n                  const algo = supportedList[k];\n\n                  if (append.test(algo)) {\n                    if (list.indexOf(algo) !== -1) continue;\n                    if (list === defaultList) list = list.slice();\n                    list.push(algo);\n                  }\n                }\n              }\n            }\n          }\n\n          break;\n\n        case 'prepend':\n          if (!Array.isArray(val)) val = [val];\n\n          if (Array.isArray(val)) {\n            for (let j = val.length; j >= 0; --j) {\n              const prepend = val[j];\n\n              if (typeof prepend === 'string') {\n                if (!prepend || list.indexOf(prepend) !== -1) continue;\n                if (supportedList.indexOf(prepend) === -1) throw new Error(`Unsupported algorithm: ${prepend}`);\n                if (list === defaultList) list = list.slice();\n                list.unshift(prepend);\n              } else if (isRegExp(prepend)) {\n                for (let k = supportedList.length; k >= 0; --k) {\n                  const algo = supportedList[k];\n\n                  if (prepend.test(algo)) {\n                    if (list.indexOf(algo) !== -1) continue;\n                    if (list === defaultList) list = list.slice();\n                    list.unshift(algo);\n                  }\n                }\n              }\n            }\n          }\n\n          break;\n\n        case 'remove':\n          if (!Array.isArray(val)) val = [val];\n\n          if (Array.isArray(val)) {\n            for (let j = 0; j < val.length; ++j) {\n              const search = val[j];\n\n              if (typeof search === 'string') {\n                if (!search) continue;\n                const idx = list.indexOf(search);\n                if (idx === -1) continue;\n                if (list === defaultList) list = list.slice();\n                list.splice(idx, 1);\n              } else if (isRegExp(search)) {\n                for (let k = 0; k < list.length; ++k) {\n                  if (search.test(list[k])) {\n                    if (list === defaultList) list = list.slice();\n                    list.splice(k, 1);\n                    --k;\n                  }\n                }\n              }\n            }\n          }\n\n          break;\n      }\n    }\n\n    return list;\n  }\n\n  return defaultList;\n}\n\nmodule.exports = {\n  ChannelManager,\n  generateAlgorithmList,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE,\n  isWritable: stream => {\n    // XXX: hack to workaround regression in node\n    // See: https://github.com/nodejs/node/issues/36029\n    return stream && stream.writable && stream._readableState && stream._readableState.ended === false;\n  }\n};","map":{"version":3,"names":["SFTP","require","MAX_CHANNEL","onChannelOpenFailure","self","recipient","info","cb","_chanMgr","remove","err","Error","description","reason","onCHANNEL_CLOSE","channel","dead","incoming","state","server","constructor","name","readable","push","stderr","writable","end","outgoing","close","readState","_readableState","writeState","_writableState","ending","finished","chanCallbacks","_callbacks","i","length","destroyed","endEmitted","emit","once","doClose","type","exit","_exit","code","signal","dump","desc","errReadState","ChannelManager","client","_client","_channels","_cur","_count","add","val","id","channels","undefined","update","isFinite","get","cleanup","chanIDs","Object","keys","_channel","isRegExp","toString","prototype","call","generateAlgorithmList","algoList","defaultList","supportedList","Array","isArray","indexOf","list","key","j","append","slice","k","algo","test","prepend","unshift","search","idx","splice","module","exports","isWritable","stream","ended"],"sources":["/home/micqdf/AlpacaPunchTests/maintest/test1/client/node_modules/ssh2/lib/utils.js"],"sourcesContent":["'use strict';\n\nconst { SFTP } = require('./protocol/SFTP.js');\n\nconst MAX_CHANNEL = 2 ** 32 - 1;\n\nfunction onChannelOpenFailure(self, recipient, info, cb) {\n  self._chanMgr.remove(recipient);\n  if (typeof cb !== 'function')\n    return;\n\n  let err;\n  if (info instanceof Error) {\n    err = info;\n  } else if (typeof info === 'object' && info !== null) {\n    err = new Error(`(SSH) Channel open failure: ${info.description}`);\n    err.reason = info.reason;\n  } else {\n    err = new Error(\n      '(SSH) Channel open failure: server closed channel unexpectedly'\n    );\n    err.reason = '';\n  }\n\n  cb(err);\n}\n\nfunction onCHANNEL_CLOSE(self, recipient, channel, err, dead) {\n  if (typeof channel === 'function') {\n    // We got CHANNEL_CLOSE instead of CHANNEL_OPEN_FAILURE when\n    // requesting to open a channel\n    onChannelOpenFailure(self, recipient, err, channel);\n    return;\n  }\n\n  if (typeof channel !== 'object' || channel === null)\n    return;\n\n  if (channel.incoming && channel.incoming.state === 'closed')\n    return;\n\n  self._chanMgr.remove(recipient);\n\n  if (channel.server && channel.constructor.name === 'Session')\n    return;\n\n  channel.incoming.state = 'closed';\n\n  if (channel.readable)\n    channel.push(null);\n  if (channel.server) {\n    if (channel.stderr.writable)\n      channel.stderr.end();\n  } else if (channel.stderr.readable) {\n    channel.stderr.push(null);\n  }\n\n  if (channel.constructor !== SFTP\n      && (channel.outgoing.state === 'open'\n          || channel.outgoing.state === 'eof')\n      && !dead) {\n    channel.close();\n  }\n  if (channel.outgoing.state === 'closing')\n    channel.outgoing.state = 'closed';\n\n  const readState = channel._readableState;\n  const writeState = channel._writableState;\n  if (writeState && !writeState.ending && !writeState.finished && !dead)\n    channel.end();\n\n  // Take care of any outstanding channel requests\n  const chanCallbacks = channel._callbacks;\n  channel._callbacks = [];\n  for (let i = 0; i < chanCallbacks.length; ++i)\n    chanCallbacks[i](true);\n\n  if (channel.server) {\n    if (!channel.readable\n        || channel.destroyed\n        || (readState && readState.endEmitted)) {\n      channel.emit('close');\n    } else {\n      channel.once('end', () => channel.emit('close'));\n    }\n  } else {\n    let doClose;\n    switch (channel.type) {\n      case 'direct-streamlocal@openssh.com':\n      case 'direct-tcpip':\n        doClose = () => channel.emit('close');\n        break;\n      default: {\n        // Align more with node child processes, where the close event gets\n        // the same arguments as the exit event\n        const exit = channel._exit;\n        doClose = () => {\n          if (exit.code === null)\n            channel.emit('close', exit.code, exit.signal, exit.dump, exit.desc);\n          else\n            channel.emit('close', exit.code);\n        };\n      }\n    }\n    if (!channel.readable\n        || channel.destroyed\n        || (readState && readState.endEmitted)) {\n      doClose();\n    } else {\n      channel.once('end', doClose);\n    }\n\n    const errReadState = channel.stderr._readableState;\n    if (!channel.stderr.readable\n        || channel.stderr.destroyed\n        || (errReadState && errReadState.endEmitted)) {\n      channel.stderr.emit('close');\n    } else {\n      channel.stderr.once('end', () => channel.stderr.emit('close'));\n    }\n  }\n}\n\nclass ChannelManager {\n  constructor(client) {\n    this._client = client;\n    this._channels = {};\n    this._cur = -1;\n    this._count = 0;\n  }\n  add(val) {\n    // Attempt to reserve an id\n\n    let id;\n    // Optimized paths\n    if (this._cur < MAX_CHANNEL) {\n      id = ++this._cur;\n    } else if (this._count === 0) {\n      // Revert and reset back to fast path once we no longer have any channels\n      // open\n      this._cur = 0;\n      id = 0;\n    } else {\n      // Slower lookup path\n\n      // This path is triggered we have opened at least MAX_CHANNEL channels\n      // while having at least one channel open at any given time, so we have\n      // to search for a free id.\n      const channels = this._channels;\n      for (let i = 0; i < MAX_CHANNEL; ++i) {\n        if (channels[i] === undefined) {\n          id = i;\n          break;\n        }\n      }\n    }\n\n    if (id === undefined)\n      return -1;\n\n    this._channels[id] = (val || true);\n    ++this._count;\n\n    return id;\n  }\n  update(id, val) {\n    if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id))\n      throw new Error(`Invalid channel id: ${id}`);\n\n    if (val && this._channels[id])\n      this._channels[id] = val;\n  }\n  get(id) {\n    if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id))\n      throw new Error(`Invalid channel id: ${id}`);\n\n    return this._channels[id];\n  }\n  remove(id) {\n    if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id))\n      throw new Error(`Invalid channel id: ${id}`);\n\n    if (this._channels[id]) {\n      delete this._channels[id];\n      if (this._count)\n        --this._count;\n    }\n  }\n  cleanup(err) {\n    const channels = this._channels;\n    this._channels = {};\n    this._cur = -1;\n    this._count = 0;\n\n    const chanIDs = Object.keys(channels);\n    const client = this._client;\n    for (let i = 0; i < chanIDs.length; ++i) {\n      const id = +chanIDs[i];\n      const channel = channels[id];\n      onCHANNEL_CLOSE(client, id, channel._channel || channel, err, true);\n    }\n  }\n}\n\nconst isRegExp = (() => {\n  const toString = Object.prototype.toString;\n  return (val) => toString.call(val) === '[object RegExp]';\n})();\n\nfunction generateAlgorithmList(algoList, defaultList, supportedList) {\n  if (Array.isArray(algoList) && algoList.length > 0) {\n    // Exact list\n    for (let i = 0; i < algoList.length; ++i) {\n      if (supportedList.indexOf(algoList[i]) === -1)\n        throw new Error(`Unsupported algorithm: ${algoList[i]}`);\n    }\n    return algoList;\n  }\n\n  if (typeof algoList === 'object' && algoList !== null) {\n    // Operations based on the default list\n    const keys = Object.keys(algoList);\n    let list = defaultList;\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      let val = algoList[key];\n      switch (key) {\n        case 'append':\n          if (!Array.isArray(val))\n            val = [val];\n          if (Array.isArray(val)) {\n            for (let j = 0; j < val.length; ++j) {\n              const append = val[j];\n              if (typeof append === 'string') {\n                if (!append || list.indexOf(append) !== -1)\n                  continue;\n                if (supportedList.indexOf(append) === -1)\n                  throw new Error(`Unsupported algorithm: ${append}`);\n                if (list === defaultList)\n                  list = list.slice();\n                list.push(append);\n              } else if (isRegExp(append)) {\n                for (let k = 0; k < supportedList.length; ++k) {\n                  const algo = supportedList[k];\n                  if (append.test(algo)) {\n                    if (list.indexOf(algo) !== -1)\n                      continue;\n                    if (list === defaultList)\n                      list = list.slice();\n                    list.push(algo);\n                  }\n                }\n              }\n            }\n          }\n          break;\n        case 'prepend':\n          if (!Array.isArray(val))\n            val = [val];\n          if (Array.isArray(val)) {\n            for (let j = val.length; j >= 0; --j) {\n              const prepend = val[j];\n              if (typeof prepend === 'string') {\n                if (!prepend || list.indexOf(prepend) !== -1)\n                  continue;\n                if (supportedList.indexOf(prepend) === -1)\n                  throw new Error(`Unsupported algorithm: ${prepend}`);\n                if (list === defaultList)\n                  list = list.slice();\n                list.unshift(prepend);\n              } else if (isRegExp(prepend)) {\n                for (let k = supportedList.length; k >= 0; --k) {\n                  const algo = supportedList[k];\n                  if (prepend.test(algo)) {\n                    if (list.indexOf(algo) !== -1)\n                      continue;\n                    if (list === defaultList)\n                      list = list.slice();\n                    list.unshift(algo);\n                  }\n                }\n              }\n            }\n          }\n          break;\n        case 'remove':\n          if (!Array.isArray(val))\n            val = [val];\n          if (Array.isArray(val)) {\n            for (let j = 0; j < val.length; ++j) {\n              const search = val[j];\n              if (typeof search === 'string') {\n                if (!search)\n                  continue;\n                const idx = list.indexOf(search);\n                if (idx === -1)\n                  continue;\n                if (list === defaultList)\n                  list = list.slice();\n                list.splice(idx, 1);\n              } else if (isRegExp(search)) {\n                for (let k = 0; k < list.length; ++k) {\n                  if (search.test(list[k])) {\n                    if (list === defaultList)\n                      list = list.slice();\n                    list.splice(k, 1);\n                    --k;\n                  }\n                }\n              }\n            }\n          }\n          break;\n      }\n    }\n\n    return list;\n  }\n\n  return defaultList;\n}\n\nmodule.exports = {\n  ChannelManager,\n  generateAlgorithmList,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE,\n  isWritable: (stream) => {\n    // XXX: hack to workaround regression in node\n    // See: https://github.com/nodejs/node/issues/36029\n    return (stream\n            && stream.writable\n            && stream._readableState\n            && stream._readableState.ended === false);\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}