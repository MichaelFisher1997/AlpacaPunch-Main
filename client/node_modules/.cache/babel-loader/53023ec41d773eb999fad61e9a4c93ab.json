{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('bn.js'), require('long')) : typeof define === 'function' && define.amd ? define(['exports', 'tslib', 'bn.js', 'long'], factory) : factory(global.zjsUtil = {}, global.tslib, global.bn.js, global.long);\n})(this, function (exports, tslib, BN, Long) {\n  'use strict';\n\n  BN = BN && BN.hasOwnProperty('default') ? BN['default'] : BN;\n  Long = Long && Long.hasOwnProperty('default') ? Long['default'] : Long; //  Copyright (C) 2018 Zilliqa\n  //\n  //  This file is part of zilliqa-js\n  //\n  //  This program is free software: you can redistribute it and/or modify\n  //  it under the terms of the GNU General Public License as published by\n  //  the Free Software Foundation, either version 3 of the License, or\n  //  (at your option) any later version.\n  //\n  //  This program is distributed in the hope that it will be useful,\n  //  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  //  GNU General Public License for more details.\n  //\n  //  You should have received a copy of the GNU General Public License\n  //  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n  /**\r\n   * intToHexArray\r\n   *\r\n   * @param {number} int - the number to be converted to hex\r\n   * @param {number)} size - the desired width of the hex value. will pad.\r\n   *\r\n   * @returns {string[]}\r\n   */\n\n  var intToHexArray = function (int, size) {\n    var hex = [];\n    var hexRep = [];\n    var hexVal = int.toString(16); // TODO: this really needs to be refactored.\n\n    for (var i = 0; i < hexVal.length; i++) {\n      hexRep[i] = hexVal[i].toString();\n    }\n\n    for (var i = 0; i < size - hexVal.length; i++) {\n      hex.push('0');\n    }\n\n    for (var i = 0; i < hexVal.length; i++) {\n      hex.push(hexRep[i]);\n    }\n\n    return hex;\n  };\n  /**\r\n   * intToByteArray\r\n   *\r\n   * Converts a number to Uint8Array\r\n   *\r\n   * @param {number} num\r\n   * @param {number} size\r\n   *\r\n   * @returns {Uint8Array}\r\n   */\n\n\n  var intToByteArray = function (num, size) {\n    var x = num;\n    var res = [];\n\n    while (x > 0) {\n      res.push(x & 255);\n      x = x >> 8;\n    }\n\n    var pad = size - res.length;\n\n    for (var i = 0; i < pad; i++) {\n      res.unshift(0);\n    }\n\n    return Uint8Array.from(res);\n  };\n  /**\r\n   * hexToByteArray\r\n   *\r\n   * Convers a hex string to a Uint8Array\r\n   *\r\n   * @param {string} hex\r\n   * @returns {Uint8Array}\r\n   */\n\n\n  var hexToByteArray = function (hex) {\n    var res = new Uint8Array(hex.length / 2);\n\n    for (var i = 0; i < hex.length; i += 2) {\n      res[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n    }\n\n    return res;\n  };\n  /**\r\n   * hexToIntArray\r\n   *\r\n   * @param {string} hex\r\n   * @returns {number[]}\r\n   */\n\n\n  var hexToIntArray = function (hex) {\n    if (!hex || !isHex(hex)) {\n      return [];\n    }\n\n    var res = [];\n\n    for (var i = 0; i < hex.length; i++) {\n      var c = hex.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      hi ? res.push(hi, lo) : res.push(lo);\n    }\n\n    return res;\n  };\n  /**\r\n   * pack\r\n   *\r\n   * Takes two 16-bit integers and combines them. Used to compute version.\r\n   *\r\n   * @param {number} a\r\n   * @param {number} b\r\n   *\r\n   * @returns {number} - a 32-bit number\r\n   */\n\n\n  var pack = function (a, b) {\n    if (a >> 16 > 0 || b >> 16 > 0) {\n      throw new Error('Both a and b must be 16 bits or less');\n    }\n\n    return (a << 16) + b;\n  };\n  /**\r\n   * compareBytes\r\n   *\r\n   * A constant time HMAC comparison function.\r\n   *\r\n   * @param {string} a\r\n   * @param {string} b\r\n   * @returns {boolean}\r\n   */\n\n\n  var isEqual = function (a, b) {\n    var bzA = hexToIntArray(a);\n    var bzB = hexToIntArray(b);\n\n    if (bzA.length !== bzB.length) {\n      return false;\n    }\n\n    var result = 0;\n\n    for (var i = 0; i < bzA.length; i++) {\n      result |= bzA[i] ^ bzB[i];\n    }\n\n    return result === 0;\n  };\n  /**\r\n   * isHex\r\n   *\r\n   * @param {string} str - string to be tested\r\n   * @returns {boolean}\r\n   */\n\n\n  var isHex = function (str) {\n    var plain = str.replace('0x', '');\n    return /[0-9a-f]*$/i.test(plain);\n  };\n\n  var bytes = /*#__PURE__*/Object.freeze({\n    intToHexArray: intToHexArray,\n    intToByteArray: intToByteArray,\n    hexToByteArray: hexToByteArray,\n    hexToIntArray: hexToIntArray,\n    pack: pack,\n    isEqual: isEqual,\n    isHex: isHex\n  }); //  Copyright (C) 2018 Zilliqa\n\n  var isAddress = function (address) {\n    return isByteString(address, 40);\n  };\n\n  var isBech32 = function (raw) {\n    return !!raw.match(/^zil1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$/);\n  };\n\n  var isBase58 = function (raw) {\n    return !!raw.match(/^[1-9ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/);\n  };\n\n  var isPrivateKey = function (privateKey) {\n    return isByteString(privateKey, 64);\n  };\n\n  var isPubKey = function (pubKey) {\n    return isByteString(pubKey, 66);\n  };\n\n  var isSignature = function (sig) {\n    return isByteString(sig, 128);\n  };\n\n  var isByteString = function (str, len) {\n    return !!str.replace('0x', '').match(\"^[0-9a-fA-F]{\" + len + \"}$\");\n  };\n\n  var isNumber = function (x) {\n    return typeof x === 'number';\n  };\n\n  var isBN = function (x) {\n    return BN.isBN(x);\n  };\n\n  var isLong = function (x) {\n    return Long.isLong(x);\n  };\n\n  var isString = function (x) {\n    return typeof x === 'string';\n  };\n\n  var isPlainObject = function (x) {\n    if (typeof x === 'object' && x !== null) {\n      var proto = Object.getPrototypeOf(x);\n      return proto === Object.prototype || proto === null;\n    }\n\n    return false;\n  };\n\n  var PRAGMA_REQUIRED = '@@ZJS_REQUIRED@@';\n\n  var required = function (fn) {\n    if (typeof fn === 'function') {\n      return Object.defineProperty(fn, 'required', {\n        value: PRAGMA_REQUIRED\n      });\n    }\n\n    throw new Error('fn is not a function');\n  };\n\n  var matchesObject = function (x, test) {\n    var e_1, _a;\n\n    if (isPlainObject(x)) {\n      for (var key in test) {\n        if (test.hasOwnProperty(key)) {\n          try {\n            for (var _b = (e_1 = void 0, tslib.__values(test[key])), _c = _b.next(); !_c.done; _c = _b.next()) {\n              var tester = _c.value;\n              var value = x[key];\n\n              if (typeof value === 'undefined' && tester.required) {\n                throw new Error('Key not found: ' + key);\n              } else {\n                continue;\n              }\n            }\n          } catch (e_1_1) {\n            e_1 = {\n              error: e_1_1\n            };\n          } finally {\n            try {\n              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  var validation = /*#__PURE__*/Object.freeze({\n    isAddress: isAddress,\n    isBech32: isBech32,\n    isBase58: isBase58,\n    isPrivateKey: isPrivateKey,\n    isPubKey: isPubKey,\n    isSignature: isSignature,\n    isByteString: isByteString,\n    isNumber: isNumber,\n    isBN: isBN,\n    isLong: isLong,\n    isString: isString,\n    isPlainObject: isPlainObject,\n    required: required,\n    matchesObject: matchesObject\n  }); //  Copyright (C) 2018 Zilliqa\n\n  var Units;\n\n  (function (Units) {\n    Units[\"Zil\"] = \"zil\";\n    Units[\"Li\"] = \"li\";\n    Units[\"Qa\"] = \"qa\";\n  })(Units || (Units = {}));\n\n  var DEFAULT_OPTIONS = {\n    pad: false\n  };\n  var unitMap = new Map([[Units.Qa, '1'], [Units.Li, '1000000'], [Units.Zil, '1000000000000'] // 1e12 qa\n  ]);\n\n  var numToStr = function (input) {\n    if (typeof input === 'string') {\n      if (!input.match(/^-?[0-9.]+$/)) {\n        throw new Error(\"while converting number to string, invalid number value '\" + input + \"', should be a number matching (^-?[0-9.]+).\");\n      }\n\n      return input;\n    } else if (typeof input === 'number') {\n      return String(input);\n    } else if (BN.isBN(input)) {\n      return input.toString(10);\n    }\n\n    throw new Error(\"while converting number to string, invalid number value '\" + input + \"' type \" + typeof input + \".\");\n  };\n\n  var fromQa = function (qa, unit, options) {\n    if (options === void 0) {\n      options = DEFAULT_OPTIONS;\n    }\n\n    if (unit === 'qa') {\n      return qa.toString(10);\n    }\n\n    var baseStr = unitMap.get(unit);\n\n    if (!baseStr) {\n      throw new Error(\"No unit of type \" + unit + \" exists.\");\n    }\n\n    var base = new BN(baseStr, 10);\n    var baseNumDecimals = baseStr.length - 1;\n    var fraction = qa.abs().mod(base).toString(10); // prepend 0s to the fraction half\n\n    while (fraction.length < baseNumDecimals) {\n      fraction = \"0\" + fraction;\n    }\n\n    if (!options.pad) {\n      fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n    }\n\n    var whole = qa.div(base).toString(10);\n    return fraction === '0' ? \"\" + whole : whole + \".\" + fraction;\n  };\n\n  var toQa = function (input, unit) {\n    var inputStr = numToStr(input);\n    var baseStr = unitMap.get(unit);\n\n    if (!baseStr) {\n      throw new Error(\"No unit of type \" + unit + \" exists.\");\n    }\n\n    var baseNumDecimals = baseStr.length - 1;\n    var base = new BN(baseStr, 10); // Is it negative?\n\n    var isNegative = inputStr.substring(0, 1) === '-';\n\n    if (isNegative) {\n      inputStr = inputStr.substring(1);\n    }\n\n    if (inputStr === '.') {\n      throw new Error(\"Cannot convert \" + inputStr + \" to Qa.\");\n    } // Split it into a whole and fractional part\n\n\n    var comps = inputStr.split('.'); // eslint-disable-line\n\n    if (comps.length > 2) {\n      throw new Error(\"Cannot convert \" + inputStr + \" to Qa.\");\n    }\n\n    var _a = tslib.__read(comps, 2),\n        whole = _a[0],\n        fraction = _a[1];\n\n    if (!whole) {\n      whole = '0';\n    }\n\n    if (!fraction) {\n      fraction = '0';\n    }\n\n    if (fraction.length > baseNumDecimals) {\n      throw new Error(\"Cannot convert \" + inputStr + \" to Qa.\");\n    }\n\n    while (fraction.length < baseNumDecimals) {\n      fraction += '0';\n    }\n\n    var wholeBN = new BN(whole);\n    var fractionBN = new BN(fraction);\n    var wei = wholeBN.mul(base).add(fractionBN); // eslint-disable-line\n\n    if (isNegative) {\n      wei = wei.neg();\n    }\n\n    return new BN(wei.toString(10), 10);\n  };\n\n  var unit = /*#__PURE__*/Object.freeze({\n    get Units() {\n      return Units;\n    },\n\n    fromQa: fromQa,\n    toQa: toQa\n  }); //  Copyright (C) 2018 Zilliqa\n\n  exports.BN = BN;\n  exports.Long = Long;\n  exports.bytes = bytes;\n  exports.units = unit;\n  exports.validation = validation;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n}); //# sourceMappingURL=index.umd.js.map","map":null,"metadata":{},"sourceType":"script"}