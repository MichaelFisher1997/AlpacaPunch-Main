{"ast":null,"code":"'use strict';\n\nconst {\n  bufferSlice,\n  bufferParser,\n  doFatalError,\n  sigSSHToASN1,\n  writeUInt32BE\n} = require('./utils.js');\n\nconst {\n  CHANNEL_OPEN_FAILURE,\n  COMPAT,\n  MESSAGE,\n  TERMINAL_MODE\n} = require('./constants.js');\n\nconst {\n  parseKey\n} = require('./keyParser.js');\n\nconst TERMINAL_MODE_BY_VALUE = Array.from(Object.entries(TERMINAL_MODE)).reduce((obj, _ref) => {\n  let [key, value] = _ref;\n  return { ...obj,\n    [key]: value\n  };\n}, {});\nmodule.exports = {\n  // Transport layer protocol ==================================================\n  [MESSAGE.DISCONNECT]: (self, payload) => {\n    /*\n      byte      SSH_MSG_DISCONNECT\n      uint32    reason code\n      string    description in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    bufferParser.init(payload, 1);\n    const reason = bufferParser.readUInt32BE();\n    const desc = bufferParser.readString(true);\n    const lang = bufferParser.readString();\n    bufferParser.clear();\n\n    if (lang === undefined) {\n      return doFatalError(self, 'Inbound: Malformed DISCONNECT packet');\n    }\n\n    self._debug && self._debug(`Inbound: Received DISCONNECT (${reason}, \"${desc}\")`);\n    const handler = self._handlers.DISCONNECT;\n    handler && handler(self, reason, desc);\n  },\n  [MESSAGE.IGNORE]: (self, payload) => {\n    /*\n      byte      SSH_MSG_IGNORE\n      string    data\n    */\n    self._debug && self._debug('Inbound: Received IGNORE');\n  },\n  [MESSAGE.UNIMPLEMENTED]: (self, payload) => {\n    /*\n      byte      SSH_MSG_UNIMPLEMENTED\n      uint32    packet sequence number of rejected message\n    */\n    bufferParser.init(payload, 1);\n    const seqno = bufferParser.readUInt32BE();\n    bufferParser.clear();\n\n    if (seqno === undefined) {\n      return doFatalError(self, 'Inbound: Malformed UNIMPLEMENTED packet');\n    }\n\n    self._debug && self._debug(`Inbound: Received UNIMPLEMENTED (seqno ${seqno})`);\n  },\n  [MESSAGE.DEBUG]: (self, payload) => {\n    /*\n      byte      SSH_MSG_DEBUG\n      boolean   always_display\n      string    message in ISO-10646 UTF-8 encoding [RFC3629]\n      string    language tag [RFC3066]\n    */\n    bufferParser.init(payload, 1);\n    const display = bufferParser.readBool();\n    const msg = bufferParser.readString(true);\n    const lang = bufferParser.readString();\n    bufferParser.clear();\n\n    if (lang === undefined) {\n      return doFatalError(self, 'Inbound: Malformed DEBUG packet');\n    }\n\n    self._debug && self._debug('Inbound: Received DEBUG');\n    const handler = self._handlers.DEBUG;\n    handler && handler(self, display, msg);\n  },\n  [MESSAGE.SERVICE_REQUEST]: (self, payload) => {\n    /*\n      byte      SSH_MSG_SERVICE_REQUEST\n      string    service name\n    */\n    bufferParser.init(payload, 1);\n    const name = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (name === undefined) {\n      return doFatalError(self, 'Inbound: Malformed SERVICE_REQUEST packet');\n    }\n\n    self._debug && self._debug(`Inbound: Received SERVICE_REQUEST (${name})`);\n    const handler = self._handlers.SERVICE_REQUEST;\n    handler && handler(self, name);\n  },\n  [MESSAGE.SERVICE_ACCEPT]: (self, payload) => {\n    // S->C\n\n    /*\n      byte      SSH_MSG_SERVICE_ACCEPT\n      string    service name\n    */\n    bufferParser.init(payload, 1);\n    const name = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (name === undefined) {\n      return doFatalError(self, 'Inbound: Malformed SERVICE_ACCEPT packet');\n    }\n\n    self._debug && self._debug(`Inbound: Received SERVICE_ACCEPT (${name})`);\n    const handler = self._handlers.SERVICE_ACCEPT;\n    handler && handler(self, name);\n  },\n  // User auth protocol -- generic =============================================\n  [MESSAGE.USERAUTH_REQUEST]: (self, payload) => {\n    /*\n      byte      SSH_MSG_USERAUTH_REQUEST\n      string    user name in ISO-10646 UTF-8 encoding [RFC3629]\n      string    service name in US-ASCII\n      string    method name in US-ASCII\n      ....      method specific fields\n    */\n    bufferParser.init(payload, 1);\n    const user = bufferParser.readString(true);\n    const service = bufferParser.readString(true);\n    const method = bufferParser.readString(true);\n    let methodData;\n    let methodDesc;\n\n    switch (method) {\n      case 'none':\n        methodData = null;\n        break;\n\n      case 'password':\n        {\n          /*\n            boolean   <new password follows (old) plaintext password?>\n            string    plaintext password in ISO-10646 UTF-8 encoding [RFC3629]\n           [string    new password]\n          */\n          const isChange = bufferParser.readBool();\n\n          if (isChange !== undefined) {\n            methodData = bufferParser.readString(true);\n\n            if (methodData !== undefined && isChange) {\n              const newPassword = bufferParser.readString(true);\n              if (newPassword !== undefined) methodData = {\n                oldPassword: methodData,\n                newPassword\n              };else methodData = undefined;\n            }\n          }\n\n          break;\n        }\n\n      case 'publickey':\n        {\n          /*\n            boolean   <signature follows public key blob?>\n            string    public key algorithm name\n            string    public key blob\n           [string    signature]\n          */\n          const hasSig = bufferParser.readBool();\n\n          if (hasSig !== undefined) {\n            const keyAlgo = bufferParser.readString(true);\n            const key = bufferParser.readString();\n\n            if (hasSig) {\n              const blobEnd = bufferParser.pos();\n              let signature = bufferParser.readString();\n\n              if (signature !== undefined) {\n                if (signature.length > 4 + keyAlgo.length + 4 && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {\n                  // Skip algoLen + algo + sigLen\n                  signature = bufferSlice(signature, 4 + keyAlgo.length + 4);\n                }\n\n                signature = sigSSHToASN1(signature, keyAlgo);\n\n                if (signature) {\n                  const sessionID = self._kex.sessionID;\n                  const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);\n                  writeUInt32BE(blob, sessionID.length, 0);\n                  blob.set(sessionID, 4);\n                  blob.set(new Uint8Array(payload.buffer, payload.byteOffset, blobEnd), 4 + sessionID.length);\n                  methodData = {\n                    keyAlgo,\n                    key,\n                    signature,\n                    blob\n                  };\n                }\n              }\n            } else {\n              methodData = {\n                keyAlgo,\n                key\n              };\n              methodDesc = 'publickey -- check';\n            }\n          }\n\n          break;\n        }\n\n      case 'hostbased':\n        {\n          /*\n            string    public key algorithm for host key\n            string    public host key and certificates for client host\n            string    client host name expressed as the FQDN in US-ASCII\n            string    user name on the client host in ISO-10646 UTF-8 encoding\n                       [RFC3629]\n            string    signature\n          */\n          const keyAlgo = bufferParser.readString(true);\n          const key = bufferParser.readString();\n          const localHostname = bufferParser.readString(true);\n          const localUsername = bufferParser.readString(true);\n          const blobEnd = bufferParser.pos();\n          let signature = bufferParser.readString();\n\n          if (signature !== undefined) {\n            if (signature.length > 4 + keyAlgo.length + 4 && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {\n              // Skip algoLen + algo + sigLen\n              signature = bufferSlice(signature, 4 + keyAlgo.length + 4);\n            }\n\n            signature = sigSSHToASN1(signature, keyAlgo);\n\n            if (signature !== undefined) {\n              const sessionID = self._kex.sessionID;\n              const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);\n              writeUInt32BE(blob, sessionID.length, 0);\n              blob.set(sessionID, 4);\n              blob.set(new Uint8Array(payload.buffer, payload.byteOffset, blobEnd), 4 + sessionID.length);\n              methodData = {\n                keyAlgo,\n                key,\n                signature,\n                blob,\n                localHostname,\n                localUsername\n              };\n            }\n          }\n\n          break;\n        }\n\n      case 'keyboard-interactive':\n        /*\n          string    language tag (as defined in [RFC-3066])\n          string    submethods (ISO-10646 UTF-8)\n        */\n        // Skip/ignore language field -- it's deprecated in RFC 4256\n        bufferParser.skipString();\n        methodData = bufferParser.readList();\n        break;\n\n      default:\n        if (method !== undefined) methodData = bufferParser.readRaw();\n    }\n\n    bufferParser.clear();\n\n    if (methodData === undefined) {\n      return doFatalError(self, 'Inbound: Malformed USERAUTH_REQUEST packet');\n    }\n\n    if (methodDesc === undefined) methodDesc = method;\n\n    self._authsQueue.push(method);\n\n    self._debug && self._debug(`Inbound: Received USERAUTH_REQUEST (${methodDesc})`);\n    const handler = self._handlers.USERAUTH_REQUEST;\n    handler && handler(self, user, service, method, methodData);\n  },\n  [MESSAGE.USERAUTH_FAILURE]: (self, payload) => {\n    // S->C\n\n    /*\n      byte         SSH_MSG_USERAUTH_FAILURE\n      name-list    authentications that can continue\n      boolean      partial success\n    */\n    bufferParser.init(payload, 1);\n    const authMethods = bufferParser.readList();\n    const partialSuccess = bufferParser.readBool();\n    bufferParser.clear();\n\n    if (partialSuccess === undefined) {\n      return doFatalError(self, 'Inbound: Malformed USERAUTH_FAILURE packet');\n    }\n\n    self._debug && self._debug(`Inbound: Received USERAUTH_FAILURE (${authMethods})`);\n\n    self._authsQueue.shift();\n\n    const handler = self._handlers.USERAUTH_FAILURE;\n    handler && handler(self, authMethods, partialSuccess);\n  },\n  [MESSAGE.USERAUTH_SUCCESS]: (self, payload) => {\n    // S->C\n\n    /*\n      byte      SSH_MSG_USERAUTH_SUCCESS\n    */\n    self._debug && self._debug('Inbound: Received USERAUTH_SUCCESS');\n\n    self._authsQueue.shift();\n\n    const handler = self._handlers.USERAUTH_SUCCESS;\n    handler && handler(self);\n  },\n  [MESSAGE.USERAUTH_BANNER]: (self, payload) => {\n    // S->C\n\n    /*\n      byte      SSH_MSG_USERAUTH_BANNER\n      string    message in ISO-10646 UTF-8 encoding [RFC3629]\n      string    language tag [RFC3066]\n    */\n    bufferParser.init(payload, 1);\n    const msg = bufferParser.readString(true);\n    const lang = bufferParser.readString();\n    bufferParser.clear();\n\n    if (lang === undefined) {\n      return doFatalError(self, 'Inbound: Malformed USERAUTH_BANNER packet');\n    }\n\n    self._debug && self._debug('Inbound: Received USERAUTH_BANNER');\n    const handler = self._handlers.USERAUTH_BANNER;\n    handler && handler(self, msg);\n  },\n  // User auth protocol -- method-specific =====================================\n  60: (self, payload) => {\n    if (!self._authsQueue.length) {\n      self._debug && self._debug('Inbound: Received payload type 60 without auth');\n      return;\n    }\n\n    switch (self._authsQueue[0]) {\n      case 'password':\n        {\n          // S->C\n\n          /*\n            byte      SSH_MSG_USERAUTH_PASSWD_CHANGEREQ\n            string    prompt in ISO-10646 UTF-8 encoding [RFC3629]\n            string    language tag [RFC3066]\n          */\n          bufferParser.init(payload, 1);\n          const prompt = bufferParser.readString(true);\n          const lang = bufferParser.readString();\n          bufferParser.clear();\n\n          if (lang === undefined) {\n            return doFatalError(self, 'Inbound: Malformed USERAUTH_PASSWD_CHANGEREQ packet');\n          }\n\n          self._debug && self._debug('Inbound: Received USERAUTH_PASSWD_CHANGEREQ');\n          const handler = self._handlers.USERAUTH_PASSWD_CHANGEREQ;\n          handler && handler(self, prompt);\n          break;\n        }\n\n      case 'publickey':\n        {\n          // S->C\n\n          /*\n            byte      SSH_MSG_USERAUTH_PK_OK\n            string    public key algorithm name from the request\n            string    public key blob from the request\n          */\n          bufferParser.init(payload, 1);\n          const keyAlgo = bufferParser.readString(true);\n          const key = bufferParser.readString();\n          bufferParser.clear();\n\n          if (key === undefined) {\n            return doFatalError(self, 'Inbound: Malformed USERAUTH_PK_OK packet');\n          }\n\n          self._debug && self._debug('Inbound: Received USERAUTH_PK_OK');\n\n          self._authsQueue.shift();\n\n          const handler = self._handlers.USERAUTH_PK_OK;\n          handler && handler(self, keyAlgo, key);\n          break;\n        }\n\n      case 'keyboard-interactive':\n        {\n          // S->C\n\n          /*\n            byte      SSH_MSG_USERAUTH_INFO_REQUEST\n            string    name (ISO-10646 UTF-8)\n            string    instruction (ISO-10646 UTF-8)\n            string    language tag (as defined in [RFC-3066])\n            int       num-prompts\n            string    prompt[1] (ISO-10646 UTF-8)\n            boolean   echo[1]\n            ...\n            string    prompt[num-prompts] (ISO-10646 UTF-8)\n            boolean   echo[num-prompts]\n          */\n          bufferParser.init(payload, 1);\n          const name = bufferParser.readString(true);\n          const instructions = bufferParser.readString(true);\n          bufferParser.readString(); // skip lang\n\n          const numPrompts = bufferParser.readUInt32BE();\n          let prompts;\n\n          if (numPrompts !== undefined) {\n            prompts = new Array(numPrompts);\n            let i;\n\n            for (i = 0; i < numPrompts; ++i) {\n              const prompt = bufferParser.readString(true);\n              const echo = bufferParser.readBool();\n              if (echo === undefined) break;\n              prompts[i] = {\n                prompt,\n                echo\n              };\n            }\n\n            if (i !== numPrompts) prompts = undefined;\n          }\n\n          bufferParser.clear();\n\n          if (prompts === undefined) {\n            return doFatalError(self, 'Inbound: Malformed USERAUTH_INFO_REQUEST packet');\n          }\n\n          self._debug && self._debug('Inbound: Received USERAUTH_INFO_REQUEST');\n          const handler = self._handlers.USERAUTH_INFO_REQUEST;\n          handler && handler(self, name, instructions, prompts);\n          break;\n        }\n\n      default:\n        self._debug && self._debug('Inbound: Received unexpected payload type 60');\n    }\n  },\n  61: (self, payload) => {\n    if (!self._authsQueue.length) {\n      self._debug && self._debug('Inbound: Received payload type 61 without auth');\n      return;\n    }\n    /*\n      byte      SSH_MSG_USERAUTH_INFO_RESPONSE\n      int       num-responses\n      string    response[1] (ISO-10646 UTF-8)\n      ...\n      string    response[num-responses] (ISO-10646 UTF-8)\n    */\n\n\n    if (self._authsQueue[0] !== 'keyboard-interactive') {\n      return doFatalError(self, 'Inbound: Received unexpected payload type 61');\n    }\n\n    bufferParser.init(payload, 1);\n    const numResponses = bufferParser.readUInt32BE();\n    let responses;\n\n    if (numResponses !== undefined) {\n      responses = new Array(numResponses);\n      let i;\n\n      for (i = 0; i < numResponses; ++i) {\n        const response = bufferParser.readString(true);\n        if (response === undefined) break;\n        responses[i] = response;\n      }\n\n      if (i !== numResponses) responses = undefined;\n    }\n\n    bufferParser.clear();\n\n    if (responses === undefined) {\n      return doFatalError(self, 'Inbound: Malformed USERAUTH_INFO_RESPONSE packet');\n    }\n\n    self._debug && self._debug('Inbound: Received USERAUTH_INFO_RESPONSE');\n    const handler = self._handlers.USERAUTH_INFO_RESPONSE;\n    handler && handler(self, responses);\n  },\n  // Connection protocol -- generic ============================================\n  [MESSAGE.GLOBAL_REQUEST]: (self, payload) => {\n    /*\n      byte      SSH_MSG_GLOBAL_REQUEST\n      string    request name in US-ASCII only\n      boolean   want reply\n      ....      request-specific data follows\n    */\n    bufferParser.init(payload, 1);\n    const name = bufferParser.readString(true);\n    const wantReply = bufferParser.readBool();\n    let data;\n\n    if (wantReply !== undefined) {\n      switch (name) {\n        case 'tcpip-forward':\n        case 'cancel-tcpip-forward':\n          {\n            /*\n              string    address to bind (e.g., \"0.0.0.0\")\n              uint32    port number to bind\n            */\n            const bindAddr = bufferParser.readString(true);\n            const bindPort = bufferParser.readUInt32BE();\n            if (bindPort !== undefined) data = {\n              bindAddr,\n              bindPort\n            };\n            break;\n          }\n\n        case 'streamlocal-forward@openssh.com':\n        case 'cancel-streamlocal-forward@openssh.com':\n          {\n            /*\n              string    socket path\n            */\n            const socketPath = bufferParser.readString(true);\n            if (socketPath !== undefined) data = {\n              socketPath\n            };\n            break;\n          }\n\n        case 'no-more-sessions@openssh.com':\n          data = null;\n          break;\n\n        case 'hostkeys-00@openssh.com':\n          {\n            data = [];\n\n            while (bufferParser.avail() > 0) {\n              const keyRaw = bufferParser.readString();\n\n              if (keyRaw === undefined) {\n                data = undefined;\n                break;\n              }\n\n              const key = parseKey(keyRaw);\n              if (!(key instanceof Error)) data.push(key);\n            }\n\n            break;\n          }\n\n        default:\n          data = bufferParser.readRaw();\n      }\n    }\n\n    bufferParser.clear();\n\n    if (data === undefined) {\n      return doFatalError(self, 'Inbound: Malformed GLOBAL_REQUEST packet');\n    }\n\n    self._debug && self._debug(`Inbound: GLOBAL_REQUEST (${name})`);\n    const handler = self._handlers.GLOBAL_REQUEST;\n    if (handler) handler(self, name, wantReply, data);else self.requestFailure(); // Auto reject\n  },\n  [MESSAGE.REQUEST_SUCCESS]: (self, payload) => {\n    /*\n      byte      SSH_MSG_REQUEST_SUCCESS\n      ....     response specific data\n    */\n    const data = payload.length > 1 ? bufferSlice(payload, 1) : null;\n    self._debug && self._debug('Inbound: REQUEST_SUCCESS');\n    const handler = self._handlers.REQUEST_SUCCESS;\n    handler && handler(self, data);\n  },\n  [MESSAGE.REQUEST_FAILURE]: (self, payload) => {\n    /*\n      byte      SSH_MSG_REQUEST_FAILURE\n    */\n    self._debug && self._debug('Inbound: Received REQUEST_FAILURE');\n    const handler = self._handlers.REQUEST_FAILURE;\n    handler && handler(self);\n  },\n  // Connection protocol -- channel-related ====================================\n  [MESSAGE.CHANNEL_OPEN]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN\n      string    channel type in US-ASCII only\n      uint32    sender channel\n      uint32    initial window size\n      uint32    maximum packet size\n      ....      channel type specific data follows\n    */\n    bufferParser.init(payload, 1);\n    const type = bufferParser.readString(true);\n    const sender = bufferParser.readUInt32BE();\n    const window = bufferParser.readUInt32BE();\n    const packetSize = bufferParser.readUInt32BE();\n    let channelInfo;\n\n    switch (type) {\n      case 'forwarded-tcpip': // S->C\n\n      case 'direct-tcpip':\n        {\n          // C->S\n\n          /*\n            string    address that was connected / host to connect\n            uint32    port that was connected / port to connect\n            string    originator IP address\n            uint32    originator port\n          */\n          const destIP = bufferParser.readString(true);\n          const destPort = bufferParser.readUInt32BE();\n          const srcIP = bufferParser.readString(true);\n          const srcPort = bufferParser.readUInt32BE();\n\n          if (srcPort !== undefined) {\n            channelInfo = {\n              type,\n              sender,\n              window,\n              packetSize,\n              data: {\n                destIP,\n                destPort,\n                srcIP,\n                srcPort\n              }\n            };\n          }\n\n          break;\n        }\n\n      case 'forwarded-streamlocal@openssh.com': // S->C\n\n      case 'direct-streamlocal@openssh.com':\n        {\n          // C->S\n\n          /*\n            string    socket path\n            string    reserved for future use\n             (direct-streamlocal@openssh.com additionally has:)\n            uint32    reserved\n          */\n          const socketPath = bufferParser.readString(true);\n\n          if (socketPath !== undefined) {\n            channelInfo = {\n              type,\n              sender,\n              window,\n              packetSize,\n              data: {\n                socketPath\n              }\n            };\n          }\n\n          break;\n        }\n\n      case 'x11':\n        {\n          // S->C\n\n          /*\n            string    originator address (e.g., \"192.168.7.38\")\n            uint32    originator port\n          */\n          const srcIP = bufferParser.readString(true);\n          const srcPort = bufferParser.readUInt32BE();\n\n          if (srcPort !== undefined) {\n            channelInfo = {\n              type,\n              sender,\n              window,\n              packetSize,\n              data: {\n                srcIP,\n                srcPort\n              }\n            };\n          }\n\n          break;\n        }\n\n      default:\n        // Includes:\n        //   'session' (C->S)\n        //   'auth-agent@openssh.com' (S->C)\n        channelInfo = {\n          type,\n          sender,\n          window,\n          packetSize,\n          data: {}\n        };\n    }\n\n    bufferParser.clear();\n\n    if (channelInfo === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_OPEN packet');\n    }\n\n    self._debug && self._debug(`Inbound: CHANNEL_OPEN (s:${sender}, ${type})`);\n    const handler = self._handlers.CHANNEL_OPEN;\n\n    if (handler) {\n      handler(self, channelInfo);\n    } else {\n      self.channelOpenFail(channelInfo.sender, CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED, '', '');\n    }\n  },\n  [MESSAGE.CHANNEL_OPEN_CONFIRMATION]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN_CONFIRMATION\n      uint32    recipient channel\n      uint32    sender channel\n      uint32    initial window size\n      uint32    maximum packet size\n      ....      channel type specific data follows\n    */\n    // \"The 'recipient channel' is the channel number given in the\n    // original open request, and 'sender channel' is the channel number\n    // allocated by the other side.\"\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const sender = bufferParser.readUInt32BE();\n    const window = bufferParser.readUInt32BE();\n    const packetSize = bufferParser.readUInt32BE();\n    const data = bufferParser.avail() ? bufferParser.readRaw() : undefined;\n    bufferParser.clear();\n\n    if (packetSize === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_OPEN_CONFIRMATION packet');\n    }\n\n    self._debug && self._debug(`Inbound: CHANNEL_OPEN_CONFIRMATION (r:${recipient}, s:${sender})`);\n    const handler = self._handlers.CHANNEL_OPEN_CONFIRMATION;\n    if (handler) handler(self, {\n      recipient,\n      sender,\n      window,\n      packetSize,\n      data\n    });\n  },\n  [MESSAGE.CHANNEL_OPEN_FAILURE]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN_FAILURE\n      uint32    recipient channel\n      uint32    reason code\n      string    description in ISO-10646 UTF-8 encoding [RFC3629]\n      string    language tag [RFC3066]\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const reason = bufferParser.readUInt32BE();\n    const description = bufferParser.readString(true);\n    const lang = bufferParser.readString();\n    bufferParser.clear();\n\n    if (lang === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_OPEN_FAILURE packet');\n    }\n\n    self._debug && self._debug(`Inbound: CHANNEL_OPEN_FAILURE (r:${recipient})`);\n    const handler = self._handlers.CHANNEL_OPEN_FAILURE;\n    handler && handler(self, recipient, reason, description);\n  },\n  [MESSAGE.CHANNEL_WINDOW_ADJUST]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_WINDOW_ADJUST\n      uint32    recipient channel\n      uint32    bytes to add\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const bytesToAdd = bufferParser.readUInt32BE();\n    bufferParser.clear();\n\n    if (bytesToAdd === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_WINDOW_ADJUST packet');\n    }\n\n    self._debug && self._debug(`Inbound: CHANNEL_WINDOW_ADJUST (r:${recipient}, ${bytesToAdd})`);\n    const handler = self._handlers.CHANNEL_WINDOW_ADJUST;\n    handler && handler(self, recipient, bytesToAdd);\n  },\n  [MESSAGE.CHANNEL_DATA]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_DATA\n      uint32    recipient channel\n      string    data\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const data = bufferParser.readString();\n    bufferParser.clear();\n\n    if (data === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_DATA packet');\n    }\n\n    self._debug && self._debug(`Inbound: CHANNEL_DATA (r:${recipient}, ${data.length})`);\n    const handler = self._handlers.CHANNEL_DATA;\n    handler && handler(self, recipient, data);\n  },\n  [MESSAGE.CHANNEL_EXTENDED_DATA]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_EXTENDED_DATA\n      uint32    recipient channel\n      uint32    data_type_code\n      string    data\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const type = bufferParser.readUInt32BE();\n    const data = bufferParser.readString();\n    bufferParser.clear();\n\n    if (data === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_EXTENDED_DATA packet');\n    }\n\n    self._debug && self._debug(`Inbound: CHANNEL_EXTENDED_DATA (r:${recipient}, ${data.length})`);\n    const handler = self._handlers.CHANNEL_EXTENDED_DATA;\n    handler && handler(self, recipient, data, type);\n  },\n  [MESSAGE.CHANNEL_EOF]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_EOF\n      uint32    recipient channel\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    bufferParser.clear();\n\n    if (recipient === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_EOF packet');\n    }\n\n    self._debug && self._debug(`Inbound: CHANNEL_EOF (r:${recipient})`);\n    const handler = self._handlers.CHANNEL_EOF;\n    handler && handler(self, recipient);\n  },\n  [MESSAGE.CHANNEL_CLOSE]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_CLOSE\n      uint32    recipient channel\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    bufferParser.clear();\n\n    if (recipient === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_CLOSE packet');\n    }\n\n    self._debug && self._debug(`Inbound: CHANNEL_CLOSE (r:${recipient})`);\n    const handler = self._handlers.CHANNEL_CLOSE;\n    handler && handler(self, recipient);\n  },\n  [MESSAGE.CHANNEL_REQUEST]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    request type in US-ASCII characters only\n      boolean   want reply\n      ....      type-specific data follows\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const type = bufferParser.readString(true);\n    const wantReply = bufferParser.readBool();\n    let data;\n\n    if (wantReply !== undefined) {\n      switch (type) {\n        case 'exit-status':\n          // S->C\n\n          /*\n            uint32    exit_status\n          */\n          data = bufferParser.readUInt32BE();\n          self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`);\n          break;\n\n        case 'exit-signal':\n          {\n            // S->C\n\n            /*\n              string    signal name (without the \"SIG\" prefix)\n              boolean   core dumped\n              string    error message in ISO-10646 UTF-8 encoding\n              string    language tag\n            */\n            let signal;\n            let coreDumped;\n\n            if (self._compatFlags & COMPAT.OLD_EXIT) {\n              /*\n                Instead of `signal name` and `core dumped`, we have just:\n                  uint32  signal number\n              */\n              const num = bufferParser.readUInt32BE();\n\n              switch (num) {\n                case 1:\n                  signal = 'HUP';\n                  break;\n\n                case 2:\n                  signal = 'INT';\n                  break;\n\n                case 3:\n                  signal = 'QUIT';\n                  break;\n\n                case 6:\n                  signal = 'ABRT';\n                  break;\n\n                case 9:\n                  signal = 'KILL';\n                  break;\n\n                case 14:\n                  signal = 'ALRM';\n                  break;\n\n                case 15:\n                  signal = 'TERM';\n                  break;\n\n                default:\n                  if (num !== undefined) {\n                    // Unknown or OS-specific\n                    signal = `UNKNOWN (${num})`;\n                  }\n\n              }\n\n              coreDumped = false;\n            } else {\n              signal = bufferParser.readString(true);\n              coreDumped = bufferParser.readBool();\n              if (coreDumped === undefined) signal = undefined;\n            }\n\n            const errorMessage = bufferParser.readString(true);\n            if (bufferParser.skipString() !== undefined) data = {\n              signal,\n              coreDumped,\n              errorMessage\n            };\n            self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${signal})`);\n            break;\n          }\n\n        case 'pty-req':\n          {\n            // C->S\n\n            /*\n              string    TERM environment variable value (e.g., vt100)\n              uint32    terminal width, characters (e.g., 80)\n              uint32    terminal height, rows (e.g., 24)\n              uint32    terminal width, pixels (e.g., 640)\n              uint32    terminal height, pixels (e.g., 480)\n              string    encoded terminal modes\n            */\n            const term = bufferParser.readString(true);\n            const cols = bufferParser.readUInt32BE();\n            const rows = bufferParser.readUInt32BE();\n            const width = bufferParser.readUInt32BE();\n            const height = bufferParser.readUInt32BE();\n            const modesBinary = bufferParser.readString();\n\n            if (modesBinary !== undefined) {\n              bufferParser.init(modesBinary, 1);\n              let modes = {};\n\n              while (bufferParser.avail()) {\n                const opcode = bufferParser.readByte();\n                if (opcode === TERMINAL_MODE.TTY_OP_END) break;\n                const name = TERMINAL_MODE_BY_VALUE[opcode];\n                const value = bufferParser.readUInt32BE();\n\n                if (opcode === undefined || name === undefined || value === undefined) {\n                  modes = undefined;\n                  break;\n                }\n\n                modes[name] = value;\n              }\n\n              if (modes !== undefined) data = {\n                term,\n                cols,\n                rows,\n                width,\n                height,\n                modes\n              };\n            }\n\n            self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);\n            break;\n          }\n\n        case 'window-change':\n          {\n            // C->S\n\n            /*\n              uint32    terminal width, columns\n              uint32    terminal height, rows\n              uint32    terminal width, pixels\n              uint32    terminal height, pixels\n            */\n            const cols = bufferParser.readUInt32BE();\n            const rows = bufferParser.readUInt32BE();\n            const width = bufferParser.readUInt32BE();\n            const height = bufferParser.readUInt32BE();\n            if (height !== undefined) data = {\n              cols,\n              rows,\n              width,\n              height\n            };\n            self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);\n            break;\n          }\n\n        case 'x11-req':\n          {\n            // C->S\n\n            /*\n              boolean   single connection\n              string    x11 authentication protocol\n              string    x11 authentication cookie\n              uint32    x11 screen number\n            */\n            const single = bufferParser.readBool();\n            const protocol = bufferParser.readString(true);\n            const cookie = bufferParser.readString();\n            const screen = bufferParser.readUInt32BE();\n            if (screen !== undefined) data = {\n              single,\n              protocol,\n              cookie,\n              screen\n            };\n            self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);\n            break;\n          }\n\n        case 'env':\n          {\n            // C->S\n\n            /*\n              string    variable name\n              string    variable value\n            */\n            const name = bufferParser.readString(true);\n            const value = bufferParser.readString(true);\n            if (value !== undefined) data = {\n              name,\n              value\n            };\n\n            if (self._debug) {\n              self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ` + `${name}=${value})`);\n            }\n\n            break;\n          }\n\n        case 'shell':\n          // C->S\n          data = null; // No extra data\n\n          self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);\n          break;\n\n        case 'exec':\n          // C->S\n\n          /*\n            string    command\n          */\n          data = bufferParser.readString(true);\n          self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`);\n          break;\n\n        case 'subsystem':\n          // C->S\n\n          /*\n            string    subsystem name\n          */\n          data = bufferParser.readString(true);\n          self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`);\n          break;\n\n        case 'signal':\n          // C->S\n\n          /*\n            string    signal name (without the \"SIG\" prefix)\n          */\n          data = bufferParser.readString(true);\n          self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`);\n          break;\n\n        case 'xon-xoff':\n          // C->S\n\n          /*\n            boolean   client can do\n          */\n          data = bufferParser.readBool();\n          self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`);\n          break;\n\n        case 'auth-agent-req@openssh.com':\n          // C-S\n          data = null; // No extra data\n\n          self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);\n          break;\n\n        default:\n          data = bufferParser.avail() ? bufferParser.readRaw() : null;\n          self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);\n      }\n    }\n\n    bufferParser.clear();\n\n    if (data === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_REQUEST packet');\n    }\n\n    const handler = self._handlers.CHANNEL_REQUEST;\n    handler && handler(self, recipient, type, wantReply, data);\n  },\n  [MESSAGE.CHANNEL_SUCCESS]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_SUCCESS\n      uint32    recipient channel\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    bufferParser.clear();\n\n    if (recipient === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_SUCCESS packet');\n    }\n\n    self._debug && self._debug(`Inbound: CHANNEL_SUCCESS (r:${recipient})`);\n    const handler = self._handlers.CHANNEL_SUCCESS;\n    handler && handler(self, recipient);\n  },\n  [MESSAGE.CHANNEL_FAILURE]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_FAILURE\n      uint32    recipient channel\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    bufferParser.clear();\n\n    if (recipient === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_FAILURE packet');\n    }\n\n    self._debug && self._debug(`Inbound: CHANNEL_FAILURE (r:${recipient})`);\n    const handler = self._handlers.CHANNEL_FAILURE;\n    handler && handler(self, recipient);\n  }\n};","map":{"version":3,"names":["bufferSlice","bufferParser","doFatalError","sigSSHToASN1","writeUInt32BE","require","CHANNEL_OPEN_FAILURE","COMPAT","MESSAGE","TERMINAL_MODE","parseKey","TERMINAL_MODE_BY_VALUE","Array","from","Object","entries","reduce","obj","key","value","module","exports","DISCONNECT","self","payload","init","reason","readUInt32BE","desc","readString","lang","clear","undefined","_debug","handler","_handlers","IGNORE","UNIMPLEMENTED","seqno","DEBUG","display","readBool","msg","SERVICE_REQUEST","name","SERVICE_ACCEPT","USERAUTH_REQUEST","user","service","method","methodData","methodDesc","isChange","newPassword","oldPassword","hasSig","keyAlgo","blobEnd","pos","signature","length","utf8Slice","sessionID","_kex","blob","Buffer","allocUnsafe","set","Uint8Array","buffer","byteOffset","localHostname","localUsername","skipString","readList","readRaw","_authsQueue","push","USERAUTH_FAILURE","authMethods","partialSuccess","shift","USERAUTH_SUCCESS","USERAUTH_BANNER","prompt","USERAUTH_PASSWD_CHANGEREQ","USERAUTH_PK_OK","instructions","numPrompts","prompts","i","echo","USERAUTH_INFO_REQUEST","numResponses","responses","response","USERAUTH_INFO_RESPONSE","GLOBAL_REQUEST","wantReply","data","bindAddr","bindPort","socketPath","avail","keyRaw","Error","requestFailure","REQUEST_SUCCESS","REQUEST_FAILURE","CHANNEL_OPEN","type","sender","window","packetSize","channelInfo","destIP","destPort","srcIP","srcPort","channelOpenFail","ADMINISTRATIVELY_PROHIBITED","CHANNEL_OPEN_CONFIRMATION","recipient","description","CHANNEL_WINDOW_ADJUST","bytesToAdd","CHANNEL_DATA","CHANNEL_EXTENDED_DATA","CHANNEL_EOF","CHANNEL_CLOSE","CHANNEL_REQUEST","signal","coreDumped","_compatFlags","OLD_EXIT","num","errorMessage","term","cols","rows","width","height","modesBinary","modes","opcode","readByte","TTY_OP_END","single","protocol","cookie","screen","CHANNEL_SUCCESS","CHANNEL_FAILURE"],"sources":["/home/micqdf/AlpacaPunchTests/maintest/test1/client/node_modules/ssh2/lib/protocol/handlers.misc.js"],"sourcesContent":["'use strict';\n\nconst {\n  bufferSlice,\n  bufferParser,\n  doFatalError,\n  sigSSHToASN1,\n  writeUInt32BE,\n} = require('./utils.js');\n\nconst {\n  CHANNEL_OPEN_FAILURE,\n  COMPAT,\n  MESSAGE,\n  TERMINAL_MODE,\n} = require('./constants.js');\n\nconst {\n  parseKey,\n} = require('./keyParser.js');\n\nconst TERMINAL_MODE_BY_VALUE =\n  Array.from(Object.entries(TERMINAL_MODE))\n       .reduce((obj, [key, value]) => ({ ...obj, [key]: value }), {});\n\nmodule.exports = {\n  // Transport layer protocol ==================================================\n  [MESSAGE.DISCONNECT]: (self, payload) => {\n    /*\n      byte      SSH_MSG_DISCONNECT\n      uint32    reason code\n      string    description in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    bufferParser.init(payload, 1);\n    const reason = bufferParser.readUInt32BE();\n    const desc = bufferParser.readString(true);\n    const lang = bufferParser.readString();\n    bufferParser.clear();\n\n    if (lang === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed DISCONNECT packet'\n      );\n    }\n\n    self._debug && self._debug(\n      `Inbound: Received DISCONNECT (${reason}, \"${desc}\")`\n    );\n\n    const handler = self._handlers.DISCONNECT;\n    handler && handler(self, reason, desc);\n  },\n  [MESSAGE.IGNORE]: (self, payload) => {\n    /*\n      byte      SSH_MSG_IGNORE\n      string    data\n    */\n    self._debug && self._debug('Inbound: Received IGNORE');\n  },\n  [MESSAGE.UNIMPLEMENTED]: (self, payload) => {\n    /*\n      byte      SSH_MSG_UNIMPLEMENTED\n      uint32    packet sequence number of rejected message\n    */\n    bufferParser.init(payload, 1);\n    const seqno = bufferParser.readUInt32BE();\n    bufferParser.clear();\n\n    if (seqno === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed UNIMPLEMENTED packet'\n      );\n    }\n\n    self._debug\n      && self._debug(`Inbound: Received UNIMPLEMENTED (seqno ${seqno})`);\n  },\n  [MESSAGE.DEBUG]: (self, payload) => {\n    /*\n      byte      SSH_MSG_DEBUG\n      boolean   always_display\n      string    message in ISO-10646 UTF-8 encoding [RFC3629]\n      string    language tag [RFC3066]\n    */\n    bufferParser.init(payload, 1);\n    const display = bufferParser.readBool();\n    const msg = bufferParser.readString(true);\n    const lang = bufferParser.readString();\n    bufferParser.clear();\n\n    if (lang === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed DEBUG packet'\n      );\n    }\n\n    self._debug && self._debug('Inbound: Received DEBUG');\n\n    const handler = self._handlers.DEBUG;\n    handler && handler(self, display, msg);\n  },\n  [MESSAGE.SERVICE_REQUEST]: (self, payload) => {\n    /*\n      byte      SSH_MSG_SERVICE_REQUEST\n      string    service name\n    */\n    bufferParser.init(payload, 1);\n    const name = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (name === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed SERVICE_REQUEST packet'\n      );\n    }\n\n    self._debug && self._debug(`Inbound: Received SERVICE_REQUEST (${name})`);\n\n    const handler = self._handlers.SERVICE_REQUEST;\n    handler && handler(self, name);\n  },\n  [MESSAGE.SERVICE_ACCEPT]: (self, payload) => {\n    // S->C\n    /*\n      byte      SSH_MSG_SERVICE_ACCEPT\n      string    service name\n    */\n    bufferParser.init(payload, 1);\n    const name = bufferParser.readString(true);\n    bufferParser.clear();\n\n    if (name === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed SERVICE_ACCEPT packet'\n      );\n    }\n\n    self._debug && self._debug(`Inbound: Received SERVICE_ACCEPT (${name})`);\n\n    const handler = self._handlers.SERVICE_ACCEPT;\n    handler && handler(self, name);\n  },\n\n  // User auth protocol -- generic =============================================\n  [MESSAGE.USERAUTH_REQUEST]: (self, payload) => {\n    /*\n      byte      SSH_MSG_USERAUTH_REQUEST\n      string    user name in ISO-10646 UTF-8 encoding [RFC3629]\n      string    service name in US-ASCII\n      string    method name in US-ASCII\n      ....      method specific fields\n    */\n    bufferParser.init(payload, 1);\n    const user = bufferParser.readString(true);\n    const service = bufferParser.readString(true);\n    const method = bufferParser.readString(true);\n    let methodData;\n    let methodDesc;\n    switch (method) {\n      case 'none':\n        methodData = null;\n        break;\n      case 'password': {\n        /*\n          boolean   <new password follows (old) plaintext password?>\n          string    plaintext password in ISO-10646 UTF-8 encoding [RFC3629]\n         [string    new password]\n        */\n        const isChange = bufferParser.readBool();\n        if (isChange !== undefined) {\n          methodData = bufferParser.readString(true);\n          if (methodData !== undefined && isChange) {\n            const newPassword = bufferParser.readString(true);\n            if (newPassword !== undefined)\n              methodData = { oldPassword: methodData, newPassword };\n            else\n              methodData = undefined;\n          }\n        }\n        break;\n      }\n      case 'publickey': {\n        /*\n          boolean   <signature follows public key blob?>\n          string    public key algorithm name\n          string    public key blob\n         [string    signature]\n        */\n        const hasSig = bufferParser.readBool();\n        if (hasSig !== undefined) {\n          const keyAlgo = bufferParser.readString(true);\n          const key = bufferParser.readString();\n          if (hasSig) {\n            const blobEnd = bufferParser.pos();\n            let signature = bufferParser.readString();\n            if (signature !== undefined) {\n              if (signature.length > (4 + keyAlgo.length + 4)\n                  && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {\n                // Skip algoLen + algo + sigLen\n                signature = bufferSlice(signature, 4 + keyAlgo.length + 4);\n              }\n\n              signature = sigSSHToASN1(signature, keyAlgo);\n              if (signature) {\n                const sessionID = self._kex.sessionID;\n                const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);\n                writeUInt32BE(blob, sessionID.length, 0);\n                blob.set(sessionID, 4);\n                blob.set(\n                  new Uint8Array(payload.buffer, payload.byteOffset, blobEnd),\n                  4 + sessionID.length\n                );\n                methodData = {\n                  keyAlgo,\n                  key,\n                  signature,\n                  blob,\n                };\n              }\n            }\n          } else {\n            methodData = { keyAlgo, key };\n            methodDesc = 'publickey -- check';\n          }\n        }\n        break;\n      }\n      case 'hostbased': {\n        /*\n          string    public key algorithm for host key\n          string    public host key and certificates for client host\n          string    client host name expressed as the FQDN in US-ASCII\n          string    user name on the client host in ISO-10646 UTF-8 encoding\n                     [RFC3629]\n          string    signature\n        */\n        const keyAlgo = bufferParser.readString(true);\n        const key = bufferParser.readString();\n        const localHostname = bufferParser.readString(true);\n        const localUsername = bufferParser.readString(true);\n\n        const blobEnd = bufferParser.pos();\n        let signature = bufferParser.readString();\n        if (signature !== undefined) {\n          if (signature.length > (4 + keyAlgo.length + 4)\n              && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {\n            // Skip algoLen + algo + sigLen\n            signature = bufferSlice(signature, 4 + keyAlgo.length + 4);\n          }\n\n          signature = sigSSHToASN1(signature, keyAlgo);\n          if (signature !== undefined) {\n            const sessionID = self._kex.sessionID;\n            const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);\n            writeUInt32BE(blob, sessionID.length, 0);\n            blob.set(sessionID, 4);\n            blob.set(\n              new Uint8Array(payload.buffer, payload.byteOffset, blobEnd),\n              4 + sessionID.length\n            );\n            methodData = {\n              keyAlgo,\n              key,\n              signature,\n              blob,\n              localHostname,\n              localUsername,\n            };\n          }\n        }\n        break;\n      }\n      case 'keyboard-interactive':\n        /*\n          string    language tag (as defined in [RFC-3066])\n          string    submethods (ISO-10646 UTF-8)\n        */\n        // Skip/ignore language field -- it's deprecated in RFC 4256\n        bufferParser.skipString();\n\n        methodData = bufferParser.readList();\n        break;\n      default:\n        if (method !== undefined)\n          methodData = bufferParser.readRaw();\n    }\n    bufferParser.clear();\n\n    if (methodData === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed USERAUTH_REQUEST packet'\n      );\n    }\n\n    if (methodDesc === undefined)\n      methodDesc = method;\n\n    self._authsQueue.push(method);\n\n    self._debug\n      && self._debug(`Inbound: Received USERAUTH_REQUEST (${methodDesc})`);\n\n    const handler = self._handlers.USERAUTH_REQUEST;\n    handler && handler(self, user, service, method, methodData);\n  },\n  [MESSAGE.USERAUTH_FAILURE]: (self, payload) => {\n    // S->C\n    /*\n      byte         SSH_MSG_USERAUTH_FAILURE\n      name-list    authentications that can continue\n      boolean      partial success\n    */\n    bufferParser.init(payload, 1);\n    const authMethods = bufferParser.readList();\n    const partialSuccess = bufferParser.readBool();\n    bufferParser.clear();\n\n    if (partialSuccess === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed USERAUTH_FAILURE packet'\n      );\n    }\n\n    self._debug\n      && self._debug(`Inbound: Received USERAUTH_FAILURE (${authMethods})`);\n\n    self._authsQueue.shift();\n    const handler = self._handlers.USERAUTH_FAILURE;\n    handler && handler(self, authMethods, partialSuccess);\n  },\n  [MESSAGE.USERAUTH_SUCCESS]: (self, payload) => {\n    // S->C\n    /*\n      byte      SSH_MSG_USERAUTH_SUCCESS\n    */\n    self._debug && self._debug('Inbound: Received USERAUTH_SUCCESS');\n\n    self._authsQueue.shift();\n    const handler = self._handlers.USERAUTH_SUCCESS;\n    handler && handler(self);\n  },\n  [MESSAGE.USERAUTH_BANNER]: (self, payload) => {\n    // S->C\n    /*\n      byte      SSH_MSG_USERAUTH_BANNER\n      string    message in ISO-10646 UTF-8 encoding [RFC3629]\n      string    language tag [RFC3066]\n    */\n    bufferParser.init(payload, 1);\n    const msg = bufferParser.readString(true);\n    const lang = bufferParser.readString();\n    bufferParser.clear();\n\n    if (lang === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed USERAUTH_BANNER packet'\n      );\n    }\n\n    self._debug && self._debug('Inbound: Received USERAUTH_BANNER');\n\n    const handler = self._handlers.USERAUTH_BANNER;\n    handler && handler(self, msg);\n  },\n\n  // User auth protocol -- method-specific =====================================\n  60: (self, payload) => {\n    if (!self._authsQueue.length) {\n      self._debug\n        && self._debug('Inbound: Received payload type 60 without auth');\n      return;\n    }\n\n    switch (self._authsQueue[0]) {\n      case 'password': {\n        // S->C\n        /*\n          byte      SSH_MSG_USERAUTH_PASSWD_CHANGEREQ\n          string    prompt in ISO-10646 UTF-8 encoding [RFC3629]\n          string    language tag [RFC3066]\n        */\n        bufferParser.init(payload, 1);\n        const prompt = bufferParser.readString(true);\n        const lang = bufferParser.readString();\n        bufferParser.clear();\n\n        if (lang === undefined) {\n          return doFatalError(\n            self,\n            'Inbound: Malformed USERAUTH_PASSWD_CHANGEREQ packet'\n          );\n        }\n\n        self._debug\n          && self._debug('Inbound: Received USERAUTH_PASSWD_CHANGEREQ');\n\n        const handler = self._handlers.USERAUTH_PASSWD_CHANGEREQ;\n        handler && handler(self, prompt);\n        break;\n      }\n      case 'publickey': {\n        // S->C\n        /*\n          byte      SSH_MSG_USERAUTH_PK_OK\n          string    public key algorithm name from the request\n          string    public key blob from the request\n        */\n        bufferParser.init(payload, 1);\n        const keyAlgo = bufferParser.readString(true);\n        const key = bufferParser.readString();\n        bufferParser.clear();\n\n        if (key === undefined) {\n          return doFatalError(\n            self,\n            'Inbound: Malformed USERAUTH_PK_OK packet'\n          );\n        }\n\n        self._debug && self._debug('Inbound: Received USERAUTH_PK_OK');\n\n        self._authsQueue.shift();\n        const handler = self._handlers.USERAUTH_PK_OK;\n        handler && handler(self, keyAlgo, key);\n        break;\n      }\n      case 'keyboard-interactive': {\n        // S->C\n        /*\n          byte      SSH_MSG_USERAUTH_INFO_REQUEST\n          string    name (ISO-10646 UTF-8)\n          string    instruction (ISO-10646 UTF-8)\n          string    language tag (as defined in [RFC-3066])\n          int       num-prompts\n          string    prompt[1] (ISO-10646 UTF-8)\n          boolean   echo[1]\n          ...\n          string    prompt[num-prompts] (ISO-10646 UTF-8)\n          boolean   echo[num-prompts]\n        */\n        bufferParser.init(payload, 1);\n        const name = bufferParser.readString(true);\n        const instructions = bufferParser.readString(true);\n        bufferParser.readString(); // skip lang\n        const numPrompts = bufferParser.readUInt32BE();\n        let prompts;\n        if (numPrompts !== undefined) {\n          prompts = new Array(numPrompts);\n          let i;\n          for (i = 0; i < numPrompts; ++i) {\n            const prompt = bufferParser.readString(true);\n            const echo = bufferParser.readBool();\n            if (echo === undefined)\n              break;\n            prompts[i] = { prompt, echo };\n          }\n          if (i !== numPrompts)\n            prompts = undefined;\n        }\n        bufferParser.clear();\n\n        if (prompts === undefined) {\n          return doFatalError(\n            self,\n            'Inbound: Malformed USERAUTH_INFO_REQUEST packet'\n          );\n        }\n\n        self._debug && self._debug('Inbound: Received USERAUTH_INFO_REQUEST');\n\n        const handler = self._handlers.USERAUTH_INFO_REQUEST;\n        handler && handler(self, name, instructions, prompts);\n        break;\n      }\n      default:\n        self._debug\n          && self._debug('Inbound: Received unexpected payload type 60');\n    }\n  },\n  61: (self, payload) => {\n    if (!self._authsQueue.length) {\n      self._debug\n        && self._debug('Inbound: Received payload type 61 without auth');\n      return;\n    }\n    /*\n      byte      SSH_MSG_USERAUTH_INFO_RESPONSE\n      int       num-responses\n      string    response[1] (ISO-10646 UTF-8)\n      ...\n      string    response[num-responses] (ISO-10646 UTF-8)\n    */\n    if (self._authsQueue[0] !== 'keyboard-interactive') {\n      return doFatalError(\n        self,\n        'Inbound: Received unexpected payload type 61'\n      );\n    }\n    bufferParser.init(payload, 1);\n    const numResponses = bufferParser.readUInt32BE();\n    let responses;\n    if (numResponses !== undefined) {\n      responses = new Array(numResponses);\n      let i;\n      for (i = 0; i < numResponses; ++i) {\n        const response = bufferParser.readString(true);\n        if (response === undefined)\n          break;\n        responses[i] = response;\n      }\n      if (i !== numResponses)\n        responses = undefined;\n    }\n    bufferParser.clear();\n\n    if (responses === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed USERAUTH_INFO_RESPONSE packet'\n      );\n    }\n\n    self._debug && self._debug('Inbound: Received USERAUTH_INFO_RESPONSE');\n\n    const handler = self._handlers.USERAUTH_INFO_RESPONSE;\n    handler && handler(self, responses);\n  },\n\n  // Connection protocol -- generic ============================================\n  [MESSAGE.GLOBAL_REQUEST]: (self, payload) => {\n    /*\n      byte      SSH_MSG_GLOBAL_REQUEST\n      string    request name in US-ASCII only\n      boolean   want reply\n      ....      request-specific data follows\n    */\n    bufferParser.init(payload, 1);\n    const name = bufferParser.readString(true);\n    const wantReply = bufferParser.readBool();\n    let data;\n    if (wantReply !== undefined) {\n      switch (name) {\n        case 'tcpip-forward':\n        case 'cancel-tcpip-forward': {\n          /*\n            string    address to bind (e.g., \"0.0.0.0\")\n            uint32    port number to bind\n          */\n          const bindAddr = bufferParser.readString(true);\n          const bindPort = bufferParser.readUInt32BE();\n          if (bindPort !== undefined)\n            data = { bindAddr, bindPort };\n          break;\n        }\n        case 'streamlocal-forward@openssh.com':\n        case 'cancel-streamlocal-forward@openssh.com': {\n          /*\n            string    socket path\n          */\n          const socketPath = bufferParser.readString(true);\n          if (socketPath !== undefined)\n            data = { socketPath };\n          break;\n        }\n        case 'no-more-sessions@openssh.com':\n          data = null;\n          break;\n        case 'hostkeys-00@openssh.com': {\n          data = [];\n          while (bufferParser.avail() > 0) {\n            const keyRaw = bufferParser.readString();\n            if (keyRaw === undefined) {\n              data = undefined;\n              break;\n            }\n            const key = parseKey(keyRaw);\n            if (!(key instanceof Error))\n              data.push(key);\n          }\n          break;\n        }\n        default:\n          data = bufferParser.readRaw();\n      }\n    }\n    bufferParser.clear();\n\n    if (data === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed GLOBAL_REQUEST packet'\n      );\n    }\n\n    self._debug && self._debug(`Inbound: GLOBAL_REQUEST (${name})`);\n\n    const handler = self._handlers.GLOBAL_REQUEST;\n    if (handler)\n      handler(self, name, wantReply, data);\n    else\n      self.requestFailure(); // Auto reject\n  },\n  [MESSAGE.REQUEST_SUCCESS]: (self, payload) => {\n    /*\n      byte      SSH_MSG_REQUEST_SUCCESS\n      ....     response specific data\n    */\n    const data = (payload.length > 1 ? bufferSlice(payload, 1) : null);\n\n    self._debug && self._debug('Inbound: REQUEST_SUCCESS');\n\n    const handler = self._handlers.REQUEST_SUCCESS;\n    handler && handler(self, data);\n  },\n  [MESSAGE.REQUEST_FAILURE]: (self, payload) => {\n    /*\n      byte      SSH_MSG_REQUEST_FAILURE\n    */\n    self._debug && self._debug('Inbound: Received REQUEST_FAILURE');\n\n    const handler = self._handlers.REQUEST_FAILURE;\n    handler && handler(self);\n  },\n\n  // Connection protocol -- channel-related ====================================\n  [MESSAGE.CHANNEL_OPEN]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN\n      string    channel type in US-ASCII only\n      uint32    sender channel\n      uint32    initial window size\n      uint32    maximum packet size\n      ....      channel type specific data follows\n    */\n    bufferParser.init(payload, 1);\n    const type = bufferParser.readString(true);\n    const sender = bufferParser.readUInt32BE();\n    const window = bufferParser.readUInt32BE();\n    const packetSize = bufferParser.readUInt32BE();\n    let channelInfo;\n\n    switch (type) {\n      case 'forwarded-tcpip': // S->C\n      case 'direct-tcpip': { // C->S\n        /*\n          string    address that was connected / host to connect\n          uint32    port that was connected / port to connect\n          string    originator IP address\n          uint32    originator port\n        */\n        const destIP = bufferParser.readString(true);\n        const destPort = bufferParser.readUInt32BE();\n        const srcIP = bufferParser.readString(true);\n        const srcPort = bufferParser.readUInt32BE();\n        if (srcPort !== undefined) {\n          channelInfo = {\n            type,\n            sender,\n            window,\n            packetSize,\n            data: { destIP, destPort, srcIP, srcPort }\n          };\n        }\n        break;\n      }\n      case 'forwarded-streamlocal@openssh.com': // S->C\n      case 'direct-streamlocal@openssh.com': { // C->S\n        /*\n          string    socket path\n          string    reserved for future use\n\n          (direct-streamlocal@openssh.com additionally has:)\n          uint32    reserved\n        */\n        const socketPath = bufferParser.readString(true);\n        if (socketPath !== undefined) {\n          channelInfo = {\n            type,\n            sender,\n            window,\n            packetSize,\n            data: { socketPath }\n          };\n        }\n        break;\n      }\n      case 'x11': { // S->C\n        /*\n          string    originator address (e.g., \"192.168.7.38\")\n          uint32    originator port\n        */\n        const srcIP = bufferParser.readString(true);\n        const srcPort = bufferParser.readUInt32BE();\n        if (srcPort !== undefined) {\n          channelInfo = {\n            type,\n            sender,\n            window,\n            packetSize,\n            data: { srcIP, srcPort }\n          };\n        }\n        break;\n      }\n      default:\n        // Includes:\n        //   'session' (C->S)\n        //   'auth-agent@openssh.com' (S->C)\n        channelInfo = {\n          type,\n          sender,\n          window,\n          packetSize,\n          data: {}\n        };\n    }\n    bufferParser.clear();\n\n    if (channelInfo === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed CHANNEL_OPEN packet'\n      );\n    }\n\n    self._debug && self._debug(`Inbound: CHANNEL_OPEN (s:${sender}, ${type})`);\n\n    const handler = self._handlers.CHANNEL_OPEN;\n    if (handler) {\n      handler(self, channelInfo);\n    } else {\n      self.channelOpenFail(\n        channelInfo.sender,\n        CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED,\n        '',\n        ''\n      );\n    }\n  },\n  [MESSAGE.CHANNEL_OPEN_CONFIRMATION]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN_CONFIRMATION\n      uint32    recipient channel\n      uint32    sender channel\n      uint32    initial window size\n      uint32    maximum packet size\n      ....      channel type specific data follows\n    */\n    // \"The 'recipient channel' is the channel number given in the\n    // original open request, and 'sender channel' is the channel number\n    // allocated by the other side.\"\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const sender = bufferParser.readUInt32BE();\n    const window = bufferParser.readUInt32BE();\n    const packetSize = bufferParser.readUInt32BE();\n    const data = (bufferParser.avail() ? bufferParser.readRaw() : undefined);\n    bufferParser.clear();\n\n    if (packetSize === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed CHANNEL_OPEN_CONFIRMATION packet'\n      );\n    }\n\n    self._debug && self._debug(\n      `Inbound: CHANNEL_OPEN_CONFIRMATION (r:${recipient}, s:${sender})`\n    );\n\n    const handler = self._handlers.CHANNEL_OPEN_CONFIRMATION;\n    if (handler)\n      handler(self, { recipient, sender, window, packetSize, data });\n  },\n  [MESSAGE.CHANNEL_OPEN_FAILURE]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN_FAILURE\n      uint32    recipient channel\n      uint32    reason code\n      string    description in ISO-10646 UTF-8 encoding [RFC3629]\n      string    language tag [RFC3066]\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const reason = bufferParser.readUInt32BE();\n    const description = bufferParser.readString(true);\n    const lang = bufferParser.readString();\n    bufferParser.clear();\n\n    if (lang === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed CHANNEL_OPEN_FAILURE packet'\n      );\n    }\n\n    self._debug\n      && self._debug(`Inbound: CHANNEL_OPEN_FAILURE (r:${recipient})`);\n\n    const handler = self._handlers.CHANNEL_OPEN_FAILURE;\n    handler && handler(self, recipient, reason, description);\n  },\n  [MESSAGE.CHANNEL_WINDOW_ADJUST]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_WINDOW_ADJUST\n      uint32    recipient channel\n      uint32    bytes to add\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const bytesToAdd = bufferParser.readUInt32BE();\n    bufferParser.clear();\n\n    if (bytesToAdd === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed CHANNEL_WINDOW_ADJUST packet'\n      );\n    }\n\n    self._debug && self._debug(\n      `Inbound: CHANNEL_WINDOW_ADJUST (r:${recipient}, ${bytesToAdd})`\n    );\n\n    const handler = self._handlers.CHANNEL_WINDOW_ADJUST;\n    handler && handler(self, recipient, bytesToAdd);\n  },\n  [MESSAGE.CHANNEL_DATA]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_DATA\n      uint32    recipient channel\n      string    data\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const data = bufferParser.readString();\n    bufferParser.clear();\n\n    if (data === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed CHANNEL_DATA packet'\n      );\n    }\n\n    self._debug\n      && self._debug(`Inbound: CHANNEL_DATA (r:${recipient}, ${data.length})`);\n\n    const handler = self._handlers.CHANNEL_DATA;\n    handler && handler(self, recipient, data);\n  },\n  [MESSAGE.CHANNEL_EXTENDED_DATA]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_EXTENDED_DATA\n      uint32    recipient channel\n      uint32    data_type_code\n      string    data\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const type = bufferParser.readUInt32BE();\n    const data = bufferParser.readString();\n    bufferParser.clear();\n\n    if (data === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed CHANNEL_EXTENDED_DATA packet'\n      );\n    }\n\n    self._debug && self._debug(\n      `Inbound: CHANNEL_EXTENDED_DATA (r:${recipient}, ${data.length})`\n    );\n\n    const handler = self._handlers.CHANNEL_EXTENDED_DATA;\n    handler && handler(self, recipient, data, type);\n  },\n  [MESSAGE.CHANNEL_EOF]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_EOF\n      uint32    recipient channel\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    bufferParser.clear();\n\n    if (recipient === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed CHANNEL_EOF packet'\n      );\n    }\n\n    self._debug && self._debug(`Inbound: CHANNEL_EOF (r:${recipient})`);\n\n    const handler = self._handlers.CHANNEL_EOF;\n    handler && handler(self, recipient);\n  },\n  [MESSAGE.CHANNEL_CLOSE]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_CLOSE\n      uint32    recipient channel\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    bufferParser.clear();\n\n    if (recipient === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed CHANNEL_CLOSE packet'\n      );\n    }\n\n    self._debug && self._debug(`Inbound: CHANNEL_CLOSE (r:${recipient})`);\n\n    const handler = self._handlers.CHANNEL_CLOSE;\n    handler && handler(self, recipient);\n  },\n  [MESSAGE.CHANNEL_REQUEST]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    request type in US-ASCII characters only\n      boolean   want reply\n      ....      type-specific data follows\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const type = bufferParser.readString(true);\n    const wantReply = bufferParser.readBool();\n    let data;\n    if (wantReply !== undefined) {\n      switch (type) {\n        case 'exit-status': // S->C\n          /*\n            uint32    exit_status\n          */\n          data = bufferParser.readUInt32BE();\n          self._debug && self._debug(\n            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`\n          );\n          break;\n        case 'exit-signal': { // S->C\n          /*\n            string    signal name (without the \"SIG\" prefix)\n            boolean   core dumped\n            string    error message in ISO-10646 UTF-8 encoding\n            string    language tag\n          */\n          let signal;\n          let coreDumped;\n          if (self._compatFlags & COMPAT.OLD_EXIT) {\n            /*\n              Instead of `signal name` and `core dumped`, we have just:\n                uint32  signal number\n            */\n            const num = bufferParser.readUInt32BE();\n            switch (num) {\n              case 1:\n                signal = 'HUP';\n                break;\n              case 2:\n                signal = 'INT';\n                break;\n              case 3:\n                signal = 'QUIT';\n                break;\n              case 6:\n                signal = 'ABRT';\n                break;\n              case 9:\n                signal = 'KILL';\n                break;\n              case 14:\n                signal = 'ALRM';\n                break;\n              case 15:\n                signal = 'TERM';\n                break;\n              default:\n                if (num !== undefined) {\n                  // Unknown or OS-specific\n                  signal = `UNKNOWN (${num})`;\n                }\n            }\n            coreDumped = false;\n          } else {\n            signal = bufferParser.readString(true);\n            coreDumped = bufferParser.readBool();\n            if (coreDumped === undefined)\n              signal = undefined;\n          }\n          const errorMessage = bufferParser.readString(true);\n          if (bufferParser.skipString() !== undefined)\n            data = { signal, coreDumped, errorMessage };\n          self._debug && self._debug(\n            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${signal})`\n          );\n          break;\n        }\n        case 'pty-req': { // C->S\n          /*\n            string    TERM environment variable value (e.g., vt100)\n            uint32    terminal width, characters (e.g., 80)\n            uint32    terminal height, rows (e.g., 24)\n            uint32    terminal width, pixels (e.g., 640)\n            uint32    terminal height, pixels (e.g., 480)\n            string    encoded terminal modes\n          */\n          const term = bufferParser.readString(true);\n          const cols = bufferParser.readUInt32BE();\n          const rows = bufferParser.readUInt32BE();\n          const width = bufferParser.readUInt32BE();\n          const height = bufferParser.readUInt32BE();\n          const modesBinary = bufferParser.readString();\n          if (modesBinary !== undefined) {\n            bufferParser.init(modesBinary, 1);\n            let modes = {};\n            while (bufferParser.avail()) {\n              const opcode = bufferParser.readByte();\n              if (opcode === TERMINAL_MODE.TTY_OP_END)\n                break;\n              const name = TERMINAL_MODE_BY_VALUE[opcode];\n              const value = bufferParser.readUInt32BE();\n              if (opcode === undefined\n                  || name === undefined\n                  || value === undefined) {\n                modes = undefined;\n                break;\n              }\n              modes[name] = value;\n            }\n            if (modes !== undefined)\n              data = { term, cols, rows, width, height, modes };\n          }\n          self._debug && self._debug(\n            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`\n          );\n          break;\n        }\n        case 'window-change': { // C->S\n          /*\n            uint32    terminal width, columns\n            uint32    terminal height, rows\n            uint32    terminal width, pixels\n            uint32    terminal height, pixels\n          */\n          const cols = bufferParser.readUInt32BE();\n          const rows = bufferParser.readUInt32BE();\n          const width = bufferParser.readUInt32BE();\n          const height = bufferParser.readUInt32BE();\n          if (height !== undefined)\n            data = { cols, rows, width, height };\n          self._debug && self._debug(\n            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`\n          );\n          break;\n        }\n        case 'x11-req': { // C->S\n          /*\n            boolean   single connection\n            string    x11 authentication protocol\n            string    x11 authentication cookie\n            uint32    x11 screen number\n          */\n          const single = bufferParser.readBool();\n          const protocol = bufferParser.readString(true);\n          const cookie = bufferParser.readString();\n          const screen = bufferParser.readUInt32BE();\n          if (screen !== undefined)\n            data = { single, protocol, cookie, screen };\n          self._debug && self._debug(\n            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`\n          );\n          break;\n        }\n        case 'env': { // C->S\n          /*\n            string    variable name\n            string    variable value\n          */\n          const name = bufferParser.readString(true);\n          const value = bufferParser.readString(true);\n          if (value !== undefined)\n            data = { name, value };\n          if (self._debug) {\n            self._debug(\n              `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: `\n                + `${name}=${value})`\n            );\n          }\n          break;\n        }\n        case 'shell': // C->S\n          data = null; // No extra data\n          self._debug && self._debug(\n            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`\n          );\n          break;\n        case 'exec': // C->S\n          /*\n            string    command\n          */\n          data = bufferParser.readString(true);\n          self._debug && self._debug(\n            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`\n          );\n          break;\n        case 'subsystem': // C->S\n          /*\n            string    subsystem name\n          */\n          data = bufferParser.readString(true);\n          self._debug && self._debug(\n            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`\n          );\n          break;\n        case 'signal': // C->S\n          /*\n            string    signal name (without the \"SIG\" prefix)\n          */\n          data = bufferParser.readString(true);\n          self._debug && self._debug(\n            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`\n          );\n          break;\n        case 'xon-xoff': // C->S\n          /*\n            boolean   client can do\n          */\n          data = bufferParser.readBool();\n          self._debug && self._debug(\n            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`\n          );\n          break;\n        case 'auth-agent-req@openssh.com': // C-S\n          data = null; // No extra data\n          self._debug && self._debug(\n            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`\n          );\n          break;\n        default:\n          data = (bufferParser.avail() ? bufferParser.readRaw() : null);\n          self._debug && self._debug(\n            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`\n          );\n      }\n    }\n    bufferParser.clear();\n\n    if (data === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed CHANNEL_REQUEST packet'\n      );\n    }\n\n    const handler = self._handlers.CHANNEL_REQUEST;\n    handler && handler(self, recipient, type, wantReply, data);\n  },\n  [MESSAGE.CHANNEL_SUCCESS]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_SUCCESS\n      uint32    recipient channel\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    bufferParser.clear();\n\n    if (recipient === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed CHANNEL_SUCCESS packet'\n      );\n    }\n\n    self._debug && self._debug(`Inbound: CHANNEL_SUCCESS (r:${recipient})`);\n\n    const handler = self._handlers.CHANNEL_SUCCESS;\n    handler && handler(self, recipient);\n  },\n  [MESSAGE.CHANNEL_FAILURE]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_FAILURE\n      uint32    recipient channel\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    bufferParser.clear();\n\n    if (recipient === undefined) {\n      return doFatalError(\n        self,\n        'Inbound: Malformed CHANNEL_FAILURE packet'\n      );\n    }\n\n    self._debug && self._debug(`Inbound: CHANNEL_FAILURE (r:${recipient})`);\n\n    const handler = self._handlers.CHANNEL_FAILURE;\n    handler && handler(self, recipient);\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}