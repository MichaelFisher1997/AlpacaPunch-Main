{"ast":null,"code":"'use strict';\n\nconst Ber = require('asn1').Ber;\n\nlet DISCONNECT_REASON;\nconst FastBuffer = Buffer[Symbol.species];\nconst TypedArrayFill = Object.getPrototypeOf(Uint8Array.prototype).fill;\n\nfunction readUInt32BE(buf, offset) {\n  return buf[offset++] * 16777216 + buf[offset++] * 65536 + buf[offset++] * 256 + buf[offset];\n}\n\nfunction bufferCopy(src, dest, srcStart, srcEnd, destStart) {\n  if (!destStart) destStart = 0;\n  if (srcEnd > src.length) srcEnd = src.length;\n  let nb = srcEnd - srcStart;\n  const destLeft = dest.length - destStart;\n  if (nb > destLeft) nb = destLeft;\n  dest.set(new Uint8Array(src.buffer, src.byteOffset + srcStart, nb), destStart);\n  return nb;\n}\n\nfunction bufferSlice(buf, start, end) {\n  if (end === undefined) end = buf.length;\n  return new FastBuffer(buf.buffer, buf.byteOffset + start, end - start);\n}\n\nfunction makeBufferParser() {\n  let pos = 0;\n  let buffer;\n  const self = {\n    init: (buf, start) => {\n      buffer = buf;\n      pos = typeof start === 'number' ? start : 0;\n    },\n    pos: () => pos,\n    length: () => buffer ? buffer.length : 0,\n    avail: () => buffer && pos < buffer.length ? buffer.length - pos : 0,\n    clear: () => {\n      buffer = undefined;\n    },\n    readUInt32BE: () => {\n      if (!buffer || pos + 3 >= buffer.length) return;\n      return buffer[pos++] * 16777216 + buffer[pos++] * 65536 + buffer[pos++] * 256 + buffer[pos++];\n    },\n    readUInt64BE: behavior => {\n      if (!buffer || pos + 7 >= buffer.length) return;\n\n      switch (behavior) {\n        case 'always':\n          return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);\n\n        case 'maybe':\n          if (buffer[pos] > 0x1F) return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);\n        // FALLTHROUGH\n\n        default:\n          return buffer[pos++] * 72057594037927940 + buffer[pos++] * 281474976710656 + buffer[pos++] * 1099511627776 + buffer[pos++] * 4294967296 + buffer[pos++] * 16777216 + buffer[pos++] * 65536 + buffer[pos++] * 256 + buffer[pos++];\n      }\n    },\n    skip: n => {\n      if (buffer && n > 0) pos += n;\n    },\n    skipString: () => {\n      const len = self.readUInt32BE();\n      if (len === undefined) return;\n      pos += len;\n      return pos <= buffer.length ? len : undefined;\n    },\n    readByte: () => {\n      if (buffer && pos < buffer.length) return buffer[pos++];\n    },\n    readBool: () => {\n      if (buffer && pos < buffer.length) return !!buffer[pos++];\n    },\n    readList: () => {\n      const list = self.readString(true);\n      if (list === undefined) return;\n      return list ? list.split(',') : [];\n    },\n    readString: (dest, maxLen) => {\n      if (typeof dest === 'number') {\n        maxLen = dest;\n        dest = undefined;\n      }\n\n      const len = self.readUInt32BE();\n      if (len === undefined) return;\n\n      if (buffer.length - pos < len || typeof maxLen === 'number' && len > maxLen) {\n        return;\n      }\n\n      if (dest) {\n        if (Buffer.isBuffer(dest)) return bufferCopy(buffer, dest, pos, pos += len);\n        return buffer.utf8Slice(pos, pos += len);\n      }\n\n      return bufferSlice(buffer, pos, pos += len);\n    },\n    readRaw: len => {\n      if (!buffer) return;\n      if (typeof len !== 'number') return bufferSlice(buffer, pos, pos += buffer.length - pos);\n      if (buffer.length - pos >= len) return bufferSlice(buffer, pos, pos += len);\n    }\n  };\n  return self;\n}\n\nfunction makeError(msg, level, fatal) {\n  const err = new Error(msg);\n\n  if (typeof level === 'boolean') {\n    fatal = level;\n    err.level = 'protocol';\n  } else {\n    err.level = level || 'protocol';\n  }\n\n  err.fatal = !!fatal;\n  return err;\n}\n\nfunction writeUInt32BE(buf, value, offset) {\n  buf[offset++] = value >>> 24;\n  buf[offset++] = value >>> 16;\n  buf[offset++] = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nconst utilBufferParser = makeBufferParser();\nmodule.exports = {\n  bufferCopy,\n  bufferSlice,\n  FastBuffer,\n  bufferFill: (buf, value, start, end) => {\n    return TypedArrayFill.call(buf, value, start, end);\n  },\n  makeError,\n  doFatalError: (protocol, msg, level, reason) => {\n    let err;\n    if (DISCONNECT_REASON === undefined) ({\n      DISCONNECT_REASON\n    } = require('./constants.js'));\n\n    if (msg instanceof Error) {\n      // doFatalError(protocol, err[, reason])\n      err = msg;\n      if (typeof level !== 'number') reason = DISCONNECT_REASON.PROTOCOL_ERROR;else reason = level;\n    } else {\n      // doFatalError(protocol, msg[, level[, reason]])\n      err = makeError(msg, level, true);\n    }\n\n    if (typeof reason !== 'number') reason = DISCONNECT_REASON.PROTOCOL_ERROR;\n    protocol.disconnect(reason);\n\n    protocol._destruct();\n\n    protocol._onError(err);\n\n    return Infinity;\n  },\n  readUInt32BE,\n  writeUInt32BE,\n  writeUInt32LE: (buf, value, offset) => {\n    buf[offset++] = value;\n    buf[offset++] = value >>> 8;\n    buf[offset++] = value >>> 16;\n    buf[offset++] = value >>> 24;\n    return offset;\n  },\n  makeBufferParser,\n  bufferParser: makeBufferParser(),\n  readString: (buffer, start, dest, maxLen) => {\n    if (typeof dest === 'number') {\n      maxLen = dest;\n      dest = undefined;\n    }\n\n    if (start === undefined) start = 0;\n    const left = buffer.length - start;\n    if (start < 0 || start >= buffer.length || left < 4) return;\n    const len = readUInt32BE(buffer, start);\n    if (left < 4 + len || typeof maxLen === 'number' && len > maxLen) return;\n    start += 4;\n    const end = start + len;\n    buffer._pos = end;\n\n    if (dest) {\n      if (Buffer.isBuffer(dest)) return bufferCopy(buffer, dest, start, end);\n      return buffer.utf8Slice(start, end);\n    }\n\n    return bufferSlice(buffer, start, end);\n  },\n  sigSSHToASN1: (sig, type) => {\n    switch (type) {\n      case 'ssh-dss':\n        {\n          if (sig.length > 40) return sig; // Change bare signature r and s values to ASN.1 BER values for OpenSSL\n\n          const asnWriter = new Ber.Writer();\n          asnWriter.startSequence();\n          let r = sig.slice(0, 20);\n          let s = sig.slice(20);\n\n          if (r[0] & 0x80) {\n            const rNew = Buffer.allocUnsafe(21);\n            rNew[0] = 0x00;\n            r.copy(rNew, 1);\n            r = rNew;\n          } else if (r[0] === 0x00 && !(r[1] & 0x80)) {\n            r = r.slice(1);\n          }\n\n          if (s[0] & 0x80) {\n            const sNew = Buffer.allocUnsafe(21);\n            sNew[0] = 0x00;\n            s.copy(sNew, 1);\n            s = sNew;\n          } else if (s[0] === 0x00 && !(s[1] & 0x80)) {\n            s = s.slice(1);\n          }\n\n          asnWriter.writeBuffer(r, Ber.Integer);\n          asnWriter.writeBuffer(s, Ber.Integer);\n          asnWriter.endSequence();\n          return asnWriter.buffer;\n        }\n\n      case 'ecdsa-sha2-nistp256':\n      case 'ecdsa-sha2-nistp384':\n      case 'ecdsa-sha2-nistp521':\n        {\n          utilBufferParser.init(sig, 0);\n          const r = utilBufferParser.readString();\n          const s = utilBufferParser.readString();\n          utilBufferParser.clear();\n          if (r === undefined || s === undefined) return;\n          const asnWriter = new Ber.Writer();\n          asnWriter.startSequence();\n          asnWriter.writeBuffer(r, Ber.Integer);\n          asnWriter.writeBuffer(s, Ber.Integer);\n          asnWriter.endSequence();\n          return asnWriter.buffer;\n        }\n\n      default:\n        return sig;\n    }\n  },\n  convertSignature: (signature, keyType) => {\n    switch (keyType) {\n      case 'ssh-dss':\n        {\n          if (signature.length <= 40) return signature; // This is a quick and dirty way to get from BER encoded r and s that\n          // OpenSSL gives us, to just the bare values back to back (40 bytes\n          // total) like OpenSSH (and possibly others) are expecting\n\n          const asnReader = new Ber.Reader(signature);\n          asnReader.readSequence();\n          let r = asnReader.readString(Ber.Integer, true);\n          let s = asnReader.readString(Ber.Integer, true);\n          let rOffset = 0;\n          let sOffset = 0;\n\n          if (r.length < 20) {\n            const rNew = Buffer.allocUnsafe(20);\n            rNew.set(r, 1);\n            r = rNew;\n            r[0] = 0;\n          }\n\n          if (s.length < 20) {\n            const sNew = Buffer.allocUnsafe(20);\n            sNew.set(s, 1);\n            s = sNew;\n            s[0] = 0;\n          }\n\n          if (r.length > 20 && r[0] === 0) rOffset = 1;\n          if (s.length > 20 && s[0] === 0) sOffset = 1;\n          const newSig = Buffer.allocUnsafe(r.length - rOffset + (s.length - sOffset));\n          bufferCopy(r, newSig, rOffset, r.length, 0);\n          bufferCopy(s, newSig, sOffset, s.length, r.length - rOffset);\n          return newSig;\n        }\n\n      case 'ecdsa-sha2-nistp256':\n      case 'ecdsa-sha2-nistp384':\n      case 'ecdsa-sha2-nistp521':\n        {\n          if (signature[0] === 0) return signature; // Convert SSH signature parameters to ASN.1 BER values for OpenSSL\n\n          const asnReader = new Ber.Reader(signature);\n          asnReader.readSequence();\n          const r = asnReader.readString(Ber.Integer, true);\n          const s = asnReader.readString(Ber.Integer, true);\n          if (r === null || s === null) return;\n          const newSig = Buffer.allocUnsafe(4 + r.length + 4 + s.length);\n          writeUInt32BE(newSig, r.length, 0);\n          newSig.set(r, 4);\n          writeUInt32BE(newSig, s.length, 4 + r.length);\n          newSig.set(s, 4 + 4 + r.length);\n          return newSig;\n        }\n    }\n\n    return signature;\n  },\n  sendPacket: (proto, packet, bypass) => {\n    if (!bypass && proto._kexinit !== undefined) {\n      // We're currently in the middle of a handshake\n      if (proto._queue === undefined) proto._queue = [];\n\n      proto._queue.push(packet);\n\n      proto._debug && proto._debug('Outbound: ... packet queued');\n      return false;\n    }\n\n    proto._cipher.encrypt(packet);\n\n    return true;\n  }\n};","map":{"version":3,"names":["Ber","require","DISCONNECT_REASON","FastBuffer","Buffer","Symbol","species","TypedArrayFill","Object","getPrototypeOf","Uint8Array","prototype","fill","readUInt32BE","buf","offset","bufferCopy","src","dest","srcStart","srcEnd","destStart","length","nb","destLeft","set","buffer","byteOffset","bufferSlice","start","end","undefined","makeBufferParser","pos","self","init","avail","clear","readUInt64BE","behavior","BigInt","hexSlice","skip","n","skipString","len","readByte","readBool","readList","list","readString","split","maxLen","isBuffer","utf8Slice","readRaw","makeError","msg","level","fatal","err","Error","writeUInt32BE","value","utilBufferParser","module","exports","bufferFill","call","doFatalError","protocol","reason","PROTOCOL_ERROR","disconnect","_destruct","_onError","Infinity","writeUInt32LE","bufferParser","left","_pos","sigSSHToASN1","sig","type","asnWriter","Writer","startSequence","r","slice","s","rNew","allocUnsafe","copy","sNew","writeBuffer","Integer","endSequence","convertSignature","signature","keyType","asnReader","Reader","readSequence","rOffset","sOffset","newSig","sendPacket","proto","packet","bypass","_kexinit","_queue","push","_debug","_cipher","encrypt"],"sources":["/home/micqdf/AlpacaPunchTests/maintest/test1/client/node_modules/ssh2/lib/protocol/utils.js"],"sourcesContent":["'use strict';\n\nconst Ber = require('asn1').Ber;\n\nlet DISCONNECT_REASON;\n\nconst FastBuffer = Buffer[Symbol.species];\nconst TypedArrayFill = Object.getPrototypeOf(Uint8Array.prototype).fill;\n\nfunction readUInt32BE(buf, offset) {\n  return (buf[offset++] * 16777216)\n         + (buf[offset++] * 65536)\n         + (buf[offset++] * 256)\n         + buf[offset];\n}\n\nfunction bufferCopy(src, dest, srcStart, srcEnd, destStart) {\n  if (!destStart)\n    destStart = 0;\n  if (srcEnd > src.length)\n    srcEnd = src.length;\n  let nb = srcEnd - srcStart;\n  const destLeft = (dest.length - destStart);\n  if (nb > destLeft)\n    nb = destLeft;\n  dest.set(new Uint8Array(src.buffer, src.byteOffset + srcStart, nb),\n           destStart);\n  return nb;\n}\n\nfunction bufferSlice(buf, start, end) {\n  if (end === undefined)\n    end = buf.length;\n  return new FastBuffer(buf.buffer, buf.byteOffset + start, end - start);\n}\n\nfunction makeBufferParser() {\n  let pos = 0;\n  let buffer;\n\n  const self = {\n    init: (buf, start) => {\n      buffer = buf;\n      pos = (typeof start === 'number' ? start : 0);\n    },\n    pos: () => pos,\n    length: () => (buffer ? buffer.length : 0),\n    avail: () => (buffer && pos < buffer.length ? buffer.length - pos : 0),\n    clear: () => {\n      buffer = undefined;\n    },\n    readUInt32BE: () => {\n      if (!buffer || pos + 3 >= buffer.length)\n        return;\n      return (buffer[pos++] * 16777216)\n             + (buffer[pos++] * 65536)\n             + (buffer[pos++] * 256)\n             + buffer[pos++];\n    },\n    readUInt64BE: (behavior) => {\n      if (!buffer || pos + 7 >= buffer.length)\n        return;\n      switch (behavior) {\n        case 'always':\n          return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);\n        case 'maybe':\n          if (buffer[pos] > 0x1F)\n            return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);\n          // FALLTHROUGH\n        default:\n          return (buffer[pos++] * 72057594037927940)\n                 + (buffer[pos++] * 281474976710656)\n                 + (buffer[pos++] * 1099511627776)\n                 + (buffer[pos++] * 4294967296)\n                 + (buffer[pos++] * 16777216)\n                 + (buffer[pos++] * 65536)\n                 + (buffer[pos++] * 256)\n                 + buffer[pos++];\n      }\n    },\n    skip: (n) => {\n      if (buffer && n > 0)\n        pos += n;\n    },\n    skipString: () => {\n      const len = self.readUInt32BE();\n      if (len === undefined)\n        return;\n      pos += len;\n      return (pos <= buffer.length ? len : undefined);\n    },\n    readByte: () => {\n      if (buffer && pos < buffer.length)\n        return buffer[pos++];\n    },\n    readBool: () => {\n      if (buffer && pos < buffer.length)\n        return !!buffer[pos++];\n    },\n    readList: () => {\n      const list = self.readString(true);\n      if (list === undefined)\n        return;\n      return (list ? list.split(',') : []);\n    },\n    readString: (dest, maxLen) => {\n      if (typeof dest === 'number') {\n        maxLen = dest;\n        dest = undefined;\n      }\n\n      const len = self.readUInt32BE();\n      if (len === undefined)\n        return;\n\n      if ((buffer.length - pos) < len\n          || (typeof maxLen === 'number' && len > maxLen)) {\n        return;\n      }\n\n      if (dest) {\n        if (Buffer.isBuffer(dest))\n          return bufferCopy(buffer, dest, pos, pos += len);\n        return buffer.utf8Slice(pos, pos += len);\n      }\n      return bufferSlice(buffer, pos, pos += len);\n    },\n    readRaw: (len) => {\n      if (!buffer)\n        return;\n      if (typeof len !== 'number')\n        return bufferSlice(buffer, pos, pos += (buffer.length - pos));\n      if ((buffer.length - pos) >= len)\n        return bufferSlice(buffer, pos, pos += len);\n    },\n  };\n\n  return self;\n}\n\nfunction makeError(msg, level, fatal) {\n  const err = new Error(msg);\n  if (typeof level === 'boolean') {\n    fatal = level;\n    err.level = 'protocol';\n  } else {\n    err.level = level || 'protocol';\n  }\n  err.fatal = !!fatal;\n  return err;\n}\n\nfunction writeUInt32BE(buf, value, offset) {\n  buf[offset++] = (value >>> 24);\n  buf[offset++] = (value >>> 16);\n  buf[offset++] = (value >>> 8);\n  buf[offset++] = value;\n  return offset;\n}\n\nconst utilBufferParser = makeBufferParser();\n\nmodule.exports = {\n  bufferCopy,\n  bufferSlice,\n  FastBuffer,\n  bufferFill: (buf, value, start, end) => {\n    return TypedArrayFill.call(buf, value, start, end);\n  },\n  makeError,\n  doFatalError: (protocol, msg, level, reason) => {\n    let err;\n    if (DISCONNECT_REASON === undefined)\n      ({ DISCONNECT_REASON } = require('./constants.js'));\n    if (msg instanceof Error) {\n      // doFatalError(protocol, err[, reason])\n      err = msg;\n      if (typeof level !== 'number')\n        reason = DISCONNECT_REASON.PROTOCOL_ERROR;\n      else\n        reason = level;\n    } else {\n      // doFatalError(protocol, msg[, level[, reason]])\n      err = makeError(msg, level, true);\n    }\n    if (typeof reason !== 'number')\n      reason = DISCONNECT_REASON.PROTOCOL_ERROR;\n    protocol.disconnect(reason);\n    protocol._destruct();\n    protocol._onError(err);\n    return Infinity;\n  },\n  readUInt32BE,\n  writeUInt32BE,\n  writeUInt32LE: (buf, value, offset) => {\n    buf[offset++] = value;\n    buf[offset++] = (value >>> 8);\n    buf[offset++] = (value >>> 16);\n    buf[offset++] = (value >>> 24);\n    return offset;\n  },\n  makeBufferParser,\n  bufferParser: makeBufferParser(),\n  readString: (buffer, start, dest, maxLen) => {\n    if (typeof dest === 'number') {\n      maxLen = dest;\n      dest = undefined;\n    }\n\n    if (start === undefined)\n      start = 0;\n\n    const left = (buffer.length - start);\n    if (start < 0 || start >= buffer.length || left < 4)\n      return;\n\n    const len = readUInt32BE(buffer, start);\n    if (left < (4 + len) || (typeof maxLen === 'number' && len > maxLen))\n      return;\n\n    start += 4;\n    const end = start + len;\n    buffer._pos = end;\n\n    if (dest) {\n      if (Buffer.isBuffer(dest))\n        return bufferCopy(buffer, dest, start, end);\n      return buffer.utf8Slice(start, end);\n    }\n    return bufferSlice(buffer, start, end);\n  },\n  sigSSHToASN1: (sig, type) => {\n    switch (type) {\n      case 'ssh-dss': {\n        if (sig.length > 40)\n          return sig;\n        // Change bare signature r and s values to ASN.1 BER values for OpenSSL\n        const asnWriter = new Ber.Writer();\n        asnWriter.startSequence();\n        let r = sig.slice(0, 20);\n        let s = sig.slice(20);\n        if (r[0] & 0x80) {\n          const rNew = Buffer.allocUnsafe(21);\n          rNew[0] = 0x00;\n          r.copy(rNew, 1);\n          r = rNew;\n        } else if (r[0] === 0x00 && !(r[1] & 0x80)) {\n          r = r.slice(1);\n        }\n        if (s[0] & 0x80) {\n          const sNew = Buffer.allocUnsafe(21);\n          sNew[0] = 0x00;\n          s.copy(sNew, 1);\n          s = sNew;\n        } else if (s[0] === 0x00 && !(s[1] & 0x80)) {\n          s = s.slice(1);\n        }\n        asnWriter.writeBuffer(r, Ber.Integer);\n        asnWriter.writeBuffer(s, Ber.Integer);\n        asnWriter.endSequence();\n        return asnWriter.buffer;\n      }\n      case 'ecdsa-sha2-nistp256':\n      case 'ecdsa-sha2-nistp384':\n      case 'ecdsa-sha2-nistp521': {\n        utilBufferParser.init(sig, 0);\n        const r = utilBufferParser.readString();\n        const s = utilBufferParser.readString();\n        utilBufferParser.clear();\n        if (r === undefined || s === undefined)\n          return;\n\n        const asnWriter = new Ber.Writer();\n        asnWriter.startSequence();\n        asnWriter.writeBuffer(r, Ber.Integer);\n        asnWriter.writeBuffer(s, Ber.Integer);\n        asnWriter.endSequence();\n        return asnWriter.buffer;\n      }\n      default:\n        return sig;\n    }\n  },\n  convertSignature: (signature, keyType) => {\n    switch (keyType) {\n      case 'ssh-dss': {\n        if (signature.length <= 40)\n          return signature;\n        // This is a quick and dirty way to get from BER encoded r and s that\n        // OpenSSL gives us, to just the bare values back to back (40 bytes\n        // total) like OpenSSH (and possibly others) are expecting\n        const asnReader = new Ber.Reader(signature);\n        asnReader.readSequence();\n        let r = asnReader.readString(Ber.Integer, true);\n        let s = asnReader.readString(Ber.Integer, true);\n        let rOffset = 0;\n        let sOffset = 0;\n        if (r.length < 20) {\n          const rNew = Buffer.allocUnsafe(20);\n          rNew.set(r, 1);\n          r = rNew;\n          r[0] = 0;\n        }\n        if (s.length < 20) {\n          const sNew = Buffer.allocUnsafe(20);\n          sNew.set(s, 1);\n          s = sNew;\n          s[0] = 0;\n        }\n        if (r.length > 20 && r[0] === 0)\n          rOffset = 1;\n        if (s.length > 20 && s[0] === 0)\n          sOffset = 1;\n        const newSig =\n          Buffer.allocUnsafe((r.length - rOffset) + (s.length - sOffset));\n        bufferCopy(r, newSig, rOffset, r.length, 0);\n        bufferCopy(s, newSig, sOffset, s.length, r.length - rOffset);\n        return newSig;\n      }\n      case 'ecdsa-sha2-nistp256':\n      case 'ecdsa-sha2-nistp384':\n      case 'ecdsa-sha2-nistp521': {\n        if (signature[0] === 0)\n          return signature;\n        // Convert SSH signature parameters to ASN.1 BER values for OpenSSL\n        const asnReader = new Ber.Reader(signature);\n        asnReader.readSequence();\n        const r = asnReader.readString(Ber.Integer, true);\n        const s = asnReader.readString(Ber.Integer, true);\n        if (r === null || s === null)\n          return;\n        const newSig = Buffer.allocUnsafe(4 + r.length + 4 + s.length);\n        writeUInt32BE(newSig, r.length, 0);\n        newSig.set(r, 4);\n        writeUInt32BE(newSig, s.length, 4 + r.length);\n        newSig.set(s, 4 + 4 + r.length);\n        return newSig;\n      }\n    }\n\n    return signature;\n  },\n  sendPacket: (proto, packet, bypass) => {\n    if (!bypass && proto._kexinit !== undefined) {\n      // We're currently in the middle of a handshake\n\n      if (proto._queue === undefined)\n        proto._queue = [];\n      proto._queue.push(packet);\n      proto._debug && proto._debug('Outbound: ... packet queued');\n      return false;\n    }\n    proto._cipher.encrypt(packet);\n    return true;\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}