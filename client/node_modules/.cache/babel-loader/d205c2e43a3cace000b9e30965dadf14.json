{"ast":null,"code":"// TODO:\n//    * make max packet size configurable\n//    * if decompression is enabled, use `._packet` in decipher instances as\n//      input to (sync) zlib inflater with appropriate offset and length to\n//      avoid an additional copy of payload data before inflation\n//    * factor decompression status into packet length checks\n'use strict';\n\nconst {\n  createCipheriv,\n  createDecipheriv,\n  createHmac,\n  randomFillSync,\n  timingSafeEqual\n} = require('crypto');\n\nconst {\n  readUInt32BE,\n  writeUInt32BE\n} = require('./utils.js');\n\nconst FastBuffer = Buffer[Symbol.species];\nconst MAX_SEQNO = 2 ** 32 - 1;\nconst EMPTY_BUFFER = Buffer.alloc(0);\nconst BUF_INT = Buffer.alloc(4);\nconst DISCARD_CACHE = new Map();\nconst MAX_PACKET_SIZE = 35000;\nlet binding;\nlet AESGCMCipher;\nlet ChaChaPolyCipher;\nlet GenericCipher;\nlet AESGCMDecipher;\nlet ChaChaPolyDecipher;\nlet GenericDecipher;\n\ntry {\n  binding = require('./crypto/build/Release/sshcrypto.node');\n  ({\n    AESGCMCipher,\n    ChaChaPolyCipher,\n    GenericCipher,\n    AESGCMDecipher,\n    ChaChaPolyDecipher,\n    GenericDecipher\n  } = binding);\n} catch {}\n\nconst CIPHER_STREAM = 1 << 0;\n\nconst CIPHER_INFO = (() => {\n  function info(sslName, blockLen, keyLen, ivLen, authLen, discardLen, flags) {\n    return {\n      sslName,\n      blockLen,\n      keyLen,\n      ivLen: ivLen !== 0 || flags & CIPHER_STREAM ? ivLen : blockLen,\n      authLen,\n      discardLen,\n      stream: !!(flags & CIPHER_STREAM)\n    };\n  }\n\n  return {\n    'chacha20-poly1305@openssh.com': info('chacha20', 8, 64, 0, 16, 0, CIPHER_STREAM),\n    'aes128-gcm': info('aes-128-gcm', 16, 16, 12, 16, 0, CIPHER_STREAM),\n    'aes256-gcm': info('aes-256-gcm', 16, 32, 12, 16, 0, CIPHER_STREAM),\n    'aes128-gcm@openssh.com': info('aes-128-gcm', 16, 16, 12, 16, 0, CIPHER_STREAM),\n    'aes256-gcm@openssh.com': info('aes-256-gcm', 16, 32, 12, 16, 0, CIPHER_STREAM),\n    'aes128-cbc': info('aes-128-cbc', 16, 16, 0, 0, 0, 0),\n    'aes192-cbc': info('aes-192-cbc', 16, 24, 0, 0, 0, 0),\n    'aes256-cbc': info('aes-256-cbc', 16, 32, 0, 0, 0, 0),\n    'rijndael-cbc@lysator.liu.se': info('aes-256-cbc', 16, 32, 0, 0, 0, 0),\n    '3des-cbc': info('des-ede3-cbc', 8, 24, 0, 0, 0, 0),\n    'blowfish-cbc': info('bf-cbc', 8, 16, 0, 0, 0, 0),\n    'idea-cbc': info('idea-cbc', 8, 16, 0, 0, 0, 0),\n    'cast128-cbc': info('cast-cbc', 8, 16, 0, 0, 0, 0),\n    'aes128-ctr': info('aes-128-ctr', 16, 16, 16, 0, 0, CIPHER_STREAM),\n    'aes192-ctr': info('aes-192-ctr', 16, 24, 16, 0, 0, CIPHER_STREAM),\n    'aes256-ctr': info('aes-256-ctr', 16, 32, 16, 0, 0, CIPHER_STREAM),\n    '3des-ctr': info('des-ede3', 8, 24, 8, 0, 0, CIPHER_STREAM),\n    'blowfish-ctr': info('bf-ecb', 8, 16, 8, 0, 0, CIPHER_STREAM),\n    'cast128-ctr': info('cast5-ecb', 8, 16, 8, 0, 0, CIPHER_STREAM),\n\n    /* The \"arcfour128\" algorithm is the RC4 cipher, as described in\n       [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream\n       generated by the cipher MUST be discarded, and the first byte of the\n       first encrypted packet MUST be encrypted using the 1537th byte of\n       keystream.\n        -- http://tools.ietf.org/html/rfc4345#section-4 */\n    'arcfour': info('rc4', 8, 16, 0, 0, 1536, CIPHER_STREAM),\n    'arcfour128': info('rc4', 8, 16, 0, 0, 1536, CIPHER_STREAM),\n    'arcfour256': info('rc4', 8, 32, 0, 0, 1536, CIPHER_STREAM),\n    'arcfour512': info('rc4', 8, 64, 0, 0, 1536, CIPHER_STREAM)\n  };\n})();\n\nconst MAC_INFO = (() => {\n  function info(sslName, len, actualLen, isETM) {\n    return {\n      sslName,\n      len,\n      actualLen,\n      isETM\n    };\n  }\n\n  return {\n    'hmac-md5': info('md5', 16, 16, false),\n    'hmac-md5-96': info('md5', 16, 12, false),\n    'hmac-ripemd160': info('ripemd160', 20, 20, false),\n    'hmac-sha1': info('sha1', 20, 20, false),\n    'hmac-sha1-etm@openssh.com': info('sha1', 20, 20, true),\n    'hmac-sha1-96': info('sha1', 20, 12, false),\n    'hmac-sha2-256': info('sha256', 32, 32, false),\n    'hmac-sha2-256-etm@openssh.com': info('sha256', 32, 32, true),\n    'hmac-sha2-256-96': info('sha256', 32, 12, false),\n    'hmac-sha2-512': info('sha512', 64, 64, false),\n    'hmac-sha2-512-etm@openssh.com': info('sha512', 64, 64, true),\n    'hmac-sha2-512-96': info('sha512', 64, 12, false)\n  };\n})(); // Should only_be used during the initial handshake\n\n\nclass NullCipher {\n  constructor(seqno, onWrite) {\n    this.outSeqno = seqno;\n    this._onWrite = onWrite;\n    this._dead = false;\n  }\n\n  free() {\n    this._dead = true;\n  }\n\n  allocPacket(payloadLen) {\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = 8 - (pktLen & 8 - 1);\n    if (padLen < 4) padLen += 8;\n    pktLen += padLen;\n    const packet = Buffer.allocUnsafe(pktLen);\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n    randomFillSync(packet, 5 + payloadLen, padLen);\n    return packet;\n  }\n\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n    if (this._dead) return;\n\n    this._onWrite(packet);\n\n    this.outSeqno = this.outSeqno + 1 >>> 0;\n  }\n\n}\n\nconst POLY1305_ZEROS = Buffer.alloc(32);\nconst POLY1305_OUT_COMPUTE = Buffer.alloc(16);\nlet POLY1305_WASM_MODULE;\nlet POLY1305_RESULT_MALLOC;\nlet poly1305_auth;\n\nclass ChaChaPolyCipherNative {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._encKeyMain = enc.cipherKey.slice(0, 32);\n    this._encKeyPktLen = enc.cipherKey.slice(32);\n    this._dead = false;\n  }\n\n  free() {\n    this._dead = true;\n  }\n\n  allocPacket(payloadLen) {\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = 8 - (pktLen - 4 & 8 - 1);\n    if (padLen < 4) padLen += 8;\n    pktLen += padLen;\n    const packet = Buffer.allocUnsafe(pktLen);\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n    randomFillSync(packet, 5 + payloadLen, padLen);\n    return packet;\n  }\n\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n    if (this._dead) return; // Generate Poly1305 key\n\n    POLY1305_OUT_COMPUTE[0] = 0; // Set counter to 0 (little endian)\n\n    writeUInt32BE(POLY1305_OUT_COMPUTE, this.outSeqno, 12);\n    const polyKey = createCipheriv('chacha20', this._encKeyMain, POLY1305_OUT_COMPUTE).update(POLY1305_ZEROS); // Encrypt packet length\n\n    const pktLenEnc = createCipheriv('chacha20', this._encKeyPktLen, POLY1305_OUT_COMPUTE).update(packet.slice(0, 4));\n\n    this._onWrite(pktLenEnc); // Encrypt rest of packet\n\n\n    POLY1305_OUT_COMPUTE[0] = 1; // Set counter to 1 (little endian)\n\n    const payloadEnc = createCipheriv('chacha20', this._encKeyMain, POLY1305_OUT_COMPUTE).update(packet.slice(4));\n\n    this._onWrite(payloadEnc); // Calculate Poly1305 MAC\n\n\n    poly1305_auth(POLY1305_RESULT_MALLOC, pktLenEnc, pktLenEnc.length, payloadEnc, payloadEnc.length, polyKey);\n    const mac = Buffer.allocUnsafe(16);\n    mac.set(new Uint8Array(POLY1305_WASM_MODULE.HEAPU8.buffer, POLY1305_RESULT_MALLOC, 16), 0);\n\n    this._onWrite(mac);\n\n    this.outSeqno = this.outSeqno + 1 >>> 0;\n  }\n\n}\n\nclass ChaChaPolyCipherBinding {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._instance = new ChaChaPolyCipher(enc.cipherKey);\n    this._dead = false;\n  }\n\n  free() {\n    this._dead = true;\n\n    this._instance.free();\n  }\n\n  allocPacket(payloadLen) {\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = 8 - (pktLen - 4 & 8 - 1);\n    if (padLen < 4) padLen += 8;\n    pktLen += padLen;\n    const packet = Buffer.allocUnsafe(pktLen + 16\n    /* MAC */\n    );\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n    randomFillSync(packet, 5 + payloadLen, padLen);\n    return packet;\n  }\n\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n    if (this._dead) return; // Encrypts in-place\n\n    this._instance.encrypt(packet, this.outSeqno);\n\n    this._onWrite(packet);\n\n    this.outSeqno = this.outSeqno + 1 >>> 0;\n  }\n\n}\n\nclass AESGCMCipherNative {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._encSSLName = enc.cipherInfo.sslName;\n    this._encKey = enc.cipherKey;\n    this._encIV = enc.cipherIV;\n    this._dead = false;\n  }\n\n  free() {\n    this._dead = true;\n  }\n\n  allocPacket(payloadLen) {\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = 16 - (pktLen - 4 & 16 - 1);\n    if (padLen < 4) padLen += 16;\n    pktLen += padLen;\n    const packet = Buffer.allocUnsafe(pktLen);\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n    randomFillSync(packet, 5 + payloadLen, padLen);\n    return packet;\n  }\n\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n    if (this._dead) return;\n    const cipher = createCipheriv(this._encSSLName, this._encKey, this._encIV);\n    cipher.setAutoPadding(false);\n    const lenData = packet.slice(0, 4);\n    cipher.setAAD(lenData);\n\n    this._onWrite(lenData); // Encrypt pad length, payload, and padding\n\n\n    const encrypted = cipher.update(packet.slice(4));\n\n    this._onWrite(encrypted);\n\n    const final = cipher.final(); // XXX: final.length === 0 always?\n\n    if (final.length) this._onWrite(final); // Generate MAC\n\n    const tag = cipher.getAuthTag();\n\n    this._onWrite(tag); // Increment counter in IV by 1 for next packet\n\n\n    ivIncrement(this._encIV);\n    this.outSeqno = this.outSeqno + 1 >>> 0;\n  }\n\n}\n\nclass AESGCMCipherBinding {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._instance = new AESGCMCipher(enc.cipherInfo.sslName, enc.cipherKey, enc.cipherIV);\n    this._dead = false;\n  }\n\n  free() {\n    this._dead = true;\n\n    this._instance.free();\n  }\n\n  allocPacket(payloadLen) {\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = 16 - (pktLen - 4 & 16 - 1);\n    if (padLen < 4) padLen += 16;\n    pktLen += padLen;\n    const packet = Buffer.allocUnsafe(pktLen + 16\n    /* authTag */\n    );\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n    randomFillSync(packet, 5 + payloadLen, padLen);\n    return packet;\n  }\n\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n    if (this._dead) return; // Encrypts in-place\n\n    this._instance.encrypt(packet);\n\n    this._onWrite(packet);\n\n    this.outSeqno = this.outSeqno + 1 >>> 0;\n  }\n\n}\n\nclass GenericCipherNative {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._encBlockLen = enc.cipherInfo.blockLen;\n    this._cipherInstance = createCipheriv(enc.cipherInfo.sslName, enc.cipherKey, enc.cipherIV);\n    this._macSSLName = enc.macInfo.sslName;\n    this._macKey = enc.macKey;\n    this._macActualLen = enc.macInfo.actualLen;\n    this._macETM = enc.macInfo.isETM;\n    this._aadLen = this._macETM ? 4 : 0;\n    this._dead = false;\n    const discardLen = enc.cipherInfo.discardLen;\n\n    if (discardLen) {\n      let discard = DISCARD_CACHE.get(discardLen);\n\n      if (discard === undefined) {\n        discard = Buffer.alloc(discardLen);\n        DISCARD_CACHE.set(discardLen, discard);\n      }\n\n      this._cipherInstance.update(discard);\n    }\n  }\n\n  free() {\n    this._dead = true;\n  }\n\n  allocPacket(payloadLen) {\n    const blockLen = this._encBlockLen;\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = blockLen - (pktLen - this._aadLen & blockLen - 1);\n    if (padLen < 4) padLen += blockLen;\n    pktLen += padLen;\n    const packet = Buffer.allocUnsafe(pktLen);\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n    randomFillSync(packet, 5 + payloadLen, padLen);\n    return packet;\n  }\n\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n    if (this._dead) return;\n    let mac;\n\n    if (this._macETM) {\n      // Encrypt pad length, payload, and padding\n      const lenBytes = new Uint8Array(packet.buffer, packet.byteOffset, 4);\n\n      const encrypted = this._cipherInstance.update(new Uint8Array(packet.buffer, packet.byteOffset + 4, packet.length - 4));\n\n      this._onWrite(lenBytes);\n\n      this._onWrite(encrypted); // TODO: look into storing seqno as 4-byte buffer and incrementing like we\n      // do for AES-GCM IVs to avoid having to (re)write all 4 bytes every time\n\n\n      mac = createHmac(this._macSSLName, this._macKey);\n      writeUInt32BE(BUF_INT, this.outSeqno, 0);\n      mac.update(BUF_INT);\n      mac.update(lenBytes);\n      mac.update(encrypted);\n    } else {\n      // Encrypt length field, pad length, payload, and padding\n      const encrypted = this._cipherInstance.update(packet);\n\n      this._onWrite(encrypted); // TODO: look into storing seqno as 4-byte buffer and incrementing like we\n      // do for AES-GCM IVs to avoid having to (re)write all 4 bytes every time\n\n\n      mac = createHmac(this._macSSLName, this._macKey);\n      writeUInt32BE(BUF_INT, this.outSeqno, 0);\n      mac.update(BUF_INT);\n      mac.update(packet);\n    }\n\n    let digest = mac.digest();\n    if (digest.length > this._macActualLen) digest = digest.slice(0, this._macActualLen);\n\n    this._onWrite(digest);\n\n    this.outSeqno = this.outSeqno + 1 >>> 0;\n  }\n\n}\n\nclass GenericCipherBinding {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._encBlockLen = enc.cipherInfo.blockLen;\n    this._macLen = enc.macInfo.len;\n    this._macActualLen = enc.macInfo.actualLen;\n    this._aadLen = enc.macInfo.isETM ? 4 : 0;\n    this._instance = new GenericCipher(enc.cipherInfo.sslName, enc.cipherKey, enc.cipherIV, enc.macInfo.sslName, enc.macKey, enc.macInfo.isETM);\n    this._dead = false;\n  }\n\n  free() {\n    this._dead = true;\n\n    this._instance.free();\n  }\n\n  allocPacket(payloadLen) {\n    const blockLen = this._encBlockLen;\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = blockLen - (pktLen - this._aadLen & blockLen - 1);\n    if (padLen < 4) padLen += blockLen;\n    pktLen += padLen;\n    const packet = Buffer.allocUnsafe(pktLen + this._macLen);\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n    randomFillSync(packet, 5 + payloadLen, padLen);\n    return packet;\n  }\n\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n    if (this._dead) return; // Encrypts in-place\n\n    this._instance.encrypt(packet, this.outSeqno);\n\n    if (this._macActualLen < this._macLen) {\n      packet = new FastBuffer(packet.buffer, packet.byteOffset, packet.length - (this._macLen - this._macActualLen));\n    }\n\n    this._onWrite(packet);\n\n    this.outSeqno = this.outSeqno + 1 >>> 0;\n  }\n\n}\n\nclass NullDecipher {\n  constructor(seqno, onPayload) {\n    this.inSeqno = seqno;\n    this._onPayload = onPayload;\n    this._len = 0;\n    this._lenBytes = 0;\n    this._packet = null;\n    this._packetPos = 0;\n  }\n\n  free() {}\n\n  decrypt(data, p, dataLen) {\n    while (p < dataLen) {\n      // Read packet length\n      if (this._lenBytes < 4) {\n        let nb = Math.min(4 - this._lenBytes, dataLen - p);\n        this._lenBytes += nb;\n\n        while (nb--) this._len = (this._len << 8) + data[p++];\n\n        if (this._lenBytes < 4) return;\n\n        if (this._len > MAX_PACKET_SIZE || this._len < 8 || (4 + this._len & 7) !== 0) {\n          throw new Error('Bad packet length');\n        }\n\n        if (p >= dataLen) return;\n      } // Read padding length, payload, and padding\n\n\n      if (this._packetPos < this._len) {\n        const nb = Math.min(this._len - this._packetPos, dataLen - p);\n        let chunk;\n        if (p !== 0 || nb !== dataLen) chunk = new Uint8Array(data.buffer, data.byteOffset + p, nb);else chunk = data;\n\n        if (nb === this._len) {\n          this._packet = chunk;\n        } else {\n          if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);\n\n          this._packet.set(chunk, this._packetPos);\n        }\n\n        p += nb;\n        this._packetPos += nb;\n        if (this._packetPos < this._len) return;\n      }\n\n      const payload = !this._packet ? EMPTY_BUFFER : new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1); // Prepare for next packet\n\n      this.inSeqno = this.inSeqno + 1 >>> 0;\n      this._len = 0;\n      this._lenBytes = 0;\n      this._packet = null;\n      this._packetPos = 0;\n      {\n        const ret = this._onPayload(payload);\n\n        if (ret !== undefined) return ret === false ? p : ret;\n      }\n    }\n  }\n\n}\n\nclass ChaChaPolyDecipherNative {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._decKeyMain = dec.decipherKey.slice(0, 32);\n    this._decKeyPktLen = dec.decipherKey.slice(32);\n    this._len = 0;\n    this._lenBuf = Buffer.alloc(4);\n    this._lenPos = 0;\n    this._packet = null;\n    this._pktLen = 0;\n    this._mac = Buffer.allocUnsafe(16);\n    this._calcMac = Buffer.allocUnsafe(16);\n    this._macPos = 0;\n  }\n\n  free() {}\n\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n    while (p < dataLen) {\n      // Read packet length\n      if (this._lenPos < 4) {\n        let nb = Math.min(4 - this._lenPos, dataLen - p);\n\n        while (nb--) this._lenBuf[this._lenPos++] = data[p++];\n\n        if (this._lenPos < 4) return;\n        POLY1305_OUT_COMPUTE[0] = 0; // Set counter to 0 (little endian)\n\n        writeUInt32BE(POLY1305_OUT_COMPUTE, this.inSeqno, 12);\n        const decLenBytes = createDecipheriv('chacha20', this._decKeyPktLen, POLY1305_OUT_COMPUTE).update(this._lenBuf);\n        this._len = readUInt32BE(decLenBytes, 0);\n\n        if (this._len > MAX_PACKET_SIZE || this._len < 8 || (this._len & 7) !== 0) {\n          throw new Error('Bad packet length');\n        }\n      } // Read padding length, payload, and padding\n\n\n      if (this._pktLen < this._len) {\n        if (p >= dataLen) return;\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let encrypted;\n        if (p !== 0 || nb !== dataLen) encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);else encrypted = data;\n\n        if (nb === this._len) {\n          this._packet = encrypted;\n        } else {\n          if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);\n\n          this._packet.set(encrypted, this._pktLen);\n        }\n\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen) return;\n      } // Read Poly1305 MAC\n\n\n      {\n        const nb = Math.min(16 - this._macPos, dataLen - p); // TODO: avoid copying if entire MAC is in current chunk\n\n        if (p !== 0 || nb !== dataLen) {\n          this._mac.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._macPos);\n        } else {\n          this._mac.set(data, this._macPos);\n        }\n\n        p += nb;\n        this._macPos += nb;\n        if (this._macPos < 16) return;\n      } // Generate Poly1305 key\n\n      POLY1305_OUT_COMPUTE[0] = 0; // Set counter to 0 (little endian)\n\n      writeUInt32BE(POLY1305_OUT_COMPUTE, this.inSeqno, 12);\n      const polyKey = createCipheriv('chacha20', this._decKeyMain, POLY1305_OUT_COMPUTE).update(POLY1305_ZEROS); // Calculate and compare Poly1305 MACs\n\n      poly1305_auth(POLY1305_RESULT_MALLOC, this._lenBuf, 4, this._packet, this._packet.length, polyKey);\n\n      this._calcMac.set(new Uint8Array(POLY1305_WASM_MODULE.HEAPU8.buffer, POLY1305_RESULT_MALLOC, 16), 0);\n\n      if (!timingSafeEqual(this._calcMac, this._mac)) throw new Error('Invalid MAC'); // Decrypt packet\n\n      POLY1305_OUT_COMPUTE[0] = 1; // Set counter to 1 (little endian)\n\n      const packet = createDecipheriv('chacha20', this._decKeyMain, POLY1305_OUT_COMPUTE).update(this._packet);\n      const payload = new FastBuffer(packet.buffer, packet.byteOffset + 1, packet.length - packet[0] - 1); // Prepare for next packet\n\n      this.inSeqno = this.inSeqno + 1 >>> 0;\n      this._len = 0;\n      this._lenPos = 0;\n      this._packet = null;\n      this._pktLen = 0;\n      this._macPos = 0;\n      {\n        const ret = this._onPayload(payload);\n\n        if (ret !== undefined) return ret === false ? p : ret;\n      }\n    }\n  }\n\n}\n\nclass ChaChaPolyDecipherBinding {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._instance = new ChaChaPolyDecipher(dec.decipherKey);\n    this._len = 0;\n    this._lenBuf = Buffer.alloc(4);\n    this._lenPos = 0;\n    this._packet = null;\n    this._pktLen = 0;\n    this._mac = Buffer.allocUnsafe(16);\n    this._macPos = 0;\n  }\n\n  free() {\n    this._instance.free();\n  }\n\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n    while (p < dataLen) {\n      // Read packet length\n      if (this._lenPos < 4) {\n        let nb = Math.min(4 - this._lenPos, dataLen - p);\n\n        while (nb--) this._lenBuf[this._lenPos++] = data[p++];\n\n        if (this._lenPos < 4) return;\n        this._len = this._instance.decryptLen(this._lenBuf, this.inSeqno);\n\n        if (this._len > MAX_PACKET_SIZE || this._len < 8 || (this._len & 7) !== 0) {\n          throw new Error('Bad packet length');\n        }\n\n        if (p >= dataLen) return;\n      } // Read padding length, payload, and padding\n\n\n      if (this._pktLen < this._len) {\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let encrypted;\n        if (p !== 0 || nb !== dataLen) encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);else encrypted = data;\n\n        if (nb === this._len) {\n          this._packet = encrypted;\n        } else {\n          if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);\n\n          this._packet.set(encrypted, this._pktLen);\n        }\n\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen) return;\n      } // Read Poly1305 MAC\n\n\n      {\n        const nb = Math.min(16 - this._macPos, dataLen - p); // TODO: avoid copying if entire MAC is in current chunk\n\n        if (p !== 0 || nb !== dataLen) {\n          this._mac.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._macPos);\n        } else {\n          this._mac.set(data, this._macPos);\n        }\n\n        p += nb;\n        this._macPos += nb;\n        if (this._macPos < 16) return;\n      }\n\n      this._instance.decrypt(this._packet, this._mac, this.inSeqno);\n\n      const payload = new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1); // Prepare for next packet\n\n      this.inSeqno = this.inSeqno + 1 >>> 0;\n      this._len = 0;\n      this._lenPos = 0;\n      this._packet = null;\n      this._pktLen = 0;\n      this._macPos = 0;\n      {\n        const ret = this._onPayload(payload);\n\n        if (ret !== undefined) return ret === false ? p : ret;\n      }\n    }\n  }\n\n}\n\nclass AESGCMDecipherNative {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._decipherInstance = null;\n    this._decipherSSLName = dec.decipherInfo.sslName;\n    this._decipherKey = dec.decipherKey;\n    this._decipherIV = dec.decipherIV;\n    this._len = 0;\n    this._lenBytes = 0;\n    this._packet = null;\n    this._packetPos = 0;\n    this._pktLen = 0;\n    this._tag = Buffer.allocUnsafe(16);\n    this._tagPos = 0;\n  }\n\n  free() {}\n\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n    while (p < dataLen) {\n      // Read packet length (unencrypted, but AAD)\n      if (this._lenBytes < 4) {\n        let nb = Math.min(4 - this._lenBytes, dataLen - p);\n        this._lenBytes += nb;\n\n        while (nb--) this._len = (this._len << 8) + data[p++];\n\n        if (this._lenBytes < 4) return;\n\n        if (this._len + 20 > MAX_PACKET_SIZE || this._len < 16 || (this._len & 15) !== 0) {\n          throw new Error('Bad packet length');\n        }\n\n        this._decipherInstance = createDecipheriv(this._decipherSSLName, this._decipherKey, this._decipherIV);\n\n        this._decipherInstance.setAutoPadding(false);\n\n        this._decipherInstance.setAAD(intToBytes(this._len));\n      } // Read padding length, payload, and padding\n\n\n      if (this._pktLen < this._len) {\n        if (p >= dataLen) return;\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let decrypted;\n\n        if (p !== 0 || nb !== dataLen) {\n          decrypted = this._decipherInstance.update(new Uint8Array(data.buffer, data.byteOffset + p, nb));\n        } else {\n          decrypted = this._decipherInstance.update(data);\n        }\n\n        if (decrypted.length) {\n          if (nb === this._len) {\n            this._packet = decrypted;\n          } else {\n            if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);\n\n            this._packet.set(decrypted, this._packetPos);\n          }\n\n          this._packetPos += decrypted.length;\n        }\n\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen) return;\n      } // Read authentication tag\n\n\n      {\n        const nb = Math.min(16 - this._tagPos, dataLen - p);\n\n        if (p !== 0 || nb !== dataLen) {\n          this._tag.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._tagPos);\n        } else {\n          this._tag.set(data, this._tagPos);\n        }\n\n        p += nb;\n        this._tagPos += nb;\n        if (this._tagPos < 16) return;\n      }\n      {\n        // Verify authentication tag\n        this._decipherInstance.setAuthTag(this._tag);\n\n        const decrypted = this._decipherInstance.final(); // XXX: this should never output any data since stream ciphers always\n        // return data from .update() and block ciphers must end on a multiple\n        // of the block length, which would have caused an exception to be\n        // thrown if the total input was not...\n\n\n        if (decrypted.length) {\n          if (this._packet) this._packet.set(decrypted, this._packetPos);else this._packet = decrypted;\n        }\n      }\n      const payload = !this._packet ? EMPTY_BUFFER : new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1); // Prepare for next packet\n\n      this.inSeqno = this.inSeqno + 1 >>> 0;\n      ivIncrement(this._decipherIV);\n      this._len = 0;\n      this._lenBytes = 0;\n      this._packet = null;\n      this._packetPos = 0;\n      this._pktLen = 0;\n      this._tagPos = 0;\n      {\n        const ret = this._onPayload(payload);\n\n        if (ret !== undefined) return ret === false ? p : ret;\n      }\n    }\n  }\n\n}\n\nclass AESGCMDecipherBinding {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._instance = new AESGCMDecipher(dec.decipherInfo.sslName, dec.decipherKey, dec.decipherIV);\n    this._len = 0;\n    this._lenBytes = 0;\n    this._packet = null;\n    this._pktLen = 0;\n    this._tag = Buffer.allocUnsafe(16);\n    this._tagPos = 0;\n  }\n\n  free() {}\n\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n    while (p < dataLen) {\n      // Read packet length (unencrypted, but AAD)\n      if (this._lenBytes < 4) {\n        let nb = Math.min(4 - this._lenBytes, dataLen - p);\n        this._lenBytes += nb;\n\n        while (nb--) this._len = (this._len << 8) + data[p++];\n\n        if (this._lenBytes < 4) return;\n\n        if (this._len + 20 > MAX_PACKET_SIZE || this._len < 16 || (this._len & 15) !== 0) {\n          throw new Error(`Bad packet length: ${this._len}`);\n        }\n      } // Read padding length, payload, and padding\n\n\n      if (this._pktLen < this._len) {\n        if (p >= dataLen) return;\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let encrypted;\n        if (p !== 0 || nb !== dataLen) encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);else encrypted = data;\n\n        if (nb === this._len) {\n          this._packet = encrypted;\n        } else {\n          if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);\n\n          this._packet.set(encrypted, this._pktLen);\n        }\n\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen) return;\n      } // Read authentication tag\n\n\n      {\n        const nb = Math.min(16 - this._tagPos, dataLen - p);\n\n        if (p !== 0 || nb !== dataLen) {\n          this._tag.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._tagPos);\n        } else {\n          this._tag.set(data, this._tagPos);\n        }\n\n        p += nb;\n        this._tagPos += nb;\n        if (this._tagPos < 16) return;\n      }\n\n      this._instance.decrypt(this._packet, this._len, this._tag);\n\n      const payload = new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1); // Prepare for next packet\n\n      this.inSeqno = this.inSeqno + 1 >>> 0;\n      this._len = 0;\n      this._lenBytes = 0;\n      this._packet = null;\n      this._pktLen = 0;\n      this._tagPos = 0;\n      {\n        const ret = this._onPayload(payload);\n\n        if (ret !== undefined) return ret === false ? p : ret;\n      }\n    }\n  }\n\n} // TODO: test incremental .update()s vs. copying to _packet and doing a single\n// .update() after entire packet read -- a single .update() would allow\n// verifying MAC before decrypting for ETM MACs\n\n\nclass GenericDecipherNative {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._decipherInstance = createDecipheriv(dec.decipherInfo.sslName, dec.decipherKey, dec.decipherIV);\n\n    this._decipherInstance.setAutoPadding(false);\n\n    this._block = Buffer.allocUnsafe(dec.macInfo.isETM ? 4 : dec.decipherInfo.blockLen);\n    this._blockSize = dec.decipherInfo.blockLen;\n    this._blockPos = 0;\n    this._len = 0;\n    this._packet = null;\n    this._packetPos = 0;\n    this._pktLen = 0;\n    this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);\n    this._macPos = 0;\n    this._macSSLName = dec.macInfo.sslName;\n    this._macKey = dec.macKey;\n    this._macActualLen = dec.macInfo.actualLen;\n    this._macETM = dec.macInfo.isETM;\n    this._macInstance = null;\n    const discardLen = dec.decipherInfo.discardLen;\n\n    if (discardLen) {\n      let discard = DISCARD_CACHE.get(discardLen);\n\n      if (discard === undefined) {\n        discard = Buffer.alloc(discardLen);\n        DISCARD_CACHE.set(discardLen, discard);\n      }\n\n      this._decipherInstance.update(discard);\n    }\n  }\n\n  free() {}\n\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n    while (p < dataLen) {\n      // Read first encrypted block\n      if (this._blockPos < this._block.length) {\n        const nb = Math.min(this._block.length - this._blockPos, dataLen - p);\n\n        if (p !== 0 || nb !== dataLen || nb < data.length) {\n          this._block.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._blockPos);\n        } else {\n          this._block.set(data, this._blockPos);\n        }\n\n        p += nb;\n        this._blockPos += nb;\n        if (this._blockPos < this._block.length) return;\n        let decrypted;\n        let need;\n\n        if (this._macETM) {\n          this._len = need = readUInt32BE(this._block, 0);\n        } else {\n          // Decrypt first block to get packet length\n          decrypted = this._decipherInstance.update(this._block);\n          this._len = readUInt32BE(decrypted, 0);\n          need = 4 + this._len - this._blockSize;\n        }\n\n        if (this._len > MAX_PACKET_SIZE || this._len < 5 || (need & this._blockSize - 1) !== 0) {\n          throw new Error('Bad packet length');\n        } // Create MAC up front to calculate in parallel with decryption\n\n\n        this._macInstance = createHmac(this._macSSLName, this._macKey);\n        writeUInt32BE(BUF_INT, this.inSeqno, 0);\n\n        this._macInstance.update(BUF_INT);\n\n        if (this._macETM) {\n          this._macInstance.update(this._block);\n        } else {\n          this._macInstance.update(new Uint8Array(decrypted.buffer, decrypted.byteOffset, 4));\n\n          this._pktLen = decrypted.length - 4;\n          this._packetPos = this._pktLen;\n          this._packet = Buffer.allocUnsafe(this._len);\n\n          this._packet.set(new Uint8Array(decrypted.buffer, decrypted.byteOffset + 4, this._packetPos), 0);\n        }\n\n        if (p >= dataLen) return;\n      } // Read padding length, payload, and padding\n\n\n      if (this._pktLen < this._len) {\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let encrypted;\n        if (p !== 0 || nb !== dataLen) encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);else encrypted = data;\n        if (this._macETM) this._macInstance.update(encrypted);\n\n        const decrypted = this._decipherInstance.update(encrypted);\n\n        if (decrypted.length) {\n          if (nb === this._len) {\n            this._packet = decrypted;\n          } else {\n            if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);\n\n            this._packet.set(decrypted, this._packetPos);\n          }\n\n          this._packetPos += decrypted.length;\n        }\n\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen) return;\n      } // Read MAC\n\n\n      {\n        const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);\n\n        if (p !== 0 || nb !== dataLen) {\n          this._mac.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._macPos);\n        } else {\n          this._mac.set(data, this._macPos);\n        }\n\n        p += nb;\n        this._macPos += nb;\n        if (this._macPos < this._macActualLen) return;\n      } // Verify MAC\n\n      if (!this._macETM) this._macInstance.update(this._packet);\n\n      let calculated = this._macInstance.digest();\n\n      if (this._macActualLen < calculated.length) {\n        calculated = new Uint8Array(calculated.buffer, calculated.byteOffset, this._macActualLen);\n      }\n\n      if (!timingSafeEquals(calculated, this._mac)) throw new Error('Invalid MAC');\n      const payload = new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1); // Prepare for next packet\n\n      this.inSeqno = this.inSeqno + 1 >>> 0;\n      this._blockPos = 0;\n      this._len = 0;\n      this._packet = null;\n      this._packetPos = 0;\n      this._pktLen = 0;\n      this._macPos = 0;\n      this._macInstance = null;\n      {\n        const ret = this._onPayload(payload);\n\n        if (ret !== undefined) return ret === false ? p : ret;\n      }\n    }\n  }\n\n}\n\nclass GenericDecipherBinding {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._instance = new GenericDecipher(dec.decipherInfo.sslName, dec.decipherKey, dec.decipherIV, dec.macInfo.sslName, dec.macKey, dec.macInfo.isETM, dec.macInfo.actualLen);\n    this._block = Buffer.allocUnsafe(dec.macInfo.isETM || dec.decipherInfo.stream ? 4 : dec.decipherInfo.blockLen);\n    this._blockPos = 0;\n    this._len = 0;\n    this._packet = null;\n    this._pktLen = 0;\n    this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);\n    this._macPos = 0;\n    this._macActualLen = dec.macInfo.actualLen;\n    this._macETM = dec.macInfo.isETM;\n  }\n\n  free() {\n    this._instance.free();\n  }\n\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n    while (p < dataLen) {\n      // Read first encrypted block\n      if (this._blockPos < this._block.length) {\n        const nb = Math.min(this._block.length - this._blockPos, dataLen - p);\n\n        if (p !== 0 || nb !== dataLen || nb < data.length) {\n          this._block.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._blockPos);\n        } else {\n          this._block.set(data, this._blockPos);\n        }\n\n        p += nb;\n        this._blockPos += nb;\n        if (this._blockPos < this._block.length) return;\n        let need;\n\n        if (this._macETM) {\n          this._len = need = readUInt32BE(this._block, 0);\n        } else {\n          // Decrypt first block to get packet length\n          this._instance.decryptBlock(this._block);\n\n          this._len = readUInt32BE(this._block, 0);\n          need = 4 + this._len - this._block.length;\n        }\n\n        if (this._len > MAX_PACKET_SIZE || this._len < 5 || (need & this._block.length - 1) !== 0) {\n          throw new Error('Bad packet length');\n        }\n\n        if (!this._macETM) {\n          this._pktLen = this._block.length - 4;\n\n          if (this._pktLen) {\n            this._packet = Buffer.allocUnsafe(this._len);\n\n            this._packet.set(new Uint8Array(this._block.buffer, this._block.byteOffset + 4, this._pktLen), 0);\n          }\n        }\n\n        if (p >= dataLen) return;\n      } // Read padding length, payload, and padding\n\n\n      if (this._pktLen < this._len) {\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let encrypted;\n        if (p !== 0 || nb !== dataLen) encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);else encrypted = data;\n\n        if (nb === this._len) {\n          this._packet = encrypted;\n        } else {\n          if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);\n\n          this._packet.set(encrypted, this._pktLen);\n        }\n\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen) return;\n      } // Read MAC\n\n\n      {\n        const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);\n\n        if (p !== 0 || nb !== dataLen) {\n          this._mac.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._macPos);\n        } else {\n          this._mac.set(data, this._macPos);\n        }\n\n        p += nb;\n        this._macPos += nb;\n        if (this._macPos < this._macActualLen) return;\n      } // Decrypt and verify MAC\n\n      this._instance.decrypt(this._packet, this.inSeqno, this._block, this._mac);\n\n      const payload = new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1); // Prepare for next packet\n\n      this.inSeqno = this.inSeqno + 1 >>> 0;\n      this._blockPos = 0;\n      this._len = 0;\n      this._packet = null;\n      this._pktLen = 0;\n      this._macPos = 0;\n      this._macInstance = null;\n      {\n        const ret = this._onPayload(payload);\n\n        if (ret !== undefined) return ret === false ? p : ret;\n      }\n    }\n  }\n\n} // Increments unsigned, big endian counter (last 8 bytes) of AES-GCM IV\n\n\nfunction ivIncrement(iv) {\n  // eslint-disable-next-line no-unused-expressions\n  ++iv[11] >>> 8 && ++iv[10] >>> 8 && ++iv[9] >>> 8 && ++iv[8] >>> 8 && ++iv[7] >>> 8 && ++iv[6] >>> 8 && ++iv[5] >>> 8 && ++iv[4] >>> 8;\n}\n\nconst intToBytes = (() => {\n  const ret = Buffer.alloc(4);\n  return n => {\n    ret[0] = n >>> 24;\n    ret[1] = n >>> 16;\n    ret[2] = n >>> 8;\n    ret[3] = n;\n    return ret;\n  };\n})();\n\nfunction timingSafeEquals(a, b) {\n  if (a.length !== b.length) {\n    timingSafeEqual(a, a);\n    return false;\n  }\n\n  return timingSafeEqual(a, b);\n}\n\nfunction createCipher(config) {\n  if (typeof config !== 'object' || config === null) throw new Error('Invalid config');\n  if (typeof config.outbound !== 'object' || config.outbound === null) throw new Error('Invalid outbound');\n  const outbound = config.outbound;\n  if (typeof outbound.onWrite !== 'function') throw new Error('Invalid outbound.onWrite');\n  if (typeof outbound.cipherInfo !== 'object' || outbound.cipherInfo === null) throw new Error('Invalid outbound.cipherInfo');\n\n  if (!Buffer.isBuffer(outbound.cipherKey) || outbound.cipherKey.length !== outbound.cipherInfo.keyLen) {\n    throw new Error('Invalid outbound.cipherKey');\n  }\n\n  if (outbound.cipherInfo.ivLen && (!Buffer.isBuffer(outbound.cipherIV) || outbound.cipherIV.length !== outbound.cipherInfo.ivLen)) {\n    throw new Error('Invalid outbound.cipherIV');\n  }\n\n  if (typeof outbound.seqno !== 'number' || outbound.seqno < 0 || outbound.seqno > MAX_SEQNO) {\n    throw new Error('Invalid outbound.seqno');\n  }\n\n  const forceNative = !!outbound.forceNative;\n\n  switch (outbound.cipherInfo.sslName) {\n    case 'aes-128-gcm':\n    case 'aes-256-gcm':\n      return AESGCMCipher && !forceNative ? new AESGCMCipherBinding(config) : new AESGCMCipherNative(config);\n\n    case 'chacha20':\n      return ChaChaPolyCipher && !forceNative ? new ChaChaPolyCipherBinding(config) : new ChaChaPolyCipherNative(config);\n\n    default:\n      {\n        if (typeof outbound.macInfo !== 'object' || outbound.macInfo === null) throw new Error('Invalid outbound.macInfo');\n\n        if (!Buffer.isBuffer(outbound.macKey) || outbound.macKey.length !== outbound.macInfo.len) {\n          throw new Error('Invalid outbound.macKey');\n        }\n\n        return GenericCipher && !forceNative ? new GenericCipherBinding(config) : new GenericCipherNative(config);\n      }\n  }\n}\n\nfunction createDecipher(config) {\n  if (typeof config !== 'object' || config === null) throw new Error('Invalid config');\n  if (typeof config.inbound !== 'object' || config.inbound === null) throw new Error('Invalid inbound');\n  const inbound = config.inbound;\n  if (typeof inbound.onPayload !== 'function') throw new Error('Invalid inbound.onPayload');\n\n  if (typeof inbound.decipherInfo !== 'object' || inbound.decipherInfo === null) {\n    throw new Error('Invalid inbound.decipherInfo');\n  }\n\n  if (!Buffer.isBuffer(inbound.decipherKey) || inbound.decipherKey.length !== inbound.decipherInfo.keyLen) {\n    throw new Error('Invalid inbound.decipherKey');\n  }\n\n  if (inbound.decipherInfo.ivLen && (!Buffer.isBuffer(inbound.decipherIV) || inbound.decipherIV.length !== inbound.decipherInfo.ivLen)) {\n    throw new Error('Invalid inbound.decipherIV');\n  }\n\n  if (typeof inbound.seqno !== 'number' || inbound.seqno < 0 || inbound.seqno > MAX_SEQNO) {\n    throw new Error('Invalid inbound.seqno');\n  }\n\n  const forceNative = !!inbound.forceNative;\n\n  switch (inbound.decipherInfo.sslName) {\n    case 'aes-128-gcm':\n    case 'aes-256-gcm':\n      return AESGCMDecipher && !forceNative ? new AESGCMDecipherBinding(config) : new AESGCMDecipherNative(config);\n\n    case 'chacha20':\n      return ChaChaPolyDecipher && !forceNative ? new ChaChaPolyDecipherBinding(config) : new ChaChaPolyDecipherNative(config);\n\n    default:\n      {\n        if (typeof inbound.macInfo !== 'object' || inbound.macInfo === null) throw new Error('Invalid inbound.macInfo');\n\n        if (!Buffer.isBuffer(inbound.macKey) || inbound.macKey.length !== inbound.macInfo.len) {\n          throw new Error('Invalid inbound.macKey');\n        }\n\n        return GenericDecipher && !forceNative ? new GenericDecipherBinding(config) : new GenericDecipherNative(config);\n      }\n  }\n}\n\nmodule.exports = {\n  CIPHER_INFO,\n  MAC_INFO,\n  bindingAvailable: !!binding,\n  init: (() => {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n      try {\n        POLY1305_WASM_MODULE = await require('./crypto/poly1305.js')();\n        POLY1305_RESULT_MALLOC = POLY1305_WASM_MODULE._malloc(16);\n        poly1305_auth = POLY1305_WASM_MODULE.cwrap('poly1305_auth', null, ['number', 'array', 'number', 'array', 'number', 'array']);\n      } catch (ex) {\n        return reject(ex);\n      }\n\n      resolve();\n    });\n  })(),\n  NullCipher,\n  createCipher,\n  NullDecipher,\n  createDecipher\n};","map":{"version":3,"names":["createCipheriv","createDecipheriv","createHmac","randomFillSync","timingSafeEqual","require","readUInt32BE","writeUInt32BE","FastBuffer","Buffer","Symbol","species","MAX_SEQNO","EMPTY_BUFFER","alloc","BUF_INT","DISCARD_CACHE","Map","MAX_PACKET_SIZE","binding","AESGCMCipher","ChaChaPolyCipher","GenericCipher","AESGCMDecipher","ChaChaPolyDecipher","GenericDecipher","CIPHER_STREAM","CIPHER_INFO","info","sslName","blockLen","keyLen","ivLen","authLen","discardLen","flags","stream","MAC_INFO","len","actualLen","isETM","NullCipher","constructor","seqno","onWrite","outSeqno","_onWrite","_dead","free","allocPacket","payloadLen","pktLen","padLen","packet","allocUnsafe","encrypt","POLY1305_ZEROS","POLY1305_OUT_COMPUTE","POLY1305_WASM_MODULE","POLY1305_RESULT_MALLOC","poly1305_auth","ChaChaPolyCipherNative","config","enc","outbound","_encKeyMain","cipherKey","slice","_encKeyPktLen","polyKey","update","pktLenEnc","payloadEnc","length","mac","set","Uint8Array","HEAPU8","buffer","ChaChaPolyCipherBinding","_instance","AESGCMCipherNative","_encSSLName","cipherInfo","_encKey","_encIV","cipherIV","cipher","setAutoPadding","lenData","setAAD","encrypted","final","tag","getAuthTag","ivIncrement","AESGCMCipherBinding","GenericCipherNative","_encBlockLen","_cipherInstance","_macSSLName","macInfo","_macKey","macKey","_macActualLen","_macETM","_aadLen","discard","get","undefined","lenBytes","byteOffset","digest","GenericCipherBinding","_macLen","NullDecipher","onPayload","inSeqno","_onPayload","_len","_lenBytes","_packet","_packetPos","decrypt","data","p","dataLen","nb","Math","min","Error","chunk","payload","ret","ChaChaPolyDecipherNative","dec","inbound","_decKeyMain","decipherKey","_decKeyPktLen","_lenBuf","_lenPos","_pktLen","_mac","_calcMac","_macPos","decLenBytes","ChaChaPolyDecipherBinding","decryptLen","AESGCMDecipherNative","_decipherInstance","_decipherSSLName","decipherInfo","_decipherKey","_decipherIV","decipherIV","_tag","_tagPos","intToBytes","decrypted","setAuthTag","AESGCMDecipherBinding","GenericDecipherNative","_block","_blockSize","_blockPos","_macInstance","need","calculated","timingSafeEquals","GenericDecipherBinding","decryptBlock","iv","n","a","b","createCipher","isBuffer","forceNative","createDecipher","module","exports","bindingAvailable","init","Promise","resolve","reject","_malloc","cwrap","ex"],"sources":["/home/micqdf/AlpacaPunchTests/maintest/test1/client/node_modules/ssh2/lib/protocol/crypto.js"],"sourcesContent":["// TODO:\n//    * make max packet size configurable\n//    * if decompression is enabled, use `._packet` in decipher instances as\n//      input to (sync) zlib inflater with appropriate offset and length to\n//      avoid an additional copy of payload data before inflation\n//    * factor decompression status into packet length checks\n'use strict';\n\nconst {\n  createCipheriv, createDecipheriv, createHmac, randomFillSync, timingSafeEqual\n} = require('crypto');\n\nconst { readUInt32BE, writeUInt32BE } = require('./utils.js');\n\nconst FastBuffer = Buffer[Symbol.species];\nconst MAX_SEQNO = 2 ** 32 - 1;\nconst EMPTY_BUFFER = Buffer.alloc(0);\nconst BUF_INT = Buffer.alloc(4);\nconst DISCARD_CACHE = new Map();\nconst MAX_PACKET_SIZE = 35000;\n\nlet binding;\nlet AESGCMCipher;\nlet ChaChaPolyCipher;\nlet GenericCipher;\nlet AESGCMDecipher;\nlet ChaChaPolyDecipher;\nlet GenericDecipher;\ntry {\n  binding = require('./crypto/build/Release/sshcrypto.node');\n  ({ AESGCMCipher, ChaChaPolyCipher, GenericCipher,\n     AESGCMDecipher, ChaChaPolyDecipher, GenericDecipher } = binding);\n} catch {}\n\nconst CIPHER_STREAM = 1 << 0;\nconst CIPHER_INFO = (() => {\n  function info(sslName, blockLen, keyLen, ivLen, authLen, discardLen, flags) {\n    return {\n      sslName,\n      blockLen,\n      keyLen,\n      ivLen: (ivLen !== 0 || (flags & CIPHER_STREAM)\n              ? ivLen\n              : blockLen),\n      authLen,\n      discardLen,\n      stream: !!(flags & CIPHER_STREAM),\n    };\n  }\n\n  return {\n    'chacha20-poly1305@openssh.com':\n      info('chacha20', 8, 64, 0, 16, 0, CIPHER_STREAM),\n\n    'aes128-gcm': info('aes-128-gcm', 16, 16, 12, 16, 0, CIPHER_STREAM),\n    'aes256-gcm': info('aes-256-gcm', 16, 32, 12, 16, 0, CIPHER_STREAM),\n    'aes128-gcm@openssh.com':\n      info('aes-128-gcm', 16, 16, 12, 16, 0, CIPHER_STREAM),\n    'aes256-gcm@openssh.com':\n      info('aes-256-gcm', 16, 32, 12, 16, 0, CIPHER_STREAM),\n\n    'aes128-cbc': info('aes-128-cbc', 16, 16, 0, 0, 0, 0),\n    'aes192-cbc': info('aes-192-cbc', 16, 24, 0, 0, 0, 0),\n    'aes256-cbc': info('aes-256-cbc', 16, 32, 0, 0, 0, 0),\n    'rijndael-cbc@lysator.liu.se': info('aes-256-cbc', 16, 32, 0, 0, 0, 0),\n    '3des-cbc': info('des-ede3-cbc', 8, 24, 0, 0, 0, 0),\n    'blowfish-cbc': info('bf-cbc', 8, 16, 0, 0, 0, 0),\n    'idea-cbc': info('idea-cbc', 8, 16, 0, 0, 0, 0),\n    'cast128-cbc': info('cast-cbc', 8, 16, 0, 0, 0, 0),\n\n    'aes128-ctr': info('aes-128-ctr', 16, 16, 16, 0, 0, CIPHER_STREAM),\n    'aes192-ctr': info('aes-192-ctr', 16, 24, 16, 0, 0, CIPHER_STREAM),\n    'aes256-ctr': info('aes-256-ctr', 16, 32, 16, 0, 0, CIPHER_STREAM),\n    '3des-ctr': info('des-ede3', 8, 24, 8, 0, 0, CIPHER_STREAM),\n    'blowfish-ctr': info('bf-ecb', 8, 16, 8, 0, 0, CIPHER_STREAM),\n    'cast128-ctr': info('cast5-ecb', 8, 16, 8, 0, 0, CIPHER_STREAM),\n\n    /* The \"arcfour128\" algorithm is the RC4 cipher, as described in\n       [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream\n       generated by the cipher MUST be discarded, and the first byte of the\n       first encrypted packet MUST be encrypted using the 1537th byte of\n       keystream.\n\n       -- http://tools.ietf.org/html/rfc4345#section-4 */\n    'arcfour': info('rc4', 8, 16, 0, 0, 1536, CIPHER_STREAM),\n    'arcfour128': info('rc4', 8, 16, 0, 0, 1536, CIPHER_STREAM),\n    'arcfour256': info('rc4', 8, 32, 0, 0, 1536, CIPHER_STREAM),\n    'arcfour512': info('rc4', 8, 64, 0, 0, 1536, CIPHER_STREAM),\n  };\n})();\n\nconst MAC_INFO = (() => {\n  function info(sslName, len, actualLen, isETM) {\n    return {\n      sslName,\n      len,\n      actualLen,\n      isETM,\n    };\n  }\n\n  return {\n    'hmac-md5': info('md5', 16, 16, false),\n    'hmac-md5-96': info('md5', 16, 12, false),\n    'hmac-ripemd160': info('ripemd160', 20, 20, false),\n    'hmac-sha1': info('sha1', 20, 20, false),\n    'hmac-sha1-etm@openssh.com': info('sha1', 20, 20, true),\n    'hmac-sha1-96': info('sha1', 20, 12, false),\n    'hmac-sha2-256': info('sha256', 32, 32, false),\n    'hmac-sha2-256-etm@openssh.com': info('sha256', 32, 32, true),\n    'hmac-sha2-256-96': info('sha256', 32, 12, false),\n    'hmac-sha2-512': info('sha512', 64, 64, false),\n    'hmac-sha2-512-etm@openssh.com': info('sha512', 64, 64, true),\n    'hmac-sha2-512-96': info('sha512', 64, 12, false),\n  };\n})();\n\n\n// Should only_be used during the initial handshake\nclass NullCipher {\n  constructor(seqno, onWrite) {\n    this.outSeqno = seqno;\n    this._onWrite = onWrite;\n    this._dead = false;\n  }\n  free() {\n    this._dead = true;\n  }\n  allocPacket(payloadLen) {\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = 8 - (pktLen & (8 - 1));\n    if (padLen < 4)\n      padLen += 8;\n    pktLen += padLen;\n\n    const packet = Buffer.allocUnsafe(pktLen);\n\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n\n    randomFillSync(packet, 5 + payloadLen, padLen);\n\n    return packet;\n  }\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n\n    if (this._dead)\n      return;\n\n    this._onWrite(packet);\n\n    this.outSeqno = (this.outSeqno + 1) >>> 0;\n  }\n}\n\n\nconst POLY1305_ZEROS = Buffer.alloc(32);\nconst POLY1305_OUT_COMPUTE = Buffer.alloc(16);\nlet POLY1305_WASM_MODULE;\nlet POLY1305_RESULT_MALLOC;\nlet poly1305_auth;\nclass ChaChaPolyCipherNative {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._encKeyMain = enc.cipherKey.slice(0, 32);\n    this._encKeyPktLen = enc.cipherKey.slice(32);\n    this._dead = false;\n  }\n  free() {\n    this._dead = true;\n  }\n  allocPacket(payloadLen) {\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = 8 - ((pktLen - 4) & (8 - 1));\n    if (padLen < 4)\n      padLen += 8;\n    pktLen += padLen;\n\n    const packet = Buffer.allocUnsafe(pktLen);\n\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n\n    randomFillSync(packet, 5 + payloadLen, padLen);\n\n    return packet;\n  }\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n\n    if (this._dead)\n      return;\n\n    // Generate Poly1305 key\n    POLY1305_OUT_COMPUTE[0] = 0; // Set counter to 0 (little endian)\n    writeUInt32BE(POLY1305_OUT_COMPUTE, this.outSeqno, 12);\n    const polyKey =\n      createCipheriv('chacha20', this._encKeyMain, POLY1305_OUT_COMPUTE)\n      .update(POLY1305_ZEROS);\n\n    // Encrypt packet length\n    const pktLenEnc =\n      createCipheriv('chacha20', this._encKeyPktLen, POLY1305_OUT_COMPUTE)\n      .update(packet.slice(0, 4));\n    this._onWrite(pktLenEnc);\n\n    // Encrypt rest of packet\n    POLY1305_OUT_COMPUTE[0] = 1; // Set counter to 1 (little endian)\n    const payloadEnc =\n      createCipheriv('chacha20', this._encKeyMain, POLY1305_OUT_COMPUTE)\n      .update(packet.slice(4));\n    this._onWrite(payloadEnc);\n\n    // Calculate Poly1305 MAC\n    poly1305_auth(POLY1305_RESULT_MALLOC,\n                  pktLenEnc,\n                  pktLenEnc.length,\n                  payloadEnc,\n                  payloadEnc.length,\n                  polyKey);\n    const mac = Buffer.allocUnsafe(16);\n    mac.set(\n      new Uint8Array(POLY1305_WASM_MODULE.HEAPU8.buffer,\n                     POLY1305_RESULT_MALLOC,\n                     16),\n      0\n    );\n    this._onWrite(mac);\n\n    this.outSeqno = (this.outSeqno + 1) >>> 0;\n  }\n}\n\nclass ChaChaPolyCipherBinding {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._instance = new ChaChaPolyCipher(enc.cipherKey);\n    this._dead = false;\n  }\n  free() {\n    this._dead = true;\n    this._instance.free();\n  }\n  allocPacket(payloadLen) {\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = 8 - ((pktLen - 4) & (8 - 1));\n    if (padLen < 4)\n      padLen += 8;\n    pktLen += padLen;\n\n    const packet = Buffer.allocUnsafe(pktLen + 16/* MAC */);\n\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n\n    randomFillSync(packet, 5 + payloadLen, padLen);\n\n    return packet;\n  }\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n\n    if (this._dead)\n      return;\n\n    // Encrypts in-place\n    this._instance.encrypt(packet, this.outSeqno);\n\n    this._onWrite(packet);\n\n    this.outSeqno = (this.outSeqno + 1) >>> 0;\n  }\n}\n\n\nclass AESGCMCipherNative {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._encSSLName = enc.cipherInfo.sslName;\n    this._encKey = enc.cipherKey;\n    this._encIV = enc.cipherIV;\n    this._dead = false;\n  }\n  free() {\n    this._dead = true;\n  }\n  allocPacket(payloadLen) {\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = 16 - ((pktLen - 4) & (16 - 1));\n    if (padLen < 4)\n      padLen += 16;\n    pktLen += padLen;\n\n    const packet = Buffer.allocUnsafe(pktLen);\n\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n\n    randomFillSync(packet, 5 + payloadLen, padLen);\n\n    return packet;\n  }\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n\n    if (this._dead)\n      return;\n\n    const cipher = createCipheriv(this._encSSLName, this._encKey, this._encIV);\n    cipher.setAutoPadding(false);\n\n    const lenData = packet.slice(0, 4);\n    cipher.setAAD(lenData);\n    this._onWrite(lenData);\n\n    // Encrypt pad length, payload, and padding\n    const encrypted = cipher.update(packet.slice(4));\n    this._onWrite(encrypted);\n    const final = cipher.final();\n    // XXX: final.length === 0 always?\n    if (final.length)\n      this._onWrite(final);\n\n    // Generate MAC\n    const tag = cipher.getAuthTag();\n    this._onWrite(tag);\n\n    // Increment counter in IV by 1 for next packet\n    ivIncrement(this._encIV);\n\n    this.outSeqno = (this.outSeqno + 1) >>> 0;\n  }\n}\n\nclass AESGCMCipherBinding {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._instance = new AESGCMCipher(enc.cipherInfo.sslName,\n                                      enc.cipherKey,\n                                      enc.cipherIV);\n    this._dead = false;\n  }\n  free() {\n    this._dead = true;\n    this._instance.free();\n  }\n  allocPacket(payloadLen) {\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = 16 - ((pktLen - 4) & (16 - 1));\n    if (padLen < 4)\n      padLen += 16;\n    pktLen += padLen;\n\n    const packet = Buffer.allocUnsafe(pktLen + 16/* authTag */);\n\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n\n    randomFillSync(packet, 5 + payloadLen, padLen);\n\n    return packet;\n  }\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n\n    if (this._dead)\n      return;\n\n    // Encrypts in-place\n    this._instance.encrypt(packet);\n\n    this._onWrite(packet);\n\n    this.outSeqno = (this.outSeqno + 1) >>> 0;\n  }\n}\n\n\nclass GenericCipherNative {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._encBlockLen = enc.cipherInfo.blockLen;\n    this._cipherInstance = createCipheriv(enc.cipherInfo.sslName,\n                                          enc.cipherKey,\n                                          enc.cipherIV);\n    this._macSSLName = enc.macInfo.sslName;\n    this._macKey = enc.macKey;\n    this._macActualLen = enc.macInfo.actualLen;\n    this._macETM = enc.macInfo.isETM;\n    this._aadLen = (this._macETM ? 4 : 0);\n    this._dead = false;\n\n    const discardLen = enc.cipherInfo.discardLen;\n    if (discardLen) {\n      let discard = DISCARD_CACHE.get(discardLen);\n      if (discard === undefined) {\n        discard = Buffer.alloc(discardLen);\n        DISCARD_CACHE.set(discardLen, discard);\n      }\n      this._cipherInstance.update(discard);\n    }\n  }\n  free() {\n    this._dead = true;\n  }\n  allocPacket(payloadLen) {\n    const blockLen = this._encBlockLen;\n\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = blockLen - ((pktLen - this._aadLen) & (blockLen - 1));\n    if (padLen < 4)\n      padLen += blockLen;\n    pktLen += padLen;\n\n    const packet = Buffer.allocUnsafe(pktLen);\n\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n\n    randomFillSync(packet, 5 + payloadLen, padLen);\n\n    return packet;\n  }\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n\n    if (this._dead)\n      return;\n\n    let mac;\n    if (this._macETM) {\n      // Encrypt pad length, payload, and padding\n      const lenBytes = new Uint8Array(packet.buffer, packet.byteOffset, 4);\n      const encrypted = this._cipherInstance.update(\n        new Uint8Array(packet.buffer,\n                       packet.byteOffset + 4,\n                       packet.length - 4)\n      );\n\n      this._onWrite(lenBytes);\n      this._onWrite(encrypted);\n\n      // TODO: look into storing seqno as 4-byte buffer and incrementing like we\n      // do for AES-GCM IVs to avoid having to (re)write all 4 bytes every time\n      mac = createHmac(this._macSSLName, this._macKey);\n      writeUInt32BE(BUF_INT, this.outSeqno, 0);\n      mac.update(BUF_INT);\n      mac.update(lenBytes);\n      mac.update(encrypted);\n    } else {\n      // Encrypt length field, pad length, payload, and padding\n      const encrypted = this._cipherInstance.update(packet);\n      this._onWrite(encrypted);\n\n      // TODO: look into storing seqno as 4-byte buffer and incrementing like we\n      // do for AES-GCM IVs to avoid having to (re)write all 4 bytes every time\n      mac = createHmac(this._macSSLName, this._macKey);\n      writeUInt32BE(BUF_INT, this.outSeqno, 0);\n      mac.update(BUF_INT);\n      mac.update(packet);\n    }\n\n    let digest = mac.digest();\n    if (digest.length > this._macActualLen)\n      digest = digest.slice(0, this._macActualLen);\n    this._onWrite(digest);\n\n    this.outSeqno = (this.outSeqno + 1) >>> 0;\n  }\n}\n\nclass GenericCipherBinding {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._encBlockLen = enc.cipherInfo.blockLen;\n    this._macLen = enc.macInfo.len;\n    this._macActualLen = enc.macInfo.actualLen;\n    this._aadLen = (enc.macInfo.isETM ? 4 : 0);\n    this._instance = new GenericCipher(enc.cipherInfo.sslName,\n                                       enc.cipherKey,\n                                       enc.cipherIV,\n                                       enc.macInfo.sslName,\n                                       enc.macKey,\n                                       enc.macInfo.isETM);\n    this._dead = false;\n  }\n  free() {\n    this._dead = true;\n    this._instance.free();\n  }\n  allocPacket(payloadLen) {\n    const blockLen = this._encBlockLen;\n\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = blockLen - ((pktLen - this._aadLen) & (blockLen - 1));\n    if (padLen < 4)\n      padLen += blockLen;\n    pktLen += padLen;\n\n    const packet = Buffer.allocUnsafe(pktLen + this._macLen);\n\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n\n    randomFillSync(packet, 5 + payloadLen, padLen);\n\n    return packet;\n  }\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n\n    if (this._dead)\n      return;\n\n    // Encrypts in-place\n    this._instance.encrypt(packet, this.outSeqno);\n\n    if (this._macActualLen < this._macLen) {\n      packet = new FastBuffer(packet.buffer,\n                              packet.byteOffset,\n                              (packet.length\n                                - (this._macLen - this._macActualLen)));\n    }\n    this._onWrite(packet);\n\n    this.outSeqno = (this.outSeqno + 1) >>> 0;\n  }\n}\n\n\nclass NullDecipher {\n  constructor(seqno, onPayload) {\n    this.inSeqno = seqno;\n    this._onPayload = onPayload;\n    this._len = 0;\n    this._lenBytes = 0;\n    this._packet = null;\n    this._packetPos = 0;\n  }\n  free() {}\n  decrypt(data, p, dataLen) {\n    while (p < dataLen) {\n      // Read packet length\n      if (this._lenBytes < 4) {\n        let nb = Math.min(4 - this._lenBytes, dataLen - p);\n\n        this._lenBytes += nb;\n        while (nb--)\n          this._len = (this._len << 8) + data[p++];\n\n        if (this._lenBytes < 4)\n          return;\n\n        if (this._len > MAX_PACKET_SIZE\n            || this._len < 8\n            || (4 + this._len & 7) !== 0) {\n          throw new Error('Bad packet length');\n        }\n        if (p >= dataLen)\n          return;\n      }\n\n      // Read padding length, payload, and padding\n      if (this._packetPos < this._len) {\n        const nb = Math.min(this._len - this._packetPos, dataLen - p);\n        let chunk;\n        if (p !== 0 || nb !== dataLen)\n          chunk = new Uint8Array(data.buffer, data.byteOffset + p, nb);\n        else\n          chunk = data;\n        if (nb === this._len) {\n          this._packet = chunk;\n        } else {\n          if (!this._packet)\n            this._packet = Buffer.allocUnsafe(this._len);\n          this._packet.set(chunk, this._packetPos);\n        }\n        p += nb;\n        this._packetPos += nb;\n        if (this._packetPos < this._len)\n          return;\n      }\n\n      const payload = (!this._packet\n                       ? EMPTY_BUFFER\n                       : new FastBuffer(this._packet.buffer,\n                                        this._packet.byteOffset + 1,\n                                        this._packet.length\n                                          - this._packet[0] - 1));\n\n      // Prepare for next packet\n      this.inSeqno = (this.inSeqno + 1) >>> 0;\n      this._len = 0;\n      this._lenBytes = 0;\n      this._packet = null;\n      this._packetPos = 0;\n\n      {\n        const ret = this._onPayload(payload);\n        if (ret !== undefined)\n          return (ret === false ? p : ret);\n      }\n    }\n  }\n}\n\nclass ChaChaPolyDecipherNative {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._decKeyMain = dec.decipherKey.slice(0, 32);\n    this._decKeyPktLen = dec.decipherKey.slice(32);\n    this._len = 0;\n    this._lenBuf = Buffer.alloc(4);\n    this._lenPos = 0;\n    this._packet = null;\n    this._pktLen = 0;\n    this._mac = Buffer.allocUnsafe(16);\n    this._calcMac = Buffer.allocUnsafe(16);\n    this._macPos = 0;\n  }\n  free() {}\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n\n    while (p < dataLen) {\n      // Read packet length\n      if (this._lenPos < 4) {\n        let nb = Math.min(4 - this._lenPos, dataLen - p);\n        while (nb--)\n          this._lenBuf[this._lenPos++] = data[p++];\n        if (this._lenPos < 4)\n          return;\n\n        POLY1305_OUT_COMPUTE[0] = 0; // Set counter to 0 (little endian)\n        writeUInt32BE(POLY1305_OUT_COMPUTE, this.inSeqno, 12);\n\n        const decLenBytes =\n          createDecipheriv('chacha20', this._decKeyPktLen, POLY1305_OUT_COMPUTE)\n          .update(this._lenBuf);\n        this._len = readUInt32BE(decLenBytes, 0);\n\n        if (this._len > MAX_PACKET_SIZE\n            || this._len < 8\n            || (this._len & 7) !== 0) {\n          throw new Error('Bad packet length');\n        }\n      }\n\n      // Read padding length, payload, and padding\n      if (this._pktLen < this._len) {\n        if (p >= dataLen)\n          return;\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let encrypted;\n        if (p !== 0 || nb !== dataLen)\n          encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);\n        else\n          encrypted = data;\n        if (nb === this._len) {\n          this._packet = encrypted;\n        } else {\n          if (!this._packet)\n            this._packet = Buffer.allocUnsafe(this._len);\n          this._packet.set(encrypted, this._pktLen);\n        }\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen)\n          return;\n      }\n\n      // Read Poly1305 MAC\n      {\n        const nb = Math.min(16 - this._macPos, dataLen - p);\n        // TODO: avoid copying if entire MAC is in current chunk\n        if (p !== 0 || nb !== dataLen) {\n          this._mac.set(\n            new Uint8Array(data.buffer, data.byteOffset + p, nb),\n            this._macPos\n          );\n        } else {\n          this._mac.set(data, this._macPos);\n        }\n        p += nb;\n        this._macPos += nb;\n        if (this._macPos < 16)\n          return;\n      }\n\n      // Generate Poly1305 key\n      POLY1305_OUT_COMPUTE[0] = 0; // Set counter to 0 (little endian)\n      writeUInt32BE(POLY1305_OUT_COMPUTE, this.inSeqno, 12);\n      const polyKey =\n        createCipheriv('chacha20', this._decKeyMain, POLY1305_OUT_COMPUTE)\n        .update(POLY1305_ZEROS);\n\n      // Calculate and compare Poly1305 MACs\n      poly1305_auth(POLY1305_RESULT_MALLOC,\n                    this._lenBuf,\n                    4,\n                    this._packet,\n                    this._packet.length,\n                    polyKey);\n\n      this._calcMac.set(\n        new Uint8Array(POLY1305_WASM_MODULE.HEAPU8.buffer,\n                       POLY1305_RESULT_MALLOC,\n                       16),\n        0\n      );\n      if (!timingSafeEqual(this._calcMac, this._mac))\n        throw new Error('Invalid MAC');\n\n      // Decrypt packet\n      POLY1305_OUT_COMPUTE[0] = 1; // Set counter to 1 (little endian)\n      const packet =\n        createDecipheriv('chacha20', this._decKeyMain, POLY1305_OUT_COMPUTE)\n        .update(this._packet);\n\n      const payload = new FastBuffer(packet.buffer,\n                                     packet.byteOffset + 1,\n                                     packet.length - packet[0] - 1);\n\n      // Prepare for next packet\n      this.inSeqno = (this.inSeqno + 1) >>> 0;\n      this._len = 0;\n      this._lenPos = 0;\n      this._packet = null;\n      this._pktLen = 0;\n      this._macPos = 0;\n\n      {\n        const ret = this._onPayload(payload);\n        if (ret !== undefined)\n          return (ret === false ? p : ret);\n      }\n    }\n  }\n}\n\nclass ChaChaPolyDecipherBinding {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._instance = new ChaChaPolyDecipher(dec.decipherKey);\n    this._len = 0;\n    this._lenBuf = Buffer.alloc(4);\n    this._lenPos = 0;\n    this._packet = null;\n    this._pktLen = 0;\n    this._mac = Buffer.allocUnsafe(16);\n    this._macPos = 0;\n  }\n  free() {\n    this._instance.free();\n  }\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n\n    while (p < dataLen) {\n      // Read packet length\n      if (this._lenPos < 4) {\n        let nb = Math.min(4 - this._lenPos, dataLen - p);\n        while (nb--)\n          this._lenBuf[this._lenPos++] = data[p++];\n        if (this._lenPos < 4)\n          return;\n\n        this._len = this._instance.decryptLen(this._lenBuf, this.inSeqno);\n\n        if (this._len > MAX_PACKET_SIZE\n            || this._len < 8\n            || (this._len & 7) !== 0) {\n          throw new Error('Bad packet length');\n        }\n\n        if (p >= dataLen)\n          return;\n      }\n\n      // Read padding length, payload, and padding\n      if (this._pktLen < this._len) {\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let encrypted;\n        if (p !== 0 || nb !== dataLen)\n          encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);\n        else\n          encrypted = data;\n        if (nb === this._len) {\n          this._packet = encrypted;\n        } else {\n          if (!this._packet)\n            this._packet = Buffer.allocUnsafe(this._len);\n          this._packet.set(encrypted, this._pktLen);\n        }\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen)\n          return;\n      }\n\n      // Read Poly1305 MAC\n      {\n        const nb = Math.min(16 - this._macPos, dataLen - p);\n        // TODO: avoid copying if entire MAC is in current chunk\n        if (p !== 0 || nb !== dataLen) {\n          this._mac.set(\n            new Uint8Array(data.buffer, data.byteOffset + p, nb),\n            this._macPos\n          );\n        } else {\n          this._mac.set(data, this._macPos);\n        }\n        p += nb;\n        this._macPos += nb;\n        if (this._macPos < 16)\n          return;\n      }\n\n      this._instance.decrypt(this._packet, this._mac, this.inSeqno);\n\n      const payload = new FastBuffer(this._packet.buffer,\n                                     this._packet.byteOffset + 1,\n                                     this._packet.length - this._packet[0] - 1);\n\n      // Prepare for next packet\n      this.inSeqno = (this.inSeqno + 1) >>> 0;\n      this._len = 0;\n      this._lenPos = 0;\n      this._packet = null;\n      this._pktLen = 0;\n      this._macPos = 0;\n\n      {\n        const ret = this._onPayload(payload);\n        if (ret !== undefined)\n          return (ret === false ? p : ret);\n      }\n    }\n  }\n}\n\nclass AESGCMDecipherNative {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._decipherInstance = null;\n    this._decipherSSLName = dec.decipherInfo.sslName;\n    this._decipherKey = dec.decipherKey;\n    this._decipherIV = dec.decipherIV;\n    this._len = 0;\n    this._lenBytes = 0;\n    this._packet = null;\n    this._packetPos = 0;\n    this._pktLen = 0;\n    this._tag = Buffer.allocUnsafe(16);\n    this._tagPos = 0;\n  }\n  free() {}\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n\n    while (p < dataLen) {\n      // Read packet length (unencrypted, but AAD)\n      if (this._lenBytes < 4) {\n        let nb = Math.min(4 - this._lenBytes, dataLen - p);\n        this._lenBytes += nb;\n        while (nb--)\n          this._len = (this._len << 8) + data[p++];\n        if (this._lenBytes < 4)\n          return;\n\n        if ((this._len + 20) > MAX_PACKET_SIZE\n            || this._len < 16\n            || (this._len & 15) !== 0) {\n          throw new Error('Bad packet length');\n        }\n\n        this._decipherInstance = createDecipheriv(\n          this._decipherSSLName,\n          this._decipherKey,\n          this._decipherIV\n        );\n        this._decipherInstance.setAutoPadding(false);\n        this._decipherInstance.setAAD(intToBytes(this._len));\n      }\n\n      // Read padding length, payload, and padding\n      if (this._pktLen < this._len) {\n        if (p >= dataLen)\n          return;\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let decrypted;\n        if (p !== 0 || nb !== dataLen) {\n          decrypted = this._decipherInstance.update(\n            new Uint8Array(data.buffer, data.byteOffset + p, nb)\n          );\n        } else {\n          decrypted = this._decipherInstance.update(data);\n        }\n        if (decrypted.length) {\n          if (nb === this._len) {\n            this._packet = decrypted;\n          } else {\n            if (!this._packet)\n              this._packet = Buffer.allocUnsafe(this._len);\n            this._packet.set(decrypted, this._packetPos);\n          }\n          this._packetPos += decrypted.length;\n        }\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen)\n          return;\n      }\n\n      // Read authentication tag\n      {\n        const nb = Math.min(16 - this._tagPos, dataLen - p);\n        if (p !== 0 || nb !== dataLen) {\n          this._tag.set(\n            new Uint8Array(data.buffer, data.byteOffset + p, nb),\n            this._tagPos\n          );\n        } else {\n          this._tag.set(data, this._tagPos);\n        }\n        p += nb;\n        this._tagPos += nb;\n        if (this._tagPos < 16)\n          return;\n      }\n\n      {\n        // Verify authentication tag\n        this._decipherInstance.setAuthTag(this._tag);\n\n        const decrypted = this._decipherInstance.final();\n\n        // XXX: this should never output any data since stream ciphers always\n        // return data from .update() and block ciphers must end on a multiple\n        // of the block length, which would have caused an exception to be\n        // thrown if the total input was not...\n        if (decrypted.length) {\n          if (this._packet)\n            this._packet.set(decrypted, this._packetPos);\n          else\n            this._packet = decrypted;\n        }\n      }\n\n      const payload = (!this._packet\n                       ? EMPTY_BUFFER\n                       : new FastBuffer(this._packet.buffer,\n                                        this._packet.byteOffset + 1,\n                                        this._packet.length\n                                          - this._packet[0] - 1));\n\n      // Prepare for next packet\n      this.inSeqno = (this.inSeqno + 1) >>> 0;\n      ivIncrement(this._decipherIV);\n      this._len = 0;\n      this._lenBytes = 0;\n      this._packet = null;\n      this._packetPos = 0;\n      this._pktLen = 0;\n      this._tagPos = 0;\n\n      {\n        const ret = this._onPayload(payload);\n        if (ret !== undefined)\n          return (ret === false ? p : ret);\n      }\n    }\n  }\n}\n\nclass AESGCMDecipherBinding {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._instance = new AESGCMDecipher(dec.decipherInfo.sslName,\n                                        dec.decipherKey,\n                                        dec.decipherIV);\n    this._len = 0;\n    this._lenBytes = 0;\n    this._packet = null;\n    this._pktLen = 0;\n    this._tag = Buffer.allocUnsafe(16);\n    this._tagPos = 0;\n  }\n  free() {}\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n\n    while (p < dataLen) {\n      // Read packet length (unencrypted, but AAD)\n      if (this._lenBytes < 4) {\n        let nb = Math.min(4 - this._lenBytes, dataLen - p);\n        this._lenBytes += nb;\n        while (nb--)\n          this._len = (this._len << 8) + data[p++];\n        if (this._lenBytes < 4)\n          return;\n\n        if ((this._len + 20) > MAX_PACKET_SIZE\n            || this._len < 16\n            || (this._len & 15) !== 0) {\n          throw new Error(`Bad packet length: ${this._len}`);\n        }\n      }\n\n      // Read padding length, payload, and padding\n      if (this._pktLen < this._len) {\n        if (p >= dataLen)\n          return;\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let encrypted;\n        if (p !== 0 || nb !== dataLen)\n          encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);\n        else\n          encrypted = data;\n        if (nb === this._len) {\n          this._packet = encrypted;\n        } else {\n          if (!this._packet)\n            this._packet = Buffer.allocUnsafe(this._len);\n          this._packet.set(encrypted, this._pktLen);\n        }\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen)\n          return;\n      }\n\n      // Read authentication tag\n      {\n        const nb = Math.min(16 - this._tagPos, dataLen - p);\n        if (p !== 0 || nb !== dataLen) {\n          this._tag.set(\n            new Uint8Array(data.buffer, data.byteOffset + p, nb),\n            this._tagPos\n          );\n        } else {\n          this._tag.set(data, this._tagPos);\n        }\n        p += nb;\n        this._tagPos += nb;\n        if (this._tagPos < 16)\n          return;\n      }\n\n      this._instance.decrypt(this._packet, this._len, this._tag);\n\n      const payload = new FastBuffer(this._packet.buffer,\n                                     this._packet.byteOffset + 1,\n                                     this._packet.length - this._packet[0] - 1);\n\n      // Prepare for next packet\n      this.inSeqno = (this.inSeqno + 1) >>> 0;\n      this._len = 0;\n      this._lenBytes = 0;\n      this._packet = null;\n      this._pktLen = 0;\n      this._tagPos = 0;\n\n      {\n        const ret = this._onPayload(payload);\n        if (ret !== undefined)\n          return (ret === false ? p : ret);\n      }\n    }\n  }\n}\n\n// TODO: test incremental .update()s vs. copying to _packet and doing a single\n// .update() after entire packet read -- a single .update() would allow\n// verifying MAC before decrypting for ETM MACs\nclass GenericDecipherNative {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._decipherInstance = createDecipheriv(dec.decipherInfo.sslName,\n                                              dec.decipherKey,\n                                              dec.decipherIV);\n    this._decipherInstance.setAutoPadding(false);\n    this._block = Buffer.allocUnsafe(\n      dec.macInfo.isETM ? 4 : dec.decipherInfo.blockLen\n    );\n    this._blockSize = dec.decipherInfo.blockLen;\n    this._blockPos = 0;\n    this._len = 0;\n    this._packet = null;\n    this._packetPos = 0;\n    this._pktLen = 0;\n    this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);\n    this._macPos = 0;\n    this._macSSLName = dec.macInfo.sslName;\n    this._macKey = dec.macKey;\n    this._macActualLen = dec.macInfo.actualLen;\n    this._macETM = dec.macInfo.isETM;\n    this._macInstance = null;\n\n    const discardLen = dec.decipherInfo.discardLen;\n    if (discardLen) {\n      let discard = DISCARD_CACHE.get(discardLen);\n      if (discard === undefined) {\n        discard = Buffer.alloc(discardLen);\n        DISCARD_CACHE.set(discardLen, discard);\n      }\n      this._decipherInstance.update(discard);\n    }\n  }\n  free() {}\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n\n    while (p < dataLen) {\n      // Read first encrypted block\n      if (this._blockPos < this._block.length) {\n        const nb = Math.min(this._block.length - this._blockPos, dataLen - p);\n        if (p !== 0 || nb !== dataLen || nb < data.length) {\n          this._block.set(\n            new Uint8Array(data.buffer, data.byteOffset + p, nb),\n            this._blockPos\n          );\n        } else {\n          this._block.set(data, this._blockPos);\n        }\n\n        p += nb;\n        this._blockPos += nb;\n        if (this._blockPos < this._block.length)\n          return;\n\n        let decrypted;\n        let need;\n        if (this._macETM) {\n          this._len = need = readUInt32BE(this._block, 0);\n        } else {\n          // Decrypt first block to get packet length\n          decrypted = this._decipherInstance.update(this._block);\n          this._len = readUInt32BE(decrypted, 0);\n          need = 4 + this._len - this._blockSize;\n        }\n\n        if (this._len > MAX_PACKET_SIZE\n            || this._len < 5\n            || (need & (this._blockSize - 1)) !== 0) {\n          throw new Error('Bad packet length');\n        }\n\n        // Create MAC up front to calculate in parallel with decryption\n        this._macInstance = createHmac(this._macSSLName, this._macKey);\n\n        writeUInt32BE(BUF_INT, this.inSeqno, 0);\n        this._macInstance.update(BUF_INT);\n        if (this._macETM) {\n          this._macInstance.update(this._block);\n        } else {\n          this._macInstance.update(new Uint8Array(decrypted.buffer,\n                                                  decrypted.byteOffset,\n                                                  4));\n          this._pktLen = decrypted.length - 4;\n          this._packetPos = this._pktLen;\n          this._packet = Buffer.allocUnsafe(this._len);\n          this._packet.set(\n            new Uint8Array(decrypted.buffer,\n                           decrypted.byteOffset + 4,\n                           this._packetPos),\n            0\n          );\n        }\n\n        if (p >= dataLen)\n          return;\n      }\n\n      // Read padding length, payload, and padding\n      if (this._pktLen < this._len) {\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let encrypted;\n        if (p !== 0 || nb !== dataLen)\n          encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);\n        else\n          encrypted = data;\n        if (this._macETM)\n          this._macInstance.update(encrypted);\n        const decrypted = this._decipherInstance.update(encrypted);\n        if (decrypted.length) {\n          if (nb === this._len) {\n            this._packet = decrypted;\n          } else {\n            if (!this._packet)\n              this._packet = Buffer.allocUnsafe(this._len);\n            this._packet.set(decrypted, this._packetPos);\n          }\n          this._packetPos += decrypted.length;\n        }\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen)\n          return;\n      }\n\n      // Read MAC\n      {\n        const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);\n        if (p !== 0 || nb !== dataLen) {\n          this._mac.set(\n            new Uint8Array(data.buffer, data.byteOffset + p, nb),\n            this._macPos\n          );\n        } else {\n          this._mac.set(data, this._macPos);\n        }\n        p += nb;\n        this._macPos += nb;\n        if (this._macPos < this._macActualLen)\n          return;\n      }\n\n      // Verify MAC\n      if (!this._macETM)\n        this._macInstance.update(this._packet);\n      let calculated = this._macInstance.digest();\n      if (this._macActualLen < calculated.length) {\n        calculated = new Uint8Array(calculated.buffer,\n                                    calculated.byteOffset,\n                                    this._macActualLen);\n      }\n      if (!timingSafeEquals(calculated, this._mac))\n        throw new Error('Invalid MAC');\n\n      const payload = new FastBuffer(this._packet.buffer,\n                                     this._packet.byteOffset + 1,\n                                     this._packet.length - this._packet[0] - 1);\n\n      // Prepare for next packet\n      this.inSeqno = (this.inSeqno + 1) >>> 0;\n      this._blockPos = 0;\n      this._len = 0;\n      this._packet = null;\n      this._packetPos = 0;\n      this._pktLen = 0;\n      this._macPos = 0;\n      this._macInstance = null;\n\n      {\n        const ret = this._onPayload(payload);\n        if (ret !== undefined)\n          return (ret === false ? p : ret);\n      }\n    }\n  }\n}\n\nclass GenericDecipherBinding {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._instance = new GenericDecipher(dec.decipherInfo.sslName,\n                                         dec.decipherKey,\n                                         dec.decipherIV,\n                                         dec.macInfo.sslName,\n                                         dec.macKey,\n                                         dec.macInfo.isETM,\n                                         dec.macInfo.actualLen);\n    this._block = Buffer.allocUnsafe(\n      dec.macInfo.isETM || dec.decipherInfo.stream\n      ? 4\n      : dec.decipherInfo.blockLen\n    );\n    this._blockPos = 0;\n    this._len = 0;\n    this._packet = null;\n    this._pktLen = 0;\n    this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);\n    this._macPos = 0;\n    this._macActualLen = dec.macInfo.actualLen;\n    this._macETM = dec.macInfo.isETM;\n  }\n  free() {\n    this._instance.free();\n  }\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n\n    while (p < dataLen) {\n      // Read first encrypted block\n      if (this._blockPos < this._block.length) {\n        const nb = Math.min(this._block.length - this._blockPos, dataLen - p);\n        if (p !== 0 || nb !== dataLen || nb < data.length) {\n          this._block.set(\n            new Uint8Array(data.buffer, data.byteOffset + p, nb),\n            this._blockPos\n          );\n        } else {\n          this._block.set(data, this._blockPos);\n        }\n\n        p += nb;\n        this._blockPos += nb;\n        if (this._blockPos < this._block.length)\n          return;\n\n        let need;\n        if (this._macETM) {\n          this._len = need = readUInt32BE(this._block, 0);\n        } else {\n          // Decrypt first block to get packet length\n          this._instance.decryptBlock(this._block);\n          this._len = readUInt32BE(this._block, 0);\n          need = 4 + this._len - this._block.length;\n        }\n\n        if (this._len > MAX_PACKET_SIZE\n            || this._len < 5\n            || (need & (this._block.length - 1)) !== 0) {\n          throw new Error('Bad packet length');\n        }\n\n        if (!this._macETM) {\n          this._pktLen = (this._block.length - 4);\n          if (this._pktLen) {\n            this._packet = Buffer.allocUnsafe(this._len);\n            this._packet.set(\n              new Uint8Array(this._block.buffer,\n                             this._block.byteOffset + 4,\n                             this._pktLen),\n              0\n            );\n          }\n        }\n\n        if (p >= dataLen)\n          return;\n      }\n\n      // Read padding length, payload, and padding\n      if (this._pktLen < this._len) {\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let encrypted;\n        if (p !== 0 || nb !== dataLen)\n          encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);\n        else\n          encrypted = data;\n        if (nb === this._len) {\n          this._packet = encrypted;\n        } else {\n          if (!this._packet)\n            this._packet = Buffer.allocUnsafe(this._len);\n          this._packet.set(encrypted, this._pktLen);\n        }\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen)\n          return;\n      }\n\n      // Read MAC\n      {\n        const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);\n        if (p !== 0 || nb !== dataLen) {\n          this._mac.set(\n            new Uint8Array(data.buffer, data.byteOffset + p, nb),\n            this._macPos\n          );\n        } else {\n          this._mac.set(data, this._macPos);\n        }\n        p += nb;\n        this._macPos += nb;\n        if (this._macPos < this._macActualLen)\n          return;\n      }\n\n      // Decrypt and verify MAC\n      this._instance.decrypt(this._packet,\n                             this.inSeqno,\n                             this._block,\n                             this._mac);\n\n      const payload = new FastBuffer(this._packet.buffer,\n                                     this._packet.byteOffset + 1,\n                                     this._packet.length - this._packet[0] - 1);\n\n      // Prepare for next packet\n      this.inSeqno = (this.inSeqno + 1) >>> 0;\n      this._blockPos = 0;\n      this._len = 0;\n      this._packet = null;\n      this._pktLen = 0;\n      this._macPos = 0;\n      this._macInstance = null;\n\n      {\n        const ret = this._onPayload(payload);\n        if (ret !== undefined)\n          return (ret === false ? p : ret);\n      }\n    }\n  }\n}\n\n// Increments unsigned, big endian counter (last 8 bytes) of AES-GCM IV\nfunction ivIncrement(iv) {\n  // eslint-disable-next-line no-unused-expressions\n  ++iv[11] >>> 8\n  && ++iv[10] >>> 8\n  && ++iv[9] >>> 8\n  && ++iv[8] >>> 8\n  && ++iv[7] >>> 8\n  && ++iv[6] >>> 8\n  && ++iv[5] >>> 8\n  && ++iv[4] >>> 8;\n}\n\nconst intToBytes = (() => {\n  const ret = Buffer.alloc(4);\n  return (n) => {\n    ret[0] = (n >>> 24);\n    ret[1] = (n >>> 16);\n    ret[2] = (n >>> 8);\n    ret[3] = n;\n    return ret;\n  };\n})();\n\nfunction timingSafeEquals(a, b) {\n  if (a.length !== b.length) {\n    timingSafeEqual(a, a);\n    return false;\n  }\n  return timingSafeEqual(a, b);\n}\n\nfunction createCipher(config) {\n  if (typeof config !== 'object' || config === null)\n    throw new Error('Invalid config');\n\n  if (typeof config.outbound !== 'object' || config.outbound === null)\n    throw new Error('Invalid outbound');\n\n  const outbound = config.outbound;\n\n  if (typeof outbound.onWrite !== 'function')\n    throw new Error('Invalid outbound.onWrite');\n\n  if (typeof outbound.cipherInfo !== 'object' || outbound.cipherInfo === null)\n    throw new Error('Invalid outbound.cipherInfo');\n\n  if (!Buffer.isBuffer(outbound.cipherKey)\n      || outbound.cipherKey.length !== outbound.cipherInfo.keyLen) {\n    throw new Error('Invalid outbound.cipherKey');\n  }\n\n  if (outbound.cipherInfo.ivLen\n      && (!Buffer.isBuffer(outbound.cipherIV)\n          || outbound.cipherIV.length !== outbound.cipherInfo.ivLen)) {\n    throw new Error('Invalid outbound.cipherIV');\n  }\n\n  if (typeof outbound.seqno !== 'number'\n      || outbound.seqno < 0\n      || outbound.seqno > MAX_SEQNO) {\n    throw new Error('Invalid outbound.seqno');\n  }\n\n  const forceNative = !!outbound.forceNative;\n\n  switch (outbound.cipherInfo.sslName) {\n    case 'aes-128-gcm':\n    case 'aes-256-gcm':\n      return (AESGCMCipher && !forceNative\n              ? new AESGCMCipherBinding(config)\n              : new AESGCMCipherNative(config));\n    case 'chacha20':\n      return (ChaChaPolyCipher && !forceNative\n              ? new ChaChaPolyCipherBinding(config)\n              : new ChaChaPolyCipherNative(config));\n    default: {\n      if (typeof outbound.macInfo !== 'object' || outbound.macInfo === null)\n        throw new Error('Invalid outbound.macInfo');\n      if (!Buffer.isBuffer(outbound.macKey)\n          || outbound.macKey.length !== outbound.macInfo.len) {\n        throw new Error('Invalid outbound.macKey');\n      }\n      return (GenericCipher && !forceNative\n              ? new GenericCipherBinding(config)\n              : new GenericCipherNative(config));\n    }\n  }\n}\n\nfunction createDecipher(config) {\n  if (typeof config !== 'object' || config === null)\n    throw new Error('Invalid config');\n\n  if (typeof config.inbound !== 'object' || config.inbound === null)\n    throw new Error('Invalid inbound');\n\n  const inbound = config.inbound;\n\n  if (typeof inbound.onPayload !== 'function')\n    throw new Error('Invalid inbound.onPayload');\n\n  if (typeof inbound.decipherInfo !== 'object'\n      || inbound.decipherInfo === null) {\n    throw new Error('Invalid inbound.decipherInfo');\n  }\n\n  if (!Buffer.isBuffer(inbound.decipherKey)\n      || inbound.decipherKey.length !== inbound.decipherInfo.keyLen) {\n    throw new Error('Invalid inbound.decipherKey');\n  }\n\n  if (inbound.decipherInfo.ivLen\n      && (!Buffer.isBuffer(inbound.decipherIV)\n          || inbound.decipherIV.length !== inbound.decipherInfo.ivLen)) {\n    throw new Error('Invalid inbound.decipherIV');\n  }\n\n  if (typeof inbound.seqno !== 'number'\n      || inbound.seqno < 0\n      || inbound.seqno > MAX_SEQNO) {\n    throw new Error('Invalid inbound.seqno');\n  }\n\n  const forceNative = !!inbound.forceNative;\n\n  switch (inbound.decipherInfo.sslName) {\n    case 'aes-128-gcm':\n    case 'aes-256-gcm':\n      return (AESGCMDecipher && !forceNative\n              ? new AESGCMDecipherBinding(config)\n              : new AESGCMDecipherNative(config));\n    case 'chacha20':\n      return (ChaChaPolyDecipher && !forceNative\n              ? new ChaChaPolyDecipherBinding(config)\n              : new ChaChaPolyDecipherNative(config));\n    default: {\n      if (typeof inbound.macInfo !== 'object' || inbound.macInfo === null)\n        throw new Error('Invalid inbound.macInfo');\n      if (!Buffer.isBuffer(inbound.macKey)\n          || inbound.macKey.length !== inbound.macInfo.len) {\n        throw new Error('Invalid inbound.macKey');\n      }\n      return (GenericDecipher && !forceNative\n              ? new GenericDecipherBinding(config)\n              : new GenericDecipherNative(config));\n    }\n  }\n}\n\nmodule.exports = {\n  CIPHER_INFO,\n  MAC_INFO,\n  bindingAvailable: !!binding,\n  init: (() => {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n      try {\n        POLY1305_WASM_MODULE = await require('./crypto/poly1305.js')();\n        POLY1305_RESULT_MALLOC = POLY1305_WASM_MODULE._malloc(16);\n        poly1305_auth = POLY1305_WASM_MODULE.cwrap(\n          'poly1305_auth',\n          null,\n          ['number', 'array', 'number', 'array', 'number', 'array']\n        );\n      } catch (ex) {\n        return reject(ex);\n      }\n      resolve();\n    });\n  })(),\n\n  NullCipher,\n  createCipher,\n  NullDecipher,\n  createDecipher,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}