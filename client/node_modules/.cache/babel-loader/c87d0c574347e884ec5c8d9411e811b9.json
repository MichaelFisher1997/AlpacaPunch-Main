{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@zilliqa-js/core'), require('@zilliqa-js/crypto'), require('@zilliqa-js/util'), require('@zilliqa-js/account')) : typeof define === 'function' && define.amd ? define(['exports', 'tslib', '@zilliqa-js/core', '@zilliqa-js/crypto', '@zilliqa-js/util', '@zilliqa-js/account'], factory) : factory(global.zjsBlockchain = {}, global.tslib, global['@zilliqa-js/core'], global['@zilliqa-js/crypto'], global['@zilliqa-js/util'], global['@zilliqa-js/account']);\n})(this, function (exports, tslib, core, crypto, util, account) {\n  'use strict'; //  Copyright (C) 2018 Zilliqa\n\n  function toTxParams(response) {\n    var _a = response.result,\n        toAddr = _a.toAddr,\n        senderPubKey = _a.senderPubKey,\n        gasPrice = _a.gasPrice,\n        gasLimit = _a.gasLimit,\n        nonce = _a.nonce,\n        amount = _a.amount,\n        receipt = _a.receipt,\n        version = _a.version,\n        code = _a.code,\n        data = _a.data,\n        rest = tslib.__rest(_a, [\"toAddr\", \"senderPubKey\", \"gasPrice\", \"gasLimit\", \"nonce\", \"amount\", \"receipt\", \"version\", \"code\", \"data\"]);\n\n    var msg = receipt.errors ? Object.keys(receipt.errors).reduce(function (acc, depth) {\n      var _a;\n\n      var errorMsgList = receipt.errors[depth].map(function (num) {\n        return core.TransactionError[num];\n      });\n      return tslib.__assign(tslib.__assign({}, acc), (_a = {}, _a[depth] = errorMsgList, _a));\n    }, {}) : {};\n    return tslib.__assign(tslib.__assign({}, rest), {\n      version: parseInt(version, 10),\n      toAddr: crypto.toChecksumAddress(toAddr),\n      pubKey: senderPubKey.replace('0x', ''),\n      gasPrice: new util.BN(gasPrice),\n      gasLimit: util.Long.fromString(gasLimit, 10),\n      amount: new util.BN(amount),\n      nonce: parseInt(nonce, 10),\n      code: code,\n      data: data,\n      receipt: tslib.__assign(tslib.__assign({}, receipt), {\n        accepted: receipt.accepted,\n        errors: msg,\n        cumulative_gas: parseInt(receipt.cumulative_gas, 10)\n      })\n    });\n  } //  Copyright (C) 2018 Zilliqa\n\n\n  var isBlockNumber = function (blockNum) {\n    return Number.isFinite(blockNum) && Number.isInteger(blockNum) && blockNum >= 0;\n  };\n\n  var Blockchain =\n  /** @class */\n  function () {\n    function Blockchain(provider, signer) {\n      this.pendingErrorMap = {\n        0: 'Transaction not found',\n        1: 'Pending - Dispatched',\n        2: 'Pending - Soft-confirmed (awaiting Tx block generation)',\n        4: 'Pending - Nonce is higher than expected',\n        5: 'Pending - Microblock gas limit exceeded',\n        6: 'Pending - Consensus failure in network',\n        3: 'Confirmed',\n        10: 'Rejected - Transaction caused math error',\n        11: 'Rejected - Scilla invocation error',\n        12: 'Rejected - Contract account initialization error',\n        13: 'Rejected - Invalid source account',\n        14: 'Rejected - Gas limit higher than shard gas limit',\n        15: 'Rejected - Unknown transaction type',\n        16: 'Rejected - Transaction sent to wrong shard',\n        17: 'Rejected - Contract & source account cross-shard issue',\n        18: 'Rejected - Code size exceeded limit',\n        19: 'Rejected - Transaction verification failed',\n        20: 'Rejected - Gas limit too low',\n        21: 'Rejected - Insufficient balance',\n        22: 'Rejected - Insufficient gas to invoke Scilla checker',\n        23: 'Rejected - Duplicate transaction exists',\n        24: 'Rejected - Transaction with same nonce but same/higher gas price exists',\n        25: 'Rejected - Invalid destination address',\n        26: 'Rejected - Failed to add contract account to state',\n        27: 'Rejected - Nonce is lower than expected',\n        255: 'Rejected - Internal error'\n      };\n      this.transactionStatusMap = {\n        0: {\n          0: 'Transaction not found',\n          1: ' Pending - Dispatched'\n        },\n        1: {\n          2: 'Pending - Soft-confirmed (awaiting Tx block generation)',\n          4: 'Pending - Nonce is higher than expected',\n          5: 'Pending - Microblock gas limit exceeded',\n          6: 'Pending - Consensus failure in network'\n        },\n        2: {\n          3: 'Confirmed',\n          10: 'Rejected - Transaction caused math error',\n          11: 'Rejected - Scilla invocation error',\n          12: 'Rejected - Contract account initialization error',\n          13: 'Rejected - Invalid source account',\n          14: 'Rejected - Gas limit higher than shard gas limit',\n          15: 'Rejected - Unknown transaction type',\n          16: 'Rejected - Transaction sent to wrong shard',\n          17: 'Rejected - Contract & source account cross-shard issue',\n          18: 'Rejected - Code size exceeded limit',\n          19: 'Rejected - Transaction verification failed',\n          20: 'Rejected - Gas limit too low',\n          21: 'Rejected - Insufficient balance',\n          22: 'Rejected - Insufficient gas to invoke Scilla checker',\n          23: 'Rejected - Duplicate transaction exists',\n          24: 'Rejected - Transaction with higher gas price exists',\n          25: 'Rejected - Invalid destination address',\n          26: 'Rejected - Failed to add contract account to state',\n          27: 'Rejected - Nonce is lower than expected',\n          255: 'Rejected - Internal error'\n        }\n      };\n      this.provider = provider;\n      this.provider.middleware.request.use(account.util.formatOutgoingTx, core.RPCMethod.CreateTransaction);\n      this.signer = signer;\n    }\n\n    Blockchain.prototype.getBlockChainInfo = function () {\n      return this.provider.send(core.RPCMethod.GetBlockchainInfo);\n    };\n\n    Blockchain.prototype.getShardingStructure = function () {\n      return this.provider.send(core.RPCMethod.GetShardingStructure);\n    }; // Gets details of a Directory Service block by block number.\n\n\n    Blockchain.prototype.getDSBlock = function (blockNum) {\n      return this.provider.send(core.RPCMethod.GetDSBlock, blockNum.toString());\n    }; // Gets details of the most recent Directory Service block.\n\n\n    Blockchain.prototype.getLatestDSBlock = function () {\n      return this.provider.send(core.RPCMethod.GetLatestDSBlock);\n    }; // Gets the number of DS blocks that the network has processed.\n\n\n    Blockchain.prototype.getNumDSBlocks = function () {\n      return this.provider.send(core.RPCMethod.GetNumDSBlocks);\n    }; // Gets the average rate of DS blocks processed per second\n\n\n    Blockchain.prototype.getDSBlockRate = function () {\n      return this.provider.send(core.RPCMethod.GetDSBlockRate);\n    }; // Gets a paginated list of up to 10 Directory Service (DS) blocks\n    // and their block hashes for a specified page.\n\n\n    Blockchain.prototype.getDSBlockListing = function (max) {\n      return this.provider.send(core.RPCMethod.DSBlockListing, max);\n    }; // Gets details of a Transaction block by block number.\n\n\n    Blockchain.prototype.getTxBlock = function (blockNum) {\n      return this.provider.send(core.RPCMethod.GetTxBlock, blockNum.toString());\n    }; // Gets details of the most recent Transaction block.\n\n\n    Blockchain.prototype.getLatestTxBlock = function () {\n      return this.provider.send(core.RPCMethod.GetLatestTxBlock);\n    }; // Gets the total number of TxBlocks.\n\n\n    Blockchain.prototype.getNumTxBlocks = function () {\n      return this.provider.send(core.RPCMethod.GetNumTxBlocks);\n    }; // Gets the average number of Tx blocks per second.\n\n\n    Blockchain.prototype.getTxBlockRate = function () {\n      return this.provider.send(core.RPCMethod.GetTxBlockRate);\n    }; // Get a paginated list of Transaction blocks.\n\n\n    Blockchain.prototype.getTxBlockListing = function (max) {\n      return this.provider.send(core.RPCMethod.TxBlockListing, max);\n    }; // Gets the number of transactions processed by the network so far.\n\n\n    Blockchain.prototype.getNumTransactions = function () {\n      return this.provider.send(core.RPCMethod.GetNumTransactions);\n    }; // Gets the number of transactions processed per second\n\n\n    Blockchain.prototype.getTransactionRate = function () {\n      return this.provider.send(core.RPCMethod.GetTransactionRate);\n    }; // Gets the current Tx Epoch.\n\n\n    Blockchain.prototype.getCurrentMiniEpoch = function () {\n      return this.provider.send(core.RPCMethod.GetCurrentMiniEpoch);\n    }; // Gets the current DS Epoch.\n\n\n    Blockchain.prototype.getCurrentDSEpoch = function () {\n      return this.provider.send(core.RPCMethod.GetCurrentDSEpoch);\n    }; // Gets shard difficulty for previous PoW round\n\n\n    Blockchain.prototype.getPrevDifficulty = function () {\n      return this.provider.send(core.RPCMethod.GetPrevDifficulty);\n    }; // Gets DS difficulty for previous PoW round\n\n\n    Blockchain.prototype.getPrevDSDifficulty = function () {\n      return this.provider.send(core.RPCMethod.GetPrevDSDifficulty);\n    }; // Returns the total supply (ZIL) of coins in the network.\n\n\n    Blockchain.prototype.getTotalCoinSupply = function () {\n      return this.provider.send(core.RPCMethod.GetTotalCoinSupply);\n    }; // Returns the mining nodes (i.e., the members of the DS committee and shards)\n    // at the specified DS block.\n\n\n    Blockchain.prototype.getMinerInfo = function (dsBlockNumber) {\n      return this.provider.send(core.RPCMethod.GetMinerInfo, dsBlockNumber);\n    }; // Creates a transaction and polls the lookup node for a transaction receipt.\n\n\n    Blockchain.prototype.createTransaction = function (tx, maxAttempts, interval, blockConfirm) {\n      if (maxAttempts === void 0) {\n        maxAttempts = core.GET_TX_ATTEMPTS;\n      }\n\n      if (interval === void 0) {\n        interval = 1000;\n      }\n\n      if (blockConfirm === void 0) {\n        blockConfirm = false;\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response, err_1;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.CreateTransaction, tslib.__assign(tslib.__assign({}, tx.txParams), {\n                priority: tx.toDS\n              }))];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error) {\n                throw response.error;\n              }\n\n              if (blockConfirm) {\n                return [2\n                /*return*/\n                , tx.blockConfirm(response.result.TranID, maxAttempts, interval)];\n              }\n\n              return [2\n              /*return*/\n              , tx.confirm(response.result.TranID, maxAttempts, interval)];\n\n            case 2:\n              err_1 = _a.sent();\n              throw err_1;\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }; // used together with signed batch\n    // this method waits for each txn to confirm\n    // see @createBatchTransactionWithoutConfirm for transactions without confirmation\n\n\n    Blockchain.prototype.createBatchTransaction = function (signedTxList, maxAttempts, interval, blockConfirm) {\n      if (maxAttempts === void 0) {\n        maxAttempts = core.GET_TX_ATTEMPTS;\n      }\n\n      if (interval === void 0) {\n        interval = 1000;\n      }\n\n      if (blockConfirm === void 0) {\n        blockConfirm = false;\n      }\n\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var txParamsList, signedTxList_1, signedTxList_1_1, signedTx, response, batchResults, i, tx, txRes, _a, _b, _c, _d, err_2;\n\n        var e_1, _e;\n\n        return tslib.__generator(this, function (_f) {\n          switch (_f.label) {\n            case 0:\n              _f.trys.push([0, 8,, 9]);\n\n              txParamsList = [];\n\n              try {\n                for (signedTxList_1 = tslib.__values(signedTxList), signedTxList_1_1 = signedTxList_1.next(); !signedTxList_1_1.done; signedTxList_1_1 = signedTxList_1.next()) {\n                  signedTx = signedTxList_1_1.value;\n\n                  if (signedTx.txParams.signature === undefined) {\n                    throw new Error('The transaction is not signed.');\n                  }\n\n                  txParamsList.push(tslib.__assign(tslib.__assign({}, signedTx.txParams), {\n                    priority: signedTx.toDS\n                  }));\n                }\n              } catch (e_1_1) {\n                e_1 = {\n                  error: e_1_1\n                };\n              } finally {\n                try {\n                  if (signedTxList_1_1 && !signedTxList_1_1.done && (_e = signedTxList_1.return)) _e.call(signedTxList_1);\n                } finally {\n                  if (e_1) throw e_1.error;\n                }\n              }\n\n              return [4\n              /*yield*/\n              , this.provider.sendBatch(core.RPCMethod.CreateTransaction, txParamsList)];\n\n            case 1:\n              response = _f.sent();\n\n              if (response.error) {\n                throw response.error;\n              }\n\n              batchResults = [];\n              i = 0;\n              _f.label = 2;\n\n            case 2:\n              if (!(i < signedTxList.length)) return [3\n              /*break*/\n              , 7];\n              tx = signedTxList[i];\n              txRes = response.batch_result[i];\n              if (!blockConfirm) return [3\n              /*break*/\n              , 4];\n              _b = (_a = batchResults).push;\n              return [4\n              /*yield*/\n              , tx.blockConfirm(txRes.result.TranID, maxAttempts, interval)];\n\n            case 3:\n              _b.apply(_a, [_f.sent()]);\n\n              return [3\n              /*break*/\n              , 6];\n\n            case 4:\n              _d = (_c = batchResults).push;\n              return [4\n              /*yield*/\n              , tx.confirm(txRes.result.TranID, maxAttempts, interval)];\n\n            case 5:\n              _d.apply(_c, [_f.sent()]);\n\n              _f.label = 6;\n\n            case 6:\n              i++;\n              return [3\n              /*break*/\n              , 2];\n\n            case 7:\n              return [2\n              /*return*/\n              , batchResults];\n\n            case 8:\n              err_2 = _f.sent();\n              throw err_2;\n\n            case 9:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }; // Create a transaction by using a exist signed transaction payload\n    // This payload may come form some offline signing software like ledger\n    // Currently we haven't supported convert a singed transaction back to transaction param, so we won't perform\n    // confirm logic here.\n\n\n    Blockchain.prototype.createTransactionRaw = function (payload) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var tx, response, err_3;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              tx = JSON.parse(payload);\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.CreateTransaction, tx)];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error) {\n                throw response.error;\n              }\n\n              return [2\n              /*return*/\n              , response.result.TranID];\n\n            case 2:\n              err_3 = _a.sent();\n              throw err_3;\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    Blockchain.prototype.createTransactionWithoutConfirm = function (tx) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response, err_4;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.CreateTransaction, tslib.__assign(tslib.__assign({}, tx.txParams), {\n                priority: tx.toDS\n              }))];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error) {\n                throw response.error;\n              }\n\n              tx.id = response.result.TranID;\n              return [2\n              /*return*/\n              , tx];\n\n            case 2:\n              err_4 = _a.sent();\n              throw err_4;\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }; // used together with signed batch\n\n\n    Blockchain.prototype.createBatchTransactionWithoutConfirm = function (signedTxList) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var txParamsList, signedTxList_2, signedTxList_2_1, signedTx, response, batchResults, i, tx, txRes, err_5;\n\n        var e_2, _a;\n\n        return tslib.__generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              _b.trys.push([0, 2,, 3]);\n\n              txParamsList = [];\n\n              try {\n                for (signedTxList_2 = tslib.__values(signedTxList), signedTxList_2_1 = signedTxList_2.next(); !signedTxList_2_1.done; signedTxList_2_1 = signedTxList_2.next()) {\n                  signedTx = signedTxList_2_1.value;\n\n                  if (signedTx.txParams.signature === undefined) {\n                    throw new Error('The transaction is not signed.');\n                  }\n\n                  txParamsList.push(tslib.__assign(tslib.__assign({}, signedTx.txParams), {\n                    priority: signedTx.toDS\n                  }));\n                }\n              } catch (e_2_1) {\n                e_2 = {\n                  error: e_2_1\n                };\n              } finally {\n                try {\n                  if (signedTxList_2_1 && !signedTxList_2_1.done && (_a = signedTxList_2.return)) _a.call(signedTxList_2);\n                } finally {\n                  if (e_2) throw e_2.error;\n                }\n              }\n\n              return [4\n              /*yield*/\n              , this.provider.sendBatch(core.RPCMethod.CreateTransaction, txParamsList)];\n\n            case 1:\n              response = _b.sent();\n\n              if (response.error) {\n                throw response.error;\n              }\n\n              batchResults = [];\n\n              for (i = 0; i < signedTxList.length; i++) {\n                tx = signedTxList[i];\n                txRes = response.batch_result[i];\n                tx.id = txRes.result.TranID;\n                batchResults.push(tx);\n              }\n\n              return [2\n              /*return*/\n              , batchResults];\n\n            case 2:\n              err_5 = _b.sent();\n              throw err_5;\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }; // Returns the details of a specified Transaction.\n\n\n    Blockchain.prototype.getTransaction = function (txHash) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response, err_6;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.GetTransaction, txHash.replace('0x', ''))];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error) {\n                return [2\n                /*return*/\n                , Promise.reject(response.error)];\n              }\n\n              return [2\n              /*return*/\n              , response.result.receipt.success ? account.Transaction.confirm(toTxParams(response), this.provider) : account.Transaction.reject(toTxParams(response), this.provider)];\n\n            case 2:\n              err_6 = _a.sent();\n              throw err_6;\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }; // Returns the status of a specified transaction.\n\n\n    Blockchain.prototype.getTransactionStatus = function (txHash) {\n      return tslib.__awaiter(this, void 0, void 0, function () {\n        var response, modificationState, status_1, err_7;\n        return tslib.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              return [4\n              /*yield*/\n              , this.provider.send(core.RPCMethod.GetTransactionStatus, txHash.replace('0x', ''))];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error) {\n                return [2\n                /*return*/\n                , Promise.reject(response.error)];\n              }\n\n              modificationState = response.result.modificationState;\n              status_1 = response.result.status;\n              response.result.statusMessage = this.transactionStatusMap[modificationState][status_1];\n              return [2\n              /*return*/\n              , response.result];\n\n            case 2:\n              err_7 = _a.sent();\n              throw err_7;\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }; // Gets a list of recent transactions\n\n\n    Blockchain.prototype.getRecentTransactions = function () {\n      return this.provider.send(core.RPCMethod.GetRecentTransactions);\n    }; // Returns the validated transactions included\n    // within a specified final transaction block as an array of\n    // length i, where i is the number of shards plus the DS committee.\n\n\n    Blockchain.prototype.getTransactionsForTxBlock = function (txBlock) {\n      return this.provider.send(core.RPCMethod.GetTransactionsForTxBlock, txBlock.toString());\n    }; // returns the transactions in batches (or pages) of 2,500.\n    // This API behaves similar to GetTransactionsForTxBlock\n\n\n    Blockchain.prototype.getTransactionsForTxBlockEx = function (txBlock) {\n      if (!isBlockNumber(txBlock)) {\n        throw new Error('invalid txBlock');\n      }\n\n      return this.provider.send(core.RPCMethod.GetTransactionsForTxBlockEx, txBlock.toString());\n    }; // Returns the validated transactions (in verbose form)\n    // included within a specified final transaction block.\n\n\n    Blockchain.prototype.getTxnBodiesForTxBlock = function (txBlock) {\n      return this.provider.send(core.RPCMethod.GetTxnBodiesForTxBlock, txBlock.toString());\n    }; // Returns the transactions in batches (or pages) of 2,500\n    // This API behaves similar to GetTxBodiesForTxBlock\n\n\n    Blockchain.prototype.getTxnBodiesForTxBlockEx = function (txBlock) {\n      if (!isBlockNumber(txBlock)) {\n        throw new Error('invalid txBlock');\n      }\n\n      return this.provider.send(core.RPCMethod.GetTxnBodiesForTxBlockEx, txBlock.toString());\n    }; // Gets the number of transactions procesed for a given Tx Epoch.\n\n\n    Blockchain.prototype.getNumTxnsTxEpoch = function (epoch) {\n      return this.provider.send(core.RPCMethod.GetNumTxnsTxEpoch, epoch);\n    }; // Gets the number of transactions procesed for a given DS Epoch.\n\n\n    Blockchain.prototype.getNumTxnsDSEpoch = function (epoch) {\n      return this.provider.send(core.RPCMethod.GetNumTxnsDSEpoch, epoch);\n    }; // Gets the numeric minimum gas price.\n\n\n    Blockchain.prototype.getMinimumGasPrice = function () {\n      return this.provider.send(core.RPCMethod.GetMinimumGasPrice);\n    }; // Gets the balance of an account by address.\n\n\n    Blockchain.prototype.getBalance = function (addr) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n      return this.provider.send(core.RPCMethod.GetBalance, address.replace('0x', '').toLowerCase());\n    }; // Returns the Scilla code associated with a smart contract address\n\n\n    Blockchain.prototype.getSmartContractCode = function (addr) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n      return this.provider.send(core.RPCMethod.GetSmartContractCode, address.replace('0x', '').toLowerCase());\n    }; // Returns the initialization (immutable) parameters of\n    // a given smart contract, represented in a JSON format.\n\n\n    Blockchain.prototype.getSmartContractInit = function (addr) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n      return this.provider.send(core.RPCMethod.GetSmartContractInit, address.replace('0x', '').toLowerCase());\n    }; // Retrieves the entire state of a smart contract.\n\n\n    Blockchain.prototype.getSmartContractState = function (addr) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n      return this.provider.send(core.RPCMethod.GetSmartContractState, address.replace('0x', '').toLowerCase());\n    }; // Queries the contract state, filtered by the variable names.\n\n\n    Blockchain.prototype.getSmartContractSubState = function (addr, variableName, indices) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n\n      if (!variableName) {\n        throw new Error('Variable name required');\n      }\n\n      return this.provider.send(core.RPCMethod.GetSmartContractSubState, address.replace('0x', '').toLowerCase(), variableName, indices === undefined ? [] : indices);\n    }; // Queries the contract state using batch rpc.\n\n\n    Blockchain.prototype.getSmartContractSubStateBatch = function (reqs) {\n      return this.provider.sendBatch(core.RPCMethod.GetSmartContractSubState, reqs);\n    };\n\n    Blockchain.prototype.getSmartContracts = function (addr) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n      return this.provider.send(core.RPCMethod.GetSmartContracts, address.replace('0x', '').toLowerCase());\n    };\n\n    Blockchain.prototype.getContractAddressFromTransactionID = function (txHash) {\n      return this.provider.send(core.RPCMethod.GetContractAddressFromTransactionID, txHash);\n    }; // Returns the state proof for the corresponding TxBlock for a smart contract.\n\n\n    Blockchain.prototype.getStateProof = function (contractAddress, sha256Hash, txBlock) {\n      var address = util.validation.isBech32(contractAddress) ? crypto.fromBech32Address(contractAddress) : contractAddress;\n      var isLatestStr = txBlock === 'latest';\n      var isValid = isLatestStr || isBlockNumber(Number(txBlock));\n\n      if (!isValid) {\n        throw new Error('invalid txBlock');\n      }\n\n      return this.provider.send(core.RPCMethod.GetStateProof, address.replace('0x', '').toLowerCase(), sha256Hash, txBlock.toString());\n    };\n\n    tslib.__decorate([core.sign, tslib.__metadata(\"design:type\", Function), tslib.__metadata(\"design:paramtypes\", [account.Transaction, Number, Number, Boolean]), tslib.__metadata(\"design:returntype\", Promise)], Blockchain.prototype, \"createTransaction\", null);\n\n    tslib.__decorate([core.sign, tslib.__metadata(\"design:type\", Function), tslib.__metadata(\"design:paramtypes\", [account.Transaction]), tslib.__metadata(\"design:returntype\", Promise)], Blockchain.prototype, \"createTransactionWithoutConfirm\", null);\n\n    return Blockchain;\n  }(); //  Copyright (C) 2018 Zilliqa\n  //\n  //  This file is part of zilliqa-js\n  //\n  //  This program is free software: you can redistribute it and/or modify\n  //  it under the terms of the GNU General Public License as published by\n  //  the Free Software Foundation, either version 3 of the License, or\n  //  (at your option) any later version.\n  //\n  //  This program is distributed in the hope that it will be useful,\n  //  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  //  GNU General Public License for more details.\n  //\n  //  You should have received a copy of the GNU General Public License\n  //  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\n  var NetworkMethods;\n\n  (function (NetworkMethods) {\n    NetworkMethods[\"GetClientVersion\"] = \"GetClientVersion\";\n    NetworkMethods[\"GetNetworkId\"] = \"GetNetworkId\";\n    NetworkMethods[\"GetProtocolVersion\"] = \"GetProtocolVersion\";\n  })(NetworkMethods || (NetworkMethods = {}));\n\n  var Network =\n  /** @class */\n  function () {\n    function Network(provider, signer) {\n      this.provider = provider;\n      this.signer = signer;\n    }\n\n    Network.prototype.getClientVersion = function () {\n      return this.provider.send(\"GetClientVersion\"\n      /* GetClientVersion */\n      );\n    };\n\n    Network.prototype.GetNetworkId = function () {\n      return this.provider.send(\"GetNetworkId\"\n      /* GetNetworkId */\n      );\n    };\n\n    Network.prototype.GetProtocolVersion = function (blockNum) {\n      return this.provider.send(\"GetProtocolVersion\"\n      /* GetProtocolVersion */\n      );\n    };\n\n    return Network;\n  }(); //  Copyright (C) 2018 Zilliqa\n\n\n  exports.Blockchain = Blockchain;\n  exports.Network = Network;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"mappings":"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","names":["toTxParams","response","_a","result","toAddr","senderPubKey","gasPrice","gasLimit","nonce","amount","receipt","version","code","data","rest","msg","errors","Object","keys","reduce","acc","depth","errorMsgList","map","num","TransactionError","parseInt","toChecksumAddress","pubKey","replace","BN","Long","fromString","accepted","cumulative_gas","isBlockNumber","blockNum","isFinite","Number","isInteger","provider","signer","middleware","request","use","util","formatOutgoingTx","RPCMethod","CreateTransaction","Blockchain","send","GetBlockchainInfo","GetShardingStructure","GetDSBlock","toString","GetLatestDSBlock","GetNumDSBlocks","GetDSBlockRate","max","DSBlockListing","GetTxBlock","GetLatestTxBlock","GetNumTxBlocks","GetTxBlockRate","TxBlockListing","GetNumTransactions","GetTransactionRate","GetCurrentMiniEpoch","GetCurrentDSEpoch","GetPrevDifficulty","GetPrevDSDifficulty","GetTotalCoinSupply","dsBlockNumber","GetMinerInfo","tx","maxAttempts","interval","blockConfirm","tslib","txParams","priority","toDS","error","TranID","confirm","err_1","signedTxList","txParamsList","signedTxList_1","signedTxList_1_1","signedTx","signature","undefined","Error","push","sendBatch","_f","batchResults","i","length","txRes","batch_result","_b","_d","err_2","payload","JSON","parse","err_3","id","err_4","signedTxList_2","signedTxList_2_1","err_5","txHash","GetTransaction","Promise","reject","success","Transaction","err_6","GetTransactionStatus","modificationState","status_1","status","statusMessage","transactionStatusMap","err_7","GetRecentTransactions","txBlock","GetTransactionsForTxBlock","GetTransactionsForTxBlockEx","GetTxnBodiesForTxBlock","GetTxnBodiesForTxBlockEx","epoch","GetNumTxnsTxEpoch","GetNumTxnsDSEpoch","GetMinimumGasPrice","addr","address","validation","isBech32","fromBech32Address","GetBalance","toLowerCase","GetSmartContractCode","GetSmartContractInit","GetSmartContractState","variableName","indices","GetSmartContractSubState","reqs","GetSmartContracts","GetContractAddressFromTransactionID","contractAddress","sha256Hash","isLatestStr","isValid","GetStateProof","__decorate","sign","NetworkMethods","Network"],"sources":["/home/micqdf/AlpacaPunchTests/maintest/test1/client/node_modules/@zilliqa-js/blockchain/src/util.ts","/home/micqdf/AlpacaPunchTests/maintest/test1/client/node_modules/@zilliqa-js/blockchain/src/chain.ts","/home/micqdf/AlpacaPunchTests/maintest/test1/client/node_modules/@zilliqa-js/blockchain/src/network.ts","/home/micqdf/AlpacaPunchTests/maintest/test1/client/node_modules/@zilliqa-js/blockchain/src/index.ts"],"sourcesContent":["//  Copyright (C) 2018 Zilliqa\n//\n//  This file is part of zilliqa-js\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  This program is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport { TxParams } from '@zilliqa-js/account';\nimport {\n  RPCResponse,\n  TransactionError,\n  TransactionObj,\n} from '@zilliqa-js/core';\nimport { toChecksumAddress } from '@zilliqa-js/crypto';\nimport { BN, Long } from '@zilliqa-js/util';\n\nexport function toTxParams(\n  response: RPCResponse<TransactionObj, never>,\n): TxParams {\n  const {\n    toAddr,\n    senderPubKey,\n    gasPrice,\n    gasLimit,\n    nonce,\n    amount,\n    receipt,\n    version,\n    code,\n    data,\n    ...rest\n  } = <TransactionObj>response.result;\n\n  const msg = receipt.errors\n    ? Object.keys(receipt.errors).reduce((acc, depth) => {\n        const errorMsgList = receipt.errors[depth].map(\n          (num: number) => TransactionError[num],\n        );\n        return { ...acc, [depth]: errorMsgList };\n      }, {})\n    : {};\n\n  return {\n    ...rest,\n    version: parseInt(version, 10),\n    toAddr: toChecksumAddress(toAddr),\n    pubKey: senderPubKey.replace('0x', ''),\n    gasPrice: new BN(gasPrice),\n    gasLimit: Long.fromString(gasLimit, 10),\n    amount: new BN(amount),\n    nonce: parseInt(nonce, 10),\n    code,\n    data,\n    receipt: {\n      ...receipt,\n      accepted: receipt.accepted,\n      errors: msg,\n      cumulative_gas: parseInt(receipt.cumulative_gas, 10),\n    },\n  };\n}\n","//  Copyright (C) 2018 Zilliqa\n//\n//  This file is part of zilliqa-js\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  This program is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport { Transaction, util, Wallet } from '@zilliqa-js/account';\nimport { fromBech32Address } from '@zilliqa-js/crypto';\nimport { validation } from '@zilliqa-js/util';\nimport {\n  BlockchainInfo,\n  BlockList,\n  DsBlockObj,\n  GET_TX_ATTEMPTS,\n  TransactionStatusObj,\n  Provider,\n  RPCMethod,\n  RPCResponse,\n  ShardingStructure,\n  sign,\n  TransactionObj,\n  MinerInfo,\n  TxBlockObj,\n  TxList,\n  ZilliqaModule,\n} from '@zilliqa-js/core';\n\nimport { toTxParams } from './util';\n\nconst isBlockNumber = (blockNum: number) =>\n  Number.isFinite(blockNum) && Number.isInteger(blockNum) && blockNum >= 0;\n\nexport class Blockchain implements ZilliqaModule {\n  signer: Wallet;\n  provider: Provider;\n  pendingErrorMap: { [key: number]: string } = {\n    0: 'Transaction not found',\n    1: 'Pending - Dispatched',\n    2: 'Pending - Soft-confirmed (awaiting Tx block generation)',\n    4: 'Pending - Nonce is higher than expected',\n    5: 'Pending - Microblock gas limit exceeded',\n    6: 'Pending - Consensus failure in network',\n    3: 'Confirmed',\n    10: 'Rejected - Transaction caused math error',\n    11: 'Rejected - Scilla invocation error',\n    12: 'Rejected - Contract account initialization error',\n    13: 'Rejected - Invalid source account',\n    14: 'Rejected - Gas limit higher than shard gas limit',\n    15: 'Rejected - Unknown transaction type',\n    16: 'Rejected - Transaction sent to wrong shard',\n    17: 'Rejected - Contract & source account cross-shard issue',\n    18: 'Rejected - Code size exceeded limit',\n    19: 'Rejected - Transaction verification failed',\n    20: 'Rejected - Gas limit too low',\n    21: 'Rejected - Insufficient balance',\n    22: 'Rejected - Insufficient gas to invoke Scilla checker',\n    23: 'Rejected - Duplicate transaction exists',\n    24: 'Rejected - Transaction with same nonce but same/higher gas price exists',\n    25: 'Rejected - Invalid destination address',\n    26: 'Rejected - Failed to add contract account to state',\n    27: 'Rejected - Nonce is lower than expected',\n    255: 'Rejected - Internal error',\n  };\n\n  transactionStatusMap: { [key: number]: { [key: number]: string } } = {\n    0: { 0: 'Transaction not found', 1: ' Pending - Dispatched' },\n    1: {\n      2: 'Pending - Soft-confirmed (awaiting Tx block generation)',\n      4: 'Pending - Nonce is higher than expected',\n      5: 'Pending - Microblock gas limit exceeded',\n      6: 'Pending - Consensus failure in network',\n    },\n    2: {\n      3: 'Confirmed',\n      10: 'Rejected - Transaction caused math error',\n      11: 'Rejected - Scilla invocation error',\n      12: 'Rejected - Contract account initialization error',\n      13: 'Rejected - Invalid source account',\n      14: 'Rejected - Gas limit higher than shard gas limit',\n      15: 'Rejected - Unknown transaction type',\n      16: 'Rejected - Transaction sent to wrong shard',\n      17: 'Rejected - Contract & source account cross-shard issue',\n      18: 'Rejected - Code size exceeded limit',\n      19: 'Rejected - Transaction verification failed',\n      20: 'Rejected - Gas limit too low',\n      21: 'Rejected - Insufficient balance',\n      22: 'Rejected - Insufficient gas to invoke Scilla checker',\n      23: 'Rejected - Duplicate transaction exists',\n      24: 'Rejected - Transaction with higher gas price exists',\n      25: 'Rejected - Invalid destination address',\n      26: 'Rejected - Failed to add contract account to state',\n      27: 'Rejected - Nonce is lower than expected',\n      255: 'Rejected - Internal error',\n    },\n  };\n\n  constructor(provider: Provider, signer: Wallet) {\n    this.provider = provider;\n    this.provider.middleware.request.use(\n      util.formatOutgoingTx,\n      RPCMethod.CreateTransaction,\n    );\n    this.signer = signer;\n  }\n\n  getBlockChainInfo(): Promise<RPCResponse<BlockchainInfo, string>> {\n    return this.provider.send(RPCMethod.GetBlockchainInfo);\n  }\n\n  getShardingStructure(): Promise<RPCResponse<ShardingStructure, string>> {\n    return this.provider.send(RPCMethod.GetShardingStructure);\n  }\n\n  // Gets details of a Directory Service block by block number.\n  getDSBlock(blockNum: number): Promise<RPCResponse<DsBlockObj, string>> {\n    return this.provider.send(RPCMethod.GetDSBlock, blockNum.toString());\n  }\n\n  // Gets details of the most recent Directory Service block.\n  getLatestDSBlock(): Promise<RPCResponse<DsBlockObj, string>> {\n    return this.provider.send(RPCMethod.GetLatestDSBlock);\n  }\n\n  // Gets the number of DS blocks that the network has processed.\n  getNumDSBlocks(): Promise<RPCResponse<string, string>> {\n    return this.provider.send(RPCMethod.GetNumDSBlocks);\n  }\n\n  // Gets the average rate of DS blocks processed per second\n  getDSBlockRate(): Promise<RPCResponse<number, string>> {\n    return this.provider.send(RPCMethod.GetDSBlockRate);\n  }\n\n  // Gets a paginated list of up to 10 Directory Service (DS) blocks\n  // and their block hashes for a specified page.\n  getDSBlockListing(max: number): Promise<RPCResponse<BlockList, string>> {\n    return this.provider.send(RPCMethod.DSBlockListing, max);\n  }\n\n  // Gets details of a Transaction block by block number.\n  getTxBlock(blockNum: number): Promise<RPCResponse<TxBlockObj, string>> {\n    return this.provider.send(RPCMethod.GetTxBlock, blockNum.toString());\n  }\n\n  // Gets details of the most recent Transaction block.\n  getLatestTxBlock(): Promise<RPCResponse<TxBlockObj, string>> {\n    return this.provider.send(RPCMethod.GetLatestTxBlock);\n  }\n\n  // Gets the total number of TxBlocks.\n  getNumTxBlocks(): Promise<RPCResponse<string, string>> {\n    return this.provider.send(RPCMethod.GetNumTxBlocks);\n  }\n\n  // Gets the average number of Tx blocks per second.\n  getTxBlockRate(): Promise<RPCResponse<number, string>> {\n    return this.provider.send(RPCMethod.GetTxBlockRate);\n  }\n\n  // Get a paginated list of Transaction blocks.\n  getTxBlockListing(max: number): Promise<RPCResponse<BlockList, string>> {\n    return this.provider.send(RPCMethod.TxBlockListing, max);\n  }\n\n  // Gets the number of transactions processed by the network so far.\n  getNumTransactions(): Promise<RPCResponse<string, string>> {\n    return this.provider.send(RPCMethod.GetNumTransactions);\n  }\n\n  // Gets the number of transactions processed per second\n  getTransactionRate(): Promise<RPCResponse<number, string>> {\n    return this.provider.send(RPCMethod.GetTransactionRate);\n  }\n\n  // Gets the current Tx Epoch.\n  getCurrentMiniEpoch(): Promise<RPCResponse<string, string>> {\n    return this.provider.send(RPCMethod.GetCurrentMiniEpoch);\n  }\n\n  // Gets the current DS Epoch.\n  getCurrentDSEpoch(): Promise<RPCResponse<any, string>> {\n    return this.provider.send(RPCMethod.GetCurrentDSEpoch);\n  }\n\n  // Gets shard difficulty for previous PoW round\n  getPrevDifficulty(): Promise<RPCResponse<number, string>> {\n    return this.provider.send(RPCMethod.GetPrevDifficulty);\n  }\n\n  // Gets DS difficulty for previous PoW round\n  getPrevDSDifficulty(): Promise<RPCResponse<number, string>> {\n    return this.provider.send(RPCMethod.GetPrevDSDifficulty);\n  }\n\n  // Returns the total supply (ZIL) of coins in the network.\n  getTotalCoinSupply(): Promise<RPCResponse<string, string>> {\n    return this.provider.send(RPCMethod.GetTotalCoinSupply);\n  }\n\n  // Returns the mining nodes (i.e., the members of the DS committee and shards)\n  // at the specified DS block.\n  getMinerInfo(dsBlockNumber: string): Promise<RPCResponse<MinerInfo, any>> {\n    return this.provider.send(RPCMethod.GetMinerInfo, dsBlockNumber);\n  }\n\n  // Creates a transaction and polls the lookup node for a transaction receipt.\n  @sign\n  async createTransaction(\n    tx: Transaction,\n    maxAttempts: number = GET_TX_ATTEMPTS,\n    interval: number = 1000,\n    blockConfirm: boolean = false,\n  ): Promise<Transaction> {\n    try {\n      const response = await this.provider.send(RPCMethod.CreateTransaction, {\n        ...tx.txParams,\n        priority: tx.toDS,\n      });\n\n      if (response.error) {\n        throw response.error;\n      }\n      if (blockConfirm) {\n        return tx.blockConfirm(response.result.TranID, maxAttempts, interval);\n      }\n      return tx.confirm(response.result.TranID, maxAttempts, interval);\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  // used together with signed batch\n  // this method waits for each txn to confirm\n  // see @createBatchTransactionWithoutConfirm for transactions without confirmation\n  async createBatchTransaction(\n    signedTxList: Transaction[],\n    maxAttempts: number = GET_TX_ATTEMPTS,\n    interval: number = 1000,\n    blockConfirm: boolean = false,\n  ): Promise<Transaction[]> {\n    try {\n      const txParamsList = [];\n      for (const signedTx of signedTxList) {\n        if (signedTx.txParams.signature === undefined) {\n          throw new Error('The transaction is not signed.');\n        }\n        txParamsList.push({\n          ...signedTx.txParams,\n          priority: signedTx.toDS,\n        });\n      }\n\n      const response = await this.provider.sendBatch(\n        RPCMethod.CreateTransaction,\n        txParamsList,\n      );\n\n      if (response.error) {\n        throw response.error;\n      }\n\n      // retrieve batch result\n      const batchResults = [];\n      for (let i = 0; i < signedTxList.length; i++) {\n        const tx = signedTxList[i];\n        const txRes = response.batch_result[i];\n\n        if (blockConfirm) {\n          batchResults.push(\n            await tx.blockConfirm(txRes.result.TranID, maxAttempts, interval),\n          );\n        } else {\n          batchResults.push(\n            await tx.confirm(txRes.result.TranID, maxAttempts, interval),\n          );\n        }\n      }\n      return batchResults;\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  // Create a transaction by using a exist signed transaction payload\n  // This payload may come form some offline signing software like ledger\n  // Currently we haven't supported convert a singed transaction back to transaction param, so we won't perform\n  // confirm logic here.\n  async createTransactionRaw(payload: string): Promise<string> {\n    try {\n      const tx = JSON.parse(payload);\n      const response = await this.provider.send(\n        RPCMethod.CreateTransaction,\n        tx,\n      );\n      if (response.error) {\n        throw response.error;\n      }\n      return response.result.TranID;\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  @sign\n  async createTransactionWithoutConfirm(tx: Transaction): Promise<Transaction> {\n    try {\n      const response = await this.provider.send(RPCMethod.CreateTransaction, {\n        ...tx.txParams,\n        priority: tx.toDS,\n      });\n      if (response.error) {\n        throw response.error;\n      }\n      tx.id = response.result.TranID;\n      return tx;\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  // used together with signed batch\n  async createBatchTransactionWithoutConfirm(\n    signedTxList: Transaction[],\n  ): Promise<Transaction[]> {\n    try {\n      const txParamsList = [];\n      for (const signedTx of signedTxList) {\n        if (signedTx.txParams.signature === undefined) {\n          throw new Error('The transaction is not signed.');\n        }\n        txParamsList.push({\n          ...signedTx.txParams,\n          priority: signedTx.toDS,\n        });\n      }\n\n      const response = await this.provider.sendBatch(\n        RPCMethod.CreateTransaction,\n        txParamsList,\n      );\n\n      if (response.error) {\n        throw response.error;\n      }\n\n      const batchResults = [];\n      for (let i = 0; i < signedTxList.length; i++) {\n        const tx = signedTxList[i];\n        const txRes = response.batch_result[i];\n        tx.id = txRes.result.TranID;\n        batchResults.push(tx);\n      }\n      return batchResults;\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  // Returns the details of a specified Transaction.\n  async getTransaction(txHash: string): Promise<Transaction> {\n    try {\n      const response = await this.provider.send<TransactionObj>(\n        RPCMethod.GetTransaction,\n        txHash.replace('0x', ''),\n      );\n\n      if (response.error) {\n        return Promise.reject(response.error);\n      }\n\n      return response.result.receipt.success\n        ? Transaction.confirm(toTxParams(response), this.provider)\n        : Transaction.reject(toTxParams(response), this.provider);\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  // Returns the status of a specified transaction.\n  async getTransactionStatus(txHash: string): Promise<TransactionStatusObj> {\n    try {\n      const response = await this.provider.send<TransactionStatusObj>(\n        RPCMethod.GetTransactionStatus,\n        txHash.replace('0x', ''),\n      );\n      if (response.error) {\n        return Promise.reject(response.error);\n      }\n\n      const modificationState = response.result.modificationState;\n      const status = response.result.status;\n      response.result.statusMessage =\n        this.transactionStatusMap[modificationState][status];\n      return response.result;\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  // Gets a list of recent transactions\n  getRecentTransactions(): Promise<RPCResponse<TxList, never>> {\n    return this.provider.send(RPCMethod.GetRecentTransactions);\n  }\n\n  // Returns the validated transactions included\n  // within a specified final transaction block as an array of\n  // length i, where i is the number of shards plus the DS committee.\n  getTransactionsForTxBlock(\n    txBlock: number,\n  ): Promise<RPCResponse<string[][], string>> {\n    return this.provider.send(\n      RPCMethod.GetTransactionsForTxBlock,\n      txBlock.toString(),\n    );\n  }\n\n  // returns the transactions in batches (or pages) of 2,500.\n  // This API behaves similar to GetTransactionsForTxBlock\n  getTransactionsForTxBlockEx(\n    txBlock: number,\n  ): Promise<RPCResponse<any, string>> {\n    if (!isBlockNumber(txBlock)) {\n      throw new Error('invalid txBlock');\n    }\n    return this.provider.send(\n      RPCMethod.GetTransactionsForTxBlockEx,\n      txBlock.toString(),\n    );\n  }\n\n  // Returns the validated transactions (in verbose form)\n  // included within a specified final transaction block.\n  getTxnBodiesForTxBlock(\n    txBlock: number,\n  ): Promise<RPCResponse<TransactionObj[], string>> {\n    return this.provider.send(\n      RPCMethod.GetTxnBodiesForTxBlock,\n      txBlock.toString(),\n    );\n  }\n\n  // Returns the transactions in batches (or pages) of 2,500\n  // This API behaves similar to GetTxBodiesForTxBlock\n  getTxnBodiesForTxBlockEx(txBlock: number): Promise<RPCResponse<any, string>> {\n    if (!isBlockNumber(txBlock)) {\n      throw new Error('invalid txBlock');\n    }\n    return this.provider.send(\n      RPCMethod.GetTxnBodiesForTxBlockEx,\n      txBlock.toString(),\n    );\n  }\n\n  // Gets the number of transactions procesed for a given Tx Epoch.\n  getNumTxnsTxEpoch(epoch: number): Promise<RPCResponse<string, string>> {\n    return this.provider.send(RPCMethod.GetNumTxnsTxEpoch, epoch);\n  }\n\n  // Gets the number of transactions procesed for a given DS Epoch.\n  getNumTxnsDSEpoch(epoch: number): Promise<RPCResponse<string, string>> {\n    return this.provider.send(RPCMethod.GetNumTxnsDSEpoch, epoch);\n  }\n\n  // Gets the numeric minimum gas price.\n  getMinimumGasPrice() {\n    return this.provider.send<string, string>(RPCMethod.GetMinimumGasPrice);\n  }\n\n  // Gets the balance of an account by address.\n  getBalance(addr: string): Promise<RPCResponse<any, string>> {\n    const address = validation.isBech32(addr) ? fromBech32Address(addr) : addr;\n    return this.provider.send(\n      RPCMethod.GetBalance,\n      address.replace('0x', '').toLowerCase(),\n    );\n  }\n\n  // Returns the Scilla code associated with a smart contract address\n  getSmartContractCode(\n    addr: string,\n  ): Promise<RPCResponse<{ code: string }, string>> {\n    const address = validation.isBech32(addr) ? fromBech32Address(addr) : addr;\n    return this.provider.send(\n      RPCMethod.GetSmartContractCode,\n      address.replace('0x', '').toLowerCase(),\n    );\n  }\n\n  // Returns the initialization (immutable) parameters of\n  // a given smart contract, represented in a JSON format.\n  getSmartContractInit(addr: string): Promise<RPCResponse<any, string>> {\n    const address = validation.isBech32(addr) ? fromBech32Address(addr) : addr;\n    return this.provider.send(\n      RPCMethod.GetSmartContractInit,\n      address.replace('0x', '').toLowerCase(),\n    );\n  }\n\n  // Retrieves the entire state of a smart contract.\n  getSmartContractState(addr: string): Promise<RPCResponse<any, string>> {\n    const address = validation.isBech32(addr) ? fromBech32Address(addr) : addr;\n    return this.provider.send(\n      RPCMethod.GetSmartContractState,\n      address.replace('0x', '').toLowerCase(),\n    );\n  }\n\n  // Queries the contract state, filtered by the variable names.\n  getSmartContractSubState(\n    addr: string,\n    variableName: string,\n    indices?: string[],\n  ): Promise<RPCResponse<any, string>> {\n    const address = validation.isBech32(addr) ? fromBech32Address(addr) : addr;\n    if (!variableName) {\n      throw new Error('Variable name required');\n    }\n\n    return this.provider.send(\n      RPCMethod.GetSmartContractSubState,\n      address.replace('0x', '').toLowerCase(),\n      variableName,\n      indices === undefined ? [] : indices,\n    );\n  }\n\n  // Queries the contract state using batch rpc.\n  getSmartContractSubStateBatch(reqs: any[]): Promise<RPCResponse<any, any>> {\n    return this.provider.sendBatch(RPCMethod.GetSmartContractSubState, reqs);\n  }\n\n  getSmartContracts(addr: string): Promise<RPCResponse<any, string>> {\n    const address = validation.isBech32(addr) ? fromBech32Address(addr) : addr;\n    return this.provider.send(\n      RPCMethod.GetSmartContracts,\n      address.replace('0x', '').toLowerCase(),\n    );\n  }\n\n  getContractAddressFromTransactionID(\n    txHash: string,\n  ): Promise<RPCResponse<string, string>> {\n    return this.provider.send(\n      RPCMethod.GetContractAddressFromTransactionID,\n      txHash,\n    );\n  }\n\n  // Returns the state proof for the corresponding TxBlock for a smart contract.\n  getStateProof(\n    contractAddress: string,\n    sha256Hash: string,\n    txBlock: number | string,\n  ): Promise<RPCResponse<any, string>> {\n    const address = validation.isBech32(contractAddress)\n      ? fromBech32Address(contractAddress)\n      : contractAddress;\n\n    const isLatestStr = txBlock === 'latest';\n    const isValid = isLatestStr || isBlockNumber(Number(txBlock));\n    if (!isValid) {\n      throw new Error('invalid txBlock');\n    }\n\n    return this.provider.send(\n      RPCMethod.GetStateProof,\n      address.replace('0x', '').toLowerCase(),\n      sha256Hash,\n      txBlock.toString(),\n    );\n  }\n}\n","//  Copyright (C) 2018 Zilliqa\n//\n//  This file is part of zilliqa-js\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  This program is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport { Provider, ZilliqaModule } from '@zilliqa-js/core';\nimport { Wallet } from '@zilliqa-js/account';\n\nconst enum NetworkMethods {\n  GetClientVersion = 'GetClientVersion',\n  GetNetworkId = 'GetNetworkId',\n  GetProtocolVersion = 'GetProtocolVersion',\n}\n\nexport class Network implements ZilliqaModule {\n  provider: Provider;\n  signer: Wallet;\n\n  constructor(provider: Provider, signer: Wallet) {\n    this.provider = provider;\n    this.signer = signer;\n  }\n\n  getClientVersion(): Promise<any> {\n    return this.provider.send(NetworkMethods.GetClientVersion);\n  }\n\n  GetNetworkId(): Promise<any> {\n    return this.provider.send(NetworkMethods.GetNetworkId);\n  }\n\n  GetProtocolVersion(blockNum: number): Promise<any> {\n    return this.provider.send(NetworkMethods.GetProtocolVersion);\n  }\n}\n","//  Copyright (C) 2018 Zilliqa\n//\n//  This file is part of zilliqa-js\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  This program is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nexport { Blockchain } from './chain';\nexport { Network } from './network';\n"]},"metadata":{},"sourceType":"script"}