{"ast":null,"code":"// TODO:\n//    * add `.connected` or similar property to allow immediate connection\n//      status checking\n//    * add/improve debug output during user authentication phase\n'use strict';\n\nconst {\n  createHash,\n  getHashes,\n  randomFillSync\n} = require('crypto');\n\nconst {\n  Socket\n} = require('net');\n\nconst {\n  lookup: dnsLookup\n} = require('dns');\n\nconst EventEmitter = require('events');\n\nconst HASHES = getHashes();\n\nconst {\n  COMPAT,\n  CHANNEL_EXTENDED_DATATYPE: {\n    STDERR\n  },\n  CHANNEL_OPEN_FAILURE,\n  DEFAULT_CIPHER,\n  DEFAULT_COMPRESSION,\n  DEFAULT_KEX,\n  DEFAULT_MAC,\n  DEFAULT_SERVER_HOST_KEY,\n  DISCONNECT_REASON,\n  DISCONNECT_REASON_BY_VALUE,\n  SUPPORTED_CIPHER,\n  SUPPORTED_COMPRESSION,\n  SUPPORTED_KEX,\n  SUPPORTED_MAC,\n  SUPPORTED_SERVER_HOST_KEY\n} = require('./protocol/constants.js');\n\nconst {\n  init: cryptoInit\n} = require('./protocol/crypto.js');\n\nconst Protocol = require('./protocol/Protocol.js');\n\nconst {\n  parseKey\n} = require('./protocol/keyParser.js');\n\nconst {\n  SFTP\n} = require('./protocol/SFTP.js');\n\nconst {\n  bufferCopy,\n  makeBufferParser,\n  makeError,\n  readUInt32BE,\n  sigSSHToASN1,\n  writeUInt32BE\n} = require('./protocol/utils.js');\n\nconst {\n  AgentContext,\n  createAgent,\n  isAgent\n} = require('./agent.js');\n\nconst {\n  Channel,\n  MAX_WINDOW,\n  PACKET_SIZE,\n  windowAdjust,\n  WINDOW_THRESHOLD\n} = require('./Channel.js');\n\nconst {\n  ChannelManager,\n  generateAlgorithmList,\n  isWritable,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE\n} = require('./utils.js');\n\nconst bufferParser = makeBufferParser();\nconst sigParser = makeBufferParser();\nconst RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\\d)|(?:\\d{2,})/;\n\nconst noop = err => {};\n\nclass Client extends EventEmitter {\n  constructor() {\n    super();\n    this.config = {\n      host: undefined,\n      port: undefined,\n      localAddress: undefined,\n      localPort: undefined,\n      forceIPv4: undefined,\n      forceIPv6: undefined,\n      keepaliveCountMax: undefined,\n      keepaliveInterval: undefined,\n      readyTimeout: undefined,\n      ident: undefined,\n      username: undefined,\n      password: undefined,\n      privateKey: undefined,\n      tryKeyboard: undefined,\n      agent: undefined,\n      allowAgentFwd: undefined,\n      authHandler: undefined,\n      hostHashAlgo: undefined,\n      hostHashCb: undefined,\n      strictVendor: undefined,\n      debug: undefined\n    };\n    this._agent = undefined;\n    this._readyTimeout = undefined;\n    this._chanMgr = undefined;\n    this._callbacks = undefined;\n    this._forwarding = undefined;\n    this._forwardingUnix = undefined;\n    this._acceptX11 = undefined;\n    this._agentFwdEnabled = undefined;\n    this._remoteVer = undefined;\n    this._protocol = undefined;\n    this._sock = undefined;\n    this._resetKA = undefined;\n  }\n\n  connect(cfg) {\n    var _this = this;\n\n    if (this._sock && isWritable(this._sock)) {\n      this.once('close', () => {\n        this.connect(cfg);\n      });\n      this.end();\n      return this;\n    }\n\n    this.config.host = cfg.hostname || cfg.host || 'localhost';\n    this.config.port = cfg.port || 22;\n    this.config.localAddress = typeof cfg.localAddress === 'string' ? cfg.localAddress : undefined;\n    this.config.localPort = typeof cfg.localPort === 'string' || typeof cfg.localPort === 'number' ? cfg.localPort : undefined;\n    this.config.forceIPv4 = cfg.forceIPv4 || false;\n    this.config.forceIPv6 = cfg.forceIPv6 || false;\n    this.config.keepaliveCountMax = typeof cfg.keepaliveCountMax === 'number' && cfg.keepaliveCountMax >= 0 ? cfg.keepaliveCountMax : 3;\n    this.config.keepaliveInterval = typeof cfg.keepaliveInterval === 'number' && cfg.keepaliveInterval > 0 ? cfg.keepaliveInterval : 0;\n    this.config.readyTimeout = typeof cfg.readyTimeout === 'number' && cfg.readyTimeout >= 0 ? cfg.readyTimeout : 20000;\n    this.config.ident = typeof cfg.ident === 'string' || Buffer.isBuffer(cfg.ident) ? cfg.ident : undefined;\n    const algorithms = {\n      kex: undefined,\n      serverHostKey: undefined,\n      cs: {\n        cipher: undefined,\n        mac: undefined,\n        compress: undefined,\n        lang: []\n      },\n      sc: undefined\n    };\n    let allOfferDefaults = true;\n\n    if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n      algorithms.kex = generateAlgorithmList(cfg.algorithms.kex, DEFAULT_KEX, SUPPORTED_KEX);\n      if (algorithms.kex !== DEFAULT_KEX) allOfferDefaults = false;\n      algorithms.serverHostKey = generateAlgorithmList(cfg.algorithms.serverHostKey, DEFAULT_SERVER_HOST_KEY, SUPPORTED_SERVER_HOST_KEY);\n      if (algorithms.serverHostKey !== DEFAULT_SERVER_HOST_KEY) allOfferDefaults = false;\n      algorithms.cs.cipher = generateAlgorithmList(cfg.algorithms.cipher, DEFAULT_CIPHER, SUPPORTED_CIPHER);\n      if (algorithms.cs.cipher !== DEFAULT_CIPHER) allOfferDefaults = false;\n      algorithms.cs.mac = generateAlgorithmList(cfg.algorithms.hmac, DEFAULT_MAC, SUPPORTED_MAC);\n      if (algorithms.cs.mac !== DEFAULT_MAC) allOfferDefaults = false;\n      algorithms.cs.compress = generateAlgorithmList(cfg.algorithms.compress, DEFAULT_COMPRESSION, SUPPORTED_COMPRESSION);\n      if (algorithms.cs.compress !== DEFAULT_COMPRESSION) allOfferDefaults = false;\n      if (!allOfferDefaults) algorithms.sc = algorithms.cs;\n    }\n\n    if (typeof cfg.username === 'string') this.config.username = cfg.username;else if (typeof cfg.user === 'string') this.config.username = cfg.user;else throw new Error('Invalid username');\n    this.config.password = typeof cfg.password === 'string' ? cfg.password : undefined;\n    this.config.privateKey = typeof cfg.privateKey === 'string' || Buffer.isBuffer(cfg.privateKey) ? cfg.privateKey : undefined;\n    this.config.localHostname = typeof cfg.localHostname === 'string' ? cfg.localHostname : undefined;\n    this.config.localUsername = typeof cfg.localUsername === 'string' ? cfg.localUsername : undefined;\n    this.config.tryKeyboard = cfg.tryKeyboard === true;\n    if (typeof cfg.agent === 'string' && cfg.agent.length) this.config.agent = createAgent(cfg.agent);else if (isAgent(cfg.agent)) this.config.agent = cfg.agent;else this.config.agent = undefined;\n    this.config.allowAgentFwd = cfg.agentForward === true && this.config.agent !== undefined;\n    let authHandler = this.config.authHandler = typeof cfg.authHandler === 'function' || Array.isArray(cfg.authHandler) ? cfg.authHandler : undefined;\n    this.config.strictVendor = typeof cfg.strictVendor === 'boolean' ? cfg.strictVendor : true;\n    const debug = this.config.debug = typeof cfg.debug === 'function' ? cfg.debug : undefined;\n\n    if (cfg.agentForward === true && !this.config.allowAgentFwd) {\n      throw new Error('You must set a valid agent path to allow agent forwarding');\n    }\n\n    let callbacks = this._callbacks = [];\n    this._chanMgr = new ChannelManager(this);\n    this._forwarding = {};\n    this._forwardingUnix = {};\n    this._acceptX11 = 0;\n    this._agentFwdEnabled = false;\n    this._agent = this.config.agent ? this.config.agent : undefined;\n    this._remoteVer = undefined;\n    let privateKey;\n\n    if (this.config.privateKey) {\n      privateKey = parseKey(this.config.privateKey, cfg.passphrase);\n      if (privateKey instanceof Error) throw new Error(`Cannot parse privateKey: ${privateKey.message}`);\n\n      if (Array.isArray(privateKey)) {\n        // OpenSSH's newer format only stores 1 key for now\n        privateKey = privateKey[0];\n      }\n\n      if (privateKey.getPrivatePEM() === null) {\n        throw new Error('privateKey value does not contain a (valid) private key');\n      }\n    }\n\n    let hostVerifier;\n\n    if (typeof cfg.hostVerifier === 'function') {\n      const hashCb = cfg.hostVerifier;\n      let hasher;\n\n      if (HASHES.indexOf(cfg.hostHash) !== -1) {\n        // Default to old behavior of hashing on user's behalf\n        hasher = createHash(cfg.hostHash);\n      }\n\n      hostVerifier = (key, verify) => {\n        if (hasher) {\n          hasher.update(key);\n          key = hasher.digest('hex');\n        }\n\n        const ret = hashCb(key, verify);\n        if (ret !== undefined) verify(ret);\n      };\n    }\n\n    const sock = this._sock = cfg.sock || new Socket();\n    let ready = false;\n    let sawHeader = false;\n    if (this._protocol) this._protocol.cleanup();\n    const DEBUG_HANDLER = !debug ? undefined : (p, display, msg) => {\n      debug(`Debug output from server: ${JSON.stringify(msg)}`);\n    };\n    const proto = this._protocol = new Protocol({\n      ident: this.config.ident,\n      offer: allOfferDefaults ? undefined : algorithms,\n      onWrite: data => {\n        if (isWritable(sock)) sock.write(data);\n      },\n      onError: err => {\n        if (err.level === 'handshake') clearTimeout(this._readyTimeout);\n        if (!proto._destruct) sock.removeAllListeners('data');\n        this.emit('error', err);\n\n        try {\n          sock.end();\n        } catch {}\n      },\n      onHeader: header => {\n        sawHeader = true;\n        this._remoteVer = header.versions.software;\n        if (header.greeting) this.emit('greeting', header.greeting);\n      },\n      onHandshakeComplete: negotiated => {\n        this.emit('handshake', negotiated);\n\n        if (!ready) {\n          ready = true;\n          proto.service('ssh-userauth');\n        }\n      },\n      debug,\n      hostVerifier,\n      messageHandlers: {\n        DEBUG: DEBUG_HANDLER,\n        DISCONNECT: (p, reason, desc) => {\n          if (reason !== DISCONNECT_REASON.BY_APPLICATION) {\n            if (!desc) {\n              desc = DISCONNECT_REASON_BY_VALUE[reason];\n              if (desc === undefined) desc = `Unexpected disconnection reason: ${reason}`;\n            }\n\n            const err = new Error(desc);\n            err.code = reason;\n            this.emit('error', err);\n          }\n\n          sock.end();\n        },\n        SERVICE_ACCEPT: (p, name) => {\n          if (name === 'ssh-userauth') tryNextAuth();\n        },\n        USERAUTH_BANNER: (p, msg) => {\n          this.emit('banner', msg);\n        },\n        USERAUTH_SUCCESS: p => {\n          // Start keepalive mechanism\n          resetKA();\n          clearTimeout(this._readyTimeout);\n          this.emit('ready');\n        },\n        USERAUTH_FAILURE: (p, authMethods, partialSuccess) => {\n          if (curAuth.type === 'agent') {\n            const pos = curAuth.agentCtx.pos();\n            debug && debug(`Client: Agent key #${pos + 1} failed`);\n            return tryNextAgentKey();\n          }\n\n          debug && debug(`Client: ${curAuth.type} auth failed`);\n          curPartial = partialSuccess;\n          curAuthsLeft = authMethods;\n          tryNextAuth();\n        },\n        USERAUTH_PASSWD_CHANGEREQ: (p, prompt) => {\n          if (curAuth.type === 'password') {\n            // TODO: support a `changePrompt()` on `curAuth` that defaults to\n            // emitting 'change password' as before\n            this.emit('change password', prompt, newPassword => {\n              proto.authPassword(this.config.username, this.config.password, newPassword);\n            });\n          }\n        },\n        USERAUTH_PK_OK: p => {\n          if (curAuth.type === 'agent') {\n            const key = curAuth.agentCtx.currentKey();\n            proto.authPK(curAuth.username, key, (buf, cb) => {\n              curAuth.agentCtx.sign(key, buf, {}, (err, signed) => {\n                if (err) {\n                  err.level = 'agent';\n                  this.emit('error', err);\n                } else {\n                  return cb(signed);\n                }\n\n                tryNextAgentKey();\n              });\n            });\n          } else if (curAuth.type === 'publickey') {\n            proto.authPK(curAuth.username, curAuth.key, (buf, cb) => {\n              const signature = curAuth.key.sign(buf);\n\n              if (signature instanceof Error) {\n                signature.message = `Error signing data with key: ${signature.message}`;\n                signature.level = 'client-authentication';\n                this.emit('error', signature);\n                return tryNextAuth();\n              }\n\n              cb(signature);\n            });\n          }\n        },\n        USERAUTH_INFO_REQUEST: (p, name, instructions, prompts) => {\n          if (curAuth.type === 'keyboard-interactive') {\n            const nprompts = Array.isArray(prompts) ? prompts.length : 0;\n\n            if (nprompts === 0) {\n              debug && debug('Client: Sending automatic USERAUTH_INFO_RESPONSE');\n              proto.authInfoRes();\n              return;\n            } // We sent a keyboard-interactive user authentication request and\n            // now the server is sending us the prompts we need to present to\n            // the user\n\n\n            curAuth.prompt(name, instructions, '', prompts, answers => {\n              proto.authInfoRes(answers);\n            });\n          }\n        },\n        REQUEST_SUCCESS: (p, data) => {\n          if (callbacks.length) callbacks.shift()(false, data);\n        },\n        REQUEST_FAILURE: p => {\n          if (callbacks.length) callbacks.shift()(true);\n        },\n        GLOBAL_REQUEST: (p, name, wantReply, data) => {\n          switch (name) {\n            case 'hostkeys-00@openssh.com':\n              // Automatically verify keys before passing to end user\n              hostKeysProve(this, data, (err, keys) => {\n                if (err) return;\n                this.emit('hostkeys', keys);\n              });\n              if (wantReply) proto.requestSuccess();\n              break;\n\n            default:\n              // Auto-reject all other global requests, this can be especially\n              // useful if the server is sending us dummy keepalive global\n              // requests\n              if (wantReply) proto.requestFailure();\n          }\n        },\n        CHANNEL_OPEN: (p, info) => {\n          // Handle incoming requests from server, typically a forwarded TCP or\n          // X11 connection\n          onCHANNEL_OPEN(this, info);\n        },\n        CHANNEL_OPEN_CONFIRMATION: (p, info) => {\n          const channel = this._chanMgr.get(info.recipient);\n\n          if (typeof channel !== 'function') return;\n          const isSFTP = channel.type === 'sftp';\n          const type = isSFTP ? 'session' : channel.type;\n          const chanInfo = {\n            type,\n            incoming: {\n              id: info.recipient,\n              window: MAX_WINDOW,\n              packetSize: PACKET_SIZE,\n              state: 'open'\n            },\n            outgoing: {\n              id: info.sender,\n              window: info.window,\n              packetSize: info.packetSize,\n              state: 'open'\n            }\n          };\n          const instance = isSFTP ? new SFTP(this, chanInfo, {\n            debug\n          }) : new Channel(this, chanInfo);\n\n          this._chanMgr.update(info.recipient, instance);\n\n          channel(undefined, instance);\n        },\n        CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {\n          const channel = this._chanMgr.get(recipient);\n\n          if (typeof channel !== 'function') return;\n          const info = {\n            reason,\n            description\n          };\n          onChannelOpenFailure(this, recipient, info, channel);\n        },\n        CHANNEL_DATA: (p, recipient, data) => {\n          const channel = this._chanMgr.get(recipient);\n\n          if (typeof channel !== 'object' || channel === null) return; // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n\n          if (channel.incoming.window === 0) return;\n          channel.incoming.window -= data.length;\n\n          if (channel.push(data) === false) {\n            channel._waitChanDrain = true;\n            return;\n          }\n\n          if (channel.incoming.window <= WINDOW_THRESHOLD) windowAdjust(channel);\n        },\n        CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {\n          if (type !== STDERR) return;\n\n          const channel = this._chanMgr.get(recipient);\n\n          if (typeof channel !== 'object' || channel === null) return; // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n\n          if (channel.incoming.window === 0) return;\n          channel.incoming.window -= data.length;\n\n          if (!channel.stderr.push(data)) {\n            channel._waitChanDrain = true;\n            return;\n          }\n\n          if (channel.incoming.window <= WINDOW_THRESHOLD) windowAdjust(channel);\n        },\n        CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {\n          const channel = this._chanMgr.get(recipient);\n\n          if (typeof channel !== 'object' || channel === null) return; // The other side is allowing us to send `amount` more bytes of data\n\n          channel.outgoing.window += amount;\n\n          if (channel._waitWindow) {\n            channel._waitWindow = false;\n\n            if (channel._chunk) {\n              channel._write(channel._chunk, null, channel._chunkcb);\n            } else if (channel._chunkcb) {\n              channel._chunkcb();\n            } else if (channel._chunkErr) {\n              channel.stderr._write(channel._chunkErr, null, channel._chunkcbErr);\n            } else if (channel._chunkcbErr) {\n              channel._chunkcbErr();\n            }\n          }\n        },\n        CHANNEL_SUCCESS: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n\n          if (typeof channel !== 'object' || channel === null) return;\n\n          this._resetKA();\n\n          if (channel._callbacks.length) channel._callbacks.shift()(false);\n        },\n        CHANNEL_FAILURE: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n\n          if (typeof channel !== 'object' || channel === null) return;\n\n          this._resetKA();\n\n          if (channel._callbacks.length) channel._callbacks.shift()(true);\n        },\n        CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {\n          const channel = this._chanMgr.get(recipient);\n\n          if (typeof channel !== 'object' || channel === null) return;\n          const exit = channel._exit;\n          if (exit.code !== undefined) return;\n\n          switch (type) {\n            case 'exit-status':\n              channel.emit('exit', exit.code = data);\n              return;\n\n            case 'exit-signal':\n              channel.emit('exit', exit.code = null, exit.signal = `SIG${data.signal}`, exit.dump = data.coreDumped, exit.desc = data.errorMessage);\n              return;\n          } // Keepalive request? OpenSSH will send one as a channel request if\n          // there is a channel open\n\n\n          if (wantReply) p.channelFailure(channel.outgoing.id);\n        },\n        CHANNEL_EOF: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n\n          if (typeof channel !== 'object' || channel === null) return;\n          if (channel.incoming.state !== 'open') return;\n          channel.incoming.state = 'eof';\n          if (channel.readable) channel.push(null);\n          if (channel.stderr.readable) channel.stderr.push(null);\n        },\n        CHANNEL_CLOSE: (p, recipient) => {\n          onCHANNEL_CLOSE(this, recipient, this._chanMgr.get(recipient));\n        }\n      }\n    });\n    sock.pause(); // TODO: check keepalive implementation\n    // Keepalive-related\n\n    const kainterval = this.config.keepaliveInterval;\n    const kacountmax = this.config.keepaliveCountMax;\n    let kacount = 0;\n    let katimer;\n\n    const sendKA = () => {\n      if (++kacount > kacountmax) {\n        clearInterval(katimer);\n\n        if (sock.readable) {\n          const err = new Error('Keepalive timeout');\n          err.level = 'client-timeout';\n          this.emit('error', err);\n          sock.destroy();\n        }\n\n        return;\n      }\n\n      if (isWritable(sock)) {\n        // Append dummy callback to keep correct callback order\n        callbacks.push(resetKA);\n        proto.ping();\n      } else {\n        clearInterval(katimer);\n      }\n    };\n\n    function resetKA() {\n      if (kainterval > 0) {\n        kacount = 0;\n        clearInterval(katimer);\n        if (isWritable(sock)) katimer = setInterval(sendKA, kainterval);\n      }\n    }\n\n    this._resetKA = resetKA;\n\n    const onDone = (() => {\n      let called = false;\n      return () => {\n        if (called) return;\n        called = true;\n\n        if (wasConnected && !sawHeader) {\n          const err = makeError('Connection lost before handshake', 'protocol', true);\n          this.emit('error', err);\n        }\n      };\n    })();\n\n    const onConnect = (() => {\n      let called = false;\n      return () => {\n        if (called) return;\n        called = true;\n        wasConnected = true;\n        debug && debug('Socket connected');\n        this.emit('connect');\n        cryptoInit.then(() => {\n          proto.start();\n          sock.on('data', data => {\n            try {\n              proto.parse(data, 0, data.length);\n            } catch (ex) {\n              this.emit('error', ex);\n\n              try {\n                if (isWritable(sock)) sock.end();\n              } catch {}\n            }\n          }); // Drain stderr if we are connection hopping using an exec stream\n\n          if (sock.stderr && typeof sock.stderr.resume === 'function') sock.stderr.resume();\n          sock.resume();\n        }).catch(err => {\n          this.emit('error', err);\n\n          try {\n            if (isWritable(sock)) sock.end();\n          } catch {}\n        });\n      };\n    })();\n\n    let wasConnected = false;\n    sock.on('connect', onConnect).on('timeout', () => {\n      this.emit('timeout');\n    }).on('error', err => {\n      debug && debug(`Socket error: ${err.message}`);\n      clearTimeout(this._readyTimeout);\n      err.level = 'client-socket';\n      this.emit('error', err);\n    }).on('end', () => {\n      debug && debug('Socket ended');\n      onDone();\n      proto.cleanup();\n      clearTimeout(this._readyTimeout);\n      clearInterval(katimer);\n      this.emit('end');\n    }).on('close', () => {\n      debug && debug('Socket closed');\n      onDone();\n      proto.cleanup();\n      clearTimeout(this._readyTimeout);\n      clearInterval(katimer);\n      this.emit('close'); // Notify outstanding channel requests of disconnection ...\n\n      const callbacks_ = callbacks;\n      callbacks = this._callbacks = [];\n      const err = new Error('No response from server');\n\n      for (let i = 0; i < callbacks_.length; ++i) callbacks_[i](err); // Simulate error for any channels waiting to be opened\n\n\n      this._chanMgr.cleanup(err);\n    }); // Begin authentication handling ===========================================\n\n    let curAuth;\n    let curPartial = null;\n    let curAuthsLeft = null;\n    const authsAllowed = ['none'];\n    if (this.config.password !== undefined) authsAllowed.push('password');\n    if (privateKey !== undefined) authsAllowed.push('publickey');\n    if (this._agent !== undefined) authsAllowed.push('agent');\n    if (this.config.tryKeyboard) authsAllowed.push('keyboard-interactive');\n\n    if (privateKey !== undefined && this.config.localHostname !== undefined && this.config.localUsername !== undefined) {\n      authsAllowed.push('hostbased');\n    }\n\n    if (Array.isArray(authHandler)) authHandler = makeSimpleAuthHandler(authHandler);else if (typeof authHandler !== 'function') authHandler = makeSimpleAuthHandler(authsAllowed);\n    let hasSentAuth = false;\n\n    const doNextAuth = nextAuth => {\n      if (hasSentAuth) return;\n      hasSentAuth = true;\n\n      if (nextAuth === false) {\n        const err = new Error('All configured authentication methods failed');\n        err.level = 'client-authentication';\n        this.emit('error', err);\n        this.end();\n        return;\n      }\n\n      if (typeof nextAuth === 'string') {\n        // Remain backwards compatible with original `authHandler()` usage,\n        // which only supported passing names of next method to try using data\n        // from the `connect()` config object\n        const type = nextAuth;\n        if (authsAllowed.indexOf(type) === -1) return skipAuth(`Authentication method not allowed: ${type}`);\n        const username = this.config.username;\n\n        switch (type) {\n          case 'password':\n            nextAuth = {\n              type,\n              username,\n              password: this.config.password\n            };\n            break;\n\n          case 'publickey':\n            nextAuth = {\n              type,\n              username,\n              key: privateKey\n            };\n            break;\n\n          case 'hostbased':\n            nextAuth = {\n              type,\n              username,\n              key: privateKey,\n              localHostname: this.config.localHostname,\n              localUsername: this.config.localUsername\n            };\n            break;\n\n          case 'agent':\n            nextAuth = {\n              type,\n              username,\n              agentCtx: new AgentContext(this._agent)\n            };\n            break;\n\n          case 'keyboard-interactive':\n            nextAuth = {\n              type,\n              username,\n              prompt: function () {\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                }\n\n                return _this.emit('keyboard-interactive', ...args);\n              }\n            };\n            break;\n\n          case 'none':\n            nextAuth = {\n              type,\n              username\n            };\n            break;\n\n          default:\n            return skipAuth(`Skipping unsupported authentication method: ${nextAuth}`);\n        }\n      } else if (typeof nextAuth !== 'object' || nextAuth === null) {\n        return skipAuth(`Skipping invalid authentication attempt: ${nextAuth}`);\n      } else {\n        const username = nextAuth.username;\n\n        if (typeof username !== 'string') {\n          return skipAuth(`Skipping invalid authentication attempt: ${nextAuth}`);\n        }\n\n        const type = nextAuth.type;\n\n        switch (type) {\n          case 'password':\n            {\n              const {\n                password\n              } = nextAuth;\n              if (typeof password !== 'string' && !Buffer.isBuffer(password)) return skipAuth('Skipping invalid password auth attempt');\n              nextAuth = {\n                type,\n                username,\n                password\n              };\n              break;\n            }\n\n          case 'publickey':\n            {\n              const key = parseKey(nextAuth.key, nextAuth.passphrase);\n              if (key instanceof Error) return skipAuth('Skipping invalid key auth attempt');\n              if (!key.isPrivateKey()) return skipAuth('Skipping non-private key');\n              nextAuth = {\n                type,\n                username,\n                key\n              };\n              break;\n            }\n\n          case 'hostbased':\n            {\n              const {\n                localHostname,\n                localUsername\n              } = nextAuth;\n              const key = parseKey(nextAuth.key, nextAuth.passphrase);\n\n              if (key instanceof Error || typeof localHostname !== 'string' || typeof localUsername !== 'string') {\n                return skipAuth('Skipping invalid hostbased auth attempt');\n              }\n\n              if (!key.isPrivateKey()) return skipAuth('Skipping non-private key');\n              nextAuth = {\n                type,\n                username,\n                key,\n                localHostname,\n                localUsername\n              };\n              break;\n            }\n\n          case 'agent':\n            {\n              let agent = nextAuth.agent;\n\n              if (typeof agent === 'string' && agent.length) {\n                agent = createAgent(agent);\n              } else if (!isAgent(agent)) {\n                return skipAuth(`Skipping invalid agent: ${nextAuth.agent}`);\n              }\n\n              nextAuth = {\n                type,\n                username,\n                agentCtx: new AgentContext(agent)\n              };\n              break;\n            }\n\n          case 'keyboard-interactive':\n            {\n              const {\n                prompt\n              } = nextAuth;\n\n              if (typeof prompt !== 'function') {\n                return skipAuth('Skipping invalid keyboard-interactive auth attempt');\n              }\n\n              nextAuth = {\n                type,\n                username,\n                prompt\n              };\n              break;\n            }\n\n          case 'none':\n            nextAuth = {\n              type,\n              username\n            };\n            break;\n\n          default:\n            return skipAuth(`Skipping unsupported authentication method: ${nextAuth}`);\n        }\n      }\n\n      curAuth = nextAuth; // Begin authentication method's process\n\n      try {\n        const username = curAuth.username;\n\n        switch (curAuth.type) {\n          case 'password':\n            proto.authPassword(username, curAuth.password);\n            break;\n\n          case 'publickey':\n            proto.authPK(username, curAuth.key);\n            break;\n\n          case 'hostbased':\n            proto.authHostbased(username, curAuth.key, curAuth.localHostname, curAuth.localUsername, (buf, cb) => {\n              const signature = curAuth.key.sign(buf);\n\n              if (signature instanceof Error) {\n                signature.message = `Error while signing with key: ${signature.message}`;\n                signature.level = 'client-authentication';\n                this.emit('error', signature);\n                return tryNextAuth();\n              }\n\n              cb(signature);\n            });\n            break;\n\n          case 'agent':\n            curAuth.agentCtx.init(err => {\n              if (err) {\n                err.level = 'agent';\n                this.emit('error', err);\n                return tryNextAuth();\n              }\n\n              tryNextAgentKey();\n            });\n            break;\n\n          case 'keyboard-interactive':\n            proto.authKeyboard(username);\n            break;\n\n          case 'none':\n            proto.authNone(username);\n            break;\n        }\n      } finally {\n        hasSentAuth = false;\n      }\n    };\n\n    function skipAuth(msg) {\n      debug && debug(msg);\n      process.nextTick(tryNextAuth);\n    }\n\n    function tryNextAuth() {\n      hasSentAuth = false;\n      const auth = authHandler(curAuthsLeft, curPartial, doNextAuth);\n      if (hasSentAuth || auth === undefined) return;\n      doNextAuth(auth);\n    }\n\n    const tryNextAgentKey = () => {\n      if (curAuth.type === 'agent') {\n        const key = curAuth.agentCtx.nextKey();\n\n        if (key === false) {\n          debug && debug('Agent: No more keys left to try');\n          debug && debug('Client: agent auth failed');\n          tryNextAuth();\n        } else {\n          const pos = curAuth.agentCtx.pos();\n          debug && debug(`Agent: Trying key #${pos + 1}`);\n          proto.authPK(curAuth.username, key);\n        }\n      }\n    };\n\n    const startTimeout = () => {\n      if (this.config.readyTimeout > 0) {\n        this._readyTimeout = setTimeout(() => {\n          const err = new Error('Timed out while waiting for handshake');\n          err.level = 'client-timeout';\n          this.emit('error', err);\n          sock.destroy();\n        }, this.config.readyTimeout);\n      }\n    };\n\n    if (!cfg.sock) {\n      let host = this.config.host;\n      const forceIPv4 = this.config.forceIPv4;\n      const forceIPv6 = this.config.forceIPv6;\n      debug && debug(`Client: Trying ${host} on port ${this.config.port} ...`);\n\n      const doConnect = () => {\n        startTimeout();\n        sock.connect({\n          host,\n          port: this.config.port,\n          localAddress: this.config.localAddress,\n          localPort: this.config.localPort\n        });\n        sock.setNoDelay(true);\n        sock.setMaxListeners(0);\n        sock.setTimeout(typeof cfg.timeout === 'number' ? cfg.timeout : 0);\n      };\n\n      if (!forceIPv4 && !forceIPv6 || forceIPv4 && forceIPv6) {\n        doConnect();\n      } else {\n        dnsLookup(host, forceIPv4 ? 4 : 6, (err, address, family) => {\n          if (err) {\n            const type = forceIPv4 ? 'IPv4' : 'IPv6';\n            const error = new Error(`Error while looking up ${type} address for '${host}': ${err}`);\n            clearTimeout(this._readyTimeout);\n            error.level = 'client-dns';\n            this.emit('error', error);\n            this.emit('close');\n            return;\n          }\n\n          host = address;\n          doConnect();\n        });\n      }\n    } else {\n      // Custom socket passed in\n      startTimeout();\n\n      if (typeof sock.connecting === 'boolean') {\n        // net.Socket\n        if (!sock.connecting) {\n          // Already connected\n          onConnect();\n        }\n      } else {\n        // Assume socket/stream is already \"connected\"\n        onConnect();\n      }\n    }\n\n    return this;\n  }\n\n  end() {\n    if (this._sock && isWritable(this._sock)) {\n      this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n\n      this._sock.end();\n    }\n\n    return this;\n  }\n\n  destroy() {\n    this._sock && isWritable(this._sock) && this._sock.destroy();\n    return this;\n  }\n\n  exec(cmd, opts, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n\n    if (typeof opts === 'function') {\n      cb = opts;\n      opts = {};\n    }\n\n    const extraOpts = {\n      allowHalfOpen: opts.allowHalfOpen !== false\n    };\n    openChannel(this, 'session', extraOpts, (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      const todo = [];\n\n      function reqCb(err) {\n        if (err) {\n          chan.close();\n          cb(err);\n          return;\n        }\n\n        if (todo.length) todo.shift()();\n      }\n\n      if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== undefined) {\n        todo.push(() => reqAgentFwd(chan, reqCb));\n      }\n\n      if (typeof opts === 'object' && opts !== null) {\n        if (typeof opts.env === 'object' && opts.env !== null) reqEnv(chan, opts.env);\n\n        if (typeof opts.pty === 'object' && opts.pty !== null || opts.pty === true) {\n          todo.push(() => reqPty(chan, opts.pty, reqCb));\n        }\n\n        if (typeof opts.x11 === 'object' && opts.x11 !== null || opts.x11 === 'number' || opts.x11 === true) {\n          todo.push(() => reqX11(chan, opts.x11, reqCb));\n        }\n      }\n\n      todo.push(() => reqExec(chan, cmd, opts, cb));\n      todo.shift()();\n    });\n    return this;\n  }\n\n  shell(wndopts, opts, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n\n    if (typeof wndopts === 'function') {\n      cb = wndopts;\n      wndopts = opts = undefined;\n    } else if (typeof opts === 'function') {\n      cb = opts;\n      opts = undefined;\n    }\n\n    if (wndopts && (wndopts.x11 !== undefined || wndopts.env !== undefined)) {\n      opts = wndopts;\n      wndopts = undefined;\n    }\n\n    openChannel(this, 'session', (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      const todo = [];\n\n      function reqCb(err) {\n        if (err) {\n          chan.close();\n          cb(err);\n          return;\n        }\n\n        if (todo.length) todo.shift()();\n      }\n\n      if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== undefined) {\n        todo.push(() => reqAgentFwd(chan, reqCb));\n      }\n\n      if (wndopts !== false) todo.push(() => reqPty(chan, wndopts, reqCb));\n\n      if (typeof opts === 'object' && opts !== null) {\n        if (typeof opts.env === 'object' && opts.env !== null) reqEnv(chan, opts.env);\n\n        if (typeof opts.x11 === 'object' && opts.x11 !== null || opts.x11 === 'number' || opts.x11 === true) {\n          todo.push(() => reqX11(chan, opts.x11, reqCb));\n        }\n      }\n\n      todo.push(() => reqShell(chan, cb));\n      todo.shift()();\n    });\n    return this;\n  }\n\n  subsys(name, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    openChannel(this, 'session', (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      reqSubsystem(chan, name, (err, stream) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n\n        cb(undefined, stream);\n      });\n    });\n    return this;\n  }\n\n  forwardIn(bindAddr, bindPort, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected'); // Send a request for the server to start forwarding TCP connections to us\n    // on a particular address and port\n\n    const wantReply = typeof cb === 'function';\n\n    if (wantReply) {\n      this._callbacks.push((had_err, data) => {\n        if (had_err) {\n          cb(had_err !== true ? had_err : new Error(`Unable to bind to ${bindAddr}:${bindPort}`));\n          return;\n        }\n\n        let realPort = bindPort;\n\n        if (bindPort === 0 && data && data.length >= 4) {\n          realPort = readUInt32BE(data, 0);\n          if (!(this._protocol._compatFlags & COMPAT.DYN_RPORT_BUG)) bindPort = realPort;\n        }\n\n        this._forwarding[`${bindAddr}:${bindPort}`] = realPort;\n        cb(undefined, realPort);\n      });\n    }\n\n    this._protocol.tcpipForward(bindAddr, bindPort, wantReply);\n\n    return this;\n  }\n\n  unforwardIn(bindAddr, bindPort, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected'); // Send a request to stop forwarding us new connections for a particular\n    // address and port\n\n    const wantReply = typeof cb === 'function';\n\n    if (wantReply) {\n      this._callbacks.push(had_err => {\n        if (had_err) {\n          cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${bindAddr}:${bindPort}`));\n          return;\n        }\n\n        delete this._forwarding[`${bindAddr}:${bindPort}`];\n        cb();\n      });\n    }\n\n    this._protocol.cancelTcpipForward(bindAddr, bindPort, wantReply);\n\n    return this;\n  }\n\n  forwardOut(srcIP, srcPort, dstIP, dstPort, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected'); // Send a request to forward a TCP connection to the server\n\n    const cfg = {\n      srcIP: srcIP,\n      srcPort: srcPort,\n      dstIP: dstIP,\n      dstPort: dstPort\n    };\n    if (typeof cb !== 'function') cb = noop;\n    openChannel(this, 'direct-tcpip', cfg, cb);\n    return this;\n  }\n\n  openssh_noMoreSessions(cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    const wantReply = typeof cb === 'function';\n\n    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {\n      if (wantReply) {\n        this._callbacks.push(had_err => {\n          if (had_err) {\n            cb(had_err !== true ? had_err : new Error('Unable to disable future sessions'));\n            return;\n          }\n\n          cb();\n        });\n      }\n\n      this._protocol.openssh_noMoreSessions(wantReply);\n\n      return this;\n    }\n\n    if (!wantReply) return this;\n    process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    return this;\n  }\n\n  openssh_forwardInStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    const wantReply = typeof cb === 'function';\n\n    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {\n      if (wantReply) {\n        this._callbacks.push(had_err => {\n          if (had_err) {\n            cb(had_err !== true ? had_err : new Error(`Unable to bind to ${socketPath}`));\n            return;\n          }\n\n          this._forwardingUnix[socketPath] = true;\n          cb();\n        });\n      }\n\n      this._protocol.openssh_streamLocalForward(socketPath, wantReply);\n\n      return this;\n    }\n\n    if (!wantReply) return this;\n    process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    return this;\n  }\n\n  openssh_unforwardInStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    const wantReply = typeof cb === 'function';\n\n    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {\n      if (wantReply) {\n        this._callbacks.push(had_err => {\n          if (had_err) {\n            cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${socketPath}`));\n            return;\n          }\n\n          delete this._forwardingUnix[socketPath];\n          cb();\n        });\n      }\n\n      this._protocol.openssh_cancelStreamLocalForward(socketPath, wantReply);\n\n      return this;\n    }\n\n    if (!wantReply) return this;\n    process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    return this;\n  }\n\n  openssh_forwardOutStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    if (typeof cb !== 'function') cb = noop;\n\n    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {\n      openChannel(this, 'direct-streamlocal@openssh.com', {\n        socketPath\n      }, cb);\n      return this;\n    }\n\n    process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    return this;\n  }\n\n  sftp(cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    openChannel(this, 'sftp', (err, sftp) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      reqSubsystem(sftp, 'sftp', (err, sftp_) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n\n        function removeListeners() {\n          sftp.removeListener('ready', onReady);\n          sftp.removeListener('error', onError);\n          sftp.removeListener('exit', onExit);\n          sftp.removeListener('close', onExit);\n        }\n\n        function onReady() {\n          // TODO: do not remove exit/close in case remote end closes the\n          // channel abruptly and we need to notify outstanding callbacks\n          removeListeners();\n          cb(undefined, sftp);\n        }\n\n        function onError(err) {\n          removeListeners();\n          cb(err);\n        }\n\n        function onExit(code, signal) {\n          removeListeners();\n          let msg;\n          if (typeof code === 'number') msg = `Received exit code ${code} while establishing SFTP session`;else if (signal !== undefined) msg = `Received signal ${signal} while establishing SFTP session`;else msg = 'Received unexpected SFTP session termination';\n          const err = new Error(msg);\n          err.code = code;\n          err.signal = signal;\n          cb(err);\n        }\n\n        sftp.on('ready', onReady).on('error', onError).on('exit', onExit).on('close', onExit);\n\n        sftp._init();\n      });\n    });\n    return this;\n  }\n\n}\n\nfunction openChannel(self, type, opts, cb) {\n  // Ask the server to open a channel for some purpose\n  // (e.g. session (sftp, exec, shell), or forwarding a TCP connection\n  const initWindow = MAX_WINDOW;\n  const maxPacket = PACKET_SIZE;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  const wrapper = (err, stream) => {\n    cb(err, stream);\n  };\n\n  wrapper.type = type;\n\n  const localChan = self._chanMgr.add(wrapper);\n\n  if (localChan === -1) {\n    cb(new Error('No free channels available'));\n    return;\n  }\n\n  switch (type) {\n    case 'session':\n    case 'sftp':\n      self._protocol.session(localChan, initWindow, maxPacket);\n\n      break;\n\n    case 'direct-tcpip':\n      self._protocol.directTcpip(localChan, initWindow, maxPacket, opts);\n\n      break;\n\n    case 'direct-streamlocal@openssh.com':\n      self._protocol.openssh_directStreamLocal(localChan, initWindow, maxPacket, opts);\n\n      break;\n\n    default:\n      throw new Error(`Unsupported channel type: ${type}`);\n  }\n}\n\nfunction reqX11(chan, screen, cb) {\n  // Asks server to start sending us X11 connections\n  const cfg = {\n    single: false,\n    protocol: 'MIT-MAGIC-COOKIE-1',\n    cookie: undefined,\n    screen: 0\n  };\n\n  if (typeof screen === 'function') {\n    cb = screen;\n  } else if (typeof screen === 'object' && screen !== null) {\n    if (typeof screen.single === 'boolean') cfg.single = screen.single;\n    if (typeof screen.screen === 'number') cfg.screen = screen.screen;\n    if (typeof screen.protocol === 'string') cfg.protocol = screen.protocol;\n    if (typeof screen.cookie === 'string') cfg.cookie = screen.cookie;else if (Buffer.isBuffer(screen.cookie)) cfg.cookie = screen.cookie.hexSlice(0, screen.cookie.length);\n  }\n\n  if (cfg.cookie === undefined) cfg.cookie = randomCookie();\n  const wantReply = typeof cb === 'function';\n\n  if (chan.outgoing.state !== 'open') {\n    if (wantReply) cb(new Error('Channel is not open'));\n    return;\n  }\n\n  if (wantReply) {\n    chan._callbacks.push(had_err => {\n      if (had_err) {\n        cb(had_err !== true ? had_err : new Error('Unable to request X11'));\n        return;\n      }\n\n      chan._hasX11 = true;\n      ++chan._client._acceptX11;\n      chan.once('close', () => {\n        if (chan._client._acceptX11) --chan._client._acceptX11;\n      });\n      cb();\n    });\n  }\n\n  chan._client._protocol.x11Forward(chan.outgoing.id, cfg, wantReply);\n}\n\nfunction reqPty(chan, opts, cb) {\n  let rows = 24;\n  let cols = 80;\n  let width = 640;\n  let height = 480;\n  let term = 'vt100';\n  let modes = null;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n  } else if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.rows === 'number') rows = opts.rows;\n    if (typeof opts.cols === 'number') cols = opts.cols;\n    if (typeof opts.width === 'number') width = opts.width;\n    if (typeof opts.height === 'number') height = opts.height;\n    if (typeof opts.term === 'string') term = opts.term;\n    if (typeof opts.modes === 'object') modes = opts.modes;\n  }\n\n  const wantReply = typeof cb === 'function';\n\n  if (chan.outgoing.state !== 'open') {\n    if (wantReply) cb(new Error('Channel is not open'));\n    return;\n  }\n\n  if (wantReply) {\n    chan._callbacks.push(had_err => {\n      if (had_err) {\n        cb(had_err !== true ? had_err : new Error('Unable to request a pseudo-terminal'));\n        return;\n      }\n\n      cb();\n    });\n  }\n\n  chan._client._protocol.pty(chan.outgoing.id, rows, cols, height, width, term, modes, wantReply);\n}\n\nfunction reqAgentFwd(chan, cb) {\n  const wantReply = typeof cb === 'function';\n\n  if (chan.outgoing.state !== 'open') {\n    wantReply && cb(new Error('Channel is not open'));\n    return;\n  }\n\n  if (chan._client._agentFwdEnabled) {\n    wantReply && cb(false);\n    return;\n  }\n\n  chan._client._agentFwdEnabled = true;\n\n  chan._callbacks.push(had_err => {\n    if (had_err) {\n      chan._client._agentFwdEnabled = false;\n\n      if (wantReply) {\n        cb(had_err !== true ? had_err : new Error('Unable to request agent forwarding'));\n      }\n\n      return;\n    }\n\n    if (wantReply) cb();\n  });\n\n  chan._client._protocol.openssh_agentForward(chan.outgoing.id, true);\n}\n\nfunction reqShell(chan, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n\n  chan._callbacks.push(had_err => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error('Unable to open shell'));\n      return;\n    }\n\n    chan.subtype = 'shell';\n    cb(undefined, chan);\n  });\n\n  chan._client._protocol.shell(chan.outgoing.id, true);\n}\n\nfunction reqExec(chan, cmd, opts, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n\n  chan._callbacks.push(had_err => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error('Unable to exec'));\n      return;\n    }\n\n    chan.subtype = 'exec';\n    chan.allowHalfOpen = opts.allowHalfOpen !== false;\n    cb(undefined, chan);\n  });\n\n  chan._client._protocol.exec(chan.outgoing.id, cmd, true);\n}\n\nfunction reqEnv(chan, env) {\n  if (chan.outgoing.state !== 'open') return;\n  const keys = Object.keys(env || {});\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    const val = env[key];\n\n    chan._client._protocol.env(chan.outgoing.id, key, val, false);\n  }\n}\n\nfunction reqSubsystem(chan, name, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n\n  chan._callbacks.push(had_err => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error(`Unable to start subsystem: ${name}`));\n      return;\n    }\n\n    chan.subtype = 'subsystem';\n    cb(undefined, chan);\n  });\n\n  chan._client._protocol.subsystem(chan.outgoing.id, name, true);\n} // TODO: inline implementation into single call site\n\n\nfunction onCHANNEL_OPEN(self, info) {\n  // The server is trying to open a channel with us, this is usually when\n  // we asked the server to forward us connections on some port and now they\n  // are asking us to accept/deny an incoming connection on their side\n  let localChan = -1;\n  let reason;\n\n  const accept = () => {\n    const chanInfo = {\n      type: info.type,\n      incoming: {\n        id: localChan,\n        window: MAX_WINDOW,\n        packetSize: PACKET_SIZE,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n    const stream = new Channel(self, chanInfo);\n\n    self._chanMgr.update(localChan, stream);\n\n    self._protocol.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);\n\n    return stream;\n  };\n\n  const reject = () => {\n    if (reason === undefined) {\n      if (localChan === -1) reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;else reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;\n    }\n\n    if (localChan !== -1) self._chanMgr.remove(localChan);\n\n    self._protocol.channelOpenFail(info.sender, reason, '');\n  };\n\n  const reserveChannel = () => {\n    localChan = self._chanMgr.add();\n\n    if (localChan === -1) {\n      reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n\n      if (self.config.debug) {\n        self.config.debug('Client: Automatic rejection of incoming channel open: ' + 'no channels available');\n      }\n    }\n\n    return localChan !== -1;\n  };\n\n  const data = info.data;\n\n  switch (info.type) {\n    case 'forwarded-tcpip':\n      {\n        const val = self._forwarding[`${data.destIP}:${data.destPort}`];\n\n        if (val !== undefined && reserveChannel()) {\n          if (data.destPort === 0) data.destPort = val;\n          self.emit('tcp connection', data, accept, reject);\n          return;\n        }\n\n        break;\n      }\n\n    case 'forwarded-streamlocal@openssh.com':\n      if (self._forwardingUnix[data.socketPath] !== undefined && reserveChannel()) {\n        self.emit('unix connection', data, accept, reject);\n        return;\n      }\n\n      break;\n\n    case 'auth-agent@openssh.com':\n      if (self._agentFwdEnabled && typeof self._agent.getStream === 'function' && reserveChannel()) {\n        self._agent.getStream((err, stream) => {\n          if (err) return reject();\n          const upstream = accept();\n          upstream.pipe(stream).pipe(upstream);\n        });\n\n        return;\n      }\n\n      break;\n\n    case 'x11':\n      if (self._acceptX11 !== 0 && reserveChannel()) {\n        self.emit('x11', data, accept, reject);\n        return;\n      }\n\n      break;\n\n    default:\n      // Automatically reject any unsupported channel open requests\n      reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;\n\n      if (self.config.debug) {\n        self.config.debug('Client: Automatic rejection of unsupported incoming channel open ' + `type: ${info.type}`);\n      }\n\n  }\n\n  if (reason === undefined) {\n    reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n\n    if (self.config.debug) {\n      self.config.debug('Client: Automatic rejection of unexpected incoming channel open for: ' + info.type);\n    }\n  }\n\n  reject();\n}\n\nconst randomCookie = (() => {\n  const buffer = Buffer.allocUnsafe(16);\n  return () => {\n    randomFillSync(buffer, 0, 16);\n    return buffer.hexSlice(0, 16);\n  };\n})();\n\nfunction makeSimpleAuthHandler(authList) {\n  if (!Array.isArray(authList)) throw new Error('authList must be an array');\n  let a = 0;\n  return (authsLeft, partialSuccess, cb) => {\n    if (a === authList.length) return false;\n    return authList[a++];\n  };\n}\n\nfunction hostKeysProve(client, keys_, cb) {\n  if (!client._sock || !isWritable(client._sock)) return;\n  if (typeof cb !== 'function') cb = noop;\n  if (!Array.isArray(keys_)) throw new TypeError('Invalid keys argument type');\n  const keys = [];\n\n  for (const key of keys_) {\n    const parsed = parseKey(key);\n    if (parsed instanceof Error) throw parsed;\n    keys.push(parsed);\n  }\n\n  if (!client.config.strictVendor || client.config.strictVendor && RE_OPENSSH.test(client._remoteVer)) {\n    client._callbacks.push((had_err, data) => {\n      if (had_err) {\n        cb(had_err !== true ? had_err : new Error('Server failed to prove supplied keys'));\n        return;\n      } // TODO: move all of this parsing/verifying logic out of the client?\n\n\n      const ret = [];\n      let keyIdx = 0;\n      bufferParser.init(data, 0);\n\n      while (bufferParser.avail()) {\n        if (keyIdx === keys.length) break;\n        const key = keys[keyIdx++];\n        const keyPublic = key.getPublicSSH();\n        const sigEntry = bufferParser.readString();\n        sigParser.init(sigEntry, 0);\n        const type = sigParser.readString(true);\n        let value = sigParser.readString();\n        let algo;\n\n        if (type !== key.type) {\n          if (key.type === 'ssh-rsa') {\n            switch (type) {\n              case 'rsa-sha2-256':\n                algo = 'sha256';\n                break;\n\n              case 'rsa-sha2-512':\n                algo = 'sha512';\n                break;\n\n              default:\n                continue;\n            }\n          } else {\n            continue;\n          }\n        }\n\n        const sessionID = client._protocol._kex.sessionID;\n        const verifyData = Buffer.allocUnsafe(4 + 29 + 4 + sessionID.length + 4 + keyPublic.length);\n        let p = 0;\n        writeUInt32BE(verifyData, 29, p);\n        verifyData.utf8Write('hostkeys-prove-00@openssh.com', p += 4, 29);\n        writeUInt32BE(verifyData, sessionID.length, p += 29);\n        bufferCopy(sessionID, verifyData, 0, sessionID.length, p += 4);\n        writeUInt32BE(verifyData, keyPublic.length, p += sessionID.length);\n        bufferCopy(keyPublic, verifyData, 0, keyPublic.length, p += 4);\n        if (!(value = sigSSHToASN1(value, type))) continue;\n        if (key.verify(verifyData, value, algo) === true) ret.push(key);\n      }\n\n      sigParser.clear();\n      bufferParser.clear();\n      cb(null, ret);\n    });\n\n    client._protocol.openssh_hostKeysProve(keys);\n\n    return;\n  }\n\n  process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n}\n\nmodule.exports = Client;","map":{"version":3,"names":["createHash","getHashes","randomFillSync","require","Socket","lookup","dnsLookup","EventEmitter","HASHES","COMPAT","CHANNEL_EXTENDED_DATATYPE","STDERR","CHANNEL_OPEN_FAILURE","DEFAULT_CIPHER","DEFAULT_COMPRESSION","DEFAULT_KEX","DEFAULT_MAC","DEFAULT_SERVER_HOST_KEY","DISCONNECT_REASON","DISCONNECT_REASON_BY_VALUE","SUPPORTED_CIPHER","SUPPORTED_COMPRESSION","SUPPORTED_KEX","SUPPORTED_MAC","SUPPORTED_SERVER_HOST_KEY","init","cryptoInit","Protocol","parseKey","SFTP","bufferCopy","makeBufferParser","makeError","readUInt32BE","sigSSHToASN1","writeUInt32BE","AgentContext","createAgent","isAgent","Channel","MAX_WINDOW","PACKET_SIZE","windowAdjust","WINDOW_THRESHOLD","ChannelManager","generateAlgorithmList","isWritable","onChannelOpenFailure","onCHANNEL_CLOSE","bufferParser","sigParser","RE_OPENSSH","noop","err","Client","constructor","config","host","undefined","port","localAddress","localPort","forceIPv4","forceIPv6","keepaliveCountMax","keepaliveInterval","readyTimeout","ident","username","password","privateKey","tryKeyboard","agent","allowAgentFwd","authHandler","hostHashAlgo","hostHashCb","strictVendor","debug","_agent","_readyTimeout","_chanMgr","_callbacks","_forwarding","_forwardingUnix","_acceptX11","_agentFwdEnabled","_remoteVer","_protocol","_sock","_resetKA","connect","cfg","once","end","hostname","Buffer","isBuffer","algorithms","kex","serverHostKey","cs","cipher","mac","compress","lang","sc","allOfferDefaults","hmac","user","Error","localHostname","localUsername","length","agentForward","Array","isArray","callbacks","passphrase","message","getPrivatePEM","hostVerifier","hashCb","hasher","indexOf","hostHash","key","verify","update","digest","ret","sock","ready","sawHeader","cleanup","DEBUG_HANDLER","p","display","msg","JSON","stringify","proto","offer","onWrite","data","write","onError","level","clearTimeout","_destruct","removeAllListeners","emit","onHeader","header","versions","software","greeting","onHandshakeComplete","negotiated","service","messageHandlers","DEBUG","DISCONNECT","reason","desc","BY_APPLICATION","code","SERVICE_ACCEPT","name","tryNextAuth","USERAUTH_BANNER","USERAUTH_SUCCESS","resetKA","USERAUTH_FAILURE","authMethods","partialSuccess","curAuth","type","pos","agentCtx","tryNextAgentKey","curPartial","curAuthsLeft","USERAUTH_PASSWD_CHANGEREQ","prompt","newPassword","authPassword","USERAUTH_PK_OK","currentKey","authPK","buf","cb","sign","signed","signature","USERAUTH_INFO_REQUEST","instructions","prompts","nprompts","authInfoRes","answers","REQUEST_SUCCESS","shift","REQUEST_FAILURE","GLOBAL_REQUEST","wantReply","hostKeysProve","keys","requestSuccess","requestFailure","CHANNEL_OPEN","info","onCHANNEL_OPEN","CHANNEL_OPEN_CONFIRMATION","channel","get","recipient","isSFTP","chanInfo","incoming","id","window","packetSize","state","outgoing","sender","instance","description","CHANNEL_DATA","push","_waitChanDrain","CHANNEL_EXTENDED_DATA","stderr","CHANNEL_WINDOW_ADJUST","amount","_waitWindow","_chunk","_write","_chunkcb","_chunkErr","_chunkcbErr","CHANNEL_SUCCESS","CHANNEL_FAILURE","CHANNEL_REQUEST","exit","_exit","signal","dump","coreDumped","errorMessage","channelFailure","CHANNEL_EOF","readable","CHANNEL_CLOSE","pause","kainterval","kacountmax","kacount","katimer","sendKA","clearInterval","destroy","ping","setInterval","onDone","called","wasConnected","onConnect","then","start","on","parse","ex","resume","catch","callbacks_","i","authsAllowed","makeSimpleAuthHandler","hasSentAuth","doNextAuth","nextAuth","skipAuth","args","isPrivateKey","authHostbased","authKeyboard","authNone","process","nextTick","auth","nextKey","startTimeout","setTimeout","doConnect","setNoDelay","setMaxListeners","timeout","address","family","error","connecting","disconnect","exec","cmd","opts","extraOpts","allowHalfOpen","openChannel","chan","todo","reqCb","close","reqAgentFwd","env","reqEnv","pty","reqPty","x11","reqX11","reqExec","shell","wndopts","reqShell","subsys","reqSubsystem","stream","forwardIn","bindAddr","bindPort","had_err","realPort","_compatFlags","DYN_RPORT_BUG","tcpipForward","unforwardIn","cancelTcpipForward","forwardOut","srcIP","srcPort","dstIP","dstPort","openssh_noMoreSessions","test","openssh_forwardInStreamLocal","socketPath","openssh_streamLocalForward","openssh_unforwardInStreamLocal","openssh_cancelStreamLocalForward","openssh_forwardOutStreamLocal","sftp","sftp_","removeListeners","removeListener","onReady","onExit","_init","self","initWindow","maxPacket","wrapper","localChan","add","session","directTcpip","openssh_directStreamLocal","screen","single","protocol","cookie","hexSlice","randomCookie","_hasX11","_client","x11Forward","rows","cols","width","height","term","modes","openssh_agentForward","subtype","Object","val","subsystem","accept","channelOpenConfirm","reject","RESOURCE_SHORTAGE","CONNECT_FAILED","remove","channelOpenFail","reserveChannel","destIP","destPort","getStream","upstream","pipe","UNKNOWN_CHANNEL_TYPE","ADMINISTRATIVELY_PROHIBITED","buffer","allocUnsafe","authList","a","authsLeft","client","keys_","TypeError","parsed","keyIdx","avail","keyPublic","getPublicSSH","sigEntry","readString","value","algo","sessionID","_kex","verifyData","utf8Write","clear","openssh_hostKeysProve","module","exports"],"sources":["/home/micqdf/AlpacaPunchTests/maintest/test1/client/node_modules/ssh2/lib/client.js"],"sourcesContent":["// TODO:\n//    * add `.connected` or similar property to allow immediate connection\n//      status checking\n//    * add/improve debug output during user authentication phase\n'use strict';\n\nconst {\n  createHash,\n  getHashes,\n  randomFillSync,\n} = require('crypto');\nconst { Socket } = require('net');\nconst { lookup: dnsLookup } = require('dns');\nconst EventEmitter = require('events');\nconst HASHES = getHashes();\n\nconst {\n  COMPAT,\n  CHANNEL_EXTENDED_DATATYPE: { STDERR },\n  CHANNEL_OPEN_FAILURE,\n  DEFAULT_CIPHER,\n  DEFAULT_COMPRESSION,\n  DEFAULT_KEX,\n  DEFAULT_MAC,\n  DEFAULT_SERVER_HOST_KEY,\n  DISCONNECT_REASON,\n  DISCONNECT_REASON_BY_VALUE,\n  SUPPORTED_CIPHER,\n  SUPPORTED_COMPRESSION,\n  SUPPORTED_KEX,\n  SUPPORTED_MAC,\n  SUPPORTED_SERVER_HOST_KEY,\n} = require('./protocol/constants.js');\nconst { init: cryptoInit } = require('./protocol/crypto.js');\nconst Protocol = require('./protocol/Protocol.js');\nconst { parseKey } = require('./protocol/keyParser.js');\nconst { SFTP } = require('./protocol/SFTP.js');\nconst {\n  bufferCopy,\n  makeBufferParser,\n  makeError,\n  readUInt32BE,\n  sigSSHToASN1,\n  writeUInt32BE,\n} = require('./protocol/utils.js');\n\nconst { AgentContext, createAgent, isAgent } = require('./agent.js');\nconst {\n  Channel,\n  MAX_WINDOW,\n  PACKET_SIZE,\n  windowAdjust,\n  WINDOW_THRESHOLD,\n} = require('./Channel.js');\nconst {\n  ChannelManager,\n  generateAlgorithmList,\n  isWritable,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE,\n} = require('./utils.js');\n\nconst bufferParser = makeBufferParser();\nconst sigParser = makeBufferParser();\nconst RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\\d)|(?:\\d{2,})/;\nconst noop = (err) => {};\n\nclass Client extends EventEmitter {\n  constructor() {\n    super();\n\n    this.config = {\n      host: undefined,\n      port: undefined,\n      localAddress: undefined,\n      localPort: undefined,\n      forceIPv4: undefined,\n      forceIPv6: undefined,\n      keepaliveCountMax: undefined,\n      keepaliveInterval: undefined,\n      readyTimeout: undefined,\n      ident: undefined,\n\n      username: undefined,\n      password: undefined,\n      privateKey: undefined,\n      tryKeyboard: undefined,\n      agent: undefined,\n      allowAgentFwd: undefined,\n      authHandler: undefined,\n\n      hostHashAlgo: undefined,\n      hostHashCb: undefined,\n      strictVendor: undefined,\n      debug: undefined\n    };\n\n    this._agent = undefined;\n    this._readyTimeout = undefined;\n    this._chanMgr = undefined;\n    this._callbacks = undefined;\n    this._forwarding = undefined;\n    this._forwardingUnix = undefined;\n    this._acceptX11 = undefined;\n    this._agentFwdEnabled = undefined;\n    this._remoteVer = undefined;\n\n    this._protocol = undefined;\n    this._sock = undefined;\n    this._resetKA = undefined;\n  }\n\n  connect(cfg) {\n    if (this._sock && isWritable(this._sock)) {\n      this.once('close', () => {\n        this.connect(cfg);\n      });\n      this.end();\n      return this;\n    }\n\n    this.config.host = cfg.hostname || cfg.host || 'localhost';\n    this.config.port = cfg.port || 22;\n    this.config.localAddress = (typeof cfg.localAddress === 'string'\n                                ? cfg.localAddress\n                                : undefined);\n    this.config.localPort = (typeof cfg.localPort === 'string'\n                             || typeof cfg.localPort === 'number'\n                             ? cfg.localPort\n                             : undefined);\n    this.config.forceIPv4 = cfg.forceIPv4 || false;\n    this.config.forceIPv6 = cfg.forceIPv6 || false;\n    this.config.keepaliveCountMax = (typeof cfg.keepaliveCountMax === 'number'\n                                     && cfg.keepaliveCountMax >= 0\n                                     ? cfg.keepaliveCountMax\n                                     : 3);\n    this.config.keepaliveInterval = (typeof cfg.keepaliveInterval === 'number'\n                                     && cfg.keepaliveInterval > 0\n                                     ? cfg.keepaliveInterval\n                                     : 0);\n    this.config.readyTimeout = (typeof cfg.readyTimeout === 'number'\n                                && cfg.readyTimeout >= 0\n                                ? cfg.readyTimeout\n                                : 20000);\n    this.config.ident = (typeof cfg.ident === 'string'\n                         || Buffer.isBuffer(cfg.ident)\n                         ? cfg.ident\n                         : undefined);\n\n    const algorithms = {\n      kex: undefined,\n      serverHostKey: undefined,\n      cs: {\n        cipher: undefined,\n        mac: undefined,\n        compress: undefined,\n        lang: [],\n      },\n      sc: undefined,\n    };\n    let allOfferDefaults = true;\n    if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n      algorithms.kex = generateAlgorithmList(cfg.algorithms.kex,\n                                             DEFAULT_KEX,\n                                             SUPPORTED_KEX);\n      if (algorithms.kex !== DEFAULT_KEX)\n        allOfferDefaults = false;\n\n      algorithms.serverHostKey =\n        generateAlgorithmList(cfg.algorithms.serverHostKey,\n                              DEFAULT_SERVER_HOST_KEY,\n                              SUPPORTED_SERVER_HOST_KEY);\n      if (algorithms.serverHostKey !== DEFAULT_SERVER_HOST_KEY)\n        allOfferDefaults = false;\n\n      algorithms.cs.cipher = generateAlgorithmList(cfg.algorithms.cipher,\n                                                   DEFAULT_CIPHER,\n                                                   SUPPORTED_CIPHER);\n      if (algorithms.cs.cipher !== DEFAULT_CIPHER)\n        allOfferDefaults = false;\n\n      algorithms.cs.mac = generateAlgorithmList(cfg.algorithms.hmac,\n                                                DEFAULT_MAC,\n                                                SUPPORTED_MAC);\n      if (algorithms.cs.mac !== DEFAULT_MAC)\n        allOfferDefaults = false;\n\n      algorithms.cs.compress = generateAlgorithmList(cfg.algorithms.compress,\n                                                     DEFAULT_COMPRESSION,\n                                                     SUPPORTED_COMPRESSION);\n      if (algorithms.cs.compress !== DEFAULT_COMPRESSION)\n        allOfferDefaults = false;\n\n      if (!allOfferDefaults)\n        algorithms.sc = algorithms.cs;\n    }\n\n    if (typeof cfg.username === 'string')\n      this.config.username = cfg.username;\n    else if (typeof cfg.user === 'string')\n      this.config.username = cfg.user;\n    else\n      throw new Error('Invalid username');\n\n    this.config.password = (typeof cfg.password === 'string'\n                            ? cfg.password\n                            : undefined);\n    this.config.privateKey = (typeof cfg.privateKey === 'string'\n                              || Buffer.isBuffer(cfg.privateKey)\n                              ? cfg.privateKey\n                              : undefined);\n    this.config.localHostname = (typeof cfg.localHostname === 'string'\n                                 ? cfg.localHostname\n                                 : undefined);\n    this.config.localUsername = (typeof cfg.localUsername === 'string'\n                                 ? cfg.localUsername\n                                 : undefined);\n    this.config.tryKeyboard = (cfg.tryKeyboard === true);\n    if (typeof cfg.agent === 'string' && cfg.agent.length)\n      this.config.agent = createAgent(cfg.agent);\n    else if (isAgent(cfg.agent))\n      this.config.agent = cfg.agent;\n    else\n      this.config.agent = undefined;\n    this.config.allowAgentFwd = (cfg.agentForward === true\n                                 && this.config.agent !== undefined);\n    let authHandler = this.config.authHandler = (\n      typeof cfg.authHandler === 'function'\n      || Array.isArray(cfg.authHandler)\n      ? cfg.authHandler\n      : undefined\n    );\n\n    this.config.strictVendor = (typeof cfg.strictVendor === 'boolean'\n                                ? cfg.strictVendor\n                                : true);\n\n    const debug = this.config.debug = (typeof cfg.debug === 'function'\n                                       ? cfg.debug\n                                       : undefined);\n\n    if (cfg.agentForward === true && !this.config.allowAgentFwd) {\n      throw new Error(\n        'You must set a valid agent path to allow agent forwarding'\n      );\n    }\n\n    let callbacks = this._callbacks = [];\n    this._chanMgr = new ChannelManager(this);\n    this._forwarding = {};\n    this._forwardingUnix = {};\n    this._acceptX11 = 0;\n    this._agentFwdEnabled = false;\n    this._agent = (this.config.agent ? this.config.agent : undefined);\n    this._remoteVer = undefined;\n    let privateKey;\n\n    if (this.config.privateKey) {\n      privateKey = parseKey(this.config.privateKey, cfg.passphrase);\n      if (privateKey instanceof Error)\n        throw new Error(`Cannot parse privateKey: ${privateKey.message}`);\n      if (Array.isArray(privateKey)) {\n        // OpenSSH's newer format only stores 1 key for now\n        privateKey = privateKey[0];\n      }\n      if (privateKey.getPrivatePEM() === null) {\n        throw new Error(\n          'privateKey value does not contain a (valid) private key'\n        );\n      }\n    }\n\n    let hostVerifier;\n    if (typeof cfg.hostVerifier === 'function') {\n      const hashCb = cfg.hostVerifier;\n      let hasher;\n      if (HASHES.indexOf(cfg.hostHash) !== -1) {\n        // Default to old behavior of hashing on user's behalf\n        hasher = createHash(cfg.hostHash);\n      }\n      hostVerifier = (key, verify) => {\n        if (hasher) {\n          hasher.update(key);\n          key = hasher.digest('hex');\n        }\n        const ret = hashCb(key, verify);\n        if (ret !== undefined)\n          verify(ret);\n      };\n    }\n\n    const sock = this._sock = (cfg.sock || new Socket());\n    let ready = false;\n    let sawHeader = false;\n    if (this._protocol)\n      this._protocol.cleanup();\n    const DEBUG_HANDLER = (!debug ? undefined : (p, display, msg) => {\n      debug(`Debug output from server: ${JSON.stringify(msg)}`);\n    });\n    const proto = this._protocol = new Protocol({\n      ident: this.config.ident,\n      offer: (allOfferDefaults ? undefined : algorithms),\n      onWrite: (data) => {\n        if (isWritable(sock))\n          sock.write(data);\n      },\n      onError: (err) => {\n        if (err.level === 'handshake')\n          clearTimeout(this._readyTimeout);\n        if (!proto._destruct)\n          sock.removeAllListeners('data');\n        this.emit('error', err);\n        try {\n          sock.end();\n        } catch {}\n      },\n      onHeader: (header) => {\n        sawHeader = true;\n        this._remoteVer = header.versions.software;\n        if (header.greeting)\n          this.emit('greeting', header.greeting);\n      },\n      onHandshakeComplete: (negotiated) => {\n        this.emit('handshake', negotiated);\n        if (!ready) {\n          ready = true;\n          proto.service('ssh-userauth');\n        }\n      },\n      debug,\n      hostVerifier,\n      messageHandlers: {\n        DEBUG: DEBUG_HANDLER,\n        DISCONNECT: (p, reason, desc) => {\n          if (reason !== DISCONNECT_REASON.BY_APPLICATION) {\n            if (!desc) {\n              desc = DISCONNECT_REASON_BY_VALUE[reason];\n              if (desc === undefined)\n                desc = `Unexpected disconnection reason: ${reason}`;\n            }\n            const err = new Error(desc);\n            err.code = reason;\n            this.emit('error', err);\n          }\n          sock.end();\n        },\n        SERVICE_ACCEPT: (p, name) => {\n          if (name === 'ssh-userauth')\n            tryNextAuth();\n        },\n        USERAUTH_BANNER: (p, msg) => {\n          this.emit('banner', msg);\n        },\n        USERAUTH_SUCCESS: (p) => {\n          // Start keepalive mechanism\n          resetKA();\n\n          clearTimeout(this._readyTimeout);\n\n          this.emit('ready');\n        },\n        USERAUTH_FAILURE: (p, authMethods, partialSuccess) => {\n          if (curAuth.type === 'agent') {\n            const pos = curAuth.agentCtx.pos();\n            debug && debug(`Client: Agent key #${pos + 1} failed`);\n            return tryNextAgentKey();\n          }\n\n          debug && debug(`Client: ${curAuth.type} auth failed`);\n\n          curPartial = partialSuccess;\n          curAuthsLeft = authMethods;\n          tryNextAuth();\n        },\n        USERAUTH_PASSWD_CHANGEREQ: (p, prompt) => {\n          if (curAuth.type === 'password') {\n            // TODO: support a `changePrompt()` on `curAuth` that defaults to\n            // emitting 'change password' as before\n            this.emit('change password', prompt, (newPassword) => {\n              proto.authPassword(\n                this.config.username,\n                this.config.password,\n                newPassword\n              );\n            });\n          }\n        },\n        USERAUTH_PK_OK: (p) => {\n          if (curAuth.type === 'agent') {\n            const key = curAuth.agentCtx.currentKey();\n            proto.authPK(curAuth.username, key, (buf, cb) => {\n              curAuth.agentCtx.sign(key, buf, {}, (err, signed) => {\n                if (err) {\n                  err.level = 'agent';\n                  this.emit('error', err);\n                } else {\n                  return cb(signed);\n                }\n\n                tryNextAgentKey();\n              });\n            });\n          } else if (curAuth.type === 'publickey') {\n            proto.authPK(curAuth.username, curAuth.key, (buf, cb) => {\n              const signature = curAuth.key.sign(buf);\n              if (signature instanceof Error) {\n                signature.message =\n                  `Error signing data with key: ${signature.message}`;\n                signature.level = 'client-authentication';\n                this.emit('error', signature);\n                return tryNextAuth();\n              }\n              cb(signature);\n            });\n          }\n        },\n        USERAUTH_INFO_REQUEST: (p, name, instructions, prompts) => {\n          if (curAuth.type === 'keyboard-interactive') {\n            const nprompts = (Array.isArray(prompts) ? prompts.length : 0);\n            if (nprompts === 0) {\n              debug && debug(\n                'Client: Sending automatic USERAUTH_INFO_RESPONSE'\n              );\n              proto.authInfoRes();\n              return;\n            }\n            // We sent a keyboard-interactive user authentication request and\n            // now the server is sending us the prompts we need to present to\n            // the user\n            curAuth.prompt(\n              name,\n              instructions,\n              '',\n              prompts,\n              (answers) => {\n                proto.authInfoRes(answers);\n              }\n            );\n          }\n        },\n        REQUEST_SUCCESS: (p, data) => {\n          if (callbacks.length)\n            callbacks.shift()(false, data);\n        },\n        REQUEST_FAILURE: (p) => {\n          if (callbacks.length)\n            callbacks.shift()(true);\n        },\n        GLOBAL_REQUEST: (p, name, wantReply, data) => {\n          switch (name) {\n            case 'hostkeys-00@openssh.com':\n              // Automatically verify keys before passing to end user\n              hostKeysProve(this, data, (err, keys) => {\n                if (err)\n                  return;\n                this.emit('hostkeys', keys);\n              });\n              if (wantReply)\n                proto.requestSuccess();\n              break;\n            default:\n              // Auto-reject all other global requests, this can be especially\n              // useful if the server is sending us dummy keepalive global\n              // requests\n              if (wantReply)\n                proto.requestFailure();\n          }\n        },\n        CHANNEL_OPEN: (p, info) => {\n          // Handle incoming requests from server, typically a forwarded TCP or\n          // X11 connection\n          onCHANNEL_OPEN(this, info);\n        },\n        CHANNEL_OPEN_CONFIRMATION: (p, info) => {\n          const channel = this._chanMgr.get(info.recipient);\n          if (typeof channel !== 'function')\n            return;\n\n          const isSFTP = (channel.type === 'sftp');\n          const type = (isSFTP ? 'session' : channel.type);\n          const chanInfo = {\n            type,\n            incoming: {\n              id: info.recipient,\n              window: MAX_WINDOW,\n              packetSize: PACKET_SIZE,\n              state: 'open'\n            },\n            outgoing: {\n              id: info.sender,\n              window: info.window,\n              packetSize: info.packetSize,\n              state: 'open'\n            }\n          };\n          const instance = (\n            isSFTP\n            ? new SFTP(this, chanInfo, { debug })\n            : new Channel(this, chanInfo)\n          );\n          this._chanMgr.update(info.recipient, instance);\n          channel(undefined, instance);\n        },\n        CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'function')\n            return;\n\n          const info = { reason, description };\n          onChannelOpenFailure(this, recipient, info, channel);\n        },\n        CHANNEL_DATA: (p, recipient, data) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n          if (channel.incoming.window === 0)\n            return;\n\n          channel.incoming.window -= data.length;\n\n          if (channel.push(data) === false) {\n            channel._waitChanDrain = true;\n            return;\n          }\n\n          if (channel.incoming.window <= WINDOW_THRESHOLD)\n            windowAdjust(channel);\n        },\n        CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {\n          if (type !== STDERR)\n            return;\n\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n          if (channel.incoming.window === 0)\n            return;\n\n          channel.incoming.window -= data.length;\n\n          if (!channel.stderr.push(data)) {\n            channel._waitChanDrain = true;\n            return;\n          }\n\n          if (channel.incoming.window <= WINDOW_THRESHOLD)\n            windowAdjust(channel);\n        },\n        CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          // The other side is allowing us to send `amount` more bytes of data\n          channel.outgoing.window += amount;\n\n          if (channel._waitWindow) {\n            channel._waitWindow = false;\n\n            if (channel._chunk) {\n              channel._write(channel._chunk, null, channel._chunkcb);\n            } else if (channel._chunkcb) {\n              channel._chunkcb();\n            } else if (channel._chunkErr) {\n              channel.stderr._write(channel._chunkErr,\n                                    null,\n                                    channel._chunkcbErr);\n            } else if (channel._chunkcbErr) {\n              channel._chunkcbErr();\n            }\n          }\n        },\n        CHANNEL_SUCCESS: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          this._resetKA();\n\n          if (channel._callbacks.length)\n            channel._callbacks.shift()(false);\n        },\n        CHANNEL_FAILURE: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          this._resetKA();\n\n          if (channel._callbacks.length)\n            channel._callbacks.shift()(true);\n        },\n        CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          const exit = channel._exit;\n          if (exit.code !== undefined)\n            return;\n          switch (type) {\n            case 'exit-status':\n              channel.emit('exit', exit.code = data);\n              return;\n            case 'exit-signal':\n              channel.emit('exit',\n                           exit.code = null,\n                           exit.signal = `SIG${data.signal}`,\n                           exit.dump = data.coreDumped,\n                           exit.desc = data.errorMessage);\n              return;\n          }\n\n          // Keepalive request? OpenSSH will send one as a channel request if\n          // there is a channel open\n\n          if (wantReply)\n            p.channelFailure(channel.outgoing.id);\n        },\n        CHANNEL_EOF: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          if (channel.incoming.state !== 'open')\n            return;\n          channel.incoming.state = 'eof';\n\n          if (channel.readable)\n            channel.push(null);\n          if (channel.stderr.readable)\n            channel.stderr.push(null);\n        },\n        CHANNEL_CLOSE: (p, recipient) => {\n          onCHANNEL_CLOSE(this, recipient, this._chanMgr.get(recipient));\n        },\n      },\n    });\n\n    sock.pause();\n\n    // TODO: check keepalive implementation\n    // Keepalive-related\n    const kainterval = this.config.keepaliveInterval;\n    const kacountmax = this.config.keepaliveCountMax;\n    let kacount = 0;\n    let katimer;\n    const sendKA = () => {\n      if (++kacount > kacountmax) {\n        clearInterval(katimer);\n        if (sock.readable) {\n          const err = new Error('Keepalive timeout');\n          err.level = 'client-timeout';\n          this.emit('error', err);\n          sock.destroy();\n        }\n        return;\n      }\n      if (isWritable(sock)) {\n        // Append dummy callback to keep correct callback order\n        callbacks.push(resetKA);\n        proto.ping();\n      } else {\n        clearInterval(katimer);\n      }\n    };\n    function resetKA() {\n      if (kainterval > 0) {\n        kacount = 0;\n        clearInterval(katimer);\n        if (isWritable(sock))\n          katimer = setInterval(sendKA, kainterval);\n      }\n    }\n    this._resetKA = resetKA;\n\n    const onDone = (() => {\n      let called = false;\n      return () => {\n        if (called)\n          return;\n        called = true;\n        if (wasConnected && !sawHeader) {\n          const err =\n            makeError('Connection lost before handshake', 'protocol', true);\n          this.emit('error', err);\n        }\n      };\n    })();\n    const onConnect = (() => {\n      let called = false;\n      return () => {\n        if (called)\n          return;\n        called = true;\n\n        wasConnected = true;\n        debug && debug('Socket connected');\n        this.emit('connect');\n\n        cryptoInit.then(() => {\n          proto.start();\n          sock.on('data', (data) => {\n            try {\n              proto.parse(data, 0, data.length);\n            } catch (ex) {\n              this.emit('error', ex);\n              try {\n                if (isWritable(sock))\n                  sock.end();\n              } catch {}\n            }\n          });\n\n          // Drain stderr if we are connection hopping using an exec stream\n          if (sock.stderr && typeof sock.stderr.resume === 'function')\n            sock.stderr.resume();\n\n          sock.resume();\n        }).catch((err) => {\n          this.emit('error', err);\n          try {\n            if (isWritable(sock))\n              sock.end();\n          } catch {}\n        });\n      };\n    })();\n    let wasConnected = false;\n    sock.on('connect', onConnect)\n        .on('timeout', () => {\n      this.emit('timeout');\n    }).on('error', (err) => {\n      debug && debug(`Socket error: ${err.message}`);\n      clearTimeout(this._readyTimeout);\n      err.level = 'client-socket';\n      this.emit('error', err);\n    }).on('end', () => {\n      debug && debug('Socket ended');\n      onDone();\n      proto.cleanup();\n      clearTimeout(this._readyTimeout);\n      clearInterval(katimer);\n      this.emit('end');\n    }).on('close', () => {\n      debug && debug('Socket closed');\n      onDone();\n      proto.cleanup();\n      clearTimeout(this._readyTimeout);\n      clearInterval(katimer);\n      this.emit('close');\n\n      // Notify outstanding channel requests of disconnection ...\n      const callbacks_ = callbacks;\n      callbacks = this._callbacks = [];\n      const err = new Error('No response from server');\n      for (let i = 0; i < callbacks_.length; ++i)\n        callbacks_[i](err);\n\n      // Simulate error for any channels waiting to be opened\n      this._chanMgr.cleanup(err);\n    });\n\n    // Begin authentication handling ===========================================\n    let curAuth;\n    let curPartial = null;\n    let curAuthsLeft = null;\n    const authsAllowed = ['none'];\n    if (this.config.password !== undefined)\n      authsAllowed.push('password');\n    if (privateKey !== undefined)\n      authsAllowed.push('publickey');\n    if (this._agent !== undefined)\n      authsAllowed.push('agent');\n    if (this.config.tryKeyboard)\n      authsAllowed.push('keyboard-interactive');\n    if (privateKey !== undefined\n        && this.config.localHostname !== undefined\n        && this.config.localUsername !== undefined) {\n      authsAllowed.push('hostbased');\n    }\n\n    if (Array.isArray(authHandler))\n      authHandler = makeSimpleAuthHandler(authHandler);\n    else if (typeof authHandler !== 'function')\n      authHandler = makeSimpleAuthHandler(authsAllowed);\n\n    let hasSentAuth = false;\n    const doNextAuth = (nextAuth) => {\n      if (hasSentAuth)\n        return;\n      hasSentAuth = true;\n\n      if (nextAuth === false) {\n        const err = new Error('All configured authentication methods failed');\n        err.level = 'client-authentication';\n        this.emit('error', err);\n        this.end();\n        return;\n      }\n\n      if (typeof nextAuth === 'string') {\n        // Remain backwards compatible with original `authHandler()` usage,\n        // which only supported passing names of next method to try using data\n        // from the `connect()` config object\n\n        const type = nextAuth;\n        if (authsAllowed.indexOf(type) === -1)\n          return skipAuth(`Authentication method not allowed: ${type}`);\n\n        const username = this.config.username;\n        switch (type) {\n          case 'password':\n            nextAuth = { type, username, password: this.config.password };\n            break;\n          case 'publickey':\n            nextAuth = { type, username, key: privateKey };\n            break;\n          case 'hostbased':\n            nextAuth = {\n              type,\n              username,\n              key: privateKey,\n              localHostname: this.config.localHostname,\n              localUsername: this.config.localUsername,\n            };\n            break;\n          case 'agent':\n            nextAuth = {\n              type,\n              username,\n              agentCtx: new AgentContext(this._agent),\n            };\n            break;\n          case 'keyboard-interactive':\n            nextAuth = {\n              type,\n              username,\n              prompt: (...args) => this.emit('keyboard-interactive', ...args),\n            };\n            break;\n          case 'none':\n            nextAuth = { type, username };\n            break;\n          default:\n            return skipAuth(\n              `Skipping unsupported authentication method: ${nextAuth}`\n            );\n        }\n      } else if (typeof nextAuth !== 'object' || nextAuth === null) {\n        return skipAuth(\n          `Skipping invalid authentication attempt: ${nextAuth}`\n        );\n      } else {\n        const username = nextAuth.username;\n        if (typeof username !== 'string') {\n          return skipAuth(\n            `Skipping invalid authentication attempt: ${nextAuth}`\n          );\n        }\n        const type = nextAuth.type;\n        switch (type) {\n          case 'password': {\n            const { password } = nextAuth;\n            if (typeof password !== 'string' && !Buffer.isBuffer(password))\n              return skipAuth('Skipping invalid password auth attempt');\n            nextAuth = { type, username, password };\n            break;\n          }\n          case 'publickey': {\n            const key = parseKey(nextAuth.key, nextAuth.passphrase);\n            if (key instanceof Error)\n              return skipAuth('Skipping invalid key auth attempt');\n            if (!key.isPrivateKey())\n              return skipAuth('Skipping non-private key');\n            nextAuth = { type, username, key };\n            break;\n          }\n          case 'hostbased': {\n            const { localHostname, localUsername } = nextAuth;\n            const key = parseKey(nextAuth.key, nextAuth.passphrase);\n            if (key instanceof Error\n                || typeof localHostname !== 'string'\n                || typeof localUsername !== 'string') {\n              return skipAuth('Skipping invalid hostbased auth attempt');\n            }\n            if (!key.isPrivateKey())\n              return skipAuth('Skipping non-private key');\n            nextAuth = { type, username, key, localHostname, localUsername };\n            break;\n          }\n          case 'agent': {\n            let agent = nextAuth.agent;\n            if (typeof agent === 'string' && agent.length) {\n              agent = createAgent(agent);\n            } else if (!isAgent(agent)) {\n              return skipAuth(\n                `Skipping invalid agent: ${nextAuth.agent}`\n              );\n            }\n            nextAuth = { type, username, agentCtx: new AgentContext(agent) };\n            break;\n          }\n          case 'keyboard-interactive': {\n            const { prompt } = nextAuth;\n            if (typeof prompt !== 'function') {\n              return skipAuth(\n                'Skipping invalid keyboard-interactive auth attempt'\n              );\n            }\n            nextAuth = { type, username, prompt };\n            break;\n          }\n          case 'none':\n            nextAuth = { type, username };\n            break;\n          default:\n            return skipAuth(\n              `Skipping unsupported authentication method: ${nextAuth}`\n            );\n        }\n      }\n      curAuth = nextAuth;\n\n      // Begin authentication method's process\n      try {\n        const username = curAuth.username;\n        switch (curAuth.type) {\n          case 'password':\n            proto.authPassword(username, curAuth.password);\n            break;\n          case 'publickey':\n            proto.authPK(username, curAuth.key);\n            break;\n          case 'hostbased':\n            proto.authHostbased(username,\n                                curAuth.key,\n                                curAuth.localHostname,\n                                curAuth.localUsername,\n                                (buf, cb) => {\n              const signature = curAuth.key.sign(buf);\n              if (signature instanceof Error) {\n                signature.message =\n                  `Error while signing with key: ${signature.message}`;\n                signature.level = 'client-authentication';\n                this.emit('error', signature);\n                return tryNextAuth();\n              }\n\n              cb(signature);\n            });\n            break;\n          case 'agent':\n            curAuth.agentCtx.init((err) => {\n              if (err) {\n                err.level = 'agent';\n                this.emit('error', err);\n                return tryNextAuth();\n              }\n              tryNextAgentKey();\n            });\n            break;\n          case 'keyboard-interactive':\n            proto.authKeyboard(username);\n            break;\n          case 'none':\n            proto.authNone(username);\n            break;\n        }\n      } finally {\n        hasSentAuth = false;\n      }\n    };\n\n    function skipAuth(msg) {\n      debug && debug(msg);\n      process.nextTick(tryNextAuth);\n    }\n\n    function tryNextAuth() {\n      hasSentAuth = false;\n      const auth = authHandler(curAuthsLeft, curPartial, doNextAuth);\n      if (hasSentAuth || auth === undefined)\n        return;\n      doNextAuth(auth);\n    }\n\n    const tryNextAgentKey = () => {\n      if (curAuth.type === 'agent') {\n        const key = curAuth.agentCtx.nextKey();\n        if (key === false) {\n          debug && debug('Agent: No more keys left to try');\n          debug && debug('Client: agent auth failed');\n          tryNextAuth();\n        } else {\n          const pos = curAuth.agentCtx.pos();\n          debug && debug(`Agent: Trying key #${pos + 1}`);\n          proto.authPK(curAuth.username, key);\n        }\n      }\n    };\n\n    const startTimeout = () => {\n      if (this.config.readyTimeout > 0) {\n        this._readyTimeout = setTimeout(() => {\n          const err = new Error('Timed out while waiting for handshake');\n          err.level = 'client-timeout';\n          this.emit('error', err);\n          sock.destroy();\n        }, this.config.readyTimeout);\n      }\n    };\n\n    if (!cfg.sock) {\n      let host = this.config.host;\n      const forceIPv4 = this.config.forceIPv4;\n      const forceIPv6 = this.config.forceIPv6;\n\n      debug && debug(`Client: Trying ${host} on port ${this.config.port} ...`);\n\n      const doConnect = () => {\n        startTimeout();\n        sock.connect({\n          host,\n          port: this.config.port,\n          localAddress: this.config.localAddress,\n          localPort: this.config.localPort\n        });\n        sock.setNoDelay(true);\n        sock.setMaxListeners(0);\n        sock.setTimeout(typeof cfg.timeout === 'number' ? cfg.timeout : 0);\n      };\n\n      if ((!forceIPv4 && !forceIPv6) || (forceIPv4 && forceIPv6)) {\n        doConnect();\n      } else {\n        dnsLookup(host, (forceIPv4 ? 4 : 6), (err, address, family) => {\n          if (err) {\n            const type = (forceIPv4 ? 'IPv4' : 'IPv6');\n            const error = new Error(\n              `Error while looking up ${type} address for '${host}': ${err}`\n            );\n            clearTimeout(this._readyTimeout);\n            error.level = 'client-dns';\n            this.emit('error', error);\n            this.emit('close');\n            return;\n          }\n          host = address;\n          doConnect();\n        });\n      }\n    } else {\n      // Custom socket passed in\n      startTimeout();\n      if (typeof sock.connecting === 'boolean') {\n        // net.Socket\n\n        if (!sock.connecting) {\n          // Already connected\n          onConnect();\n        }\n      } else {\n        // Assume socket/stream is already \"connected\"\n        onConnect();\n      }\n    }\n\n    return this;\n  }\n\n  end() {\n    if (this._sock && isWritable(this._sock)) {\n      this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n      this._sock.end();\n    }\n    return this;\n  }\n\n  destroy() {\n    this._sock && isWritable(this._sock) && this._sock.destroy();\n    return this;\n  }\n\n  exec(cmd, opts, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    if (typeof opts === 'function') {\n      cb = opts;\n      opts = {};\n    }\n\n    const extraOpts = { allowHalfOpen: (opts.allowHalfOpen !== false) };\n\n    openChannel(this, 'session', extraOpts, (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      const todo = [];\n\n      function reqCb(err) {\n        if (err) {\n          chan.close();\n          cb(err);\n          return;\n        }\n        if (todo.length)\n          todo.shift()();\n      }\n\n      if (this.config.allowAgentFwd === true\n          || (opts\n              && opts.agentForward === true\n              && this._agent !== undefined)) {\n        todo.push(() => reqAgentFwd(chan, reqCb));\n      }\n\n      if (typeof opts === 'object' && opts !== null) {\n        if (typeof opts.env === 'object' && opts.env !== null)\n          reqEnv(chan, opts.env);\n        if ((typeof opts.pty === 'object' && opts.pty !== null)\n            || opts.pty === true) {\n          todo.push(() => reqPty(chan, opts.pty, reqCb));\n        }\n        if ((typeof opts.x11 === 'object' && opts.x11 !== null)\n            || opts.x11 === 'number'\n            || opts.x11 === true) {\n          todo.push(() => reqX11(chan, opts.x11, reqCb));\n        }\n      }\n\n      todo.push(() => reqExec(chan, cmd, opts, cb));\n      todo.shift()();\n    });\n\n    return this;\n  }\n\n  shell(wndopts, opts, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    if (typeof wndopts === 'function') {\n      cb = wndopts;\n      wndopts = opts = undefined;\n    } else if (typeof opts === 'function') {\n      cb = opts;\n      opts = undefined;\n    }\n    if (wndopts && (wndopts.x11 !== undefined || wndopts.env !== undefined)) {\n      opts = wndopts;\n      wndopts = undefined;\n    }\n\n    openChannel(this, 'session', (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      const todo = [];\n\n      function reqCb(err) {\n        if (err) {\n          chan.close();\n          cb(err);\n          return;\n        }\n        if (todo.length)\n          todo.shift()();\n      }\n\n      if (this.config.allowAgentFwd === true\n          || (opts\n              && opts.agentForward === true\n              && this._agent !== undefined)) {\n        todo.push(() => reqAgentFwd(chan, reqCb));\n      }\n\n      if (wndopts !== false)\n        todo.push(() => reqPty(chan, wndopts, reqCb));\n\n      if (typeof opts === 'object' && opts !== null) {\n        if (typeof opts.env === 'object' && opts.env !== null)\n          reqEnv(chan, opts.env);\n        if ((typeof opts.x11 === 'object' && opts.x11 !== null)\n            || opts.x11 === 'number'\n            || opts.x11 === true) {\n          todo.push(() => reqX11(chan, opts.x11, reqCb));\n        }\n      }\n\n      todo.push(() => reqShell(chan, cb));\n      todo.shift()();\n    });\n\n    return this;\n  }\n\n  subsys(name, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    openChannel(this, 'session', (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      reqSubsystem(chan, name, (err, stream) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n\n        cb(undefined, stream);\n      });\n    });\n\n    return this;\n  }\n\n  forwardIn(bindAddr, bindPort, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    // Send a request for the server to start forwarding TCP connections to us\n    // on a particular address and port\n\n    const wantReply = (typeof cb === 'function');\n\n    if (wantReply) {\n      this._callbacks.push((had_err, data) => {\n        if (had_err) {\n          cb(had_err !== true\n             ? had_err\n             : new Error(`Unable to bind to ${bindAddr}:${bindPort}`));\n          return;\n        }\n\n        let realPort = bindPort;\n        if (bindPort === 0 && data && data.length >= 4) {\n          realPort = readUInt32BE(data, 0);\n          if (!(this._protocol._compatFlags & COMPAT.DYN_RPORT_BUG))\n            bindPort = realPort;\n        }\n\n        this._forwarding[`${bindAddr}:${bindPort}`] = realPort;\n\n        cb(undefined, realPort);\n      });\n    }\n\n    this._protocol.tcpipForward(bindAddr, bindPort, wantReply);\n\n    return this;\n  }\n\n  unforwardIn(bindAddr, bindPort, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    // Send a request to stop forwarding us new connections for a particular\n    // address and port\n\n    const wantReply = (typeof cb === 'function');\n\n    if (wantReply) {\n      this._callbacks.push((had_err) => {\n        if (had_err) {\n          cb(had_err !== true\n             ? had_err\n             : new Error(`Unable to unbind from ${bindAddr}:${bindPort}`));\n          return;\n        }\n\n        delete this._forwarding[`${bindAddr}:${bindPort}`];\n\n        cb();\n      });\n    }\n\n    this._protocol.cancelTcpipForward(bindAddr, bindPort, wantReply);\n\n    return this;\n  }\n\n  forwardOut(srcIP, srcPort, dstIP, dstPort, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    // Send a request to forward a TCP connection to the server\n\n    const cfg = {\n      srcIP: srcIP,\n      srcPort: srcPort,\n      dstIP: dstIP,\n      dstPort: dstPort\n    };\n\n    if (typeof cb !== 'function')\n      cb = noop;\n\n    openChannel(this, 'direct-tcpip', cfg, cb);\n\n    return this;\n  }\n\n  openssh_noMoreSessions(cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    const wantReply = (typeof cb === 'function');\n\n    if (!this.config.strictVendor\n        || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n      if (wantReply) {\n        this._callbacks.push((had_err) => {\n          if (had_err) {\n            cb(had_err !== true\n               ? had_err\n               : new Error('Unable to disable future sessions'));\n            return;\n          }\n\n          cb();\n        });\n      }\n\n      this._protocol.openssh_noMoreSessions(wantReply);\n      return this;\n    }\n\n    if (!wantReply)\n      return this;\n\n    process.nextTick(\n      cb,\n      new Error(\n        'strictVendor enabled and server is not OpenSSH or compatible version'\n      )\n    );\n\n    return this;\n  }\n\n  openssh_forwardInStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    const wantReply = (typeof cb === 'function');\n\n    if (!this.config.strictVendor\n        || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n      if (wantReply) {\n        this._callbacks.push((had_err) => {\n          if (had_err) {\n            cb(had_err !== true\n               ? had_err\n               : new Error(`Unable to bind to ${socketPath}`));\n            return;\n          }\n          this._forwardingUnix[socketPath] = true;\n          cb();\n        });\n      }\n\n      this._protocol.openssh_streamLocalForward(socketPath, wantReply);\n      return this;\n    }\n\n    if (!wantReply)\n      return this;\n\n    process.nextTick(\n      cb,\n      new Error(\n        'strictVendor enabled and server is not OpenSSH or compatible version'\n      )\n    );\n\n    return this;\n  }\n\n  openssh_unforwardInStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    const wantReply = (typeof cb === 'function');\n\n    if (!this.config.strictVendor\n        || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n      if (wantReply) {\n        this._callbacks.push((had_err) => {\n          if (had_err) {\n            cb(had_err !== true\n               ? had_err\n               : new Error(`Unable to unbind from ${socketPath}`));\n            return;\n          }\n          delete this._forwardingUnix[socketPath];\n          cb();\n        });\n      }\n\n      this._protocol.openssh_cancelStreamLocalForward(socketPath, wantReply);\n      return this;\n    }\n\n    if (!wantReply)\n      return this;\n\n    process.nextTick(\n      cb,\n      new Error(\n        'strictVendor enabled and server is not OpenSSH or compatible version'\n      )\n    );\n\n    return this;\n  }\n\n  openssh_forwardOutStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    if (typeof cb !== 'function')\n      cb = noop;\n\n    if (!this.config.strictVendor\n        || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n      openChannel(this, 'direct-streamlocal@openssh.com', { socketPath }, cb);\n      return this;\n    }\n    process.nextTick(\n      cb,\n      new Error(\n        'strictVendor enabled and server is not OpenSSH or compatible version'\n      )\n    );\n\n    return this;\n  }\n\n  sftp(cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    openChannel(this, 'sftp', (err, sftp) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      reqSubsystem(sftp, 'sftp', (err, sftp_) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n\n        function removeListeners() {\n          sftp.removeListener('ready', onReady);\n          sftp.removeListener('error', onError);\n          sftp.removeListener('exit', onExit);\n          sftp.removeListener('close', onExit);\n        }\n\n        function onReady() {\n          // TODO: do not remove exit/close in case remote end closes the\n          // channel abruptly and we need to notify outstanding callbacks\n          removeListeners();\n          cb(undefined, sftp);\n        }\n\n        function onError(err) {\n          removeListeners();\n          cb(err);\n        }\n\n        function onExit(code, signal) {\n          removeListeners();\n          let msg;\n          if (typeof code === 'number')\n            msg = `Received exit code ${code} while establishing SFTP session`;\n          else if (signal !== undefined)\n            msg = `Received signal ${signal} while establishing SFTP session`;\n          else\n            msg = 'Received unexpected SFTP session termination';\n          const err = new Error(msg);\n          err.code = code;\n          err.signal = signal;\n          cb(err);\n        }\n\n        sftp.on('ready', onReady)\n            .on('error', onError)\n            .on('exit', onExit)\n            .on('close', onExit);\n\n        sftp._init();\n      });\n    });\n\n    return this;\n  }\n}\n\nfunction openChannel(self, type, opts, cb) {\n  // Ask the server to open a channel for some purpose\n  // (e.g. session (sftp, exec, shell), or forwarding a TCP connection\n  const initWindow = MAX_WINDOW;\n  const maxPacket = PACKET_SIZE;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  const wrapper = (err, stream) => {\n    cb(err, stream);\n  };\n  wrapper.type = type;\n\n  const localChan = self._chanMgr.add(wrapper);\n\n  if (localChan === -1) {\n    cb(new Error('No free channels available'));\n    return;\n  }\n\n  switch (type) {\n    case 'session':\n    case 'sftp':\n      self._protocol.session(localChan, initWindow, maxPacket);\n      break;\n    case 'direct-tcpip':\n      self._protocol.directTcpip(localChan, initWindow, maxPacket, opts);\n      break;\n    case 'direct-streamlocal@openssh.com':\n      self._protocol.openssh_directStreamLocal(\n        localChan, initWindow, maxPacket, opts\n      );\n      break;\n    default:\n      throw new Error(`Unsupported channel type: ${type}`);\n  }\n}\n\nfunction reqX11(chan, screen, cb) {\n  // Asks server to start sending us X11 connections\n  const cfg = {\n    single: false,\n    protocol: 'MIT-MAGIC-COOKIE-1',\n    cookie: undefined,\n    screen: 0\n  };\n\n  if (typeof screen === 'function') {\n    cb = screen;\n  } else if (typeof screen === 'object' && screen !== null) {\n    if (typeof screen.single === 'boolean')\n      cfg.single = screen.single;\n    if (typeof screen.screen === 'number')\n      cfg.screen = screen.screen;\n    if (typeof screen.protocol === 'string')\n      cfg.protocol = screen.protocol;\n    if (typeof screen.cookie === 'string')\n      cfg.cookie = screen.cookie;\n    else if (Buffer.isBuffer(screen.cookie))\n      cfg.cookie = screen.cookie.hexSlice(0, screen.cookie.length);\n  }\n  if (cfg.cookie === undefined)\n    cfg.cookie = randomCookie();\n\n  const wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    if (wantReply)\n      cb(new Error('Channel is not open'));\n    return;\n  }\n\n  if (wantReply) {\n    chan._callbacks.push((had_err) => {\n      if (had_err) {\n        cb(had_err !== true ? had_err : new Error('Unable to request X11'));\n        return;\n      }\n\n      chan._hasX11 = true;\n      ++chan._client._acceptX11;\n      chan.once('close', () => {\n        if (chan._client._acceptX11)\n          --chan._client._acceptX11;\n      });\n\n      cb();\n    });\n  }\n\n  chan._client._protocol.x11Forward(chan.outgoing.id, cfg, wantReply);\n}\n\nfunction reqPty(chan, opts, cb) {\n  let rows = 24;\n  let cols = 80;\n  let width = 640;\n  let height = 480;\n  let term = 'vt100';\n  let modes = null;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n  } else if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.rows === 'number')\n      rows = opts.rows;\n    if (typeof opts.cols === 'number')\n      cols = opts.cols;\n    if (typeof opts.width === 'number')\n      width = opts.width;\n    if (typeof opts.height === 'number')\n      height = opts.height;\n    if (typeof opts.term === 'string')\n      term = opts.term;\n    if (typeof opts.modes === 'object')\n      modes = opts.modes;\n  }\n\n  const wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    if (wantReply)\n      cb(new Error('Channel is not open'));\n    return;\n  }\n\n  if (wantReply) {\n    chan._callbacks.push((had_err) => {\n      if (had_err) {\n        cb(had_err !== true\n           ? had_err\n           : new Error('Unable to request a pseudo-terminal'));\n        return;\n      }\n      cb();\n    });\n  }\n\n  chan._client._protocol.pty(chan.outgoing.id,\n                             rows,\n                             cols,\n                             height,\n                             width,\n                             term,\n                             modes,\n                             wantReply);\n}\n\nfunction reqAgentFwd(chan, cb) {\n  const wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    wantReply && cb(new Error('Channel is not open'));\n    return;\n  }\n  if (chan._client._agentFwdEnabled) {\n    wantReply && cb(false);\n    return;\n  }\n\n  chan._client._agentFwdEnabled = true;\n\n  chan._callbacks.push((had_err) => {\n    if (had_err) {\n      chan._client._agentFwdEnabled = false;\n      if (wantReply) {\n        cb(had_err !== true\n           ? had_err\n           : new Error('Unable to request agent forwarding'));\n      }\n      return;\n    }\n\n    if (wantReply)\n      cb();\n  });\n\n  chan._client._protocol.openssh_agentForward(chan.outgoing.id, true);\n}\n\nfunction reqShell(chan, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n\n  chan._callbacks.push((had_err) => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error('Unable to open shell'));\n      return;\n    }\n    chan.subtype = 'shell';\n    cb(undefined, chan);\n  });\n\n  chan._client._protocol.shell(chan.outgoing.id, true);\n}\n\nfunction reqExec(chan, cmd, opts, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n\n  chan._callbacks.push((had_err) => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error('Unable to exec'));\n      return;\n    }\n    chan.subtype = 'exec';\n    chan.allowHalfOpen = (opts.allowHalfOpen !== false);\n    cb(undefined, chan);\n  });\n\n  chan._client._protocol.exec(chan.outgoing.id, cmd, true);\n}\n\nfunction reqEnv(chan, env) {\n  if (chan.outgoing.state !== 'open')\n    return;\n\n  const keys = Object.keys(env || {});\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    const val = env[key];\n    chan._client._protocol.env(chan.outgoing.id, key, val, false);\n  }\n}\n\nfunction reqSubsystem(chan, name, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n\n  chan._callbacks.push((had_err) => {\n    if (had_err) {\n      cb(had_err !== true\n         ? had_err\n         : new Error(`Unable to start subsystem: ${name}`));\n      return;\n    }\n    chan.subtype = 'subsystem';\n    cb(undefined, chan);\n  });\n\n  chan._client._protocol.subsystem(chan.outgoing.id, name, true);\n}\n\n// TODO: inline implementation into single call site\nfunction onCHANNEL_OPEN(self, info) {\n  // The server is trying to open a channel with us, this is usually when\n  // we asked the server to forward us connections on some port and now they\n  // are asking us to accept/deny an incoming connection on their side\n\n  let localChan = -1;\n  let reason;\n\n  const accept = () => {\n    const chanInfo = {\n      type: info.type,\n      incoming: {\n        id: localChan,\n        window: MAX_WINDOW,\n        packetSize: PACKET_SIZE,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n    const stream = new Channel(self, chanInfo);\n    self._chanMgr.update(localChan, stream);\n\n    self._protocol.channelOpenConfirm(info.sender,\n                                      localChan,\n                                      MAX_WINDOW,\n                                      PACKET_SIZE);\n    return stream;\n  };\n  const reject = () => {\n    if (reason === undefined) {\n      if (localChan === -1)\n        reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n      else\n        reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;\n    }\n\n    if (localChan !== -1)\n      self._chanMgr.remove(localChan);\n\n    self._protocol.channelOpenFail(info.sender, reason, '');\n  };\n  const reserveChannel = () => {\n    localChan = self._chanMgr.add();\n\n    if (localChan === -1) {\n      reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n      if (self.config.debug) {\n        self.config.debug(\n          'Client: Automatic rejection of incoming channel open: '\n            + 'no channels available'\n        );\n      }\n    }\n\n    return (localChan !== -1);\n  };\n\n  const data = info.data;\n  switch (info.type) {\n    case 'forwarded-tcpip': {\n      const val = self._forwarding[`${data.destIP}:${data.destPort}`];\n      if (val !== undefined && reserveChannel()) {\n        if (data.destPort === 0)\n          data.destPort = val;\n        self.emit('tcp connection', data, accept, reject);\n        return;\n      }\n      break;\n    }\n    case 'forwarded-streamlocal@openssh.com':\n      if (self._forwardingUnix[data.socketPath] !== undefined\n          && reserveChannel()) {\n        self.emit('unix connection', data, accept, reject);\n        return;\n      }\n      break;\n    case 'auth-agent@openssh.com':\n      if (self._agentFwdEnabled\n          && typeof self._agent.getStream === 'function'\n          && reserveChannel()) {\n        self._agent.getStream((err, stream) => {\n          if (err)\n            return reject();\n\n          const upstream = accept();\n          upstream.pipe(stream).pipe(upstream);\n        });\n        return;\n      }\n      break;\n    case 'x11':\n      if (self._acceptX11 !== 0 && reserveChannel()) {\n        self.emit('x11', data, accept, reject);\n        return;\n      }\n      break;\n    default:\n      // Automatically reject any unsupported channel open requests\n      reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;\n      if (self.config.debug) {\n        self.config.debug(\n          'Client: Automatic rejection of unsupported incoming channel open '\n            + `type: ${info.type}`\n        );\n      }\n  }\n\n  if (reason === undefined) {\n    reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n    if (self.config.debug) {\n       self.config.debug(\n        'Client: Automatic rejection of unexpected incoming channel open for: '\n          + info.type\n      );\n    }\n  }\n\n  reject();\n}\n\nconst randomCookie = (() => {\n  const buffer = Buffer.allocUnsafe(16);\n  return () => {\n    randomFillSync(buffer, 0, 16);\n    return buffer.hexSlice(0, 16);\n  };\n})();\n\nfunction makeSimpleAuthHandler(authList) {\n  if (!Array.isArray(authList))\n    throw new Error('authList must be an array');\n\n  let a = 0;\n  return (authsLeft, partialSuccess, cb) => {\n    if (a === authList.length)\n      return false;\n    return authList[a++];\n  };\n}\n\nfunction hostKeysProve(client, keys_, cb) {\n  if (!client._sock || !isWritable(client._sock))\n    return;\n\n  if (typeof cb !== 'function')\n    cb = noop;\n\n  if (!Array.isArray(keys_))\n    throw new TypeError('Invalid keys argument type');\n\n  const keys = [];\n  for (const key of keys_) {\n    const parsed = parseKey(key);\n    if (parsed instanceof Error)\n      throw parsed;\n    keys.push(parsed);\n  }\n\n  if (!client.config.strictVendor\n      || (client.config.strictVendor && RE_OPENSSH.test(client._remoteVer))) {\n    client._callbacks.push((had_err, data) => {\n      if (had_err) {\n        cb(had_err !== true\n           ? had_err\n           : new Error('Server failed to prove supplied keys'));\n        return;\n      }\n\n      // TODO: move all of this parsing/verifying logic out of the client?\n      const ret = [];\n      let keyIdx = 0;\n      bufferParser.init(data, 0);\n      while (bufferParser.avail()) {\n        if (keyIdx === keys.length)\n          break;\n        const key = keys[keyIdx++];\n        const keyPublic = key.getPublicSSH();\n\n        const sigEntry = bufferParser.readString();\n        sigParser.init(sigEntry, 0);\n        const type = sigParser.readString(true);\n        let value = sigParser.readString();\n\n        let algo;\n        if (type !== key.type) {\n          if (key.type === 'ssh-rsa') {\n            switch (type) {\n              case 'rsa-sha2-256':\n                algo = 'sha256';\n                break;\n              case 'rsa-sha2-512':\n                algo = 'sha512';\n                break;\n              default:\n                continue;\n            }\n          } else {\n            continue;\n          }\n        }\n\n        const sessionID = client._protocol._kex.sessionID;\n        const verifyData = Buffer.allocUnsafe(\n          4 + 29 + 4 + sessionID.length + 4 + keyPublic.length\n        );\n        let p = 0;\n        writeUInt32BE(verifyData, 29, p);\n        verifyData.utf8Write('hostkeys-prove-00@openssh.com', p += 4, 29);\n        writeUInt32BE(verifyData, sessionID.length, p += 29);\n        bufferCopy(sessionID, verifyData, 0, sessionID.length, p += 4);\n        writeUInt32BE(verifyData, keyPublic.length, p += sessionID.length);\n        bufferCopy(keyPublic, verifyData, 0, keyPublic.length, p += 4);\n\n        if (!(value = sigSSHToASN1(value, type)))\n          continue;\n        if (key.verify(verifyData, value, algo) === true)\n          ret.push(key);\n      }\n      sigParser.clear();\n      bufferParser.clear();\n\n      cb(null, ret);\n    });\n\n    client._protocol.openssh_hostKeysProve(keys);\n    return;\n  }\n\n  process.nextTick(\n    cb,\n    new Error(\n      'strictVendor enabled and server is not OpenSSH or compatible version'\n    )\n  );\n}\n\nmodule.exports = Client;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,MAAM;EACJA,UADI;EAEJC,SAFI;EAGJC;AAHI,IAIFC,OAAO,CAAC,QAAD,CAJX;;AAKA,MAAM;EAAEC;AAAF,IAAaD,OAAO,CAAC,KAAD,CAA1B;;AACA,MAAM;EAAEE,MAAM,EAAEC;AAAV,IAAwBH,OAAO,CAAC,KAAD,CAArC;;AACA,MAAMI,YAAY,GAAGJ,OAAO,CAAC,QAAD,CAA5B;;AACA,MAAMK,MAAM,GAAGP,SAAS,EAAxB;;AAEA,MAAM;EACJQ,MADI;EAEJC,yBAAyB,EAAE;IAAEC;EAAF,CAFvB;EAGJC,oBAHI;EAIJC,cAJI;EAKJC,mBALI;EAMJC,WANI;EAOJC,WAPI;EAQJC,uBARI;EASJC,iBATI;EAUJC,0BAVI;EAWJC,gBAXI;EAYJC,qBAZI;EAaJC,aAbI;EAcJC,aAdI;EAeJC;AAfI,IAgBFrB,OAAO,CAAC,yBAAD,CAhBX;;AAiBA,MAAM;EAAEsB,IAAI,EAAEC;AAAR,IAAuBvB,OAAO,CAAC,sBAAD,CAApC;;AACA,MAAMwB,QAAQ,GAAGxB,OAAO,CAAC,wBAAD,CAAxB;;AACA,MAAM;EAAEyB;AAAF,IAAezB,OAAO,CAAC,yBAAD,CAA5B;;AACA,MAAM;EAAE0B;AAAF,IAAW1B,OAAO,CAAC,oBAAD,CAAxB;;AACA,MAAM;EACJ2B,UADI;EAEJC,gBAFI;EAGJC,SAHI;EAIJC,YAJI;EAKJC,YALI;EAMJC;AANI,IAOFhC,OAAO,CAAC,qBAAD,CAPX;;AASA,MAAM;EAAEiC,YAAF;EAAgBC,WAAhB;EAA6BC;AAA7B,IAAyCnC,OAAO,CAAC,YAAD,CAAtD;;AACA,MAAM;EACJoC,OADI;EAEJC,UAFI;EAGJC,WAHI;EAIJC,YAJI;EAKJC;AALI,IAMFxC,OAAO,CAAC,cAAD,CANX;;AAOA,MAAM;EACJyC,cADI;EAEJC,qBAFI;EAGJC,UAHI;EAIJC,oBAJI;EAKJC;AALI,IAMF7C,OAAO,CAAC,YAAD,CANX;;AAQA,MAAM8C,YAAY,GAAGlB,gBAAgB,EAArC;AACA,MAAMmB,SAAS,GAAGnB,gBAAgB,EAAlC;AACA,MAAMoB,UAAU,GAAG,qCAAnB;;AACA,MAAMC,IAAI,GAAIC,GAAD,IAAS,CAAE,CAAxB;;AAEA,MAAMC,MAAN,SAAqB/C,YAArB,CAAkC;EAChCgD,WAAW,GAAG;IACZ;IAEA,KAAKC,MAAL,GAAc;MACZC,IAAI,EAAEC,SADM;MAEZC,IAAI,EAAED,SAFM;MAGZE,YAAY,EAAEF,SAHF;MAIZG,SAAS,EAAEH,SAJC;MAKZI,SAAS,EAAEJ,SALC;MAMZK,SAAS,EAAEL,SANC;MAOZM,iBAAiB,EAAEN,SAPP;MAQZO,iBAAiB,EAAEP,SARP;MASZQ,YAAY,EAAER,SATF;MAUZS,KAAK,EAAET,SAVK;MAYZU,QAAQ,EAAEV,SAZE;MAaZW,QAAQ,EAAEX,SAbE;MAcZY,UAAU,EAAEZ,SAdA;MAeZa,WAAW,EAAEb,SAfD;MAgBZc,KAAK,EAAEd,SAhBK;MAiBZe,aAAa,EAAEf,SAjBH;MAkBZgB,WAAW,EAAEhB,SAlBD;MAoBZiB,YAAY,EAAEjB,SApBF;MAqBZkB,UAAU,EAAElB,SArBA;MAsBZmB,YAAY,EAAEnB,SAtBF;MAuBZoB,KAAK,EAAEpB;IAvBK,CAAd;IA0BA,KAAKqB,MAAL,GAAcrB,SAAd;IACA,KAAKsB,aAAL,GAAqBtB,SAArB;IACA,KAAKuB,QAAL,GAAgBvB,SAAhB;IACA,KAAKwB,UAAL,GAAkBxB,SAAlB;IACA,KAAKyB,WAAL,GAAmBzB,SAAnB;IACA,KAAK0B,eAAL,GAAuB1B,SAAvB;IACA,KAAK2B,UAAL,GAAkB3B,SAAlB;IACA,KAAK4B,gBAAL,GAAwB5B,SAAxB;IACA,KAAK6B,UAAL,GAAkB7B,SAAlB;IAEA,KAAK8B,SAAL,GAAiB9B,SAAjB;IACA,KAAK+B,KAAL,GAAa/B,SAAb;IACA,KAAKgC,QAAL,GAAgBhC,SAAhB;EACD;;EAEDiC,OAAO,CAACC,GAAD,EAAM;IAAA;;IACX,IAAI,KAAKH,KAAL,IAAc3C,UAAU,CAAC,KAAK2C,KAAN,CAA5B,EAA0C;MACxC,KAAKI,IAAL,CAAU,OAAV,EAAmB,MAAM;QACvB,KAAKF,OAAL,CAAaC,GAAb;MACD,CAFD;MAGA,KAAKE,GAAL;MACA,OAAO,IAAP;IACD;;IAED,KAAKtC,MAAL,CAAYC,IAAZ,GAAmBmC,GAAG,CAACG,QAAJ,IAAgBH,GAAG,CAACnC,IAApB,IAA4B,WAA/C;IACA,KAAKD,MAAL,CAAYG,IAAZ,GAAmBiC,GAAG,CAACjC,IAAJ,IAAY,EAA/B;IACA,KAAKH,MAAL,CAAYI,YAAZ,GAA4B,OAAOgC,GAAG,CAAChC,YAAX,KAA4B,QAA5B,GACEgC,GAAG,CAAChC,YADN,GAEEF,SAF9B;IAGA,KAAKF,MAAL,CAAYK,SAAZ,GAAyB,OAAO+B,GAAG,CAAC/B,SAAX,KAAyB,QAAzB,IACG,OAAO+B,GAAG,CAAC/B,SAAX,KAAyB,QAD5B,GAEE+B,GAAG,CAAC/B,SAFN,GAGEH,SAH3B;IAIA,KAAKF,MAAL,CAAYM,SAAZ,GAAwB8B,GAAG,CAAC9B,SAAJ,IAAiB,KAAzC;IACA,KAAKN,MAAL,CAAYO,SAAZ,GAAwB6B,GAAG,CAAC7B,SAAJ,IAAiB,KAAzC;IACA,KAAKP,MAAL,CAAYQ,iBAAZ,GAAiC,OAAO4B,GAAG,CAAC5B,iBAAX,KAAiC,QAAjC,IACG4B,GAAG,CAAC5B,iBAAJ,IAAyB,CAD5B,GAEE4B,GAAG,CAAC5B,iBAFN,GAGE,CAHnC;IAIA,KAAKR,MAAL,CAAYS,iBAAZ,GAAiC,OAAO2B,GAAG,CAAC3B,iBAAX,KAAiC,QAAjC,IACG2B,GAAG,CAAC3B,iBAAJ,GAAwB,CAD3B,GAEE2B,GAAG,CAAC3B,iBAFN,GAGE,CAHnC;IAIA,KAAKT,MAAL,CAAYU,YAAZ,GAA4B,OAAO0B,GAAG,CAAC1B,YAAX,KAA4B,QAA5B,IACG0B,GAAG,CAAC1B,YAAJ,IAAoB,CADvB,GAEE0B,GAAG,CAAC1B,YAFN,GAGE,KAH9B;IAIA,KAAKV,MAAL,CAAYW,KAAZ,GAAqB,OAAOyB,GAAG,CAACzB,KAAX,KAAqB,QAArB,IACG6B,MAAM,CAACC,QAAP,CAAgBL,GAAG,CAACzB,KAApB,CADH,GAEEyB,GAAG,CAACzB,KAFN,GAGET,SAHvB;IAKA,MAAMwC,UAAU,GAAG;MACjBC,GAAG,EAAEzC,SADY;MAEjB0C,aAAa,EAAE1C,SAFE;MAGjB2C,EAAE,EAAE;QACFC,MAAM,EAAE5C,SADN;QAEF6C,GAAG,EAAE7C,SAFH;QAGF8C,QAAQ,EAAE9C,SAHR;QAIF+C,IAAI,EAAE;MAJJ,CAHa;MASjBC,EAAE,EAAEhD;IATa,CAAnB;IAWA,IAAIiD,gBAAgB,GAAG,IAAvB;;IACA,IAAI,OAAOf,GAAG,CAACM,UAAX,KAA0B,QAA1B,IAAsCN,GAAG,CAACM,UAAJ,KAAmB,IAA7D,EAAmE;MACjEA,UAAU,CAACC,GAAX,GAAiBtD,qBAAqB,CAAC+C,GAAG,CAACM,UAAJ,CAAeC,GAAhB,EACCpF,WADD,EAECO,aAFD,CAAtC;MAGA,IAAI4E,UAAU,CAACC,GAAX,KAAmBpF,WAAvB,EACE4F,gBAAgB,GAAG,KAAnB;MAEFT,UAAU,CAACE,aAAX,GACEvD,qBAAqB,CAAC+C,GAAG,CAACM,UAAJ,CAAeE,aAAhB,EACCnF,uBADD,EAECO,yBAFD,CADvB;MAIA,IAAI0E,UAAU,CAACE,aAAX,KAA6BnF,uBAAjC,EACE0F,gBAAgB,GAAG,KAAnB;MAEFT,UAAU,CAACG,EAAX,CAAcC,MAAd,GAAuBzD,qBAAqB,CAAC+C,GAAG,CAACM,UAAJ,CAAeI,MAAhB,EACCzF,cADD,EAECO,gBAFD,CAA5C;MAGA,IAAI8E,UAAU,CAACG,EAAX,CAAcC,MAAd,KAAyBzF,cAA7B,EACE8F,gBAAgB,GAAG,KAAnB;MAEFT,UAAU,CAACG,EAAX,CAAcE,GAAd,GAAoB1D,qBAAqB,CAAC+C,GAAG,CAACM,UAAJ,CAAeU,IAAhB,EACC5F,WADD,EAECO,aAFD,CAAzC;MAGA,IAAI2E,UAAU,CAACG,EAAX,CAAcE,GAAd,KAAsBvF,WAA1B,EACE2F,gBAAgB,GAAG,KAAnB;MAEFT,UAAU,CAACG,EAAX,CAAcG,QAAd,GAAyB3D,qBAAqB,CAAC+C,GAAG,CAACM,UAAJ,CAAeM,QAAhB,EACC1F,mBADD,EAECO,qBAFD,CAA9C;MAGA,IAAI6E,UAAU,CAACG,EAAX,CAAcG,QAAd,KAA2B1F,mBAA/B,EACE6F,gBAAgB,GAAG,KAAnB;MAEF,IAAI,CAACA,gBAAL,EACET,UAAU,CAACQ,EAAX,GAAgBR,UAAU,CAACG,EAA3B;IACH;;IAED,IAAI,OAAOT,GAAG,CAACxB,QAAX,KAAwB,QAA5B,EACE,KAAKZ,MAAL,CAAYY,QAAZ,GAAuBwB,GAAG,CAACxB,QAA3B,CADF,KAEK,IAAI,OAAOwB,GAAG,CAACiB,IAAX,KAAoB,QAAxB,EACH,KAAKrD,MAAL,CAAYY,QAAZ,GAAuBwB,GAAG,CAACiB,IAA3B,CADG,KAGH,MAAM,IAAIC,KAAJ,CAAU,kBAAV,CAAN;IAEF,KAAKtD,MAAL,CAAYa,QAAZ,GAAwB,OAAOuB,GAAG,CAACvB,QAAX,KAAwB,QAAxB,GACEuB,GAAG,CAACvB,QADN,GAEEX,SAF1B;IAGA,KAAKF,MAAL,CAAYc,UAAZ,GAA0B,OAAOsB,GAAG,CAACtB,UAAX,KAA0B,QAA1B,IACG0B,MAAM,CAACC,QAAP,CAAgBL,GAAG,CAACtB,UAApB,CADH,GAEEsB,GAAG,CAACtB,UAFN,GAGEZ,SAH5B;IAIA,KAAKF,MAAL,CAAYuD,aAAZ,GAA6B,OAAOnB,GAAG,CAACmB,aAAX,KAA6B,QAA7B,GACEnB,GAAG,CAACmB,aADN,GAEErD,SAF/B;IAGA,KAAKF,MAAL,CAAYwD,aAAZ,GAA6B,OAAOpB,GAAG,CAACoB,aAAX,KAA6B,QAA7B,GACEpB,GAAG,CAACoB,aADN,GAEEtD,SAF/B;IAGA,KAAKF,MAAL,CAAYe,WAAZ,GAA2BqB,GAAG,CAACrB,WAAJ,KAAoB,IAA/C;IACA,IAAI,OAAOqB,GAAG,CAACpB,KAAX,KAAqB,QAArB,IAAiCoB,GAAG,CAACpB,KAAJ,CAAUyC,MAA/C,EACE,KAAKzD,MAAL,CAAYgB,KAAZ,GAAoBnC,WAAW,CAACuD,GAAG,CAACpB,KAAL,CAA/B,CADF,KAEK,IAAIlC,OAAO,CAACsD,GAAG,CAACpB,KAAL,CAAX,EACH,KAAKhB,MAAL,CAAYgB,KAAZ,GAAoBoB,GAAG,CAACpB,KAAxB,CADG,KAGH,KAAKhB,MAAL,CAAYgB,KAAZ,GAAoBd,SAApB;IACF,KAAKF,MAAL,CAAYiB,aAAZ,GAA6BmB,GAAG,CAACsB,YAAJ,KAAqB,IAArB,IACG,KAAK1D,MAAL,CAAYgB,KAAZ,KAAsBd,SADtD;IAEA,IAAIgB,WAAW,GAAG,KAAKlB,MAAL,CAAYkB,WAAZ,GAChB,OAAOkB,GAAG,CAAClB,WAAX,KAA2B,UAA3B,IACGyC,KAAK,CAACC,OAAN,CAAcxB,GAAG,CAAClB,WAAlB,CADH,GAEEkB,GAAG,CAAClB,WAFN,GAGEhB,SAJJ;IAOA,KAAKF,MAAL,CAAYqB,YAAZ,GAA4B,OAAOe,GAAG,CAACf,YAAX,KAA4B,SAA5B,GACEe,GAAG,CAACf,YADN,GAEE,IAF9B;IAIA,MAAMC,KAAK,GAAG,KAAKtB,MAAL,CAAYsB,KAAZ,GAAqB,OAAOc,GAAG,CAACd,KAAX,KAAqB,UAArB,GACEc,GAAG,CAACd,KADN,GAEEpB,SAFrC;;IAIA,IAAIkC,GAAG,CAACsB,YAAJ,KAAqB,IAArB,IAA6B,CAAC,KAAK1D,MAAL,CAAYiB,aAA9C,EAA6D;MAC3D,MAAM,IAAIqC,KAAJ,CACJ,2DADI,CAAN;IAGD;;IAED,IAAIO,SAAS,GAAG,KAAKnC,UAAL,GAAkB,EAAlC;IACA,KAAKD,QAAL,GAAgB,IAAIrC,cAAJ,CAAmB,IAAnB,CAAhB;IACA,KAAKuC,WAAL,GAAmB,EAAnB;IACA,KAAKC,eAAL,GAAuB,EAAvB;IACA,KAAKC,UAAL,GAAkB,CAAlB;IACA,KAAKC,gBAAL,GAAwB,KAAxB;IACA,KAAKP,MAAL,GAAe,KAAKvB,MAAL,CAAYgB,KAAZ,GAAoB,KAAKhB,MAAL,CAAYgB,KAAhC,GAAwCd,SAAvD;IACA,KAAK6B,UAAL,GAAkB7B,SAAlB;IACA,IAAIY,UAAJ;;IAEA,IAAI,KAAKd,MAAL,CAAYc,UAAhB,EAA4B;MAC1BA,UAAU,GAAG1C,QAAQ,CAAC,KAAK4B,MAAL,CAAYc,UAAb,EAAyBsB,GAAG,CAAC0B,UAA7B,CAArB;MACA,IAAIhD,UAAU,YAAYwC,KAA1B,EACE,MAAM,IAAIA,KAAJ,CAAW,4BAA2BxC,UAAU,CAACiD,OAAQ,EAAzD,CAAN;;MACF,IAAIJ,KAAK,CAACC,OAAN,CAAc9C,UAAd,CAAJ,EAA+B;QAC7B;QACAA,UAAU,GAAGA,UAAU,CAAC,CAAD,CAAvB;MACD;;MACD,IAAIA,UAAU,CAACkD,aAAX,OAA+B,IAAnC,EAAyC;QACvC,MAAM,IAAIV,KAAJ,CACJ,yDADI,CAAN;MAGD;IACF;;IAED,IAAIW,YAAJ;;IACA,IAAI,OAAO7B,GAAG,CAAC6B,YAAX,KAA4B,UAAhC,EAA4C;MAC1C,MAAMC,MAAM,GAAG9B,GAAG,CAAC6B,YAAnB;MACA,IAAIE,MAAJ;;MACA,IAAInH,MAAM,CAACoH,OAAP,CAAehC,GAAG,CAACiC,QAAnB,MAAiC,CAAC,CAAtC,EAAyC;QACvC;QACAF,MAAM,GAAG3H,UAAU,CAAC4F,GAAG,CAACiC,QAAL,CAAnB;MACD;;MACDJ,YAAY,GAAG,CAACK,GAAD,EAAMC,MAAN,KAAiB;QAC9B,IAAIJ,MAAJ,EAAY;UACVA,MAAM,CAACK,MAAP,CAAcF,GAAd;UACAA,GAAG,GAAGH,MAAM,CAACM,MAAP,CAAc,KAAd,CAAN;QACD;;QACD,MAAMC,GAAG,GAAGR,MAAM,CAACI,GAAD,EAAMC,MAAN,CAAlB;QACA,IAAIG,GAAG,KAAKxE,SAAZ,EACEqE,MAAM,CAACG,GAAD,CAAN;MACH,CARD;IASD;;IAED,MAAMC,IAAI,GAAG,KAAK1C,KAAL,GAAcG,GAAG,CAACuC,IAAJ,IAAY,IAAI/H,MAAJ,EAAvC;IACA,IAAIgI,KAAK,GAAG,KAAZ;IACA,IAAIC,SAAS,GAAG,KAAhB;IACA,IAAI,KAAK7C,SAAT,EACE,KAAKA,SAAL,CAAe8C,OAAf;IACF,MAAMC,aAAa,GAAI,CAACzD,KAAD,GAASpB,SAAT,GAAqB,CAAC8E,CAAD,EAAIC,OAAJ,EAAaC,GAAb,KAAqB;MAC/D5D,KAAK,CAAE,6BAA4B6D,IAAI,CAACC,SAAL,CAAeF,GAAf,CAAoB,EAAlD,CAAL;IACD,CAFD;IAGA,MAAMG,KAAK,GAAG,KAAKrD,SAAL,GAAiB,IAAI7D,QAAJ,CAAa;MAC1CwC,KAAK,EAAE,KAAKX,MAAL,CAAYW,KADuB;MAE1C2E,KAAK,EAAGnC,gBAAgB,GAAGjD,SAAH,GAAewC,UAFG;MAG1C6C,OAAO,EAAGC,IAAD,IAAU;QACjB,IAAIlG,UAAU,CAACqF,IAAD,CAAd,EACEA,IAAI,CAACc,KAAL,CAAWD,IAAX;MACH,CANyC;MAO1CE,OAAO,EAAG7F,GAAD,IAAS;QAChB,IAAIA,GAAG,CAAC8F,KAAJ,KAAc,WAAlB,EACEC,YAAY,CAAC,KAAKpE,aAAN,CAAZ;QACF,IAAI,CAAC6D,KAAK,CAACQ,SAAX,EACElB,IAAI,CAACmB,kBAAL,CAAwB,MAAxB;QACF,KAAKC,IAAL,CAAU,OAAV,EAAmBlG,GAAnB;;QACA,IAAI;UACF8E,IAAI,CAACrC,GAAL;QACD,CAFD,CAEE,MAAM,CAAE;MACX,CAhByC;MAiB1C0D,QAAQ,EAAGC,MAAD,IAAY;QACpBpB,SAAS,GAAG,IAAZ;QACA,KAAK9C,UAAL,GAAkBkE,MAAM,CAACC,QAAP,CAAgBC,QAAlC;QACA,IAAIF,MAAM,CAACG,QAAX,EACE,KAAKL,IAAL,CAAU,UAAV,EAAsBE,MAAM,CAACG,QAA7B;MACH,CAtByC;MAuB1CC,mBAAmB,EAAGC,UAAD,IAAgB;QACnC,KAAKP,IAAL,CAAU,WAAV,EAAuBO,UAAvB;;QACA,IAAI,CAAC1B,KAAL,EAAY;UACVA,KAAK,GAAG,IAAR;UACAS,KAAK,CAACkB,OAAN,CAAc,cAAd;QACD;MACF,CA7ByC;MA8B1CjF,KA9B0C;MA+B1C2C,YA/B0C;MAgC1CuC,eAAe,EAAE;QACfC,KAAK,EAAE1B,aADQ;QAEf2B,UAAU,EAAE,CAAC1B,CAAD,EAAI2B,MAAJ,EAAYC,IAAZ,KAAqB;UAC/B,IAAID,MAAM,KAAKjJ,iBAAiB,CAACmJ,cAAjC,EAAiD;YAC/C,IAAI,CAACD,IAAL,EAAW;cACTA,IAAI,GAAGjJ,0BAA0B,CAACgJ,MAAD,CAAjC;cACA,IAAIC,IAAI,KAAK1G,SAAb,EACE0G,IAAI,GAAI,oCAAmCD,MAAO,EAAlD;YACH;;YACD,MAAM9G,GAAG,GAAG,IAAIyD,KAAJ,CAAUsD,IAAV,CAAZ;YACA/G,GAAG,CAACiH,IAAJ,GAAWH,MAAX;YACA,KAAKZ,IAAL,CAAU,OAAV,EAAmBlG,GAAnB;UACD;;UACD8E,IAAI,CAACrC,GAAL;QACD,CAdc;QAefyE,cAAc,EAAE,CAAC/B,CAAD,EAAIgC,IAAJ,KAAa;UAC3B,IAAIA,IAAI,KAAK,cAAb,EACEC,WAAW;QACd,CAlBc;QAmBfC,eAAe,EAAE,CAAClC,CAAD,EAAIE,GAAJ,KAAY;UAC3B,KAAKa,IAAL,CAAU,QAAV,EAAoBb,GAApB;QACD,CArBc;QAsBfiC,gBAAgB,EAAGnC,CAAD,IAAO;UACvB;UACAoC,OAAO;UAEPxB,YAAY,CAAC,KAAKpE,aAAN,CAAZ;UAEA,KAAKuE,IAAL,CAAU,OAAV;QACD,CA7Bc;QA8BfsB,gBAAgB,EAAE,CAACrC,CAAD,EAAIsC,WAAJ,EAAiBC,cAAjB,KAAoC;UACpD,IAAIC,OAAO,CAACC,IAAR,KAAiB,OAArB,EAA8B;YAC5B,MAAMC,GAAG,GAAGF,OAAO,CAACG,QAAR,CAAiBD,GAAjB,EAAZ;YACApG,KAAK,IAAIA,KAAK,CAAE,sBAAqBoG,GAAG,GAAG,CAAE,SAA/B,CAAd;YACA,OAAOE,eAAe,EAAtB;UACD;;UAEDtG,KAAK,IAAIA,KAAK,CAAE,WAAUkG,OAAO,CAACC,IAAK,cAAzB,CAAd;UAEAI,UAAU,GAAGN,cAAb;UACAO,YAAY,GAAGR,WAAf;UACAL,WAAW;QACZ,CA1Cc;QA2Cfc,yBAAyB,EAAE,CAAC/C,CAAD,EAAIgD,MAAJ,KAAe;UACxC,IAAIR,OAAO,CAACC,IAAR,KAAiB,UAArB,EAAiC;YAC/B;YACA;YACA,KAAK1B,IAAL,CAAU,iBAAV,EAA6BiC,MAA7B,EAAsCC,WAAD,IAAiB;cACpD5C,KAAK,CAAC6C,YAAN,CACE,KAAKlI,MAAL,CAAYY,QADd,EAEE,KAAKZ,MAAL,CAAYa,QAFd,EAGEoH,WAHF;YAKD,CAND;UAOD;QACF,CAvDc;QAwDfE,cAAc,EAAGnD,CAAD,IAAO;UACrB,IAAIwC,OAAO,CAACC,IAAR,KAAiB,OAArB,EAA8B;YAC5B,MAAMnD,GAAG,GAAGkD,OAAO,CAACG,QAAR,CAAiBS,UAAjB,EAAZ;YACA/C,KAAK,CAACgD,MAAN,CAAab,OAAO,CAAC5G,QAArB,EAA+B0D,GAA/B,EAAoC,CAACgE,GAAD,EAAMC,EAAN,KAAa;cAC/Cf,OAAO,CAACG,QAAR,CAAiBa,IAAjB,CAAsBlE,GAAtB,EAA2BgE,GAA3B,EAAgC,EAAhC,EAAoC,CAACzI,GAAD,EAAM4I,MAAN,KAAiB;gBACnD,IAAI5I,GAAJ,EAAS;kBACPA,GAAG,CAAC8F,KAAJ,GAAY,OAAZ;kBACA,KAAKI,IAAL,CAAU,OAAV,EAAmBlG,GAAnB;gBACD,CAHD,MAGO;kBACL,OAAO0I,EAAE,CAACE,MAAD,CAAT;gBACD;;gBAEDb,eAAe;cAChB,CATD;YAUD,CAXD;UAYD,CAdD,MAcO,IAAIJ,OAAO,CAACC,IAAR,KAAiB,WAArB,EAAkC;YACvCpC,KAAK,CAACgD,MAAN,CAAab,OAAO,CAAC5G,QAArB,EAA+B4G,OAAO,CAAClD,GAAvC,EAA4C,CAACgE,GAAD,EAAMC,EAAN,KAAa;cACvD,MAAMG,SAAS,GAAGlB,OAAO,CAAClD,GAAR,CAAYkE,IAAZ,CAAiBF,GAAjB,CAAlB;;cACA,IAAII,SAAS,YAAYpF,KAAzB,EAAgC;gBAC9BoF,SAAS,CAAC3E,OAAV,GACG,gCAA+B2E,SAAS,CAAC3E,OAAQ,EADpD;gBAEA2E,SAAS,CAAC/C,KAAV,GAAkB,uBAAlB;gBACA,KAAKI,IAAL,CAAU,OAAV,EAAmB2C,SAAnB;gBACA,OAAOzB,WAAW,EAAlB;cACD;;cACDsB,EAAE,CAACG,SAAD,CAAF;YACD,CAVD;UAWD;QACF,CApFc;QAqFfC,qBAAqB,EAAE,CAAC3D,CAAD,EAAIgC,IAAJ,EAAU4B,YAAV,EAAwBC,OAAxB,KAAoC;UACzD,IAAIrB,OAAO,CAACC,IAAR,KAAiB,sBAArB,EAA6C;YAC3C,MAAMqB,QAAQ,GAAInF,KAAK,CAACC,OAAN,CAAciF,OAAd,IAAyBA,OAAO,CAACpF,MAAjC,GAA0C,CAA5D;;YACA,IAAIqF,QAAQ,KAAK,CAAjB,EAAoB;cAClBxH,KAAK,IAAIA,KAAK,CACZ,kDADY,CAAd;cAGA+D,KAAK,CAAC0D,WAAN;cACA;YACD,CAR0C,CAS3C;YACA;YACA;;;YACAvB,OAAO,CAACQ,MAAR,CACEhB,IADF,EAEE4B,YAFF,EAGE,EAHF,EAIEC,OAJF,EAKGG,OAAD,IAAa;cACX3D,KAAK,CAAC0D,WAAN,CAAkBC,OAAlB;YACD,CAPH;UASD;QACF,CA5Gc;QA6GfC,eAAe,EAAE,CAACjE,CAAD,EAAIQ,IAAJ,KAAa;UAC5B,IAAI3B,SAAS,CAACJ,MAAd,EACEI,SAAS,CAACqF,KAAV,GAAkB,KAAlB,EAAyB1D,IAAzB;QACH,CAhHc;QAiHf2D,eAAe,EAAGnE,CAAD,IAAO;UACtB,IAAInB,SAAS,CAACJ,MAAd,EACEI,SAAS,CAACqF,KAAV,GAAkB,IAAlB;QACH,CApHc;QAqHfE,cAAc,EAAE,CAACpE,CAAD,EAAIgC,IAAJ,EAAUqC,SAAV,EAAqB7D,IAArB,KAA8B;UAC5C,QAAQwB,IAAR;YACE,KAAK,yBAAL;cACE;cACAsC,aAAa,CAAC,IAAD,EAAO9D,IAAP,EAAa,CAAC3F,GAAD,EAAM0J,IAAN,KAAe;gBACvC,IAAI1J,GAAJ,EACE;gBACF,KAAKkG,IAAL,CAAU,UAAV,EAAsBwD,IAAtB;cACD,CAJY,CAAb;cAKA,IAAIF,SAAJ,EACEhE,KAAK,CAACmE,cAAN;cACF;;YACF;cACE;cACA;cACA;cACA,IAAIH,SAAJ,EACEhE,KAAK,CAACoE,cAAN;UAhBN;QAkBD,CAxIc;QAyIfC,YAAY,EAAE,CAAC1E,CAAD,EAAI2E,IAAJ,KAAa;UACzB;UACA;UACAC,cAAc,CAAC,IAAD,EAAOD,IAAP,CAAd;QACD,CA7Ic;QA8IfE,yBAAyB,EAAE,CAAC7E,CAAD,EAAI2E,IAAJ,KAAa;UACtC,MAAMG,OAAO,GAAG,KAAKrI,QAAL,CAAcsI,GAAd,CAAkBJ,IAAI,CAACK,SAAvB,CAAhB;;UACA,IAAI,OAAOF,OAAP,KAAmB,UAAvB,EACE;UAEF,MAAMG,MAAM,GAAIH,OAAO,CAACrC,IAAR,KAAiB,MAAjC;UACA,MAAMA,IAAI,GAAIwC,MAAM,GAAG,SAAH,GAAeH,OAAO,CAACrC,IAA3C;UACA,MAAMyC,QAAQ,GAAG;YACfzC,IADe;YAEf0C,QAAQ,EAAE;cACRC,EAAE,EAAET,IAAI,CAACK,SADD;cAERK,MAAM,EAAErL,UAFA;cAGRsL,UAAU,EAAErL,WAHJ;cAIRsL,KAAK,EAAE;YAJC,CAFK;YAQfC,QAAQ,EAAE;cACRJ,EAAE,EAAET,IAAI,CAACc,MADD;cAERJ,MAAM,EAAEV,IAAI,CAACU,MAFL;cAGRC,UAAU,EAAEX,IAAI,CAACW,UAHT;cAIRC,KAAK,EAAE;YAJC;UARK,CAAjB;UAeA,MAAMG,QAAQ,GACZT,MAAM,GACJ,IAAI5L,IAAJ,CAAS,IAAT,EAAe6L,QAAf,EAAyB;YAAE5I;UAAF,CAAzB,CADI,GAEJ,IAAIvC,OAAJ,CAAY,IAAZ,EAAkBmL,QAAlB,CAHJ;;UAKA,KAAKzI,QAAL,CAAc+C,MAAd,CAAqBmF,IAAI,CAACK,SAA1B,EAAqCU,QAArC;;UACAZ,OAAO,CAAC5J,SAAD,EAAYwK,QAAZ,CAAP;QACD,CA3Kc;QA4KftN,oBAAoB,EAAE,CAAC4H,CAAD,EAAIgF,SAAJ,EAAerD,MAAf,EAAuBgE,WAAvB,KAAuC;UAC3D,MAAMb,OAAO,GAAG,KAAKrI,QAAL,CAAcsI,GAAd,CAAkBC,SAAlB,CAAhB;;UACA,IAAI,OAAOF,OAAP,KAAmB,UAAvB,EACE;UAEF,MAAMH,IAAI,GAAG;YAAEhD,MAAF;YAAUgE;UAAV,CAAb;UACApL,oBAAoB,CAAC,IAAD,EAAOyK,SAAP,EAAkBL,IAAlB,EAAwBG,OAAxB,CAApB;QACD,CAnLc;QAoLfc,YAAY,EAAE,CAAC5F,CAAD,EAAIgF,SAAJ,EAAexE,IAAf,KAAwB;UACpC,MAAMsE,OAAO,GAAG,KAAKrI,QAAL,CAAcsI,GAAd,CAAkBC,SAAlB,CAAhB;;UACA,IAAI,OAAOF,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAK,IAA/C,EACE,OAHkC,CAKpC;UACA;UACA;;UACA,IAAIA,OAAO,CAACK,QAAR,CAAiBE,MAAjB,KAA4B,CAAhC,EACE;UAEFP,OAAO,CAACK,QAAR,CAAiBE,MAAjB,IAA2B7E,IAAI,CAAC/B,MAAhC;;UAEA,IAAIqG,OAAO,CAACe,IAAR,CAAarF,IAAb,MAAuB,KAA3B,EAAkC;YAChCsE,OAAO,CAACgB,cAAR,GAAyB,IAAzB;YACA;UACD;;UAED,IAAIhB,OAAO,CAACK,QAAR,CAAiBE,MAAjB,IAA2BlL,gBAA/B,EACED,YAAY,CAAC4K,OAAD,CAAZ;QACH,CAxMc;QAyMfiB,qBAAqB,EAAE,CAAC/F,CAAD,EAAIgF,SAAJ,EAAexE,IAAf,EAAqBiC,IAArB,KAA8B;UACnD,IAAIA,IAAI,KAAKtK,MAAb,EACE;;UAEF,MAAM2M,OAAO,GAAG,KAAKrI,QAAL,CAAcsI,GAAd,CAAkBC,SAAlB,CAAhB;;UACA,IAAI,OAAOF,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAK,IAA/C,EACE,OANiD,CAQnD;UACA;UACA;;UACA,IAAIA,OAAO,CAACK,QAAR,CAAiBE,MAAjB,KAA4B,CAAhC,EACE;UAEFP,OAAO,CAACK,QAAR,CAAiBE,MAAjB,IAA2B7E,IAAI,CAAC/B,MAAhC;;UAEA,IAAI,CAACqG,OAAO,CAACkB,MAAR,CAAeH,IAAf,CAAoBrF,IAApB,CAAL,EAAgC;YAC9BsE,OAAO,CAACgB,cAAR,GAAyB,IAAzB;YACA;UACD;;UAED,IAAIhB,OAAO,CAACK,QAAR,CAAiBE,MAAjB,IAA2BlL,gBAA/B,EACED,YAAY,CAAC4K,OAAD,CAAZ;QACH,CAhOc;QAiOfmB,qBAAqB,EAAE,CAACjG,CAAD,EAAIgF,SAAJ,EAAekB,MAAf,KAA0B;UAC/C,MAAMpB,OAAO,GAAG,KAAKrI,QAAL,CAAcsI,GAAd,CAAkBC,SAAlB,CAAhB;;UACA,IAAI,OAAOF,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAK,IAA/C,EACE,OAH6C,CAK/C;;UACAA,OAAO,CAACU,QAAR,CAAiBH,MAAjB,IAA2Ba,MAA3B;;UAEA,IAAIpB,OAAO,CAACqB,WAAZ,EAAyB;YACvBrB,OAAO,CAACqB,WAAR,GAAsB,KAAtB;;YAEA,IAAIrB,OAAO,CAACsB,MAAZ,EAAoB;cAClBtB,OAAO,CAACuB,MAAR,CAAevB,OAAO,CAACsB,MAAvB,EAA+B,IAA/B,EAAqCtB,OAAO,CAACwB,QAA7C;YACD,CAFD,MAEO,IAAIxB,OAAO,CAACwB,QAAZ,EAAsB;cAC3BxB,OAAO,CAACwB,QAAR;YACD,CAFM,MAEA,IAAIxB,OAAO,CAACyB,SAAZ,EAAuB;cAC5BzB,OAAO,CAACkB,MAAR,CAAeK,MAAf,CAAsBvB,OAAO,CAACyB,SAA9B,EACsB,IADtB,EAEsBzB,OAAO,CAAC0B,WAF9B;YAGD,CAJM,MAIA,IAAI1B,OAAO,CAAC0B,WAAZ,EAAyB;cAC9B1B,OAAO,CAAC0B,WAAR;YACD;UACF;QACF,CAxPc;QAyPfC,eAAe,EAAE,CAACzG,CAAD,EAAIgF,SAAJ,KAAkB;UACjC,MAAMF,OAAO,GAAG,KAAKrI,QAAL,CAAcsI,GAAd,CAAkBC,SAAlB,CAAhB;;UACA,IAAI,OAAOF,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAK,IAA/C,EACE;;UAEF,KAAK5H,QAAL;;UAEA,IAAI4H,OAAO,CAACpI,UAAR,CAAmB+B,MAAvB,EACEqG,OAAO,CAACpI,UAAR,CAAmBwH,KAAnB,GAA2B,KAA3B;QACH,CAlQc;QAmQfwC,eAAe,EAAE,CAAC1G,CAAD,EAAIgF,SAAJ,KAAkB;UACjC,MAAMF,OAAO,GAAG,KAAKrI,QAAL,CAAcsI,GAAd,CAAkBC,SAAlB,CAAhB;;UACA,IAAI,OAAOF,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAK,IAA/C,EACE;;UAEF,KAAK5H,QAAL;;UAEA,IAAI4H,OAAO,CAACpI,UAAR,CAAmB+B,MAAvB,EACEqG,OAAO,CAACpI,UAAR,CAAmBwH,KAAnB,GAA2B,IAA3B;QACH,CA5Qc;QA6QfyC,eAAe,EAAE,CAAC3G,CAAD,EAAIgF,SAAJ,EAAevC,IAAf,EAAqB4B,SAArB,EAAgC7D,IAAhC,KAAyC;UACxD,MAAMsE,OAAO,GAAG,KAAKrI,QAAL,CAAcsI,GAAd,CAAkBC,SAAlB,CAAhB;;UACA,IAAI,OAAOF,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAK,IAA/C,EACE;UAEF,MAAM8B,IAAI,GAAG9B,OAAO,CAAC+B,KAArB;UACA,IAAID,IAAI,CAAC9E,IAAL,KAAc5G,SAAlB,EACE;;UACF,QAAQuH,IAAR;YACE,KAAK,aAAL;cACEqC,OAAO,CAAC/D,IAAR,CAAa,MAAb,EAAqB6F,IAAI,CAAC9E,IAAL,GAAYtB,IAAjC;cACA;;YACF,KAAK,aAAL;cACEsE,OAAO,CAAC/D,IAAR,CAAa,MAAb,EACa6F,IAAI,CAAC9E,IAAL,GAAY,IADzB,EAEa8E,IAAI,CAACE,MAAL,GAAe,MAAKtG,IAAI,CAACsG,MAAO,EAF7C,EAGaF,IAAI,CAACG,IAAL,GAAYvG,IAAI,CAACwG,UAH9B,EAIaJ,IAAI,CAAChF,IAAL,GAAYpB,IAAI,CAACyG,YAJ9B;cAKA;UAVJ,CARwD,CAqBxD;UACA;;;UAEA,IAAI5C,SAAJ,EACErE,CAAC,CAACkH,cAAF,CAAiBpC,OAAO,CAACU,QAAR,CAAiBJ,EAAlC;QACH,CAvSc;QAwSf+B,WAAW,EAAE,CAACnH,CAAD,EAAIgF,SAAJ,KAAkB;UAC7B,MAAMF,OAAO,GAAG,KAAKrI,QAAL,CAAcsI,GAAd,CAAkBC,SAAlB,CAAhB;;UACA,IAAI,OAAOF,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAK,IAA/C,EACE;UAEF,IAAIA,OAAO,CAACK,QAAR,CAAiBI,KAAjB,KAA2B,MAA/B,EACE;UACFT,OAAO,CAACK,QAAR,CAAiBI,KAAjB,GAAyB,KAAzB;UAEA,IAAIT,OAAO,CAACsC,QAAZ,EACEtC,OAAO,CAACe,IAAR,CAAa,IAAb;UACF,IAAIf,OAAO,CAACkB,MAAR,CAAeoB,QAAnB,EACEtC,OAAO,CAACkB,MAAR,CAAeH,IAAf,CAAoB,IAApB;QACH,CArTc;QAsTfwB,aAAa,EAAE,CAACrH,CAAD,EAAIgF,SAAJ,KAAkB;UAC/BxK,eAAe,CAAC,IAAD,EAAOwK,SAAP,EAAkB,KAAKvI,QAAL,CAAcsI,GAAd,CAAkBC,SAAlB,CAAlB,CAAf;QACD;MAxTc;IAhCyB,CAAb,CAA/B;IA4VArF,IAAI,CAAC2H,KAAL,GAvhBW,CAyhBX;IACA;;IACA,MAAMC,UAAU,GAAG,KAAKvM,MAAL,CAAYS,iBAA/B;IACA,MAAM+L,UAAU,GAAG,KAAKxM,MAAL,CAAYQ,iBAA/B;IACA,IAAIiM,OAAO,GAAG,CAAd;IACA,IAAIC,OAAJ;;IACA,MAAMC,MAAM,GAAG,MAAM;MACnB,IAAI,EAAEF,OAAF,GAAYD,UAAhB,EAA4B;QAC1BI,aAAa,CAACF,OAAD,CAAb;;QACA,IAAI/H,IAAI,CAACyH,QAAT,EAAmB;UACjB,MAAMvM,GAAG,GAAG,IAAIyD,KAAJ,CAAU,mBAAV,CAAZ;UACAzD,GAAG,CAAC8F,KAAJ,GAAY,gBAAZ;UACA,KAAKI,IAAL,CAAU,OAAV,EAAmBlG,GAAnB;UACA8E,IAAI,CAACkI,OAAL;QACD;;QACD;MACD;;MACD,IAAIvN,UAAU,CAACqF,IAAD,CAAd,EAAsB;QACpB;QACAd,SAAS,CAACgH,IAAV,CAAezD,OAAf;QACA/B,KAAK,CAACyH,IAAN;MACD,CAJD,MAIO;QACLF,aAAa,CAACF,OAAD,CAAb;MACD;IACF,CAlBD;;IAmBA,SAAStF,OAAT,GAAmB;MACjB,IAAImF,UAAU,GAAG,CAAjB,EAAoB;QAClBE,OAAO,GAAG,CAAV;QACAG,aAAa,CAACF,OAAD,CAAb;QACA,IAAIpN,UAAU,CAACqF,IAAD,CAAd,EACE+H,OAAO,GAAGK,WAAW,CAACJ,MAAD,EAASJ,UAAT,CAArB;MACH;IACF;;IACD,KAAKrK,QAAL,GAAgBkF,OAAhB;;IAEA,MAAM4F,MAAM,GAAG,CAAC,MAAM;MACpB,IAAIC,MAAM,GAAG,KAAb;MACA,OAAO,MAAM;QACX,IAAIA,MAAJ,EACE;QACFA,MAAM,GAAG,IAAT;;QACA,IAAIC,YAAY,IAAI,CAACrI,SAArB,EAAgC;UAC9B,MAAMhF,GAAG,GACPrB,SAAS,CAAC,kCAAD,EAAqC,UAArC,EAAiD,IAAjD,CADX;UAEA,KAAKuH,IAAL,CAAU,OAAV,EAAmBlG,GAAnB;QACD;MACF,CATD;IAUD,CAZc,GAAf;;IAaA,MAAMsN,SAAS,GAAG,CAAC,MAAM;MACvB,IAAIF,MAAM,GAAG,KAAb;MACA,OAAO,MAAM;QACX,IAAIA,MAAJ,EACE;QACFA,MAAM,GAAG,IAAT;QAEAC,YAAY,GAAG,IAAf;QACA5L,KAAK,IAAIA,KAAK,CAAC,kBAAD,CAAd;QACA,KAAKyE,IAAL,CAAU,SAAV;QAEA7H,UAAU,CAACkP,IAAX,CAAgB,MAAM;UACpB/H,KAAK,CAACgI,KAAN;UACA1I,IAAI,CAAC2I,EAAL,CAAQ,MAAR,EAAiB9H,IAAD,IAAU;YACxB,IAAI;cACFH,KAAK,CAACkI,KAAN,CAAY/H,IAAZ,EAAkB,CAAlB,EAAqBA,IAAI,CAAC/B,MAA1B;YACD,CAFD,CAEE,OAAO+J,EAAP,EAAW;cACX,KAAKzH,IAAL,CAAU,OAAV,EAAmByH,EAAnB;;cACA,IAAI;gBACF,IAAIlO,UAAU,CAACqF,IAAD,CAAd,EACEA,IAAI,CAACrC,GAAL;cACH,CAHD,CAGE,MAAM,CAAE;YACX;UACF,CAVD,EAFoB,CAcpB;;UACA,IAAIqC,IAAI,CAACqG,MAAL,IAAe,OAAOrG,IAAI,CAACqG,MAAL,CAAYyC,MAAnB,KAA8B,UAAjD,EACE9I,IAAI,CAACqG,MAAL,CAAYyC,MAAZ;UAEF9I,IAAI,CAAC8I,MAAL;QACD,CAnBD,EAmBGC,KAnBH,CAmBU7N,GAAD,IAAS;UAChB,KAAKkG,IAAL,CAAU,OAAV,EAAmBlG,GAAnB;;UACA,IAAI;YACF,IAAIP,UAAU,CAACqF,IAAD,CAAd,EACEA,IAAI,CAACrC,GAAL;UACH,CAHD,CAGE,MAAM,CAAE;QACX,CAzBD;MA0BD,CAnCD;IAoCD,CAtCiB,GAAlB;;IAuCA,IAAI4K,YAAY,GAAG,KAAnB;IACAvI,IAAI,CAAC2I,EAAL,CAAQ,SAAR,EAAmBH,SAAnB,EACKG,EADL,CACQ,SADR,EACmB,MAAM;MACvB,KAAKvH,IAAL,CAAU,SAAV;IACD,CAHD,EAGGuH,EAHH,CAGM,OAHN,EAGgBzN,GAAD,IAAS;MACtByB,KAAK,IAAIA,KAAK,CAAE,iBAAgBzB,GAAG,CAACkE,OAAQ,EAA9B,CAAd;MACA6B,YAAY,CAAC,KAAKpE,aAAN,CAAZ;MACA3B,GAAG,CAAC8F,KAAJ,GAAY,eAAZ;MACA,KAAKI,IAAL,CAAU,OAAV,EAAmBlG,GAAnB;IACD,CARD,EAQGyN,EARH,CAQM,KARN,EAQa,MAAM;MACjBhM,KAAK,IAAIA,KAAK,CAAC,cAAD,CAAd;MACA0L,MAAM;MACN3H,KAAK,CAACP,OAAN;MACAc,YAAY,CAAC,KAAKpE,aAAN,CAAZ;MACAoL,aAAa,CAACF,OAAD,CAAb;MACA,KAAK3G,IAAL,CAAU,KAAV;IACD,CAfD,EAeGuH,EAfH,CAeM,OAfN,EAee,MAAM;MACnBhM,KAAK,IAAIA,KAAK,CAAC,eAAD,CAAd;MACA0L,MAAM;MACN3H,KAAK,CAACP,OAAN;MACAc,YAAY,CAAC,KAAKpE,aAAN,CAAZ;MACAoL,aAAa,CAACF,OAAD,CAAb;MACA,KAAK3G,IAAL,CAAU,OAAV,EANmB,CAQnB;;MACA,MAAM4H,UAAU,GAAG9J,SAAnB;MACAA,SAAS,GAAG,KAAKnC,UAAL,GAAkB,EAA9B;MACA,MAAM7B,GAAG,GAAG,IAAIyD,KAAJ,CAAU,yBAAV,CAAZ;;MACA,KAAK,IAAIsK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,UAAU,CAAClK,MAA/B,EAAuC,EAAEmK,CAAzC,EACED,UAAU,CAACC,CAAD,CAAV,CAAc/N,GAAd,EAbiB,CAenB;;;MACA,KAAK4B,QAAL,CAAcqD,OAAd,CAAsBjF,GAAtB;IACD,CAhCD,EAjnBW,CAmpBX;;IACA,IAAI2H,OAAJ;IACA,IAAIK,UAAU,GAAG,IAAjB;IACA,IAAIC,YAAY,GAAG,IAAnB;IACA,MAAM+F,YAAY,GAAG,CAAC,MAAD,CAArB;IACA,IAAI,KAAK7N,MAAL,CAAYa,QAAZ,KAAyBX,SAA7B,EACE2N,YAAY,CAAChD,IAAb,CAAkB,UAAlB;IACF,IAAI/J,UAAU,KAAKZ,SAAnB,EACE2N,YAAY,CAAChD,IAAb,CAAkB,WAAlB;IACF,IAAI,KAAKtJ,MAAL,KAAgBrB,SAApB,EACE2N,YAAY,CAAChD,IAAb,CAAkB,OAAlB;IACF,IAAI,KAAK7K,MAAL,CAAYe,WAAhB,EACE8M,YAAY,CAAChD,IAAb,CAAkB,sBAAlB;;IACF,IAAI/J,UAAU,KAAKZ,SAAf,IACG,KAAKF,MAAL,CAAYuD,aAAZ,KAA8BrD,SADjC,IAEG,KAAKF,MAAL,CAAYwD,aAAZ,KAA8BtD,SAFrC,EAEgD;MAC9C2N,YAAY,CAAChD,IAAb,CAAkB,WAAlB;IACD;;IAED,IAAIlH,KAAK,CAACC,OAAN,CAAc1C,WAAd,CAAJ,EACEA,WAAW,GAAG4M,qBAAqB,CAAC5M,WAAD,CAAnC,CADF,KAEK,IAAI,OAAOA,WAAP,KAAuB,UAA3B,EACHA,WAAW,GAAG4M,qBAAqB,CAACD,YAAD,CAAnC;IAEF,IAAIE,WAAW,GAAG,KAAlB;;IACA,MAAMC,UAAU,GAAIC,QAAD,IAAc;MAC/B,IAAIF,WAAJ,EACE;MACFA,WAAW,GAAG,IAAd;;MAEA,IAAIE,QAAQ,KAAK,KAAjB,EAAwB;QACtB,MAAMpO,GAAG,GAAG,IAAIyD,KAAJ,CAAU,8CAAV,CAAZ;QACAzD,GAAG,CAAC8F,KAAJ,GAAY,uBAAZ;QACA,KAAKI,IAAL,CAAU,OAAV,EAAmBlG,GAAnB;QACA,KAAKyC,GAAL;QACA;MACD;;MAED,IAAI,OAAO2L,QAAP,KAAoB,QAAxB,EAAkC;QAChC;QACA;QACA;QAEA,MAAMxG,IAAI,GAAGwG,QAAb;QACA,IAAIJ,YAAY,CAACzJ,OAAb,CAAqBqD,IAArB,MAA+B,CAAC,CAApC,EACE,OAAOyG,QAAQ,CAAE,sCAAqCzG,IAAK,EAA5C,CAAf;QAEF,MAAM7G,QAAQ,GAAG,KAAKZ,MAAL,CAAYY,QAA7B;;QACA,QAAQ6G,IAAR;UACE,KAAK,UAAL;YACEwG,QAAQ,GAAG;cAAExG,IAAF;cAAQ7G,QAAR;cAAkBC,QAAQ,EAAE,KAAKb,MAAL,CAAYa;YAAxC,CAAX;YACA;;UACF,KAAK,WAAL;YACEoN,QAAQ,GAAG;cAAExG,IAAF;cAAQ7G,QAAR;cAAkB0D,GAAG,EAAExD;YAAvB,CAAX;YACA;;UACF,KAAK,WAAL;YACEmN,QAAQ,GAAG;cACTxG,IADS;cAET7G,QAFS;cAGT0D,GAAG,EAAExD,UAHI;cAITyC,aAAa,EAAE,KAAKvD,MAAL,CAAYuD,aAJlB;cAKTC,aAAa,EAAE,KAAKxD,MAAL,CAAYwD;YALlB,CAAX;YAOA;;UACF,KAAK,OAAL;YACEyK,QAAQ,GAAG;cACTxG,IADS;cAET7G,QAFS;cAGT+G,QAAQ,EAAE,IAAI/I,YAAJ,CAAiB,KAAK2C,MAAtB;YAHD,CAAX;YAKA;;UACF,KAAK,sBAAL;YACE0M,QAAQ,GAAG;cACTxG,IADS;cAET7G,QAFS;cAGToH,MAAM,EAAE;gBAAA,kCAAImG,IAAJ;kBAAIA,IAAJ;gBAAA;;gBAAA,OAAa,KAAI,CAACpI,IAAL,CAAU,sBAAV,EAAkC,GAAGoI,IAArC,CAAb;cAAA;YAHC,CAAX;YAKA;;UACF,KAAK,MAAL;YACEF,QAAQ,GAAG;cAAExG,IAAF;cAAQ7G;YAAR,CAAX;YACA;;UACF;YACE,OAAOsN,QAAQ,CACZ,+CAA8CD,QAAS,EAD3C,CAAf;QAlCJ;MAsCD,CAhDD,MAgDO,IAAI,OAAOA,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAK,IAAjD,EAAuD;QAC5D,OAAOC,QAAQ,CACZ,4CAA2CD,QAAS,EADxC,CAAf;MAGD,CAJM,MAIA;QACL,MAAMrN,QAAQ,GAAGqN,QAAQ,CAACrN,QAA1B;;QACA,IAAI,OAAOA,QAAP,KAAoB,QAAxB,EAAkC;UAChC,OAAOsN,QAAQ,CACZ,4CAA2CD,QAAS,EADxC,CAAf;QAGD;;QACD,MAAMxG,IAAI,GAAGwG,QAAQ,CAACxG,IAAtB;;QACA,QAAQA,IAAR;UACE,KAAK,UAAL;YAAiB;cACf,MAAM;gBAAE5G;cAAF,IAAeoN,QAArB;cACA,IAAI,OAAOpN,QAAP,KAAoB,QAApB,IAAgC,CAAC2B,MAAM,CAACC,QAAP,CAAgB5B,QAAhB,CAArC,EACE,OAAOqN,QAAQ,CAAC,wCAAD,CAAf;cACFD,QAAQ,GAAG;gBAAExG,IAAF;gBAAQ7G,QAAR;gBAAkBC;cAAlB,CAAX;cACA;YACD;;UACD,KAAK,WAAL;YAAkB;cAChB,MAAMyD,GAAG,GAAGlG,QAAQ,CAAC6P,QAAQ,CAAC3J,GAAV,EAAe2J,QAAQ,CAACnK,UAAxB,CAApB;cACA,IAAIQ,GAAG,YAAYhB,KAAnB,EACE,OAAO4K,QAAQ,CAAC,mCAAD,CAAf;cACF,IAAI,CAAC5J,GAAG,CAAC8J,YAAJ,EAAL,EACE,OAAOF,QAAQ,CAAC,0BAAD,CAAf;cACFD,QAAQ,GAAG;gBAAExG,IAAF;gBAAQ7G,QAAR;gBAAkB0D;cAAlB,CAAX;cACA;YACD;;UACD,KAAK,WAAL;YAAkB;cAChB,MAAM;gBAAEf,aAAF;gBAAiBC;cAAjB,IAAmCyK,QAAzC;cACA,MAAM3J,GAAG,GAAGlG,QAAQ,CAAC6P,QAAQ,CAAC3J,GAAV,EAAe2J,QAAQ,CAACnK,UAAxB,CAApB;;cACA,IAAIQ,GAAG,YAAYhB,KAAf,IACG,OAAOC,aAAP,KAAyB,QAD5B,IAEG,OAAOC,aAAP,KAAyB,QAFhC,EAE0C;gBACxC,OAAO0K,QAAQ,CAAC,yCAAD,CAAf;cACD;;cACD,IAAI,CAAC5J,GAAG,CAAC8J,YAAJ,EAAL,EACE,OAAOF,QAAQ,CAAC,0BAAD,CAAf;cACFD,QAAQ,GAAG;gBAAExG,IAAF;gBAAQ7G,QAAR;gBAAkB0D,GAAlB;gBAAuBf,aAAvB;gBAAsCC;cAAtC,CAAX;cACA;YACD;;UACD,KAAK,OAAL;YAAc;cACZ,IAAIxC,KAAK,GAAGiN,QAAQ,CAACjN,KAArB;;cACA,IAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACyC,MAAvC,EAA+C;gBAC7CzC,KAAK,GAAGnC,WAAW,CAACmC,KAAD,CAAnB;cACD,CAFD,MAEO,IAAI,CAAClC,OAAO,CAACkC,KAAD,CAAZ,EAAqB;gBAC1B,OAAOkN,QAAQ,CACZ,2BAA0BD,QAAQ,CAACjN,KAAM,EAD7B,CAAf;cAGD;;cACDiN,QAAQ,GAAG;gBAAExG,IAAF;gBAAQ7G,QAAR;gBAAkB+G,QAAQ,EAAE,IAAI/I,YAAJ,CAAiBoC,KAAjB;cAA5B,CAAX;cACA;YACD;;UACD,KAAK,sBAAL;YAA6B;cAC3B,MAAM;gBAAEgH;cAAF,IAAaiG,QAAnB;;cACA,IAAI,OAAOjG,MAAP,KAAkB,UAAtB,EAAkC;gBAChC,OAAOkG,QAAQ,CACb,oDADa,CAAf;cAGD;;cACDD,QAAQ,GAAG;gBAAExG,IAAF;gBAAQ7G,QAAR;gBAAkBoH;cAAlB,CAAX;cACA;YACD;;UACD,KAAK,MAAL;YACEiG,QAAQ,GAAG;cAAExG,IAAF;cAAQ7G;YAAR,CAAX;YACA;;UACF;YACE,OAAOsN,QAAQ,CACZ,+CAA8CD,QAAS,EAD3C,CAAf;QAxDJ;MA4DD;;MACDzG,OAAO,GAAGyG,QAAV,CAtI+B,CAwI/B;;MACA,IAAI;QACF,MAAMrN,QAAQ,GAAG4G,OAAO,CAAC5G,QAAzB;;QACA,QAAQ4G,OAAO,CAACC,IAAhB;UACE,KAAK,UAAL;YACEpC,KAAK,CAAC6C,YAAN,CAAmBtH,QAAnB,EAA6B4G,OAAO,CAAC3G,QAArC;YACA;;UACF,KAAK,WAAL;YACEwE,KAAK,CAACgD,MAAN,CAAazH,QAAb,EAAuB4G,OAAO,CAAClD,GAA/B;YACA;;UACF,KAAK,WAAL;YACEe,KAAK,CAACgJ,aAAN,CAAoBzN,QAApB,EACoB4G,OAAO,CAAClD,GAD5B,EAEoBkD,OAAO,CAACjE,aAF5B,EAGoBiE,OAAO,CAAChE,aAH5B,EAIoB,CAAC8E,GAAD,EAAMC,EAAN,KAAa;cAC/B,MAAMG,SAAS,GAAGlB,OAAO,CAAClD,GAAR,CAAYkE,IAAZ,CAAiBF,GAAjB,CAAlB;;cACA,IAAII,SAAS,YAAYpF,KAAzB,EAAgC;gBAC9BoF,SAAS,CAAC3E,OAAV,GACG,iCAAgC2E,SAAS,CAAC3E,OAAQ,EADrD;gBAEA2E,SAAS,CAAC/C,KAAV,GAAkB,uBAAlB;gBACA,KAAKI,IAAL,CAAU,OAAV,EAAmB2C,SAAnB;gBACA,OAAOzB,WAAW,EAAlB;cACD;;cAEDsB,EAAE,CAACG,SAAD,CAAF;YACD,CAfD;YAgBA;;UACF,KAAK,OAAL;YACElB,OAAO,CAACG,QAAR,CAAiB1J,IAAjB,CAAuB4B,GAAD,IAAS;cAC7B,IAAIA,GAAJ,EAAS;gBACPA,GAAG,CAAC8F,KAAJ,GAAY,OAAZ;gBACA,KAAKI,IAAL,CAAU,OAAV,EAAmBlG,GAAnB;gBACA,OAAOoH,WAAW,EAAlB;cACD;;cACDW,eAAe;YAChB,CAPD;YAQA;;UACF,KAAK,sBAAL;YACEvC,KAAK,CAACiJ,YAAN,CAAmB1N,QAAnB;YACA;;UACF,KAAK,MAAL;YACEyE,KAAK,CAACkJ,QAAN,CAAe3N,QAAf;YACA;QAxCJ;MA0CD,CA5CD,SA4CU;QACRmN,WAAW,GAAG,KAAd;MACD;IACF,CAxLD;;IA0LA,SAASG,QAAT,CAAkBhJ,GAAlB,EAAuB;MACrB5D,KAAK,IAAIA,KAAK,CAAC4D,GAAD,CAAd;MACAsJ,OAAO,CAACC,QAAR,CAAiBxH,WAAjB;IACD;;IAED,SAASA,WAAT,GAAuB;MACrB8G,WAAW,GAAG,KAAd;MACA,MAAMW,IAAI,GAAGxN,WAAW,CAAC4G,YAAD,EAAeD,UAAf,EAA2BmG,UAA3B,CAAxB;MACA,IAAID,WAAW,IAAIW,IAAI,KAAKxO,SAA5B,EACE;MACF8N,UAAU,CAACU,IAAD,CAAV;IACD;;IAED,MAAM9G,eAAe,GAAG,MAAM;MAC5B,IAAIJ,OAAO,CAACC,IAAR,KAAiB,OAArB,EAA8B;QAC5B,MAAMnD,GAAG,GAAGkD,OAAO,CAACG,QAAR,CAAiBgH,OAAjB,EAAZ;;QACA,IAAIrK,GAAG,KAAK,KAAZ,EAAmB;UACjBhD,KAAK,IAAIA,KAAK,CAAC,iCAAD,CAAd;UACAA,KAAK,IAAIA,KAAK,CAAC,2BAAD,CAAd;UACA2F,WAAW;QACZ,CAJD,MAIO;UACL,MAAMS,GAAG,GAAGF,OAAO,CAACG,QAAR,CAAiBD,GAAjB,EAAZ;UACApG,KAAK,IAAIA,KAAK,CAAE,sBAAqBoG,GAAG,GAAG,CAAE,EAA/B,CAAd;UACArC,KAAK,CAACgD,MAAN,CAAab,OAAO,CAAC5G,QAArB,EAA+B0D,GAA/B;QACD;MACF;IACF,CAbD;;IAeA,MAAMsK,YAAY,GAAG,MAAM;MACzB,IAAI,KAAK5O,MAAL,CAAYU,YAAZ,GAA2B,CAA/B,EAAkC;QAChC,KAAKc,aAAL,GAAqBqN,UAAU,CAAC,MAAM;UACpC,MAAMhP,GAAG,GAAG,IAAIyD,KAAJ,CAAU,uCAAV,CAAZ;UACAzD,GAAG,CAAC8F,KAAJ,GAAY,gBAAZ;UACA,KAAKI,IAAL,CAAU,OAAV,EAAmBlG,GAAnB;UACA8E,IAAI,CAACkI,OAAL;QACD,CAL8B,EAK5B,KAAK7M,MAAL,CAAYU,YALgB,CAA/B;MAMD;IACF,CATD;;IAWA,IAAI,CAAC0B,GAAG,CAACuC,IAAT,EAAe;MACb,IAAI1E,IAAI,GAAG,KAAKD,MAAL,CAAYC,IAAvB;MACA,MAAMK,SAAS,GAAG,KAAKN,MAAL,CAAYM,SAA9B;MACA,MAAMC,SAAS,GAAG,KAAKP,MAAL,CAAYO,SAA9B;MAEAe,KAAK,IAAIA,KAAK,CAAE,kBAAiBrB,IAAK,YAAW,KAAKD,MAAL,CAAYG,IAAK,MAApD,CAAd;;MAEA,MAAM2O,SAAS,GAAG,MAAM;QACtBF,YAAY;QACZjK,IAAI,CAACxC,OAAL,CAAa;UACXlC,IADW;UAEXE,IAAI,EAAE,KAAKH,MAAL,CAAYG,IAFP;UAGXC,YAAY,EAAE,KAAKJ,MAAL,CAAYI,YAHf;UAIXC,SAAS,EAAE,KAAKL,MAAL,CAAYK;QAJZ,CAAb;QAMAsE,IAAI,CAACoK,UAAL,CAAgB,IAAhB;QACApK,IAAI,CAACqK,eAAL,CAAqB,CAArB;QACArK,IAAI,CAACkK,UAAL,CAAgB,OAAOzM,GAAG,CAAC6M,OAAX,KAAuB,QAAvB,GAAkC7M,GAAG,CAAC6M,OAAtC,GAAgD,CAAhE;MACD,CAXD;;MAaA,IAAK,CAAC3O,SAAD,IAAc,CAACC,SAAhB,IAA+BD,SAAS,IAAIC,SAAhD,EAA4D;QAC1DuO,SAAS;MACV,CAFD,MAEO;QACLhS,SAAS,CAACmD,IAAD,EAAQK,SAAS,GAAG,CAAH,GAAO,CAAxB,EAA4B,CAACT,GAAD,EAAMqP,OAAN,EAAeC,MAAf,KAA0B;UAC7D,IAAItP,GAAJ,EAAS;YACP,MAAM4H,IAAI,GAAInH,SAAS,GAAG,MAAH,GAAY,MAAnC;YACA,MAAM8O,KAAK,GAAG,IAAI9L,KAAJ,CACX,0BAAyBmE,IAAK,iBAAgBxH,IAAK,MAAKJ,GAAI,EADjD,CAAd;YAGA+F,YAAY,CAAC,KAAKpE,aAAN,CAAZ;YACA4N,KAAK,CAACzJ,KAAN,GAAc,YAAd;YACA,KAAKI,IAAL,CAAU,OAAV,EAAmBqJ,KAAnB;YACA,KAAKrJ,IAAL,CAAU,OAAV;YACA;UACD;;UACD9F,IAAI,GAAGiP,OAAP;UACAJ,SAAS;QACV,CAdQ,CAAT;MAeD;IACF,CAvCD,MAuCO;MACL;MACAF,YAAY;;MACZ,IAAI,OAAOjK,IAAI,CAAC0K,UAAZ,KAA2B,SAA/B,EAA0C;QACxC;QAEA,IAAI,CAAC1K,IAAI,CAAC0K,UAAV,EAAsB;UACpB;UACAlC,SAAS;QACV;MACF,CAPD,MAOO;QACL;QACAA,SAAS;MACV;IACF;;IAED,OAAO,IAAP;EACD;;EAED7K,GAAG,GAAG;IACJ,IAAI,KAAKL,KAAL,IAAc3C,UAAU,CAAC,KAAK2C,KAAN,CAA5B,EAA0C;MACxC,KAAKD,SAAL,CAAesN,UAAf,CAA0B5R,iBAAiB,CAACmJ,cAA5C;;MACA,KAAK5E,KAAL,CAAWK,GAAX;IACD;;IACD,OAAO,IAAP;EACD;;EAEDuK,OAAO,GAAG;IACR,KAAK5K,KAAL,IAAc3C,UAAU,CAAC,KAAK2C,KAAN,CAAxB,IAAwC,KAAKA,KAAL,CAAW4K,OAAX,EAAxC;IACA,OAAO,IAAP;EACD;;EAED0C,IAAI,CAACC,GAAD,EAAMC,IAAN,EAAYlH,EAAZ,EAAgB;IAClB,IAAI,CAAC,KAAKtG,KAAN,IAAe,CAAC3C,UAAU,CAAC,KAAK2C,KAAN,CAA9B,EACE,MAAM,IAAIqB,KAAJ,CAAU,eAAV,CAAN;;IAEF,IAAI,OAAOmM,IAAP,KAAgB,UAApB,EAAgC;MAC9BlH,EAAE,GAAGkH,IAAL;MACAA,IAAI,GAAG,EAAP;IACD;;IAED,MAAMC,SAAS,GAAG;MAAEC,aAAa,EAAGF,IAAI,CAACE,aAAL,KAAuB;IAAzC,CAAlB;IAEAC,WAAW,CAAC,IAAD,EAAO,SAAP,EAAkBF,SAAlB,EAA6B,CAAC7P,GAAD,EAAMgQ,IAAN,KAAe;MACrD,IAAIhQ,GAAJ,EAAS;QACP0I,EAAE,CAAC1I,GAAD,CAAF;QACA;MACD;;MAED,MAAMiQ,IAAI,GAAG,EAAb;;MAEA,SAASC,KAAT,CAAelQ,GAAf,EAAoB;QAClB,IAAIA,GAAJ,EAAS;UACPgQ,IAAI,CAACG,KAAL;UACAzH,EAAE,CAAC1I,GAAD,CAAF;UACA;QACD;;QACD,IAAIiQ,IAAI,CAACrM,MAAT,EACEqM,IAAI,CAAC5G,KAAL;MACH;;MAED,IAAI,KAAKlJ,MAAL,CAAYiB,aAAZ,KAA8B,IAA9B,IACIwO,IAAI,IACDA,IAAI,CAAC/L,YAAL,KAAsB,IADzB,IAEG,KAAKnC,MAAL,KAAgBrB,SAH3B,EAGuC;QACrC4P,IAAI,CAACjF,IAAL,CAAU,MAAMoF,WAAW,CAACJ,IAAD,EAAOE,KAAP,CAA3B;MACD;;MAED,IAAI,OAAON,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,IAAzC,EAA+C;QAC7C,IAAI,OAAOA,IAAI,CAACS,GAAZ,KAAoB,QAApB,IAAgCT,IAAI,CAACS,GAAL,KAAa,IAAjD,EACEC,MAAM,CAACN,IAAD,EAAOJ,IAAI,CAACS,GAAZ,CAAN;;QACF,IAAK,OAAOT,IAAI,CAACW,GAAZ,KAAoB,QAApB,IAAgCX,IAAI,CAACW,GAAL,KAAa,IAA9C,IACGX,IAAI,CAACW,GAAL,KAAa,IADpB,EAC0B;UACxBN,IAAI,CAACjF,IAAL,CAAU,MAAMwF,MAAM,CAACR,IAAD,EAAOJ,IAAI,CAACW,GAAZ,EAAiBL,KAAjB,CAAtB;QACD;;QACD,IAAK,OAAON,IAAI,CAACa,GAAZ,KAAoB,QAApB,IAAgCb,IAAI,CAACa,GAAL,KAAa,IAA9C,IACGb,IAAI,CAACa,GAAL,KAAa,QADhB,IAEGb,IAAI,CAACa,GAAL,KAAa,IAFpB,EAE0B;UACxBR,IAAI,CAACjF,IAAL,CAAU,MAAM0F,MAAM,CAACV,IAAD,EAAOJ,IAAI,CAACa,GAAZ,EAAiBP,KAAjB,CAAtB;QACD;MACF;;MAEDD,IAAI,CAACjF,IAAL,CAAU,MAAM2F,OAAO,CAACX,IAAD,EAAOL,GAAP,EAAYC,IAAZ,EAAkBlH,EAAlB,CAAvB;MACAuH,IAAI,CAAC5G,KAAL;IACD,CAzCU,CAAX;IA2CA,OAAO,IAAP;EACD;;EAEDuH,KAAK,CAACC,OAAD,EAAUjB,IAAV,EAAgBlH,EAAhB,EAAoB;IACvB,IAAI,CAAC,KAAKtG,KAAN,IAAe,CAAC3C,UAAU,CAAC,KAAK2C,KAAN,CAA9B,EACE,MAAM,IAAIqB,KAAJ,CAAU,eAAV,CAAN;;IAEF,IAAI,OAAOoN,OAAP,KAAmB,UAAvB,EAAmC;MACjCnI,EAAE,GAAGmI,OAAL;MACAA,OAAO,GAAGjB,IAAI,GAAGvP,SAAjB;IACD,CAHD,MAGO,IAAI,OAAOuP,IAAP,KAAgB,UAApB,EAAgC;MACrClH,EAAE,GAAGkH,IAAL;MACAA,IAAI,GAAGvP,SAAP;IACD;;IACD,IAAIwQ,OAAO,KAAKA,OAAO,CAACJ,GAAR,KAAgBpQ,SAAhB,IAA6BwQ,OAAO,CAACR,GAAR,KAAgBhQ,SAAlD,CAAX,EAAyE;MACvEuP,IAAI,GAAGiB,OAAP;MACAA,OAAO,GAAGxQ,SAAV;IACD;;IAED0P,WAAW,CAAC,IAAD,EAAO,SAAP,EAAkB,CAAC/P,GAAD,EAAMgQ,IAAN,KAAe;MAC1C,IAAIhQ,GAAJ,EAAS;QACP0I,EAAE,CAAC1I,GAAD,CAAF;QACA;MACD;;MAED,MAAMiQ,IAAI,GAAG,EAAb;;MAEA,SAASC,KAAT,CAAelQ,GAAf,EAAoB;QAClB,IAAIA,GAAJ,EAAS;UACPgQ,IAAI,CAACG,KAAL;UACAzH,EAAE,CAAC1I,GAAD,CAAF;UACA;QACD;;QACD,IAAIiQ,IAAI,CAACrM,MAAT,EACEqM,IAAI,CAAC5G,KAAL;MACH;;MAED,IAAI,KAAKlJ,MAAL,CAAYiB,aAAZ,KAA8B,IAA9B,IACIwO,IAAI,IACDA,IAAI,CAAC/L,YAAL,KAAsB,IADzB,IAEG,KAAKnC,MAAL,KAAgBrB,SAH3B,EAGuC;QACrC4P,IAAI,CAACjF,IAAL,CAAU,MAAMoF,WAAW,CAACJ,IAAD,EAAOE,KAAP,CAA3B;MACD;;MAED,IAAIW,OAAO,KAAK,KAAhB,EACEZ,IAAI,CAACjF,IAAL,CAAU,MAAMwF,MAAM,CAACR,IAAD,EAAOa,OAAP,EAAgBX,KAAhB,CAAtB;;MAEF,IAAI,OAAON,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,IAAzC,EAA+C;QAC7C,IAAI,OAAOA,IAAI,CAACS,GAAZ,KAAoB,QAApB,IAAgCT,IAAI,CAACS,GAAL,KAAa,IAAjD,EACEC,MAAM,CAACN,IAAD,EAAOJ,IAAI,CAACS,GAAZ,CAAN;;QACF,IAAK,OAAOT,IAAI,CAACa,GAAZ,KAAoB,QAApB,IAAgCb,IAAI,CAACa,GAAL,KAAa,IAA9C,IACGb,IAAI,CAACa,GAAL,KAAa,QADhB,IAEGb,IAAI,CAACa,GAAL,KAAa,IAFpB,EAE0B;UACxBR,IAAI,CAACjF,IAAL,CAAU,MAAM0F,MAAM,CAACV,IAAD,EAAOJ,IAAI,CAACa,GAAZ,EAAiBP,KAAjB,CAAtB;QACD;MACF;;MAEDD,IAAI,CAACjF,IAAL,CAAU,MAAM8F,QAAQ,CAACd,IAAD,EAAOtH,EAAP,CAAxB;MACAuH,IAAI,CAAC5G,KAAL;IACD,CAxCU,CAAX;IA0CA,OAAO,IAAP;EACD;;EAED0H,MAAM,CAAC5J,IAAD,EAAOuB,EAAP,EAAW;IACf,IAAI,CAAC,KAAKtG,KAAN,IAAe,CAAC3C,UAAU,CAAC,KAAK2C,KAAN,CAA9B,EACE,MAAM,IAAIqB,KAAJ,CAAU,eAAV,CAAN;IAEFsM,WAAW,CAAC,IAAD,EAAO,SAAP,EAAkB,CAAC/P,GAAD,EAAMgQ,IAAN,KAAe;MAC1C,IAAIhQ,GAAJ,EAAS;QACP0I,EAAE,CAAC1I,GAAD,CAAF;QACA;MACD;;MAEDgR,YAAY,CAAChB,IAAD,EAAO7I,IAAP,EAAa,CAACnH,GAAD,EAAMiR,MAAN,KAAiB;QACxC,IAAIjR,GAAJ,EAAS;UACP0I,EAAE,CAAC1I,GAAD,CAAF;UACA;QACD;;QAED0I,EAAE,CAACrI,SAAD,EAAY4Q,MAAZ,CAAF;MACD,CAPW,CAAZ;IAQD,CAdU,CAAX;IAgBA,OAAO,IAAP;EACD;;EAEDC,SAAS,CAACC,QAAD,EAAWC,QAAX,EAAqB1I,EAArB,EAAyB;IAChC,IAAI,CAAC,KAAKtG,KAAN,IAAe,CAAC3C,UAAU,CAAC,KAAK2C,KAAN,CAA9B,EACE,MAAM,IAAIqB,KAAJ,CAAU,eAAV,CAAN,CAF8B,CAIhC;IACA;;IAEA,MAAM+F,SAAS,GAAI,OAAOd,EAAP,KAAc,UAAjC;;IAEA,IAAIc,SAAJ,EAAe;MACb,KAAK3H,UAAL,CAAgBmJ,IAAhB,CAAqB,CAACqG,OAAD,EAAU1L,IAAV,KAAmB;QACtC,IAAI0L,OAAJ,EAAa;UACX3I,EAAE,CAAC2I,OAAO,KAAK,IAAZ,GACEA,OADF,GAEE,IAAI5N,KAAJ,CAAW,qBAAoB0N,QAAS,IAAGC,QAAS,EAApD,CAFH,CAAF;UAGA;QACD;;QAED,IAAIE,QAAQ,GAAGF,QAAf;;QACA,IAAIA,QAAQ,KAAK,CAAb,IAAkBzL,IAAlB,IAA0BA,IAAI,CAAC/B,MAAL,IAAe,CAA7C,EAAgD;UAC9C0N,QAAQ,GAAG1S,YAAY,CAAC+G,IAAD,EAAO,CAAP,CAAvB;UACA,IAAI,EAAE,KAAKxD,SAAL,CAAeoP,YAAf,GAA8BnU,MAAM,CAACoU,aAAvC,CAAJ,EACEJ,QAAQ,GAAGE,QAAX;QACH;;QAED,KAAKxP,WAAL,CAAkB,GAAEqP,QAAS,IAAGC,QAAS,EAAzC,IAA8CE,QAA9C;QAEA5I,EAAE,CAACrI,SAAD,EAAYiR,QAAZ,CAAF;MACD,CAlBD;IAmBD;;IAED,KAAKnP,SAAL,CAAesP,YAAf,CAA4BN,QAA5B,EAAsCC,QAAtC,EAAgD5H,SAAhD;;IAEA,OAAO,IAAP;EACD;;EAEDkI,WAAW,CAACP,QAAD,EAAWC,QAAX,EAAqB1I,EAArB,EAAyB;IAClC,IAAI,CAAC,KAAKtG,KAAN,IAAe,CAAC3C,UAAU,CAAC,KAAK2C,KAAN,CAA9B,EACE,MAAM,IAAIqB,KAAJ,CAAU,eAAV,CAAN,CAFgC,CAIlC;IACA;;IAEA,MAAM+F,SAAS,GAAI,OAAOd,EAAP,KAAc,UAAjC;;IAEA,IAAIc,SAAJ,EAAe;MACb,KAAK3H,UAAL,CAAgBmJ,IAAhB,CAAsBqG,OAAD,IAAa;QAChC,IAAIA,OAAJ,EAAa;UACX3I,EAAE,CAAC2I,OAAO,KAAK,IAAZ,GACEA,OADF,GAEE,IAAI5N,KAAJ,CAAW,yBAAwB0N,QAAS,IAAGC,QAAS,EAAxD,CAFH,CAAF;UAGA;QACD;;QAED,OAAO,KAAKtP,WAAL,CAAkB,GAAEqP,QAAS,IAAGC,QAAS,EAAzC,CAAP;QAEA1I,EAAE;MACH,CAXD;IAYD;;IAED,KAAKvG,SAAL,CAAewP,kBAAf,CAAkCR,QAAlC,EAA4CC,QAA5C,EAAsD5H,SAAtD;;IAEA,OAAO,IAAP;EACD;;EAEDoI,UAAU,CAACC,KAAD,EAAQC,OAAR,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiCtJ,EAAjC,EAAqC;IAC7C,IAAI,CAAC,KAAKtG,KAAN,IAAe,CAAC3C,UAAU,CAAC,KAAK2C,KAAN,CAA9B,EACE,MAAM,IAAIqB,KAAJ,CAAU,eAAV,CAAN,CAF2C,CAI7C;;IAEA,MAAMlB,GAAG,GAAG;MACVsP,KAAK,EAAEA,KADG;MAEVC,OAAO,EAAEA,OAFC;MAGVC,KAAK,EAAEA,KAHG;MAIVC,OAAO,EAAEA;IAJC,CAAZ;IAOA,IAAI,OAAOtJ,EAAP,KAAc,UAAlB,EACEA,EAAE,GAAG3I,IAAL;IAEFgQ,WAAW,CAAC,IAAD,EAAO,cAAP,EAAuBxN,GAAvB,EAA4BmG,EAA5B,CAAX;IAEA,OAAO,IAAP;EACD;;EAEDuJ,sBAAsB,CAACvJ,EAAD,EAAK;IACzB,IAAI,CAAC,KAAKtG,KAAN,IAAe,CAAC3C,UAAU,CAAC,KAAK2C,KAAN,CAA9B,EACE,MAAM,IAAIqB,KAAJ,CAAU,eAAV,CAAN;IAEF,MAAM+F,SAAS,GAAI,OAAOd,EAAP,KAAc,UAAjC;;IAEA,IAAI,CAAC,KAAKvI,MAAL,CAAYqB,YAAb,IACI,KAAKrB,MAAL,CAAYqB,YAAZ,IAA4B1B,UAAU,CAACoS,IAAX,CAAgB,KAAKhQ,UAArB,CADpC,EACuE;MACrE,IAAIsH,SAAJ,EAAe;QACb,KAAK3H,UAAL,CAAgBmJ,IAAhB,CAAsBqG,OAAD,IAAa;UAChC,IAAIA,OAAJ,EAAa;YACX3I,EAAE,CAAC2I,OAAO,KAAK,IAAZ,GACEA,OADF,GAEE,IAAI5N,KAAJ,CAAU,mCAAV,CAFH,CAAF;YAGA;UACD;;UAEDiF,EAAE;QACH,CATD;MAUD;;MAED,KAAKvG,SAAL,CAAe8P,sBAAf,CAAsCzI,SAAtC;;MACA,OAAO,IAAP;IACD;;IAED,IAAI,CAACA,SAAL,EACE,OAAO,IAAP;IAEFmF,OAAO,CAACC,QAAR,CACElG,EADF,EAEE,IAAIjF,KAAJ,CACE,sEADF,CAFF;IAOA,OAAO,IAAP;EACD;;EAED0O,4BAA4B,CAACC,UAAD,EAAa1J,EAAb,EAAiB;IAC3C,IAAI,CAAC,KAAKtG,KAAN,IAAe,CAAC3C,UAAU,CAAC,KAAK2C,KAAN,CAA9B,EACE,MAAM,IAAIqB,KAAJ,CAAU,eAAV,CAAN;IAEF,MAAM+F,SAAS,GAAI,OAAOd,EAAP,KAAc,UAAjC;;IAEA,IAAI,CAAC,KAAKvI,MAAL,CAAYqB,YAAb,IACI,KAAKrB,MAAL,CAAYqB,YAAZ,IAA4B1B,UAAU,CAACoS,IAAX,CAAgB,KAAKhQ,UAArB,CADpC,EACuE;MACrE,IAAIsH,SAAJ,EAAe;QACb,KAAK3H,UAAL,CAAgBmJ,IAAhB,CAAsBqG,OAAD,IAAa;UAChC,IAAIA,OAAJ,EAAa;YACX3I,EAAE,CAAC2I,OAAO,KAAK,IAAZ,GACEA,OADF,GAEE,IAAI5N,KAAJ,CAAW,qBAAoB2O,UAAW,EAA1C,CAFH,CAAF;YAGA;UACD;;UACD,KAAKrQ,eAAL,CAAqBqQ,UAArB,IAAmC,IAAnC;UACA1J,EAAE;QACH,CATD;MAUD;;MAED,KAAKvG,SAAL,CAAekQ,0BAAf,CAA0CD,UAA1C,EAAsD5I,SAAtD;;MACA,OAAO,IAAP;IACD;;IAED,IAAI,CAACA,SAAL,EACE,OAAO,IAAP;IAEFmF,OAAO,CAACC,QAAR,CACElG,EADF,EAEE,IAAIjF,KAAJ,CACE,sEADF,CAFF;IAOA,OAAO,IAAP;EACD;;EAED6O,8BAA8B,CAACF,UAAD,EAAa1J,EAAb,EAAiB;IAC7C,IAAI,CAAC,KAAKtG,KAAN,IAAe,CAAC3C,UAAU,CAAC,KAAK2C,KAAN,CAA9B,EACE,MAAM,IAAIqB,KAAJ,CAAU,eAAV,CAAN;IAEF,MAAM+F,SAAS,GAAI,OAAOd,EAAP,KAAc,UAAjC;;IAEA,IAAI,CAAC,KAAKvI,MAAL,CAAYqB,YAAb,IACI,KAAKrB,MAAL,CAAYqB,YAAZ,IAA4B1B,UAAU,CAACoS,IAAX,CAAgB,KAAKhQ,UAArB,CADpC,EACuE;MACrE,IAAIsH,SAAJ,EAAe;QACb,KAAK3H,UAAL,CAAgBmJ,IAAhB,CAAsBqG,OAAD,IAAa;UAChC,IAAIA,OAAJ,EAAa;YACX3I,EAAE,CAAC2I,OAAO,KAAK,IAAZ,GACEA,OADF,GAEE,IAAI5N,KAAJ,CAAW,yBAAwB2O,UAAW,EAA9C,CAFH,CAAF;YAGA;UACD;;UACD,OAAO,KAAKrQ,eAAL,CAAqBqQ,UAArB,CAAP;UACA1J,EAAE;QACH,CATD;MAUD;;MAED,KAAKvG,SAAL,CAAeoQ,gCAAf,CAAgDH,UAAhD,EAA4D5I,SAA5D;;MACA,OAAO,IAAP;IACD;;IAED,IAAI,CAACA,SAAL,EACE,OAAO,IAAP;IAEFmF,OAAO,CAACC,QAAR,CACElG,EADF,EAEE,IAAIjF,KAAJ,CACE,sEADF,CAFF;IAOA,OAAO,IAAP;EACD;;EAED+O,6BAA6B,CAACJ,UAAD,EAAa1J,EAAb,EAAiB;IAC5C,IAAI,CAAC,KAAKtG,KAAN,IAAe,CAAC3C,UAAU,CAAC,KAAK2C,KAAN,CAA9B,EACE,MAAM,IAAIqB,KAAJ,CAAU,eAAV,CAAN;IAEF,IAAI,OAAOiF,EAAP,KAAc,UAAlB,EACEA,EAAE,GAAG3I,IAAL;;IAEF,IAAI,CAAC,KAAKI,MAAL,CAAYqB,YAAb,IACI,KAAKrB,MAAL,CAAYqB,YAAZ,IAA4B1B,UAAU,CAACoS,IAAX,CAAgB,KAAKhQ,UAArB,CADpC,EACuE;MACrE6N,WAAW,CAAC,IAAD,EAAO,gCAAP,EAAyC;QAAEqC;MAAF,CAAzC,EAAyD1J,EAAzD,CAAX;MACA,OAAO,IAAP;IACD;;IACDiG,OAAO,CAACC,QAAR,CACElG,EADF,EAEE,IAAIjF,KAAJ,CACE,sEADF,CAFF;IAOA,OAAO,IAAP;EACD;;EAEDgP,IAAI,CAAC/J,EAAD,EAAK;IACP,IAAI,CAAC,KAAKtG,KAAN,IAAe,CAAC3C,UAAU,CAAC,KAAK2C,KAAN,CAA9B,EACE,MAAM,IAAIqB,KAAJ,CAAU,eAAV,CAAN;IAEFsM,WAAW,CAAC,IAAD,EAAO,MAAP,EAAe,CAAC/P,GAAD,EAAMyS,IAAN,KAAe;MACvC,IAAIzS,GAAJ,EAAS;QACP0I,EAAE,CAAC1I,GAAD,CAAF;QACA;MACD;;MAEDgR,YAAY,CAACyB,IAAD,EAAO,MAAP,EAAe,CAACzS,GAAD,EAAM0S,KAAN,KAAgB;QACzC,IAAI1S,GAAJ,EAAS;UACP0I,EAAE,CAAC1I,GAAD,CAAF;UACA;QACD;;QAED,SAAS2S,eAAT,GAA2B;UACzBF,IAAI,CAACG,cAAL,CAAoB,OAApB,EAA6BC,OAA7B;UACAJ,IAAI,CAACG,cAAL,CAAoB,OAApB,EAA6B/M,OAA7B;UACA4M,IAAI,CAACG,cAAL,CAAoB,MAApB,EAA4BE,MAA5B;UACAL,IAAI,CAACG,cAAL,CAAoB,OAApB,EAA6BE,MAA7B;QACD;;QAED,SAASD,OAAT,GAAmB;UACjB;UACA;UACAF,eAAe;UACfjK,EAAE,CAACrI,SAAD,EAAYoS,IAAZ,CAAF;QACD;;QAED,SAAS5M,OAAT,CAAiB7F,GAAjB,EAAsB;UACpB2S,eAAe;UACfjK,EAAE,CAAC1I,GAAD,CAAF;QACD;;QAED,SAAS8S,MAAT,CAAgB7L,IAAhB,EAAsBgF,MAAtB,EAA8B;UAC5B0G,eAAe;UACf,IAAItN,GAAJ;UACA,IAAI,OAAO4B,IAAP,KAAgB,QAApB,EACE5B,GAAG,GAAI,sBAAqB4B,IAAK,kCAAjC,CADF,KAEK,IAAIgF,MAAM,KAAK5L,SAAf,EACHgF,GAAG,GAAI,mBAAkB4G,MAAO,kCAAhC,CADG,KAGH5G,GAAG,GAAG,8CAAN;UACF,MAAMrF,GAAG,GAAG,IAAIyD,KAAJ,CAAU4B,GAAV,CAAZ;UACArF,GAAG,CAACiH,IAAJ,GAAWA,IAAX;UACAjH,GAAG,CAACiM,MAAJ,GAAaA,MAAb;UACAvD,EAAE,CAAC1I,GAAD,CAAF;QACD;;QAEDyS,IAAI,CAAChF,EAAL,CAAQ,OAAR,EAAiBoF,OAAjB,EACKpF,EADL,CACQ,OADR,EACiB5H,OADjB,EAEK4H,EAFL,CAEQ,MAFR,EAEgBqF,MAFhB,EAGKrF,EAHL,CAGQ,OAHR,EAGiBqF,MAHjB;;QAKAL,IAAI,CAACM,KAAL;MACD,CA9CW,CAAZ;IA+CD,CArDU,CAAX;IAuDA,OAAO,IAAP;EACD;;AAx6C+B;;AA26ClC,SAAShD,WAAT,CAAqBiD,IAArB,EAA2BpL,IAA3B,EAAiCgI,IAAjC,EAAuClH,EAAvC,EAA2C;EACzC;EACA;EACA,MAAMuK,UAAU,GAAG9T,UAAnB;EACA,MAAM+T,SAAS,GAAG9T,WAAlB;;EAEA,IAAI,OAAOwQ,IAAP,KAAgB,UAApB,EAAgC;IAC9BlH,EAAE,GAAGkH,IAAL;IACAA,IAAI,GAAG,EAAP;EACD;;EAED,MAAMuD,OAAO,GAAG,CAACnT,GAAD,EAAMiR,MAAN,KAAiB;IAC/BvI,EAAE,CAAC1I,GAAD,EAAMiR,MAAN,CAAF;EACD,CAFD;;EAGAkC,OAAO,CAACvL,IAAR,GAAeA,IAAf;;EAEA,MAAMwL,SAAS,GAAGJ,IAAI,CAACpR,QAAL,CAAcyR,GAAd,CAAkBF,OAAlB,CAAlB;;EAEA,IAAIC,SAAS,KAAK,CAAC,CAAnB,EAAsB;IACpB1K,EAAE,CAAC,IAAIjF,KAAJ,CAAU,4BAAV,CAAD,CAAF;IACA;EACD;;EAED,QAAQmE,IAAR;IACE,KAAK,SAAL;IACA,KAAK,MAAL;MACEoL,IAAI,CAAC7Q,SAAL,CAAemR,OAAf,CAAuBF,SAAvB,EAAkCH,UAAlC,EAA8CC,SAA9C;;MACA;;IACF,KAAK,cAAL;MACEF,IAAI,CAAC7Q,SAAL,CAAeoR,WAAf,CAA2BH,SAA3B,EAAsCH,UAAtC,EAAkDC,SAAlD,EAA6DtD,IAA7D;;MACA;;IACF,KAAK,gCAAL;MACEoD,IAAI,CAAC7Q,SAAL,CAAeqR,yBAAf,CACEJ,SADF,EACaH,UADb,EACyBC,SADzB,EACoCtD,IADpC;;MAGA;;IACF;MACE,MAAM,IAAInM,KAAJ,CAAW,6BAA4BmE,IAAK,EAA5C,CAAN;EAdJ;AAgBD;;AAED,SAAS8I,MAAT,CAAgBV,IAAhB,EAAsByD,MAAtB,EAA8B/K,EAA9B,EAAkC;EAChC;EACA,MAAMnG,GAAG,GAAG;IACVmR,MAAM,EAAE,KADE;IAEVC,QAAQ,EAAE,oBAFA;IAGVC,MAAM,EAAEvT,SAHE;IAIVoT,MAAM,EAAE;EAJE,CAAZ;;EAOA,IAAI,OAAOA,MAAP,KAAkB,UAAtB,EAAkC;IAChC/K,EAAE,GAAG+K,MAAL;EACD,CAFD,MAEO,IAAI,OAAOA,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,KAAK,IAA7C,EAAmD;IACxD,IAAI,OAAOA,MAAM,CAACC,MAAd,KAAyB,SAA7B,EACEnR,GAAG,CAACmR,MAAJ,GAAaD,MAAM,CAACC,MAApB;IACF,IAAI,OAAOD,MAAM,CAACA,MAAd,KAAyB,QAA7B,EACElR,GAAG,CAACkR,MAAJ,GAAaA,MAAM,CAACA,MAApB;IACF,IAAI,OAAOA,MAAM,CAACE,QAAd,KAA2B,QAA/B,EACEpR,GAAG,CAACoR,QAAJ,GAAeF,MAAM,CAACE,QAAtB;IACF,IAAI,OAAOF,MAAM,CAACG,MAAd,KAAyB,QAA7B,EACErR,GAAG,CAACqR,MAAJ,GAAaH,MAAM,CAACG,MAApB,CADF,KAEK,IAAIjR,MAAM,CAACC,QAAP,CAAgB6Q,MAAM,CAACG,MAAvB,CAAJ,EACHrR,GAAG,CAACqR,MAAJ,GAAaH,MAAM,CAACG,MAAP,CAAcC,QAAd,CAAuB,CAAvB,EAA0BJ,MAAM,CAACG,MAAP,CAAchQ,MAAxC,CAAb;EACH;;EACD,IAAIrB,GAAG,CAACqR,MAAJ,KAAevT,SAAnB,EACEkC,GAAG,CAACqR,MAAJ,GAAaE,YAAY,EAAzB;EAEF,MAAMtK,SAAS,GAAI,OAAOd,EAAP,KAAc,UAAjC;;EAEA,IAAIsH,IAAI,CAACrF,QAAL,CAAcD,KAAd,KAAwB,MAA5B,EAAoC;IAClC,IAAIlB,SAAJ,EACEd,EAAE,CAAC,IAAIjF,KAAJ,CAAU,qBAAV,CAAD,CAAF;IACF;EACD;;EAED,IAAI+F,SAAJ,EAAe;IACbwG,IAAI,CAACnO,UAAL,CAAgBmJ,IAAhB,CAAsBqG,OAAD,IAAa;MAChC,IAAIA,OAAJ,EAAa;QACX3I,EAAE,CAAC2I,OAAO,KAAK,IAAZ,GAAmBA,OAAnB,GAA6B,IAAI5N,KAAJ,CAAU,uBAAV,CAA9B,CAAF;QACA;MACD;;MAEDuM,IAAI,CAAC+D,OAAL,GAAe,IAAf;MACA,EAAE/D,IAAI,CAACgE,OAAL,CAAahS,UAAf;MACAgO,IAAI,CAACxN,IAAL,CAAU,OAAV,EAAmB,MAAM;QACvB,IAAIwN,IAAI,CAACgE,OAAL,CAAahS,UAAjB,EACE,EAAEgO,IAAI,CAACgE,OAAL,CAAahS,UAAf;MACH,CAHD;MAKA0G,EAAE;IACH,CAdD;EAeD;;EAEDsH,IAAI,CAACgE,OAAL,CAAa7R,SAAb,CAAuB8R,UAAvB,CAAkCjE,IAAI,CAACrF,QAAL,CAAcJ,EAAhD,EAAoDhI,GAApD,EAAyDiH,SAAzD;AACD;;AAED,SAASgH,MAAT,CAAgBR,IAAhB,EAAsBJ,IAAtB,EAA4BlH,EAA5B,EAAgC;EAC9B,IAAIwL,IAAI,GAAG,EAAX;EACA,IAAIC,IAAI,GAAG,EAAX;EACA,IAAIC,KAAK,GAAG,GAAZ;EACA,IAAIC,MAAM,GAAG,GAAb;EACA,IAAIC,IAAI,GAAG,OAAX;EACA,IAAIC,KAAK,GAAG,IAAZ;;EAEA,IAAI,OAAO3E,IAAP,KAAgB,UAApB,EAAgC;IAC9BlH,EAAE,GAAGkH,IAAL;EACD,CAFD,MAEO,IAAI,OAAOA,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,IAAzC,EAA+C;IACpD,IAAI,OAAOA,IAAI,CAACsE,IAAZ,KAAqB,QAAzB,EACEA,IAAI,GAAGtE,IAAI,CAACsE,IAAZ;IACF,IAAI,OAAOtE,IAAI,CAACuE,IAAZ,KAAqB,QAAzB,EACEA,IAAI,GAAGvE,IAAI,CAACuE,IAAZ;IACF,IAAI,OAAOvE,IAAI,CAACwE,KAAZ,KAAsB,QAA1B,EACEA,KAAK,GAAGxE,IAAI,CAACwE,KAAb;IACF,IAAI,OAAOxE,IAAI,CAACyE,MAAZ,KAAuB,QAA3B,EACEA,MAAM,GAAGzE,IAAI,CAACyE,MAAd;IACF,IAAI,OAAOzE,IAAI,CAAC0E,IAAZ,KAAqB,QAAzB,EACEA,IAAI,GAAG1E,IAAI,CAAC0E,IAAZ;IACF,IAAI,OAAO1E,IAAI,CAAC2E,KAAZ,KAAsB,QAA1B,EACEA,KAAK,GAAG3E,IAAI,CAAC2E,KAAb;EACH;;EAED,MAAM/K,SAAS,GAAI,OAAOd,EAAP,KAAc,UAAjC;;EAEA,IAAIsH,IAAI,CAACrF,QAAL,CAAcD,KAAd,KAAwB,MAA5B,EAAoC;IAClC,IAAIlB,SAAJ,EACEd,EAAE,CAAC,IAAIjF,KAAJ,CAAU,qBAAV,CAAD,CAAF;IACF;EACD;;EAED,IAAI+F,SAAJ,EAAe;IACbwG,IAAI,CAACnO,UAAL,CAAgBmJ,IAAhB,CAAsBqG,OAAD,IAAa;MAChC,IAAIA,OAAJ,EAAa;QACX3I,EAAE,CAAC2I,OAAO,KAAK,IAAZ,GACEA,OADF,GAEE,IAAI5N,KAAJ,CAAU,qCAAV,CAFH,CAAF;QAGA;MACD;;MACDiF,EAAE;IACH,CARD;EASD;;EAEDsH,IAAI,CAACgE,OAAL,CAAa7R,SAAb,CAAuBoO,GAAvB,CAA2BP,IAAI,CAACrF,QAAL,CAAcJ,EAAzC,EAC2B2J,IAD3B,EAE2BC,IAF3B,EAG2BE,MAH3B,EAI2BD,KAJ3B,EAK2BE,IAL3B,EAM2BC,KAN3B,EAO2B/K,SAP3B;AAQD;;AAED,SAAS4G,WAAT,CAAqBJ,IAArB,EAA2BtH,EAA3B,EAA+B;EAC7B,MAAMc,SAAS,GAAI,OAAOd,EAAP,KAAc,UAAjC;;EAEA,IAAIsH,IAAI,CAACrF,QAAL,CAAcD,KAAd,KAAwB,MAA5B,EAAoC;IAClClB,SAAS,IAAId,EAAE,CAAC,IAAIjF,KAAJ,CAAU,qBAAV,CAAD,CAAf;IACA;EACD;;EACD,IAAIuM,IAAI,CAACgE,OAAL,CAAa/R,gBAAjB,EAAmC;IACjCuH,SAAS,IAAId,EAAE,CAAC,KAAD,CAAf;IACA;EACD;;EAEDsH,IAAI,CAACgE,OAAL,CAAa/R,gBAAb,GAAgC,IAAhC;;EAEA+N,IAAI,CAACnO,UAAL,CAAgBmJ,IAAhB,CAAsBqG,OAAD,IAAa;IAChC,IAAIA,OAAJ,EAAa;MACXrB,IAAI,CAACgE,OAAL,CAAa/R,gBAAb,GAAgC,KAAhC;;MACA,IAAIuH,SAAJ,EAAe;QACbd,EAAE,CAAC2I,OAAO,KAAK,IAAZ,GACEA,OADF,GAEE,IAAI5N,KAAJ,CAAU,oCAAV,CAFH,CAAF;MAGD;;MACD;IACD;;IAED,IAAI+F,SAAJ,EACEd,EAAE;EACL,CAbD;;EAeAsH,IAAI,CAACgE,OAAL,CAAa7R,SAAb,CAAuBqS,oBAAvB,CAA4CxE,IAAI,CAACrF,QAAL,CAAcJ,EAA1D,EAA8D,IAA9D;AACD;;AAED,SAASuG,QAAT,CAAkBd,IAAlB,EAAwBtH,EAAxB,EAA4B;EAC1B,IAAIsH,IAAI,CAACrF,QAAL,CAAcD,KAAd,KAAwB,MAA5B,EAAoC;IAClChC,EAAE,CAAC,IAAIjF,KAAJ,CAAU,qBAAV,CAAD,CAAF;IACA;EACD;;EAEDuM,IAAI,CAACnO,UAAL,CAAgBmJ,IAAhB,CAAsBqG,OAAD,IAAa;IAChC,IAAIA,OAAJ,EAAa;MACX3I,EAAE,CAAC2I,OAAO,KAAK,IAAZ,GAAmBA,OAAnB,GAA6B,IAAI5N,KAAJ,CAAU,sBAAV,CAA9B,CAAF;MACA;IACD;;IACDuM,IAAI,CAACyE,OAAL,GAAe,OAAf;IACA/L,EAAE,CAACrI,SAAD,EAAY2P,IAAZ,CAAF;EACD,CAPD;;EASAA,IAAI,CAACgE,OAAL,CAAa7R,SAAb,CAAuByO,KAAvB,CAA6BZ,IAAI,CAACrF,QAAL,CAAcJ,EAA3C,EAA+C,IAA/C;AACD;;AAED,SAASoG,OAAT,CAAiBX,IAAjB,EAAuBL,GAAvB,EAA4BC,IAA5B,EAAkClH,EAAlC,EAAsC;EACpC,IAAIsH,IAAI,CAACrF,QAAL,CAAcD,KAAd,KAAwB,MAA5B,EAAoC;IAClChC,EAAE,CAAC,IAAIjF,KAAJ,CAAU,qBAAV,CAAD,CAAF;IACA;EACD;;EAEDuM,IAAI,CAACnO,UAAL,CAAgBmJ,IAAhB,CAAsBqG,OAAD,IAAa;IAChC,IAAIA,OAAJ,EAAa;MACX3I,EAAE,CAAC2I,OAAO,KAAK,IAAZ,GAAmBA,OAAnB,GAA6B,IAAI5N,KAAJ,CAAU,gBAAV,CAA9B,CAAF;MACA;IACD;;IACDuM,IAAI,CAACyE,OAAL,GAAe,MAAf;IACAzE,IAAI,CAACF,aAAL,GAAsBF,IAAI,CAACE,aAAL,KAAuB,KAA7C;IACApH,EAAE,CAACrI,SAAD,EAAY2P,IAAZ,CAAF;EACD,CARD;;EAUAA,IAAI,CAACgE,OAAL,CAAa7R,SAAb,CAAuBuN,IAAvB,CAA4BM,IAAI,CAACrF,QAAL,CAAcJ,EAA1C,EAA8CoF,GAA9C,EAAmD,IAAnD;AACD;;AAED,SAASW,MAAT,CAAgBN,IAAhB,EAAsBK,GAAtB,EAA2B;EACzB,IAAIL,IAAI,CAACrF,QAAL,CAAcD,KAAd,KAAwB,MAA5B,EACE;EAEF,MAAMhB,IAAI,GAAGgL,MAAM,CAAChL,IAAP,CAAY2G,GAAG,IAAI,EAAnB,CAAb;;EAEA,KAAK,IAAItC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGrE,IAAI,CAAC9F,MAAzB,EAAiC,EAAEmK,CAAnC,EAAsC;IACpC,MAAMtJ,GAAG,GAAGiF,IAAI,CAACqE,CAAD,CAAhB;IACA,MAAM4G,GAAG,GAAGtE,GAAG,CAAC5L,GAAD,CAAf;;IACAuL,IAAI,CAACgE,OAAL,CAAa7R,SAAb,CAAuBkO,GAAvB,CAA2BL,IAAI,CAACrF,QAAL,CAAcJ,EAAzC,EAA6C9F,GAA7C,EAAkDkQ,GAAlD,EAAuD,KAAvD;EACD;AACF;;AAED,SAAS3D,YAAT,CAAsBhB,IAAtB,EAA4B7I,IAA5B,EAAkCuB,EAAlC,EAAsC;EACpC,IAAIsH,IAAI,CAACrF,QAAL,CAAcD,KAAd,KAAwB,MAA5B,EAAoC;IAClChC,EAAE,CAAC,IAAIjF,KAAJ,CAAU,qBAAV,CAAD,CAAF;IACA;EACD;;EAEDuM,IAAI,CAACnO,UAAL,CAAgBmJ,IAAhB,CAAsBqG,OAAD,IAAa;IAChC,IAAIA,OAAJ,EAAa;MACX3I,EAAE,CAAC2I,OAAO,KAAK,IAAZ,GACEA,OADF,GAEE,IAAI5N,KAAJ,CAAW,8BAA6B0D,IAAK,EAA7C,CAFH,CAAF;MAGA;IACD;;IACD6I,IAAI,CAACyE,OAAL,GAAe,WAAf;IACA/L,EAAE,CAACrI,SAAD,EAAY2P,IAAZ,CAAF;EACD,CATD;;EAWAA,IAAI,CAACgE,OAAL,CAAa7R,SAAb,CAAuByS,SAAvB,CAAiC5E,IAAI,CAACrF,QAAL,CAAcJ,EAA/C,EAAmDpD,IAAnD,EAAyD,IAAzD;AACD,C,CAED;;;AACA,SAAS4C,cAAT,CAAwBiJ,IAAxB,EAA8BlJ,IAA9B,EAAoC;EAClC;EACA;EACA;EAEA,IAAIsJ,SAAS,GAAG,CAAC,CAAjB;EACA,IAAItM,MAAJ;;EAEA,MAAM+N,MAAM,GAAG,MAAM;IACnB,MAAMxK,QAAQ,GAAG;MACfzC,IAAI,EAAEkC,IAAI,CAAClC,IADI;MAEf0C,QAAQ,EAAE;QACRC,EAAE,EAAE6I,SADI;QAER5I,MAAM,EAAErL,UAFA;QAGRsL,UAAU,EAAErL,WAHJ;QAIRsL,KAAK,EAAE;MAJC,CAFK;MAQfC,QAAQ,EAAE;QACRJ,EAAE,EAAET,IAAI,CAACc,MADD;QAERJ,MAAM,EAAEV,IAAI,CAACU,MAFL;QAGRC,UAAU,EAAEX,IAAI,CAACW,UAHT;QAIRC,KAAK,EAAE;MAJC;IARK,CAAjB;IAeA,MAAMuG,MAAM,GAAG,IAAI/R,OAAJ,CAAY8T,IAAZ,EAAkB3I,QAAlB,CAAf;;IACA2I,IAAI,CAACpR,QAAL,CAAc+C,MAAd,CAAqByO,SAArB,EAAgCnC,MAAhC;;IAEA+B,IAAI,CAAC7Q,SAAL,CAAe2S,kBAAf,CAAkChL,IAAI,CAACc,MAAvC,EACkCwI,SADlC,EAEkCjU,UAFlC,EAGkCC,WAHlC;;IAIA,OAAO6R,MAAP;EACD,CAxBD;;EAyBA,MAAM8D,MAAM,GAAG,MAAM;IACnB,IAAIjO,MAAM,KAAKzG,SAAf,EAA0B;MACxB,IAAI+S,SAAS,KAAK,CAAC,CAAnB,EACEtM,MAAM,GAAGvJ,oBAAoB,CAACyX,iBAA9B,CADF,KAGElO,MAAM,GAAGvJ,oBAAoB,CAAC0X,cAA9B;IACH;;IAED,IAAI7B,SAAS,KAAK,CAAC,CAAnB,EACEJ,IAAI,CAACpR,QAAL,CAAcsT,MAAd,CAAqB9B,SAArB;;IAEFJ,IAAI,CAAC7Q,SAAL,CAAegT,eAAf,CAA+BrL,IAAI,CAACc,MAApC,EAA4C9D,MAA5C,EAAoD,EAApD;EACD,CAZD;;EAaA,MAAMsO,cAAc,GAAG,MAAM;IAC3BhC,SAAS,GAAGJ,IAAI,CAACpR,QAAL,CAAcyR,GAAd,EAAZ;;IAEA,IAAID,SAAS,KAAK,CAAC,CAAnB,EAAsB;MACpBtM,MAAM,GAAGvJ,oBAAoB,CAACyX,iBAA9B;;MACA,IAAIhC,IAAI,CAAC7S,MAAL,CAAYsB,KAAhB,EAAuB;QACrBuR,IAAI,CAAC7S,MAAL,CAAYsB,KAAZ,CACE,2DACI,uBAFN;MAID;IACF;;IAED,OAAQ2R,SAAS,KAAK,CAAC,CAAvB;EACD,CAdD;;EAgBA,MAAMzN,IAAI,GAAGmE,IAAI,CAACnE,IAAlB;;EACA,QAAQmE,IAAI,CAAClC,IAAb;IACE,KAAK,iBAAL;MAAwB;QACtB,MAAM+M,GAAG,GAAG3B,IAAI,CAAClR,WAAL,CAAkB,GAAE6D,IAAI,CAAC0P,MAAO,IAAG1P,IAAI,CAAC2P,QAAS,EAAjD,CAAZ;;QACA,IAAIX,GAAG,KAAKtU,SAAR,IAAqB+U,cAAc,EAAvC,EAA2C;UACzC,IAAIzP,IAAI,CAAC2P,QAAL,KAAkB,CAAtB,EACE3P,IAAI,CAAC2P,QAAL,GAAgBX,GAAhB;UACF3B,IAAI,CAAC9M,IAAL,CAAU,gBAAV,EAA4BP,IAA5B,EAAkCkP,MAAlC,EAA0CE,MAA1C;UACA;QACD;;QACD;MACD;;IACD,KAAK,mCAAL;MACE,IAAI/B,IAAI,CAACjR,eAAL,CAAqB4D,IAAI,CAACyM,UAA1B,MAA0C/R,SAA1C,IACG+U,cAAc,EADrB,EACyB;QACvBpC,IAAI,CAAC9M,IAAL,CAAU,iBAAV,EAA6BP,IAA7B,EAAmCkP,MAAnC,EAA2CE,MAA3C;QACA;MACD;;MACD;;IACF,KAAK,wBAAL;MACE,IAAI/B,IAAI,CAAC/Q,gBAAL,IACG,OAAO+Q,IAAI,CAACtR,MAAL,CAAY6T,SAAnB,KAAiC,UADpC,IAEGH,cAAc,EAFrB,EAEyB;QACvBpC,IAAI,CAACtR,MAAL,CAAY6T,SAAZ,CAAsB,CAACvV,GAAD,EAAMiR,MAAN,KAAiB;UACrC,IAAIjR,GAAJ,EACE,OAAO+U,MAAM,EAAb;UAEF,MAAMS,QAAQ,GAAGX,MAAM,EAAvB;UACAW,QAAQ,CAACC,IAAT,CAAcxE,MAAd,EAAsBwE,IAAtB,CAA2BD,QAA3B;QACD,CAND;;QAOA;MACD;;MACD;;IACF,KAAK,KAAL;MACE,IAAIxC,IAAI,CAAChR,UAAL,KAAoB,CAApB,IAAyBoT,cAAc,EAA3C,EAA+C;QAC7CpC,IAAI,CAAC9M,IAAL,CAAU,KAAV,EAAiBP,IAAjB,EAAuBkP,MAAvB,EAA+BE,MAA/B;QACA;MACD;;MACD;;IACF;MACE;MACAjO,MAAM,GAAGvJ,oBAAoB,CAACmY,oBAA9B;;MACA,IAAI1C,IAAI,CAAC7S,MAAL,CAAYsB,KAAhB,EAAuB;QACrBuR,IAAI,CAAC7S,MAAL,CAAYsB,KAAZ,CACE,sEACK,SAAQqI,IAAI,CAAClC,IAAK,EAFzB;MAID;;EA9CL;;EAiDA,IAAId,MAAM,KAAKzG,SAAf,EAA0B;IACxByG,MAAM,GAAGvJ,oBAAoB,CAACoY,2BAA9B;;IACA,IAAI3C,IAAI,CAAC7S,MAAL,CAAYsB,KAAhB,EAAuB;MACpBuR,IAAI,CAAC7S,MAAL,CAAYsB,KAAZ,CACC,0EACIqI,IAAI,CAAClC,IAFV;IAIF;EACF;;EAEDmN,MAAM;AACP;;AAED,MAAMjB,YAAY,GAAG,CAAC,MAAM;EAC1B,MAAM8B,MAAM,GAAGjT,MAAM,CAACkT,WAAP,CAAmB,EAAnB,CAAf;EACA,OAAO,MAAM;IACXhZ,cAAc,CAAC+Y,MAAD,EAAS,CAAT,EAAY,EAAZ,CAAd;IACA,OAAOA,MAAM,CAAC/B,QAAP,CAAgB,CAAhB,EAAmB,EAAnB,CAAP;EACD,CAHD;AAID,CANoB,GAArB;;AAQA,SAAS5F,qBAAT,CAA+B6H,QAA/B,EAAyC;EACvC,IAAI,CAAChS,KAAK,CAACC,OAAN,CAAc+R,QAAd,CAAL,EACE,MAAM,IAAIrS,KAAJ,CAAU,2BAAV,CAAN;EAEF,IAAIsS,CAAC,GAAG,CAAR;EACA,OAAO,CAACC,SAAD,EAAYtO,cAAZ,EAA4BgB,EAA5B,KAAmC;IACxC,IAAIqN,CAAC,KAAKD,QAAQ,CAAClS,MAAnB,EACE,OAAO,KAAP;IACF,OAAOkS,QAAQ,CAACC,CAAC,EAAF,CAAf;EACD,CAJD;AAKD;;AAED,SAAStM,aAAT,CAAuBwM,MAAvB,EAA+BC,KAA/B,EAAsCxN,EAAtC,EAA0C;EACxC,IAAI,CAACuN,MAAM,CAAC7T,KAAR,IAAiB,CAAC3C,UAAU,CAACwW,MAAM,CAAC7T,KAAR,CAAhC,EACE;EAEF,IAAI,OAAOsG,EAAP,KAAc,UAAlB,EACEA,EAAE,GAAG3I,IAAL;EAEF,IAAI,CAAC+D,KAAK,CAACC,OAAN,CAAcmS,KAAd,CAAL,EACE,MAAM,IAAIC,SAAJ,CAAc,4BAAd,CAAN;EAEF,MAAMzM,IAAI,GAAG,EAAb;;EACA,KAAK,MAAMjF,GAAX,IAAkByR,KAAlB,EAAyB;IACvB,MAAME,MAAM,GAAG7X,QAAQ,CAACkG,GAAD,CAAvB;IACA,IAAI2R,MAAM,YAAY3S,KAAtB,EACE,MAAM2S,MAAN;IACF1M,IAAI,CAACsB,IAAL,CAAUoL,MAAV;EACD;;EAED,IAAI,CAACH,MAAM,CAAC9V,MAAP,CAAcqB,YAAf,IACIyU,MAAM,CAAC9V,MAAP,CAAcqB,YAAd,IAA8B1B,UAAU,CAACoS,IAAX,CAAgB+D,MAAM,CAAC/T,UAAvB,CADtC,EAC2E;IACzE+T,MAAM,CAACpU,UAAP,CAAkBmJ,IAAlB,CAAuB,CAACqG,OAAD,EAAU1L,IAAV,KAAmB;MACxC,IAAI0L,OAAJ,EAAa;QACX3I,EAAE,CAAC2I,OAAO,KAAK,IAAZ,GACEA,OADF,GAEE,IAAI5N,KAAJ,CAAU,sCAAV,CAFH,CAAF;QAGA;MACD,CANuC,CAQxC;;;MACA,MAAMoB,GAAG,GAAG,EAAZ;MACA,IAAIwR,MAAM,GAAG,CAAb;MACAzW,YAAY,CAACxB,IAAb,CAAkBuH,IAAlB,EAAwB,CAAxB;;MACA,OAAO/F,YAAY,CAAC0W,KAAb,EAAP,EAA6B;QAC3B,IAAID,MAAM,KAAK3M,IAAI,CAAC9F,MAApB,EACE;QACF,MAAMa,GAAG,GAAGiF,IAAI,CAAC2M,MAAM,EAAP,CAAhB;QACA,MAAME,SAAS,GAAG9R,GAAG,CAAC+R,YAAJ,EAAlB;QAEA,MAAMC,QAAQ,GAAG7W,YAAY,CAAC8W,UAAb,EAAjB;QACA7W,SAAS,CAACzB,IAAV,CAAeqY,QAAf,EAAyB,CAAzB;QACA,MAAM7O,IAAI,GAAG/H,SAAS,CAAC6W,UAAV,CAAqB,IAArB,CAAb;QACA,IAAIC,KAAK,GAAG9W,SAAS,CAAC6W,UAAV,EAAZ;QAEA,IAAIE,IAAJ;;QACA,IAAIhP,IAAI,KAAKnD,GAAG,CAACmD,IAAjB,EAAuB;UACrB,IAAInD,GAAG,CAACmD,IAAJ,KAAa,SAAjB,EAA4B;YAC1B,QAAQA,IAAR;cACE,KAAK,cAAL;gBACEgP,IAAI,GAAG,QAAP;gBACA;;cACF,KAAK,cAAL;gBACEA,IAAI,GAAG,QAAP;gBACA;;cACF;gBACE;YARJ;UAUD,CAXD,MAWO;YACL;UACD;QACF;;QAED,MAAMC,SAAS,GAAGZ,MAAM,CAAC9T,SAAP,CAAiB2U,IAAjB,CAAsBD,SAAxC;QACA,MAAME,UAAU,GAAGpU,MAAM,CAACkT,WAAP,CACjB,IAAI,EAAJ,GAAS,CAAT,GAAagB,SAAS,CAACjT,MAAvB,GAAgC,CAAhC,GAAoC2S,SAAS,CAAC3S,MAD7B,CAAnB;QAGA,IAAIuB,CAAC,GAAG,CAAR;QACArG,aAAa,CAACiY,UAAD,EAAa,EAAb,EAAiB5R,CAAjB,CAAb;QACA4R,UAAU,CAACC,SAAX,CAAqB,+BAArB,EAAsD7R,CAAC,IAAI,CAA3D,EAA8D,EAA9D;QACArG,aAAa,CAACiY,UAAD,EAAaF,SAAS,CAACjT,MAAvB,EAA+BuB,CAAC,IAAI,EAApC,CAAb;QACA1G,UAAU,CAACoY,SAAD,EAAYE,UAAZ,EAAwB,CAAxB,EAA2BF,SAAS,CAACjT,MAArC,EAA6CuB,CAAC,IAAI,CAAlD,CAAV;QACArG,aAAa,CAACiY,UAAD,EAAaR,SAAS,CAAC3S,MAAvB,EAA+BuB,CAAC,IAAI0R,SAAS,CAACjT,MAA9C,CAAb;QACAnF,UAAU,CAAC8X,SAAD,EAAYQ,UAAZ,EAAwB,CAAxB,EAA2BR,SAAS,CAAC3S,MAArC,EAA6CuB,CAAC,IAAI,CAAlD,CAAV;QAEA,IAAI,EAAEwR,KAAK,GAAG9X,YAAY,CAAC8X,KAAD,EAAQ/O,IAAR,CAAtB,CAAJ,EACE;QACF,IAAInD,GAAG,CAACC,MAAJ,CAAWqS,UAAX,EAAuBJ,KAAvB,EAA8BC,IAA9B,MAAwC,IAA5C,EACE/R,GAAG,CAACmG,IAAJ,CAASvG,GAAT;MACH;;MACD5E,SAAS,CAACoX,KAAV;MACArX,YAAY,CAACqX,KAAb;MAEAvO,EAAE,CAAC,IAAD,EAAO7D,GAAP,CAAF;IACD,CA9DD;;IAgEAoR,MAAM,CAAC9T,SAAP,CAAiB+U,qBAAjB,CAAuCxN,IAAvC;;IACA;EACD;;EAEDiF,OAAO,CAACC,QAAR,CACElG,EADF,EAEE,IAAIjF,KAAJ,CACE,sEADF,CAFF;AAMD;;AAED0T,MAAM,CAACC,OAAP,GAAiBnX,MAAjB"},"metadata":{},"sourceType":"script"}